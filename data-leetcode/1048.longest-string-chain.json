[
    {
        "title": "Longest String Chain",
        "question_content": "You are given an array of words where each word consists of lowercase English letters.\nwordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.\n\tFor example, \"abc\" is a predecessor of \"abac\", while \"cba\" is not a predecessor of \"bcad\".\nA word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.\nReturn the length of the longest possible word chain with words chosen from the given list of words.\n&nbsp;\nExample 1:\nInput: words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\nOutput: 4\nExplanation: One of the longest word chains is [\"a\",\"ba\",\"bda\",\"bdca\"].\nExample 2:\nInput: words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\nOutput: 5\nExplanation: All the words can be put in a word chain [\"xb\", \"xbc\", \"cxbc\", \"pcxbc\", \"pcxbcf\"].\nExample 3:\nInput: words = [\"abcd\",\"dbqca\"]\nOutput: 1\nExplanation: The trivial word chain [\"abcd\"] is one of the longest word chains.\n[\"abcd\",\"dbqca\"] is not a valid word chain because the ordering of the letters is changed.\n&nbsp;\nConstraints:\n\t1 <= words.length <= 1000\n\t1 <= words[i].length <= 16\n\twords[i] only consists of lowercase English letters.",
        "solutions": [
            {
                "id": 294890,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\nSort the `words` by word\\'s length. (also can apply bucket sort)\\nFor each word, loop on all possible previous word with 1 letter missing.\\nIf we have seen this previous word, update the longest chain for the current word.\\nFinally return the longest word chain.\\n<br>\\n\\n# **Complexity**\\nTime `O(NlogN)` for sorting,\\nTime  `O(NSS)` for the `for` loop, where the second `S` refers to the string generation and `S <= 16`.\\nSpace `O(NS)`\\n<br>\\n\\n**Python:**\\n```python\\n    def longestStrChain(self, words):\\n        dp = {}\\n        for w in sorted(words, key=len):\\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in xrange(len(w)))\\n        return max(dp.values())\\n```\\n\\n**C++**\\n```cpp\\n    static bool compare(const string &s1, const string &s2) {\\n        return s1.length() < s2.length();\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> dp;\\n        int res = 0;\\n        for (string w : words) {\\n            for (int i = 0; i < w.length(); i++) {\\n                string pre = w.substr(0, i) + w.substr(i + 1);\\n                dp[w] = max(dp[w], dp.find(pre) == dp.end() ? 1 : dp[pre] + 1);\\n            }\\n            res = max(res, dp[w]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java**\\nSuggested by @noname_minion and @jenniferwang\\n```java\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> dp = new HashMap<>();\\n        Arrays.sort(words, (a, b)->a.length() - b.length());\\n        int res = 0;\\n        for (String word : words) {\\n            int best = 0;\\n            for (int i = 0; i < word.length(); ++i) {\\n                String prev = word.substring(0, i) + word.substring(i + 1);\\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\\n            }\\n            dp.put(word, best);\\n            res = Math.max(res, best);\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\n    def longestStrChain(self, words):\\n        dp = {}\\n        for w in sorted(words, key=len):\\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in xrange(len(w)))\\n        return max(dp.values())\\n```\n```cpp\\n    static bool compare(const string &s1, const string &s2) {\\n        return s1.length() < s2.length();\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> dp;\\n        int res = 0;\\n        for (string w : words) {\\n            for (int i = 0; i < w.length(); i++) {\\n                string pre = w.substr(0, i) + w.substr(i + 1);\\n                dp[w] = max(dp[w], dp.find(pre) == dp.end() ? 1 : dp[pre] + 1);\\n            }\\n            res = max(res, dp[w]);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> dp = new HashMap<>();\\n        Arrays.sort(words, (a, b)->a.length() - b.length());\\n        int res = 0;\\n        for (String word : words) {\\n            int best = 0;\\n            for (int i = 0; i < word.length(); ++i) {\\n                String prev = word.substring(0, i) + word.substring(i + 1);\\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\\n            }\\n            dp.put(word, best);\\n            res = Math.max(res, best);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2153007,
                "title": "c-python-simple-solution-w-explanation-dp",
                "content": "Given an array of `words`, we need to find the length of the ***longest possible word chain***. I will use some terms whose definitions are given in the problem statement without explaining them here.\\n\\nHow should we approach this problem? \\uD83E\\uDD14\\nThe first thing which comes into mind is **DP**. There are a few reasons for this thought.\\n\\n- It asks for **longest** possible word chain, so it is an optimization problem.\\n- The chain is extended by adding a new word which only depends on the last word of the chain. So, it can be broken down into subproblems.\\n\\n___\\n\\u2705 **Solution I: Bottom-Up DP [Accepted]**\\n\\nGenerally, we need to think of a recursive relation in a DP problem and then optimize it. But here, it wasn\\'t required. Can we start with the shortest word and try to build a chain starting with it? Let\\'s think in this direction. We then need to find the next shortest word and so on. It could be expensive, so *sorting* the entire array based on length will help.\\n\\nLet `prev` be the predecessor of a word. Building a successor from `prev` will be more expensive than building a predecessor from that word. The following example will make it clear:\\n\\n```text\\nprev = \"chain\"\\nTo build all possible successors, we need to add a letter anywhere in the word.\\n_ c _ h _ a _ i _ n _\\nWe have 6 possible spaces and 26 possible letters, so a total of 6 * 26 possibilities.\\n\\nNow, getting a predecessor from a word is a lot easier. Just remove a letter.\\nword = \"chains\"\\npred = {\"hains\", \"cains\", \"chins\", \"chans\", \"chais\", \"chain\"}\\n```\\n\\nSo, for each word, we\\'ll look for a predecessor. Wouldn\\'t it be great if can have a *data structure* with the following two properties: \\n\\n- Can tell which of these predecessors are present in the array efficiently.\\n- Store size of the chain ending with that predecessor.\\n\\nTurns out that we already have one. It is `unordered_map` in `C++` and `dictionary` in python.\\n**Example:**\\n\\n```text\\nwords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\n1. word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n2. word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n3. word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\n\\tHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n4. word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n5. word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n6. word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4.\\n```\\n\\nNow with these ideas in mind, we are ready to code!\\n\\n<iframe src=\"https://leetcode.com/playground/WheZr2K3/shared\" frameBorder=\"0\" width=\"1080\" height=\"380\"></iframe>\\n\\n- **Time Complexity:** `O(nlog(n) + nll)`\\n  - `O(nlog(n))` for sorting\\n  - `O(nll)`: `n` for each loop, `l` for inner loop and `l` for string concatenation.\\n- **Space Complexity:** `O(ns)`\\n  - `O(n)` for both sorting and storing in dictionary.\\n  - `O(ns)`: `s` for creating space for `prev`, `n` times. \\n___\\n___\\nIf you like the solution, please **upvote**! \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```text\\nprev = \"chain\"\\nTo build all possible successors, we need to add a letter anywhere in the word.\\n_ c _ h _ a _ i _ n _\\nWe have 6 possible spaces and 26 possible letters, so a total of 6 * 26 possibilities.\\n\\nNow, getting a predecessor from a word is a lot easier. Just remove a letter.\\nword = \"chains\"\\npred = {\"hains\", \"cains\", \"chins\", \"chans\", \"chais\", \"chain\"}\\n```\n```text\\nwords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\n1. word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n2. word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n3. word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\n\\tHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n4. word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n5. word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n6. word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458069,
                "title": "java-easy-solution-with-explanation-must-read",
                "content": "```\\npublic int longestStrChain(String[] words) {\\n        \\n\\tif(words == null || words.length == 0) return 0;\\n\\tint res = 0;\\n\\tArrays.sort(words, (a,b)-> a.length()-b.length());  // Sort the words based on their lengths\\n\\tHashMap<String, Integer> map = new HashMap();       //Stores each word and length of its max chain.\\n\\n\\tfor(String w : words) {                             //From shortest word to longest word\\n\\t\\tmap.put(w, 1);                                  //Each word is atleast 1 chain long\\n\\t\\tfor(int i=0; i<w.length(); i++) {               //Form next word removing 1 char each time for each w\\n\\t\\t\\tStringBuilder sb = new StringBuilder(w);\\n\\t\\t\\tString next = sb.deleteCharAt(i).toString();\\n\\t\\t\\tif(map.containsKey(next) && map.get(next)+1 > map.get(w))\\n\\t\\t\\t\\tmap.put(w, map.get(next)+1);            //If the new chain is longer, update the map\\n\\t\\t}\\n\\t\\tres = Math.max(res, map.get(w));                //Store max length of all chains\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n**Edit History:**\\n1. In agreement to @Krizzt comment below, I removed `if(map.containsKey(w)) continue;` since it was not necessary",
                "solutionTags": [],
                "code": "```\\npublic int longestStrChain(String[] words) {\\n        \\n\\tif(words == null || words.length == 0) return 0;\\n\\tint res = 0;\\n\\tArrays.sort(words, (a,b)-> a.length()-b.length());  // Sort the words based on their lengths\\n\\tHashMap<String, Integer> map = new HashMap();       //Stores each word and length of its max chain.\\n\\n\\tfor(String w : words) {                             //From shortest word to longest word\\n\\t\\tmap.put(w, 1);                                  //Each word is atleast 1 chain long\\n\\t\\tfor(int i=0; i<w.length(); i++) {               //Form next word removing 1 char each time for each w\\n\\t\\t\\tStringBuilder sb = new StringBuilder(w);\\n\\t\\t\\tString next = sb.deleteCharAt(i).toString();\\n\\t\\t\\tif(map.containsKey(next) && map.get(next)+1 > map.get(w))\\n\\t\\t\\t\\tmap.put(w, map.get(next)+1);            //If the new chain is longer, update the map\\n\\t\\t}\\n\\t\\tres = Math.max(res, map.get(w));                //Store max length of all chains\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213876,
                "title": "python-3-solutions-lis-dp-top-down-dp-bottom-up-dp-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Longest Increasing Subsequence Idea**\\n- Firstly, we sort words in increasing order by their length, to ensure length of the previous word no longer than length of the current word, it means `len(words[j]) <= len(word[i])`, where `j < i`.\\n- Let `dp[i]` be the longest increasing subsequence which ends at `words[i]`.\\n- To check if `word1` is a predecessor of `word2`, we need to check\\n\\t- `len(word1) + 1` must equal to `len(word2)`.\\n\\t- `word1` must be a subsequence of `word2`.\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def isPredecessor(word1, word2):\\n            if len(word1) + 1 != len(word2): return False\\n            i = 0\\n            for c in word2:\\n                if i == len(word1): return True\\n                if word1[i] == c:\\n                    i += 1\\n            return i == len(word1)\\n        \\n        words.sort(key=len)\\n        n = len(words)\\n        dp = [1] * n\\n        ans = 1\\n        for i in range(1, n):\\n            for j in range(i):\\n                if isPredecessor(words[j], words[i]) and dp[i] < dp[j] + 1:\\n                    dp[i] = dp[j] + 1\\n            ans = max(ans, dp[i])\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N^2 * L)`, where `N <= 1000` is number of words, `L <= 16` is length of each word.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top-Down DP**\\n- Let `dp(word)` be the length of the **longest possible word chain** end at word `word`.\\n- To calculate `dp(word)`, we try all predecessors of word `word` and get the maximum length among them.\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        wordSet = set(words)\\n\\n        @lru_cache(None)\\n        def dp(word):\\n            ans = 1\\n            for i in range(len(word)):\\n                predecessor = word[:i] + word[i + 1:]\\n                if predecessor in wordSet:\\n                    ans = max(ans, dp(predecessor) + 1)\\n            return ans\\n\\n        return max(dp(w) for w in words)\\n```\\n**Complexity**\\n- Time: `O(N * L * L)`, where `N <= 1000` is number of words, `L <= 16` is length of a word\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom-Up DP**\\n- Firstly, we sort words in increasing order by their length, to ensure length of the previous word no longer than length of the current word, it means `len(words[j]) <= len(word[i])`, where `j < i`.\\n- Let `dp(word)` be the length of the **longest possible word chain** end at word `word`.\\n- To calculate `dp(word)`, we try all predecessors of word `word` and get the maximum length among them.\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)  # sort words by its length\\n        ans = 0\\n        dp = defaultdict(int)\\n        for word in words:\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                predecessor = word[:i] + word[i+1:]\\n                if predecessor in dp and dp[word] < dp[predecessor] + 1:\\n                    dp[word] = dp[predecessor] + 1\\n            ans = max(ans, dp[word])\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(NlogN + N*L*L)`, where `N <= 1000` is number of words, `L <= 16` is length of a word\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def isPredecessor(word1, word2):\\n            if len(word1) + 1 != len(word2): return False\\n            i = 0\\n            for c in word2:\\n                if i == len(word1): return True\\n                if word1[i] == c:\\n                    i += 1\\n            return i == len(word1)\\n        \\n        words.sort(key=len)\\n        n = len(words)\\n        dp = [1] * n\\n        ans = 1\\n        for i in range(1, n):\\n            for j in range(i):\\n                if isPredecessor(words[j], words[i]) and dp[i] < dp[j] + 1:\\n                    dp[i] = dp[j] + 1\\n            ans = max(ans, dp[i])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        wordSet = set(words)\\n\\n        @lru_cache(None)\\n        def dp(word):\\n            ans = 1\\n            for i in range(len(word)):\\n                predecessor = word[:i] + word[i + 1:]\\n                if predecessor in wordSet:\\n                    ans = max(ans, dp(predecessor) + 1)\\n            return ans\\n\\n        return max(dp(w) for w in words)\\n```\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)  # sort words by its length\\n        ans = 0\\n        dp = defaultdict(int)\\n        for word in words:\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                predecessor = word[:i] + word[i+1:]\\n                if predecessor in dp and dp[word] < dp[predecessor] + 1:\\n                    dp[word] = dp[predecessor] + 1\\n            ans = max(ans, dp[word])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153004,
                "title": "explaining-three-approaches-java",
                "content": "### Intuition:\\nThere are quite a few ways to solve this problem. Below are some ways I\\'ve compiled together and I\\'ll try my best to explain how they work and how you might transition from an intuitive thought process to code. Let\\'s get started! \\n\\nThe fundamental logic behind all three solutions remains the same: \\n![image](https://assets.leetcode.com/users/images/02391de9-bfa7-46b6-8515-88f445f406e5_1655259685.068525.png)\\n\\nBelow are the three main approaches I\\'ll go through that follow the above template:\\n1. **DFS + Memoization:** <ins>Increasing the length of the word in each call</ins>.\\n2. **DFS + Memoization:** <ins>Decreasing the length of the word in each call</ins>.\\n3. **DP:** <ins>Decreasing the length of the word in each iteration</ins>.\\n___\\n### DFS + Memoization:\\nWhen you\\'re first thinking of a memoization solution to this question, you\\'ve probably thought of starting  from any word and then finding all the valid \"next words\" that follow after. This makes the most sense intuitively since this is quite literally what the question is asking.\\n\\n**Approach 1: Increase Word Length:**\\n\\n![image](https://assets.leetcode.com/users/images/8259517c-db06-43cc-8fb1-48a134200c4b_1655256779.452725.png)\\nAs you can see from the above illustration, we\\'re computing the results for some strings multiple times. If we already know how deep a path can go from any given string, why calculate it again? We don\\'t have to; we can just store the result of that string in a memo cache and never have to recalculate for that string ever again. This concept is known as <ins>memoization</ins>. \\n\\n<ins>How do we implement this in code?</ins>\\nTurns out that all the valid words that follow the current word are guaranteed to be exactly one letter longer. Therefore, we can just store all the words with their associated lengths in a hashmap. E.g. Words with length 1: \"a\" and \"b\" would be stored with key `1`. Therefore, we can just get the list of words with a certain length, loop through them and see if any of them are valid words to continue the chain. \\nTo compare two words, we\\'ll use a custom function as you\\'ll see in the code. \\n___\\n**Approach 2: Decrease Word Length:**\\nThe slightly less intuitive idea here is to go in reverse; removing a letter from each word as the \"next\" step. This is a good example of the \"reframing the question\" strategy I\\'ve discussed in previous posts! This approach has the same time complexity as the previous approach but it\\'s a good example of how you can approach a question from multiple angles. Let\\'s see how this would work:\\n![image](https://assets.leetcode.com/users/images/d3811d30-0b83-4214-86b9-54528e328721_1655256829.9690504.png)\\nAgain, memoization is applied to avoid recomputation.\\n\\n<ins>How do we implement this in code?</ins>\\nThe way we find the next (or in this case, the previous) words is a bit different to how we did it in the previous approach despite following the same general structure. Since we\\'re decreasing a letter each time, we can simply chop off a letter from the current word, see if it exists in `words[]`, and add the letter back afterwards before continuing to the next letter. \\nFor constant time look-up, we\\'ll convert our `words[]` array to a hash set. \\n___\\n### Dynamic Programming:\\nThis is just your usual memoization to DP conversion. Nothing special! It\\'s basically an iterative version of the corresponding memoization algorithm. We can choose either of the above methods to convert to but I\\'ve chosen the second approach. As an exercise for yourself, try converting approach 1 from memoization to DP :)\\n\\n**Approach 3: Decrease Word Length using DP:**\\n![image](https://assets.leetcode.com/users/images/6ab94500-c156-478b-984d-a4b82dde6636_1655258399.1031818.png)\\n\\n<ins>How do we implement this in code?</ins>\\nThe most important adjustment here is that we need to sort our input array by length since at each word, we add to it the max length from each previous string in the chain. So, we would like all shorter strings to be computed before longer ones. If you chose to convert approach 1 to DP, you\\'d have to sort the array in reverse order. Remember, the fundamental approach hasn\\'t changed, but our execution has altered slightly since we\\'re replacing our memo table with a DP table,\\n\\nThat\\'s it! Now we\\'re ready to code something up.\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, please feel free to let me know. Thanks for reading!\\nFor the below complexity analyses, assume that `n` is the length of the array and `m` is the max word length.\\n\\n**DFS + Memoization | Increasing Word Length:**\\n> Time complexity: `O(n*m^2)`: In dfs(), we look at `n` word at most one time due to memoization. At each dfs(), we compare all nextWords which takes at most `O(m^2)` \\n> Space complexity: `O(n)` due to the call stack\\n```java\\nprivate Map<Integer, List<String>> wordLengthMap;\\nprivate Map<String, Integer> memo;\\n\\npublic int longestStrChain(String[] words) {\\n\\t// store each word with its corresponding length\\n\\twordLengthMap = new HashMap<>();\\n\\tfor (String word: words) {\\n\\t\\twordLengthMap.putIfAbsent(word.length(), new ArrayList<>());\\n\\t\\twordLengthMap.get(word.length()).add(word);\\n\\t}\\n\\n\\tint maxPath = 1;\\n\\tmemo = new HashMap<>();\\n\\tfor (String word: words) \\n\\t\\tmaxPath = Math.max(maxPath, dfs(word));\\n\\n\\treturn maxPath;\\n}\\n\\nprivate int dfs(String word) {\\n\\tif (!wordLengthMap.containsKey(word.length() + 1)) return 1; // if there are no words of the next length, we\\'re done with this path.\\n\\tif (memo.containsKey(word)) return memo.get(word); // if we\\'re computed this word before, return the result.\\n\\n\\tint maxPath = 0;\\n\\t// for each word, find all words which are 1 letter longer and see if they are valid successors.\\n\\tList<String> nextWords = wordLengthMap.get(word.length() + 1);\\n\\tfor (String nextWord: nextWords) \\n\\t\\tif (isOneOff(word, nextWord)) \\n\\t\\t\\tmaxPath = Math.max(maxPath, dfs(nextWord));\\n\\t\\n\\tmemo.put(word, maxPath + 1); // store our result\\n\\treturn memo.get(word);\\n}\\n\\n// returns true if two strings differ by no more than 1 letter\\nprivate boolean isOneOff(String a, String b) {\\n\\tint count = 0;\\n\\tfor (int i=0, j=0; i<b.length() && j<a.length() && count <= 1; i++) {\\n\\t\\tif (a.charAt(j) != b.charAt(i)) count++;\\n\\t\\telse j++;\\n\\t}\\n\\treturn count <= 1;\\n}\\n```\\n\\n**DFS + Memoization | Decreasing Word Length:**\\n> Time complexity: `O(n*m^2)`: In dfs(), we look at \\'n\\' words at most one time due to memoization. At each dfs(), we loop through `m` characters and use `remove()` and `insert()` which each cost `O(m)`.\\n> Space complexity: `O(n)` due to the call stack.\\n```java\\nprivate Set<String> wordDict;\\nprivate Map<String, Integer> memo;\\n\\npublic int longestStrChain(String[] words) {\\n\\twordDict = new HashSet<>();\\n\\tCollections.addAll(wordDict, words); // adding all words to a set for constant look-up\\n\\n\\tint maxPath = 1;\\n\\tmemo = new HashMap<>();\\n\\tfor (String word: words) \\n\\t\\tmaxPath = Math.max(maxPath, dfs(word));\\n\\n\\treturn maxPath;\\n}\\n\\nprivate int dfs(String word) {\\n\\tif (memo.containsKey(word)) return memo.get(word); // if we\\'re computed this word before, return the result.\\n\\n\\tStringBuilder sb = new StringBuilder(word);\\n\\tint maxPath = 0;\\n\\t// delete each character, check if that\\'s a valid word in the set, add the character back and continue\\n\\tfor (int i=0; i<word.length(); i++) {\\n\\t\\tsb.deleteCharAt(i);\\n\\t\\tString prevWord = sb.toString();\\n\\t\\tif (wordDict.contains(prevWord)) \\n\\t\\t\\tmaxPath = Math.max(maxPath, dfs(prevWord));\\n\\t\\tsb.insert(i, word.charAt(i));\\n\\t}\\n\\t\\n\\tmemo.put(word, maxPath + 1); // store the result\\n\\treturn memo.get(word);\\n}\\n```\\n\\n**DP | Decreasing Word Length:**\\n> Time complexity: `O(nlogn + n*m^2)`: sorting + same reasons as above.\\n> Space complexity: `O(n)` for the dp map.\\n```java\\npublic int longestStrChain(String[] words) {\\n\\tArrays.sort(words, (String a, String b) -> a.length() - b.length()); // sort by length\\n\\tMap<String, Integer> dp = new HashMap<>();\\n\\n\\tint maxPath = 1;\\n\\t// same idea behind the previous approach but performed iteratively.\\n\\tfor (String word: words) {\\n\\t\\tint currLength = 1;\\n\\t\\tStringBuilder sb = new StringBuilder(word);\\n\\t\\tfor (int i=0; i<word.length(); i++) {\\n\\t\\t\\tsb.deleteCharAt(i);\\n\\t\\t\\tString prevWord = sb.toString();\\n\\t\\t\\tcurrLength = Math.max(currLength, dp.getOrDefault(prevWord, 0) + 1); \\n\\t\\t\\tsb.insert(i, word.charAt(i));\\n\\t\\t}\\n\\t\\tdp.put(word, currLength);\\n\\t\\tmaxPath = Math.max(maxPath, currLength);\\n\\t}\\n\\n\\treturn maxPath;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```java\\nprivate Map<Integer, List<String>> wordLengthMap;\\nprivate Map<String, Integer> memo;\\n\\npublic int longestStrChain(String[] words) {\\n\\t// store each word with its corresponding length\\n\\twordLengthMap = new HashMap<>();\\n\\tfor (String word: words) {\\n\\t\\twordLengthMap.putIfAbsent(word.length(), new ArrayList<>());\\n\\t\\twordLengthMap.get(word.length()).add(word);\\n\\t}\\n\\n\\tint maxPath = 1;\\n\\tmemo = new HashMap<>();\\n\\tfor (String word: words) \\n\\t\\tmaxPath = Math.max(maxPath, dfs(word));\\n\\n\\treturn maxPath;\\n}\\n\\nprivate int dfs(String word) {\\n\\tif (!wordLengthMap.containsKey(word.length() + 1)) return 1; // if there are no words of the next length, we\\'re done with this path.\\n\\tif (memo.containsKey(word)) return memo.get(word); // if we\\'re computed this word before, return the result.\\n\\n\\tint maxPath = 0;\\n\\t// for each word, find all words which are 1 letter longer and see if they are valid successors.\\n\\tList<String> nextWords = wordLengthMap.get(word.length() + 1);\\n\\tfor (String nextWord: nextWords) \\n\\t\\tif (isOneOff(word, nextWord)) \\n\\t\\t\\tmaxPath = Math.max(maxPath, dfs(nextWord));\\n\\t\\n\\tmemo.put(word, maxPath + 1); // store our result\\n\\treturn memo.get(word);\\n}\\n\\n// returns true if two strings differ by no more than 1 letter\\nprivate boolean isOneOff(String a, String b) {\\n\\tint count = 0;\\n\\tfor (int i=0, j=0; i<b.length() && j<a.length() && count <= 1; i++) {\\n\\t\\tif (a.charAt(j) != b.charAt(i)) count++;\\n\\t\\telse j++;\\n\\t}\\n\\treturn count <= 1;\\n}\\n```\n```java\\nprivate Set<String> wordDict;\\nprivate Map<String, Integer> memo;\\n\\npublic int longestStrChain(String[] words) {\\n\\twordDict = new HashSet<>();\\n\\tCollections.addAll(wordDict, words); // adding all words to a set for constant look-up\\n\\n\\tint maxPath = 1;\\n\\tmemo = new HashMap<>();\\n\\tfor (String word: words) \\n\\t\\tmaxPath = Math.max(maxPath, dfs(word));\\n\\n\\treturn maxPath;\\n}\\n\\nprivate int dfs(String word) {\\n\\tif (memo.containsKey(word)) return memo.get(word); // if we\\'re computed this word before, return the result.\\n\\n\\tStringBuilder sb = new StringBuilder(word);\\n\\tint maxPath = 0;\\n\\t// delete each character, check if that\\'s a valid word in the set, add the character back and continue\\n\\tfor (int i=0; i<word.length(); i++) {\\n\\t\\tsb.deleteCharAt(i);\\n\\t\\tString prevWord = sb.toString();\\n\\t\\tif (wordDict.contains(prevWord)) \\n\\t\\t\\tmaxPath = Math.max(maxPath, dfs(prevWord));\\n\\t\\tsb.insert(i, word.charAt(i));\\n\\t}\\n\\t\\n\\tmemo.put(word, maxPath + 1); // store the result\\n\\treturn memo.get(word);\\n}\\n```\n```java\\npublic int longestStrChain(String[] words) {\\n\\tArrays.sort(words, (String a, String b) -> a.length() - b.length()); // sort by length\\n\\tMap<String, Integer> dp = new HashMap<>();\\n\\n\\tint maxPath = 1;\\n\\t// same idea behind the previous approach but performed iteratively.\\n\\tfor (String word: words) {\\n\\t\\tint currLength = 1;\\n\\t\\tStringBuilder sb = new StringBuilder(word);\\n\\t\\tfor (int i=0; i<word.length(); i++) {\\n\\t\\t\\tsb.deleteCharAt(i);\\n\\t\\t\\tString prevWord = sb.toString();\\n\\t\\t\\tcurrLength = Math.max(currLength, dp.getOrDefault(prevWord, 0) + 1); \\n\\t\\t\\tsb.insert(i, word.charAt(i));\\n\\t\\t}\\n\\t\\tdp.put(word, currLength);\\n\\t\\tmaxPath = Math.max(maxPath, currLength);\\n\\t}\\n\\n\\treturn maxPath;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078579,
                "title": "95-46-dp-memo",
                "content": "# Interview Guide: \"Longest String Chain\" Problem\\n\\n## Problem Understanding\\n\\nThe \"Longest String Chain\" problem presents you with an array of words. The objective is to identify the lengthiest chain of words where every word in the chain acts as a predecessor to the subsequent word. A word, say `A`, stands as a predecessor to another word, `B`, if you can inject just a single letter at any position in `A`, without altering the sequence of its other characters, to match it to `B`.\\n\\n### Key Points to Ponder:\\n\\n1. **Grasp the Boundaries**\\n   Start by thoroughly comprehending the constraints of the problem. Words in the array can be as few as 1 or as many as 1000. Each word\\'s length can range between 1 to 16 characters. Understanding these limits can guide your solution\\'s design and efficiency.\\n\\n2. **Diverse Pathways**\\n   Multiple avenues can be explored to crack this problem, such as:\\n   - Dynamic Programming\\n   - Depth-First Search (DFS) with Memoization\\n\\n   Every approach carries its own time and space complexity. Thus, select wisely, keeping the constraints in mind.\\n\\n3. **Be Wary of Edge Cases**\\n   If you notice words that don\\'t adhere to the lowercase English letters rule or exceed the mentioned lengths, they can be potential edge cases to consider.\\n\\n4. **Narrate Your Thought Journey**\\n   As you unravel the problem, always articulate your thought process and the rationale behind picking a certain methodology. Shed light on any trade-offs you\\'re contemplating in terms of computational time and space.\\n\\n5. **Test and Validate**\\n   Once you\\'ve drafted a solution, validate it with different test cases, especially edge cases, to ensure its robustness.\\n\\n### Conclusion\\n\\nThe \"Longest String Chain\" problem is a classic example of challenges that examine your string manipulation and optimization skills. Being adept at various solution techniques and understanding the nuances can not only help you solve the problem efficiently but also make a strong impression in technical discussions or interviews. Your ability to understand, analyze, and optimize will set you apart.\\n\\n---\\n\\n# Strategy to Solve the Problem:\\n\\n## Live Coding Special\\nhttps://youtu.be/EiQpUgUghzY?si=leq4DHTH6WC7iiSB\\n\\n## Approach: Dynamic Programming\\n\\nTackling the \"Longest String Chain\" puzzle requires a blend of systematic organization and methodical computation. Our primary weapon of choice for this challenge is Dynamic Programming, a strategy that breaks problems down into smaller, more manageable sub-problems. The beauty of this approach lies in its ability to remember past results, which significantly speeds up computing the final solution.\\n\\n### Key Data Structures:\\n\\n- `dp`: A dictionary, acting like our memory vault, that remembers the longest chain length we can achieve for each word.\\n\\n### Detailed Breakdown:\\n\\n1. **Setting the Stage - Organizing Words**:\\n   - Imagine you\\'re arranging dominoes; the smallest pieces first, growing to the largest. Similarly, we start by sorting our words from shortest to longest. This ensures that when we\\'re looking at a word, any potential \\'parent\\' word (a word it could have evolved from) has already been evaluated.\\n\\n2. **Constructing Chains**:\\n   - For every word, we assume it to be a unique entity and assign a chain length of 1. This is our base scenario, the minimal chain.\\n   - Now, we dive deep into each word. By omitting one character at a time, we attempt to form a predecessor word. If this predecessor exists in our `dp` (our memory vault), it means our current word could have evolved from it. Using the transition function, we then update our current word\\'s chain length based on the predecessor\\'s length.\\n\\n**Why the Transition Function?**  \\nIn dynamic programming, transition functions act like bridges, connecting sub-problems to construct the bigger picture. Here, it helps us decide if the chain length of the current word should be updated based on its predecessor. It\\'s the heart of our solution, ensuring we always have the longest chain possible.\\n\\n### Complexity Commentary:\\n\\n**Time Complexity**: \\n- Our method involves scanning through our sorted list of words. For each word, it evaluates all possible words it could have evolved from. This double traversal gives rise to a time complexity of $$ O(n \\\\times m) $$, where $$ n $$ denotes the total number of words and $$ m $$ signifies the average word length.\\n\\n**Space Complexity**: \\n- Our `dp` dictionary occupies space based on the number of words, giving us a space complexity of $$ O(n) $$.\\n\\n\\n# Code Dynamic Programming\\n``` Python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)\\n        dp = {}\\n        max_chain = 0\\n        for word in words:\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                prev_word = word[:i] + word[i+1:]\\n                if prev_word in dp:\\n                    dp[word] = max(dp[word], dp[prev_word] + 1)\\n            max_chain = max(max_chain, dp[word])\\n        return max_chain\\n```\\n``` Go []\\nfunc longestStrChain(words []string) int {\\n    sort.Slice(words, func(i, j int) bool {\\n        return len(words[i]) < len(words[j])\\n    })\\n    dp := make(map[string]int)\\n    max_chain := 0\\n    for _, word := range words {\\n        dp[word] = 1\\n        for i := 0; i < len(word); i++ {\\n            prev_word := word[:i] + word[i+1:]\\n            if val, exists := dp[prev_word]; exists {\\n                dp[word] = max(dp[word], val + 1)\\n            }\\n        }\\n        max_chain = max(max_chain, dp[word])\\n    }\\n    return max_chain\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn longest_str_chain(words: Vec<String>) -> i32 {\\n        let mut words = words;\\n        words.sort_by_key(|a| a.len());\\n        let mut dp: HashMap<String, i32> = HashMap::new();\\n        let mut max_chain = 0;\\n        for word in &words {\\n            dp.insert(word.clone(), 1);\\n            for i in 0..word.len() {\\n                let prev_word = format!(\"{}{}\", &word[..i], &word[i+1..]);\\n                if let Some(val) = dp.get(&prev_word) {\\n                    dp.insert(word.clone(), std::cmp::max(dp[word], val + 1));\\n                }\\n            }\\n            max_chain = std::cmp::max(max_chain, dp[word]);\\n        }\\n        max_chain\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int longestStrChain(std::vector<std::string>& words) {\\n        std::sort(words.begin(), words.end(), [](const std::string& a, const std::string& b) {\\n            return a.size() < b.size();\\n        });\\n        \\n        std::unordered_map<std::string, int> dp;\\n        int max_chain = 0;\\n        for (const auto& word : words) {\\n            dp[word] = 1;\\n            for (int i = 0; i < word.size(); ++i) {\\n                std::string prev_word = word.substr(0, i) + word.substr(i + 1);\\n                if (dp.find(prev_word) != dp.end()) {\\n                    dp[word] = std::max(dp[word], dp[prev_word] + 1);\\n                }\\n            }\\n            max_chain = std::max(max_chain, dp[word]);\\n        }\\n        return max_chain;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        HashMap<String, Integer> dp = new HashMap<>();\\n        int max_chain = 0;\\n        for (String word : words) {\\n            dp.put(word, 1);\\n            for (int i = 0; i < word.length(); i++) {\\n                String prev_word = word.substring(0, i) + word.substring(i + 1);\\n                if (dp.containsKey(prev_word)) {\\n                    dp.put(word, Math.max(dp.get(word), dp.get(prev_word) + 1));\\n                }\\n            }\\n            max_chain = Math.max(max_chain, dp.get(word));\\n        }\\n        return max_chain;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function longestStrChain($words) {\\n        usort($words, function($a, $b) {\\n            return strlen($a) - strlen($b);\\n        });\\n        $dp = [];\\n        $max_chain = 0;\\n        foreach ($words as $word) {\\n            $dp[$word] = 1;\\n            for ($i = 0; $i < strlen($word); $i++) {\\n                $prev_word = substr($word, 0, $i) . substr($word, $i + 1);\\n                if (isset($dp[$prev_word])) {\\n                    $dp[$word] = max($dp[$word], $dp[$prev_word] + 1);\\n                }\\n            }\\n            $max_chain = max($max_chain, $dp[$word]);\\n        }\\n        return $max_chain;\\n    }\\n}\\n```\\n``` JavaScritp []\\nvar longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    const dp = {};\\n    let max_chain = 0;\\n    for (const word of words) {\\n        dp[word] = 1;\\n        for (let i = 0; i < word.length; i++) {\\n            const prev_word = word.slice(0, i) + word.slice(i + 1);\\n            if (prev_word in dp) {\\n                dp[word] = Math.max(dp[word], dp[prev_word] + 1);\\n            }\\n        }\\n        max_chain = Math.max(max_chain, dp[word]);\\n    }\\n    return max_chain;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        Array.Sort(words, (a, b) => a.Length.CompareTo(b.Length));\\n        Dictionary<string, int> dp = new Dictionary<string, int>();\\n        int max_chain = 0;\\n        foreach (var word in words) {\\n            dp[word] = 1;\\n            for (int i = 0; i < word.Length; i++) {\\n                string prev_word = word.Remove(i, 1);\\n                if (dp.ContainsKey(prev_word)) {\\n                    dp[word] = Math.Max(dp[word], dp[prev_word] + 1);\\n                }\\n            }\\n            max_chain = Math.Max(max_chain, dp[word]);\\n        }\\n        return max_chain;\\n    }\\n}\\n```\\n\\n---\\n\\n## Memoization with DFS Approach:\\n\\nThis approach uses DFS to explore the potential chains starting from each word. To optimize the solution, the results of expensive recursive calls are cached using memoization.\\n\\n### Key Data Structures:\\n\\n- `memo`: A dictionary to cache the results of DFS calls for each word.\\n\\n### Enhanced Breakdown:\\n\\n1. **DFS Exploration**:\\n   - For each word, recursively explore its potential predecessors by removing one character at a time.\\n   - Cache the result of the DFS exploration for each word to avoid redundant calculations.\\n\\n2. **Check Maximum Chain Length**:\\n   - After exploring all potential chains starting from a word, store the maximum chain length found in the `memo` dictionary.\\n\\n### Complexity Analysis:\\n\\n**Time Complexity**: \\n- The algorithm explores each word once and, for each word, checks all its potential predecessors. Due to memoization, repeated calculations are avoided. The time complexity is $$ O(n \\\\times m) $$.\\n\\n**Space Complexity**: \\n- The space complexity is $$ O(n) $$ due to the storage requirements of the `memo` dictionary and the `word_set`.\\n\\n\\n## Code Memoization with DFS\\n``` Python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        word_set = set(words)\\n        memo = {}\\n\\n        def dfs(word):\\n            if word not in word_set:\\n                return 0\\n\\n            if word in memo:\\n                return memo[word]\\n\\n            max_chain = 1\\n            for i in range(len(word)):\\n                next_word = word[:i] + word[i+1:]\\n                max_chain = max(max_chain, 1 + dfs(next_word))\\n\\n            memo[word] = max_chain\\n            return max_chain\\n\\n        return max(dfs(word) for word in words)\\n```\\n\\n## Performance\\n\\n| Language    | Time (ms) | Memory (MB) | Solution Technique    |\\n|-------------|----------:|------------:|-----------------------|\\n| Go          | 21        | 6.8         | DP                    |\\n| Rust        | 28        | 2.5         | DP                    |\\n| Java        | 39        | 44.5        | DP                    |\\n| PHP         | 42        | 19.3        | DP                    |\\n| C++         | 58        | 17.0        | DP                    |\\n| C#          | 96        | 56.8        | DP                    |\\n| Python3     | 112       | 16.7        | DP                    |\\n| Python3     | 147       | 20.2        | Memoization with DFS  |\\n| JavaScript  | 167       | 63.4        | DP                    |\\n\\n![plot2.png](https://assets.leetcode.com/users/images/8240584c-22d3-47ba-9123-ab459b86a6a8_1695429079.3058512.png)\\n\\n\\n## Summary\\n\\nAll strategies provided above tackle the problem effectively. The dynamic programming approach offers a systematic way of computing the chain lengths, making it intuitive and efficient. On the other hand, the DFS with memoization approach provides a depth-first exploration of the problem, optimized by caching results. Depending on the nature of the input and specific use cases, one can choose the appropriate strategy to solve the problem.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)\\n        dp = {}\\n        max_chain = 0\\n        for word in words:\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                prev_word = word[:i] + word[i+1:]\\n                if prev_word in dp:\\n                    dp[word] = max(dp[word], dp[prev_word] + 1)\\n            max_chain = max(max_chain, dp[word])\\n        return max_chain\\n```\n``` Go []\\nfunc longestStrChain(words []string) int {\\n    sort.Slice(words, func(i, j int) bool {\\n        return len(words[i]) < len(words[j])\\n    })\\n    dp := make(map[string]int)\\n    max_chain := 0\\n    for _, word := range words {\\n        dp[word] = 1\\n        for i := 0; i < len(word); i++ {\\n            prev_word := word[:i] + word[i+1:]\\n            if val, exists := dp[prev_word]; exists {\\n                dp[word] = max(dp[word], val + 1)\\n            }\\n        }\\n        max_chain = max(max_chain, dp[word])\\n    }\\n    return max_chain\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn longest_str_chain(words: Vec<String>) -> i32 {\\n        let mut words = words;\\n        words.sort_by_key(|a| a.len());\\n        let mut dp: HashMap<String, i32> = HashMap::new();\\n        let mut max_chain = 0;\\n        for word in &words {\\n            dp.insert(word.clone(), 1);\\n            for i in 0..word.len() {\\n                let prev_word = format!(\"{}{}\", &word[..i], &word[i+1..]);\\n                if let Some(val) = dp.get(&prev_word) {\\n                    dp.insert(word.clone(), std::cmp::max(dp[word], val + 1));\\n                }\\n            }\\n            max_chain = std::cmp::max(max_chain, dp[word]);\\n        }\\n        max_chain\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int longestStrChain(std::vector<std::string>& words) {\\n        std::sort(words.begin(), words.end(), [](const std::string& a, const std::string& b) {\\n            return a.size() < b.size();\\n        });\\n        \\n        std::unordered_map<std::string, int> dp;\\n        int max_chain = 0;\\n        for (const auto& word : words) {\\n            dp[word] = 1;\\n            for (int i = 0; i < word.size(); ++i) {\\n                std::string prev_word = word.substr(0, i) + word.substr(i + 1);\\n                if (dp.find(prev_word) != dp.end()) {\\n                    dp[word] = std::max(dp[word], dp[prev_word] + 1);\\n                }\\n            }\\n            max_chain = std::max(max_chain, dp[word]);\\n        }\\n        return max_chain;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        HashMap<String, Integer> dp = new HashMap<>();\\n        int max_chain = 0;\\n        for (String word : words) {\\n            dp.put(word, 1);\\n            for (int i = 0; i < word.length(); i++) {\\n                String prev_word = word.substring(0, i) + word.substring(i + 1);\\n                if (dp.containsKey(prev_word)) {\\n                    dp.put(word, Math.max(dp.get(word), dp.get(prev_word) + 1));\\n                }\\n            }\\n            max_chain = Math.max(max_chain, dp.get(word));\\n        }\\n        return max_chain;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function longestStrChain($words) {\\n        usort($words, function($a, $b) {\\n            return strlen($a) - strlen($b);\\n        });\\n        $dp = [];\\n        $max_chain = 0;\\n        foreach ($words as $word) {\\n            $dp[$word] = 1;\\n            for ($i = 0; $i < strlen($word); $i++) {\\n                $prev_word = substr($word, 0, $i) . substr($word, $i + 1);\\n                if (isset($dp[$prev_word])) {\\n                    $dp[$word] = max($dp[$word], $dp[$prev_word] + 1);\\n                }\\n            }\\n            $max_chain = max($max_chain, $dp[$word]);\\n        }\\n        return $max_chain;\\n    }\\n}\\n```\n``` JavaScritp []\\nvar longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    const dp = {};\\n    let max_chain = 0;\\n    for (const word of words) {\\n        dp[word] = 1;\\n        for (let i = 0; i < word.length; i++) {\\n            const prev_word = word.slice(0, i) + word.slice(i + 1);\\n            if (prev_word in dp) {\\n                dp[word] = Math.max(dp[word], dp[prev_word] + 1);\\n            }\\n        }\\n        max_chain = Math.max(max_chain, dp[word]);\\n    }\\n    return max_chain;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        Array.Sort(words, (a, b) => a.Length.CompareTo(b.Length));\\n        Dictionary<string, int> dp = new Dictionary<string, int>();\\n        int max_chain = 0;\\n        foreach (var word in words) {\\n            dp[word] = 1;\\n            for (int i = 0; i < word.Length; i++) {\\n                string prev_word = word.Remove(i, 1);\\n                if (dp.ContainsKey(prev_word)) {\\n                    dp[word] = Math.Max(dp[word], dp[prev_word] + 1);\\n                }\\n            }\\n            max_chain = Math.Max(max_chain, dp[word]);\\n        }\\n        return max_chain;\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        word_set = set(words)\\n        memo = {}\\n\\n        def dfs(word):\\n            if word not in word_set:\\n                return 0\\n\\n            if word in memo:\\n                return memo[word]\\n\\n            max_chain = 1\\n            for i in range(len(word)):\\n                next_word = word[:i] + word[i+1:]\\n                max_chain = max(max_chain, 1 + dfs(next_word))\\n\\n            memo[word] = max_chain\\n            return max_chain\\n\\n        return max(dfs(word) for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213855,
                "title": "js-python-java-c-fast-set-dp-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nA naive approach would be to check every word against every other word looking for predecessors, but that would lead to a **TLE** result. The first important realization that we should be able to make is that while a **word** may have many **26 * (word.length + 1)** possible successors, it can only have **word.length** predecessors.\\n\\nSo rather than iterating from small to large words and checking every combination for a link, we can store the words in a **set** and only check the few possible predecessors while iterating from large to small. To aid in that, we can actually separate words into an array of sets (**W**) indexed by word length, so that we can directly access batches of words by their length.\\n\\n_(**Note**: As we iterate backward through **W**, if we find that **W[i-1]** is empty, we don\\'t need to process the words in **W[i]**, since there cannot possibly be a predecessor match.)_\\n\\nThen we can use a **dynamic programming** (**DP**) approach to eliminate some common subproblems. We can define a **hashmap** (**dp**) where **dp[word]** is the length of the longest chain ending at **word** found so far.\\n\\nSo at each **word**, we\\'ll iterate through each of its predecessors (**pred**) and check the appropriate set in **W** for a match. If we find a match, we can update **dp[pred]** if **dp[word] + 1** is better, increasing the chain by one. We should also separately keep track of the **best** chain length we\\'ve seen, so that once we reach the end, we can just **return best**.\\n\\n - _**Time Complexity: O(N*M)** where **N** is the length of **words** and **M** is the average length of the words in **words**._\\n - _**Space Complexity: O(N + P)** where **P** is the number of predecessors found and stored in **dp**._\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 45.8MB** (beats 100% / 75%).\\n```javascript\\nvar longestStrChain = function(words) {\\n    let W = Array.from({length: 17}, _ => new Set())\\n    for (let i = 0; i < words.length; i++) \\n        W[words[i].length].add(words[i])\\n    let dp = new Map(), best = 1\\n    for (let i = 16; i; i--) {\\n        if (!W[i-1].size) continue\\n        for (let word of W[i]) {\\n            let wVal = dp.get(word) || 1\\n            for (let j = 0; j < word.length; j++) {\\n                let pred = word.slice(0,j) + word.slice(j+1)\\n                if (W[i-1].has(pred) && wVal >= (dp.get(pred) || 1)) {\\n                    dp.set(pred, wVal + 1)\\n                    best = Math.max(best, wVal + 1)\\n                }\\n            }\\n        }\\n    }\\n    return best\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **84ms / 14.5MB** (beats 100% / 90%).\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        W = [set() for _ in range(17)]\\n        for word in words:\\n            W[len(word)].add(word)\\n        dp, best = defaultdict(lambda:1), 1\\n        for i in range(16,0,-1):\\n            if len(W[i-1]) == 0: continue\\n            for word in W[i]:\\n                wVal = dp[word]\\n                for j in range(len(word)):\\n                    pred = word[0:j] + word[j+1:]\\n                    if pred in W[i-1] and wVal >= (dp.get(pred) or 1):\\n                        dp[pred] = wVal + 1\\n                        best = max(best, wVal + 1)\\n        return best\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **20ms / 38.8MB** (beats 92% / 91%).\\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<Set<String>> W = new ArrayList<>(17);\\n        for (int i = 0; i < 17; i++)\\n            W.add(new HashSet<>());\\n        for (String word : words) \\n            W.get(word.length()).add(word);\\n        Map<String, Integer> dp = new HashMap<>();\\n        int best = 1;\\n        for (int i = 16; i > 0; i--) {\\n            if (W.get(i-1).isEmpty()) continue;\\n            for (String word : W.get(i)) {\\n                int wVal = dp.getOrDefault(word, 1);\\n                for (int j = 0; j < word.length(); j++) {\\n                    String pred = word.substring(0,j) + word.substring(j+1);\\n                    if (W.get(i-1).contains(pred) && wVal >= dp.getOrDefault(pred,1)) {\\n                        dp.put(pred, wVal + 1);\\n                        best = Math.max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **52ms / 31.2MB** (beats 91% / 27%).\\n```c++\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestStrChain = function(words) {\\n    let W = Array.from({length: 17}, _ => new Set())\\n    for (let i = 0; i < words.length; i++) \\n        W[words[i].length].add(words[i])\\n    let dp = new Map(), best = 1\\n    for (let i = 16; i; i--) {\\n        if (!W[i-1].size) continue\\n        for (let word of W[i]) {\\n            let wVal = dp.get(word) || 1\\n            for (let j = 0; j < word.length; j++) {\\n                let pred = word.slice(0,j) + word.slice(j+1)\\n                if (W[i-1].has(pred) && wVal >= (dp.get(pred) || 1)) {\\n                    dp.set(pred, wVal + 1)\\n                    best = Math.max(best, wVal + 1)\\n                }\\n            }\\n        }\\n    }\\n    return best\\n};\\n```\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        W = [set() for _ in range(17)]\\n        for word in words:\\n            W[len(word)].add(word)\\n        dp, best = defaultdict(lambda:1), 1\\n        for i in range(16,0,-1):\\n            if len(W[i-1]) == 0: continue\\n            for word in W[i]:\\n                wVal = dp[word]\\n                for j in range(len(word)):\\n                    pred = word[0:j] + word[j+1:]\\n                    if pred in W[i-1] and wVal >= (dp.get(pred) or 1):\\n                        dp[pred] = wVal + 1\\n                        best = max(best, wVal + 1)\\n        return best\\n```\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<Set<String>> W = new ArrayList<>(17);\\n        for (int i = 0; i < 17; i++)\\n            W.add(new HashSet<>());\\n        for (String word : words) \\n            W.get(word.length()).add(word);\\n        Map<String, Integer> dp = new HashMap<>();\\n        int best = 1;\\n        for (int i = 16; i > 0; i--) {\\n            if (W.get(i-1).isEmpty()) continue;\\n            for (String word : W.get(i)) {\\n                int wVal = dp.getOrDefault(word, 1);\\n                for (int j = 0; j < word.length(); j++) {\\n                    String pred = word.substring(0,j) + word.substring(j+1);\\n                    if (W.get(i-1).contains(pred) && wVal >= dp.getOrDefault(pred,1)) {\\n                        dp.put(pred, wVal + 1);\\n                        best = Math.max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485951,
                "title": "python-correct-dp-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        d = dict()\\n        for word in words:\\n            d[word] = 1\\n        longest = 1\\n        for word in sorted(words, key=len):\\n            for i in range(len(word)):\\n                prev = word[:i] + word[i + 1:]\\n                if prev in d:\\n                    d[word] = max(d[word], d[prev] + 1)\\n            longest = max(longest, d[word])\\n        return longest\\n```\\nInitially, each word\\'s longest chain is set to 1. Then, we loop the list of words to find out whether it has a predecessor in the list. If there is a predecessor, we know current word\\'s longest chain could be predecessor\\'s longest chain plus one.\\n\\nThere are two main points for this solution:\\n1.  Sort the word list `words` by each length of the word.\\nAs mentioned above, current word\\'s longest chain is formed by predecessor\\'s longest chain plus one. Therefore, we must calculate the predecessor\\'s longest chain first, otherwise the answer would be incorrect.\\n\\n2. Comparing the current word\\'s chain with all its predecessor\\'s longest chain plus one to find out the current word\\'s longest chain. \\nThis is because the current word\\'s chain could possibly be formed in many different ways, so we need to compare them to find out the longest one.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        d = dict()\\n        for word in words:\\n            d[word] = 1\\n        longest = 1\\n        for word in sorted(words, key=len):\\n            for i in range(len(word)):\\n                prev = word[:i] + word[i + 1:]\\n                if prev in d:\\n                    d[word] = max(d[word], d[prev] + 1)\\n            longest = max(longest, d[word])\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295025,
                "title": "java-concise-dp-solution",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        \\n        Map<String, Integer> dp = new HashMap<>();\\n        for (String word : words) {\\n            dp.put(word, 1);\\n        }\\n    \\n        int max = 0;\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); ++i) {   // delete one char from current word to find the previous string\\n                String prev = word.substring(0, i) + word.substring(i+1);\\n                if (dp.containsKey(prev)) {\\n                    dp.put(word, Math.max(dp.get(word), dp.get(prev) + 1));\\n                }\\n            }\\n            max = Math.max(max, dp.get(word));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        \\n        Map<String, Integer> dp = new HashMap<>();\\n        for (String word : words) {\\n            dp.put(word, 1);\\n        }\\n    \\n        int max = 0;\\n        for (String word : words) {\\n            for (int i = 0; i < word.length(); ++i) {   // delete one char from current word to find the previous string\\n                String prev = word.substring(0, i) + word.substring(i+1);\\n                if (dp.containsKey(prev)) {\\n                    dp.put(word, Math.max(dp.get(word), dp.get(prev) + 1));\\n                }\\n            }\\n            max = Math.max(max, dp.get(word));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294918,
                "title": "dp-with-hashmap-in-java",
                "content": "1. Sort the strings by their lengths\\n2. Start from shorter words (bottom up DP)\\n2. During the loop: for each word, iterate through its length and each time delete 1 char. Update the longest string chain length in the hashmap for the current word. \\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        if (words == null || words.length == 0) return 0;\\n        int res = 0;\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare(String str1, String str2) {\\n                return str1.length() - str2.length();\\n            }\\n        });\\n        HashMap<String, Integer> map = new HashMap();\\n        for (String word : words) {\\n            if (map.containsKey(word)) continue;\\n            map.put(word, 1);\\n            for (int i = 0; i < word.length(); i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                sb.deleteCharAt(i);\\n                String next = sb.toString();\\n                if (map.containsKey(next) && map.get(next) + 1 > map.get(word)) {\\n                    map.put(word, map.get(next) + 1);\\n                }\\n            }\\n            if (map.get(word) > res) res = map.get(word);\\n        }\\n        return res;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        if (words == null || words.length == 0) return 0;\\n        int res = 0;\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare(String str1, String str2) {\\n                return str1.length() - str2.length();\\n            }\\n        });\\n        HashMap<String, Integer> map = new HashMap();\\n        for (String word : words) {\\n            if (map.containsKey(word)) continue;\\n            map.put(word, 1);\\n            for (int i = 0; i < word.length(); i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                sb.deleteCharAt(i);\\n                String next = sb.toString();\\n                if (map.containsKey(next) && map.get(next) + 1 > map.get(word)) {\\n                    map.put(word, map.get(next) + 1);\\n                }\\n            }\\n            if (map.get(word) > res) res = map.get(word);\\n        }\\n        return res;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309808,
                "title": "python-graph-intuitive",
                "content": "I found the official solutions insanely unintuitive and difficult to reason about. Here\\'s a simple, straightforward graph-theory-based solution for this problem.\\n\\n#### Graph Theory\\n - `words` form a Directed Acyclic Graph (DAG)\\n - the problem is to find the *longest path* in the DAG\\n - normally longest path is NP-hard, but for a DAG, it can be done much faster\\n - we want to first topologically sort the nodes, in this case, that means sorting by word length\\n - next, we need to build our graph. We could either compare each word to every other word O(n^2) or build a dictionary of each previous word to the next word O(n * L) where L is the average length of a word in words. Because `n <= 1000` and `L <= 16`, we want O(n * L)\\n - we initialize a `dists` array where `dists[i]` is initially `1`\\n - finally we iterate over each `u, v` pair in topologically sorted order and we offer to set `dists[v]` to `dists[u] + 1` and then offer to set `ans` to `dists[v]`\\n\\n##### One quick catch:\\n`graph[word]` is a `set`, not a `list` because a word with duplicate adjacent letters would be added twice (ie `hello`). This isn\\'t technically a problem because we can offer to set `dists[v]` twice and you could view the graph as having two parallel edges. I just prefer to do it this way.\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        n = len(words)\\n        words.sort(key=lambda w: len(w))\\n        graph = defaultdict(set)\\n        for i in range(n):\\n            word = words[i]\\n            for j in range(len(word)):\\n                graph[word[:j]+word[j+1:]].add(i)\\n        dists = [1] * n\\n        ans = 1\\n        for u in range(n):\\n            for v in graph[words[u]]:\\n                dists[v] = max(dists[v], dists[u]+1)\\n                ans = max(ans, dists[v])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        n = len(words)\\n        words.sort(key=lambda w: len(w))\\n        graph = defaultdict(set)\\n        for i in range(n):\\n            word = words[i]\\n            for j in range(len(word)):\\n                graph[word[:j]+word[j+1:]].add(i)\\n        dists = [1] * n\\n        ans = 1\\n        for u in range(n):\\n            for v in graph[words[u]]:\\n                dists[v] = max(dists[v], dists[u]+1)\\n                ans = max(ans, dists[v])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152874,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nFIrstly ```sort``` the given array on basis of length of words. Such that for a word **i** we would be checking words having length smaller than **i**\\n\\nCreate a ```dictionary``` or ```mapping``` to store the chain length till that words.\\nWhen chain of bigger word is to be found , it will be -> ``` 1 + smaller_length_of_chain```.\\n\\nInitialize the chain length of each word to be ***1***.\\n\\nAs ```word.length <= 16```, it is easy to create all combinations by taking out one character.\\n\\nForm different words ```successor``` by deleting a letter and check if that word has a larger chain length.\\n\\nKeep updating and select maximum chain length from ```mapping``` / ```dictionary```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n    std::sort(words.begin(), words.end(), [](const std::string& first, const std::string& second)\\n\\t{\\n        return first.size() < second.size();\\n\\t});\\n        \\n        map<string,int> m;\\n        int res = 0;\\n        \\n        for(string word:words)\\n        {\\n            int longest =0;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                string sub = word.substr(0,i) + word.substr(i+1,word.length()+1);\\n                longest = max(longest,m[sub]+1);   \\n            }\\n            \\n            m[word] = longest;\\n            res = max(res,longest);\\n        }\\n        return res;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/c36e9897-0d0f-4077-8457-784cfe87aaf9_1655253023.3773618.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```sort```\n```dictionary```\n```mapping```\n``` 1 + smaller_length_of_chain```\n```word.length <= 16```\n```successor```\n```mapping```\n```dictionary```\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n    std::sort(words.begin(), words.end(), [](const std::string& first, const std::string& second)\\n\\t{\\n        return first.size() < second.size();\\n\\t});\\n        \\n        map<string,int> m;\\n        int res = 0;\\n        \\n        for(string word:words)\\n        {\\n            int longest =0;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                string sub = word.substr(0,i) + word.substr(i+1,word.length()+1);\\n                longest = max(longest,m[sub]+1);   \\n            }\\n            \\n            m[word] = longest;\\n            res = max(res,longest);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152864,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nFIrstly ```sort``` the given array on basis of length of words. Such that for a word **i** we would be checking words having length smaller than **i**\\n\\nCreate a ```dictionary``` or ```mapping``` to store the chain length till that words.\\nWhen chain of bigger word is to be found , it will be -> ``` 1 + smaller_length_of_chain```.\\n\\nInitialize the chain length of each word to be ***1***.\\n\\nAs ```word.length <= 16```, it is easy to create all combinations by taking out one character.\\n\\nForm different words ```successor``` by deleting a letter and check if that word has a larger chain length.\\n\\nKeep updating and select maximum chain length from ```mapping``` / ```dictionary```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        words.sort(key=len)\\n        dic = {}\\n        \\n        for i in words:\\n            dic[ i ] = 1\\n            \\n            for j in range(len(i)):\\n                \\n                # creating words by deleting a letter\\n                successor = i[:j] + i[j+1:]\\n                if successor in dic:\\n                    dic[ i ] = max (dic[i], 1 + dic[successor])\\n        \\n        res = max(dic.values())\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/77cb1004-ff4a-4800-a861-1ed09b1cb8e9_1655252348.3756516.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```sort```\n```dictionary```\n```mapping```\n``` 1 + smaller_length_of_chain```\n```word.length <= 16```\n```successor```\n```mapping```\n```dictionary```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        words.sort(key=len)\\n        dic = {}\\n        \\n        for i in words:\\n            dic[ i ] = 1\\n            \\n            for j in range(len(i)):\\n                \\n                # creating words by deleting a letter\\n                successor = i[:j] + i[j+1:]\\n                if successor in dic:\\n                    dic[ i ] = max (dic[i], 1 + dic[successor])\\n        \\n        res = max(dic.values())\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295182,
                "title": "c-bottom-up-dp-solution-with-explanation",
                "content": "**Steps Involed :**\\n1. Divide the words list into different levels according to their length, (atmost 17 as given in the contraint).\\n2. Initialize each word with chain value 1, using a map. i.e. each word in the list is itself a chain of length 1.\\n3. Now we loop through all the levels, since words of length 1 cannot can have predecessor and there is any word of length 1, it\\'s value has been already mapped to 1, we start with words of length 2. \\n4. Now, we find possible predecessor of all words of length, using method **findAllWords** . eg - say for word ac, predecessor would be a or c. For word abcd it would be bcd, acd, abd.\\n5. For each predecessory word, we check if it already exists using our map, if yes, we add\\n1 to its value, since now we have word chain of length 1 more than the predecessory. It may happen that a predecessory has a value greater than other predecessor, so we need to take the maximum of them. \\n6. We maintain our ans by taking maximum of all the word chains we have till now.\\n\\n**If you have any doubt regarding my solution, feel free to ask.**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<string> findAllWords(string &a)\\n    {\\n        vector<string> vec;\\n        for (int i=0; i<a.size(); ++i)\\n        {\\n            vec.push_back(a.substr(0, i) + a.substr(i+1, a.size()-i-1));\\n        }\\n        return vec;\\n    }\\n    \\n    int longestStrChain(vector<string>& words)\\n    {\\n        // Divides given word in 17 levels, according to their word length.\\n        vector<vector<string>> levels(17);\\n        for (auto &word : words)    levels[word.size()].push_back(word);\\n        \\n        unordered_map<string, int> mp;\\n        for (auto word: words)  mp[word] = 1;\\n        \\n        int ans = 1;\\n        for (int i=2; i<=16; ++i)\\n        {\\n            for (int j=0; j<levels[i].size(); ++j)\\n            {\\n                vector<string> diffWords = findAllWords(levels[i][j]);\\n                \\n                for (auto word: diffWords)\\n                {\\n                    if (mp.find(word) != mp.end())  mp[levels[i][j]] = max(mp[word] + 1, mp[levels[i][j]]);\\n                }\\n                \\n                ans = max (ans, mp[levels[i][j]]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<string> findAllWords(string &a)\\n    {\\n        vector<string> vec;\\n        for (int i=0; i<a.size(); ++i)\\n        {\\n            vec.push_back(a.substr(0, i) + a.substr(i+1, a.size()-i-1));\\n        }\\n        return vec;\\n    }\\n    \\n    int longestStrChain(vector<string>& words)\\n    {\\n        // Divides given word in 17 levels, according to their word length.\\n        vector<vector<string>> levels(17);\\n        for (auto &word : words)    levels[word.size()].push_back(word);\\n        \\n        unordered_map<string, int> mp;\\n        for (auto word: words)  mp[word] = 1;\\n        \\n        int ans = 1;\\n        for (int i=2; i<=16; ++i)\\n        {\\n            for (int j=0; j<levels[i].size(); ++j)\\n            {\\n                vector<string> diffWords = findAllWords(levels[i][j]);\\n                \\n                for (auto word: diffWords)\\n                {\\n                    if (mp.find(word) != mp.end())  mp[levels[i][j]] = max(mp[word] + 1, mp[levels[i][j]]);\\n                }\\n                \\n                ans = max (ans, mp[levels[i][j]]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334384,
                "title": "no-sort-easy-and-short-to-understand-solution-90",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        ans = 0\\n        words_set = set(words)\\n        dp = {}\\n        def dfs(word):\\n            if word in dp: return dp[word]\\n            ans = 1\\n            for i in range(len(word)):\\n                next_word = word[:i] + word[i + 1:]\\n                if next_word in words_set:\\n                    ans = max(1 + dfs(next_word), ans)\\n            dp[word] = ans\\n            return ans\\n                \\n        for word in words:\\n            ans = max(ans, dfs(word))\\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        ans = 0\\n        words_set = set(words)\\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 298884,
                "title": "python-using-dictionary",
                "content": "```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        words = sorted(words, key=lambda word:len(word))\\n        word_dict = {}\\n        \\n        for word in words:\\n            word_dict[word] = 1\\n        \\n        longest = 1\\n        for word in words:\\n            for i in xrange(len(word)):\\n                if word[:i] + word[i + 1:] in word_dict:\\n\\t\\t\\t\\t\\tword_dict[word]=max(word_dict[word[:i]+word[i+1:]]+1, word_dict[word])\\n                    longest = max(longest, word_dict[word])\\n        \\n        return longest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        words = sorted(words, key=lambda word:len(word))\\n        word_dict = {}\\n        \\n        for word in words:\\n            word_dict[word] = 1\\n        \\n        longest = 1\\n        for word in words:\\n            for i in xrange(len(word)):\\n                if word[:i] + word[i + 1:] in word_dict:\\n\\t\\t\\t\\t\\tword_dict[word]=max(word_dict[word[:i]+word[i+1:]]+1, word_dict[word])\\n                    longest = max(longest, word_dict[word])\\n        \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080044,
                "title": "video-how-we-think-about-a-solution-beats-97-49-python-javascript-java-c",
                "content": "This artcle starts with \"How we think about a solution\". In other words, that is my thought process to solve the question. This article explains how I get to my solution instead of just posting solution codes or out of blue algorithms. I hope this aricle is helpful for someone.\\n\\n# Intuition\\nSort all words by length of the words\\n\\n---\\n\\n# Solution Video\\n\\nIn the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/NJzV2nE8KjI\\n\\n\\u25A0 Timeline\\n`0:00` Read the question of Longest String Chain\\n`0:57` How we think about a solution\\n`4:01` Explain how to solve Longest String Chain with a concrete example\\n`7:19` Coding\\n`11:20` Time Complexity and Space Complexity\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,446\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n## How we think about a solution\\nAccording to the description, we can create another word `wordB` from `wordA` by adding one letter anywhere in `wordA`, so seems like it\\'s easy for us to solve the question with `sorting` because the differece between `wordA` and `wordB` is just one letter. I thought `sorting` might make the question easy to compare words.\\n\\nQuestion is that what do you sort all input data by? each character in all words? My answer is `to sort by length of input words`. \\n\\nI have 3 reasons.\\n\\n1. **Increased Potential for Efficient Solutions**:\\n   Sorting the words by their length allows us to process the words starting from the shortest, potentially leading to more efficient algorithms as we can prioritize shorter words first.\\n\\n2. **Enables Preprocessing**:\\n    Since we are sure that `wordB` is +1 longer than `wordA` and `wordB` has one different letter from `wordA`, if we take off one letter from `wordB` one by one, we can create all predecessors of `wordB` which are all possible `wordA`.  For example,\\n\\n```\\nwordB = \"abc\"\\n\\nwordA should be\\ntake off \"a\" \\u2192 \"bc\"\\ntake off \"b\" \\u2192 \"ac\"\\ntake off \"c\" \\u2192 \"ab\"\\n```\\n\\nSo we have 3 possible predecessor candidates.\\n\\nOne more important thing why we should sort by length is that now we check `abc` which is `length of 3`. That means we already finished checking `the max chain length unitl length of 2` because we sorted by length of input words. In other words, We should have the results for all possible words until length of 2. `all possible words` means all words coming from input list `words`. That is the third reason to sort by length of words.\\n\\nIn this case, we need to keep all the previous results. What strategy do you use to keep the results?\\n\\nMy answer is `Dynamic Programming`. More precisely use `HashMap`.\\n\\nWe can only use words from input list `words`, so keys of `Hashmap` should be words from input list `words`. Each value stands for max chain length for each word.\\n\\nLet\\'s see what I said with \\n```\\nwordB = \"abc\"\\n\\nwordA should be\\ntake off \"a\" \\u2192 \"bc\"\\ntake off \"b\" \\u2192 \"ac\"\\ntake off \"c\" \\u2192 \"ab\"\\n```\\nCurrent `wordB` is `abc` and we have 3 possible predecessor candidates. Let\\'s say we have the results until length of 2 like this\\n```\\nhash =  {\\'bc\\': 1, \\'ab\\': 2}\\n```\\nIn this case, we check `bc`, `ac`, `ab` one by one.\\n\\nFirst of all, we should add `abc` with `1` because word `abc` itself is at least one chain.\\n\\n```\\nhash =  {\\'bc\\': 1, \\'ab\\': 2, \\'abc\\': 1}\\n```\\n\\nThen check `bc`. We have the result of `bc` which is 1, so compare like this\\n```\\nhash[wordB] = max(hash[wordB], hash[\"bc\"] + 1)\\n```\\n`hash[wordB]` is current result so far and `hash[\"bc\"]` is the previous result `1`, `+1` is for adding some character. This time, a chain should be `+1` longer than from previous word. Now `hash[wordB] = 2`\\n\\nNext, check `ac` but we don\\'t have the result for `ac` which means `ac` is not listed in input list `words`.\\n\\nAt last, check `ab` and we have the result of `ab` which is `2`, so\\n\\n```\\nNow, hash[wordB] = 2\\n\\nhash[wordB] = max(hash[wordB], hash[\"ab\"] + 1)\\n\\u2193\\nhash[wordB] = max(2, 2 + 1)\\n\\u2193\\nhash[wordB] = 3\\n```\\n\\nIn the end, `hash` has the max chain length for each valid word. So all we have to do is just take max of chains from `hash`.\\n\\nSeems like `sorting` and `dynamic programming` strategy works. Let\\'s see a real algorithm.\\n\\n## Algorithm Overview\\n1. Create a dictionary `chains` to store the maximum chain length for each word.\\n2. Sort the words in the input list by their lengths.\\n3. Iterate through the sorted words and calculate the maximum chain length for each word.\\n4. Return the maximum chain length found.\\n\\n## Detailed Explanation\\n1. Initialize an empty dictionary `chains` to store the maximum chain length for each word.\\n\\n2. Sort the words in the input list (`words`) by their lengths using the `sorted` function and assign the result to `sorted_words`.\\n\\n3. Iterate through each word in the sorted list (`sorted_words`):\\n\\n   a. For each word, initialize the chain length for that word in the `chains` dictionary to 1, representing the chain with just the word itself.\\n   \\n   b. For each index `i` in the range of the length of the current word:\\n   \\n    i. Generate the predecessor of the current word by removing the character at index `i` using slicing (`word[:i] + word[i+1:]`), and assign it to `pred`.\\n      \\n      ii. Check if the predecessor `pred` is already in the `chains` dictionary:\\n      \\n    - If it is, update the chain length for the current word (`chains[word]`) to the maximum of its current chain length and the chain length of the predecessor incremented by 1 (`chains[pred] + 1`).\\n          \\n    - If it\\'s not, continue to the next iteration.\\n   \\n4. Return the maximum chain length found by taking the maximum value from the values in the `chains` dictionary using the `max` function. This represents the longest string chain.\\n\\n5. The function returns the maximum chain length.\\n\\n\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n log n + len(words) * 16) \\u2192 `O(n log n)`\\n    - the first part of `O(n log n)` comes from `sorting`, where `n` is the number of words (which can be at most 1000)\\n\\n    - `len(words) * 16` comes from for loop. `len(words)` is `n` and `16` comes from one of constraints and can be removed, so part of `len(words) * 16` should be `n`.\\n    - Since `O(n log n)` dominates time, overall time complexity is `O(n log n)`\\n\\n- Space complexity: O(n)\\n`n` is the number of words\\n\\n\\n```python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        chains = {}  # Stores the max chain length for each word\\n        sorted_words = sorted(words, key=len) # Sort words by length\\n\\n        for word in sorted_words:\\n            chains[word] = 1  # Initialize the chain length for the current word\\n            \\n            for i in range(len(word)):\\n                # word = abc, i = 0, word[:i] = \"\" + word[i+1:] = \"bc\" = \"bc\"\\n                # word = abc, i = 1, word[:i] = \"a\" + word[i+1:] = \"c\" = \"ac\"\\n                # word = abc, i = 2, word[:i] = \"ab\" + word[i+1:] = \"\" = \"ab\"\\n                pred = word[:i] + word[i+1:]  # Generate predecessor by removing one character\\n                if pred in chains:\\n                    chains[word] = max(chains[word], chains[pred] + 1)\\n\\n        return max(chains.values())\\n```\\n```javascript []\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestStrChain = function(words) {\\n    const chains = new Map();  // Stores the max chain length for each word\\n    const sortedWords = words.slice().sort((a, b) => a.length - b.length);  // Sort words by length\\n\\n    for (const word of sortedWords) {\\n        chains.set(word, 1);  // Initialize the chain length for the current word\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const pred = word.slice(0, i) + word.slice(i + 1);  // Generate predecessor by removing one character\\n            if (chains.has(pred)) {\\n                chains.set(word, Math.max(chains.get(word) || 0, chains.get(pred) + 1));\\n            }\\n        }\\n    }\\n\\n    return Math.max(...Array.from(chains.values()));  // Return the maximum chain length    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> chains = new HashMap<>();  // Stores the max chain length for each word\\n        String[] sortedWords = Arrays.copyOf(words, words.length);\\n        Arrays.sort(sortedWords, (a, b) -> a.length() - b.length());  // Sort words by length\\n\\n        for (String word : sortedWords) {\\n            chains.put(word, 1);  // Initialize the chain length for the current word\\n\\n            for (int i = 0; i < word.length(); i++) {\\n                String pred = word.substring(0, i) + word.substring(i + 1);  // Generate predecessor by removing one character\\n                if (chains.containsKey(pred)) {\\n                    chains.put(word, Math.max(chains.getOrDefault(word, 0), chains.get(pred) + 1));\\n                }\\n            }\\n        }\\n\\n        int maxChainLength = chains.values().stream().mapToInt(Integer::intValue).max().orElse(0);\\n        return maxChainLength;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        std::unordered_map<std::string, int> chains;  // Stores the max chain length for each word\\n        std::vector<std::string> sortedWords = words;\\n        std::sort(sortedWords.begin(), sortedWords.end(), [](const std::string& a, const std::string& b) {\\n            return a.length() < b.length();  // Sort words by length\\n        });\\n\\n        for (const std::string& word : sortedWords) {\\n            chains[word] = 1;  // Initialize the chain length for the current word\\n\\n            for (int i = 0; i < word.length(); i++) {\\n                std::string pred = word.substr(0, i) + word.substr(i + 1);  // Generate predecessor by removing one character\\n                if (chains.find(pred) != chains.end()) {\\n                    chains[word] = std::max(chains[word], chains[pred] + 1);\\n                }\\n            }\\n        }\\n\\n        int maxChainLength = 0;\\n        for (const auto& entry : chains) {\\n            maxChainLength = std::max(maxChainLength, entry.second);\\n        }\\n\\n        return maxChainLength;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\nThank you for reading such a long post. Please upvote it and don\\'t forget to subscribe to my channel!\\n\\nMy next post for daily coding challenge on Sep 24th, 2023\\nhttps://leetcode.com/problems/champagne-tower/solutions/4082622/video-how-we-think-about-a-solution-dp-solution-with-1d-and-2d-python-javascript-java-and-c/\\n\\nHave a nice day!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nwordB = \"abc\"\\n\\nwordA should be\\ntake off \"a\" \\u2192 \"bc\"\\ntake off \"b\" \\u2192 \"ac\"\\ntake off \"c\" \\u2192 \"ab\"\\n```\n```\\nwordB = \"abc\"\\n\\nwordA should be\\ntake off \"a\" \\u2192 \"bc\"\\ntake off \"b\" \\u2192 \"ac\"\\ntake off \"c\" \\u2192 \"ab\"\\n```\n```\\nhash =  {\\'bc\\': 1, \\'ab\\': 2}\\n```\n```\\nhash =  {\\'bc\\': 1, \\'ab\\': 2, \\'abc\\': 1}\\n```\n```\\nhash[wordB] = max(hash[wordB], hash[\"bc\"] + 1)\\n```\n```\\nNow, hash[wordB] = 2\\n\\nhash[wordB] = max(hash[wordB], hash[\"ab\"] + 1)\\n\\u2193\\nhash[wordB] = max(2, 2 + 1)\\n\\u2193\\nhash[wordB] = 3\\n```\n```python []\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        chains = {}  # Stores the max chain length for each word\\n        sorted_words = sorted(words, key=len) # Sort words by length\\n\\n        for word in sorted_words:\\n            chains[word] = 1  # Initialize the chain length for the current word\\n            \\n            for i in range(len(word)):\\n                # word = abc, i = 0, word[:i] = \"\" + word[i+1:] = \"bc\" = \"bc\"\\n                # word = abc, i = 1, word[:i] = \"a\" + word[i+1:] = \"c\" = \"ac\"\\n                # word = abc, i = 2, word[:i] = \"ab\" + word[i+1:] = \"\" = \"ab\"\\n                pred = word[:i] + word[i+1:]  # Generate predecessor by removing one character\\n                if pred in chains:\\n                    chains[word] = max(chains[word], chains[pred] + 1)\\n\\n        return max(chains.values())\\n```\n```javascript []\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestStrChain = function(words) {\\n    const chains = new Map();  // Stores the max chain length for each word\\n    const sortedWords = words.slice().sort((a, b) => a.length - b.length);  // Sort words by length\\n\\n    for (const word of sortedWords) {\\n        chains.set(word, 1);  // Initialize the chain length for the current word\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const pred = word.slice(0, i) + word.slice(i + 1);  // Generate predecessor by removing one character\\n            if (chains.has(pred)) {\\n                chains.set(word, Math.max(chains.get(word) || 0, chains.get(pred) + 1));\\n            }\\n        }\\n    }\\n\\n    return Math.max(...Array.from(chains.values()));  // Return the maximum chain length    \\n};\\n```\n```java []\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> chains = new HashMap<>();  // Stores the max chain length for each word\\n        String[] sortedWords = Arrays.copyOf(words, words.length);\\n        Arrays.sort(sortedWords, (a, b) -> a.length() - b.length());  // Sort words by length\\n\\n        for (String word : sortedWords) {\\n            chains.put(word, 1);  // Initialize the chain length for the current word\\n\\n            for (int i = 0; i < word.length(); i++) {\\n                String pred = word.substring(0, i) + word.substring(i + 1);  // Generate predecessor by removing one character\\n                if (chains.containsKey(pred)) {\\n                    chains.put(word, Math.max(chains.getOrDefault(word, 0), chains.get(pred) + 1));\\n                }\\n            }\\n        }\\n\\n        int maxChainLength = chains.values().stream().mapToInt(Integer::intValue).max().orElse(0);\\n        return maxChainLength;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        std::unordered_map<std::string, int> chains;  // Stores the max chain length for each word\\n        std::vector<std::string> sortedWords = words;\\n        std::sort(sortedWords.begin(), sortedWords.end(), [](const std::string& a, const std::string& b) {\\n            return a.length() < b.length();  // Sort words by length\\n        });\\n\\n        for (const std::string& word : sortedWords) {\\n            chains[word] = 1;  // Initialize the chain length for the current word\\n\\n            for (int i = 0; i < word.length(); i++) {\\n                std::string pred = word.substr(0, i) + word.substr(i + 1);  // Generate predecessor by removing one character\\n                if (chains.find(pred) != chains.end()) {\\n                    chains[word] = std::max(chains[word], chains[pred] + 1);\\n                }\\n            }\\n        }\\n\\n        int maxChainLength = 0;\\n        for (const auto& entry : chains) {\\n            maxChainLength = std::max(maxChainLength, entry.second);\\n        }\\n\\n        return maxChainLength;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079040,
                "title": "97-50-dp-recursive-iterative-commented-code",
                "content": "# Problem Description\\nGiven an **array** of words, each composed of **lowercase** English letters.\\n\\nA word `wordA` is considered a **predecessor** of another word `wordB` if and only if we can **insert** exactly **one** letter anywhere in `wordA`, **without changing** the **order** of the other characters, to make it equal to `wordB`.\\n\\nFor instance, `abc` is a **predecessor** of `abac` since we can insert `a` after the `b` in `abc` to get `abac`. However, `cba` is **not** a **predecessor** of `bcad` as **rearrangement** is needed.\\n\\nA word **chain** is defined as a **sequence** of words `[word1, word2, ..., wordk]` where `k` is **greater** than or **equal** to `1`, and each word in the sequence is a **predecessor** of the next word.\\n\\nThe task is to **determine** the length of the **longest** possible word chain that can be formed using words chosen from the given list of words.\\n\\n---\\n\\n# Dynamic Programming\\n![leet_dp.jpg](https://assets.leetcode.com/users/images/91848a67-bd6d-4faf-8027-b74bf5f068e4_1694307086.8311543.jpeg)\\n\\n\\n**Dynamic Programming** is a powerful technique that involves **caching** pre-computed results, thereby **eliminating** the need for redundant computations and significantly **optimizing** time complexity.\\nThere are **two primary approaches** to Dynamic Programming:\\n\\n## Recursive Approach (Top-Down)\\nWe can think of Recursive Approach as **breaking** hard bricks into **small** rocks. but, how this apply to our problem ?\\nWe can **break** our **complex problem** into **easier** ones. for each word search for all of its possible predecessors. If one exist, then seach also for its all possible predecessors until we reach a base case. \\n\\n## Iterative Approach (Bottom-Up)\\nWe can think of Iterative Approach as **building** high building from small bricks. but, how this also apply to our problem ?\\nWe can **solve** our **complex problem** by solving **easier** ones first and build until we reach our complex problem. We can start by words of length `1` and search for their predecessors and then words of length `2` then `3` so on.\\n\\n---\\n# Intuition\\nHello There\\uD83D\\uDE00\\nLet\\'s take a look on our today\\'s interesting problem\\uD83D\\uDE80\\n\\n- In our today\\'s problem we have **two** important requirements:\\n    - A chain if consist of **multiple** words each one is a predecessor for the one before it.\\n    - We want to find the **longest** chain.\\n\\n- If we sat a little and thought about this problem we can conclude some points.\\uD83D\\uDE33\\n    - For each word, we want to try each **possible** **predecessor** of it.\\n    - See if the predecessor **exists** in our words list then try also each predecessor of it and so on.\\n\\nLet\\'s see an example:\\uD83D\\uDE80\\nWith words list = `[\"a\", \"d\", \"b\",\"aa\", \"ab\", \"da\", \"aba\", \"ada\"]`\\nLet\\'s see what can we do for word `ada`\\n![image.png](https://assets.leetcode.com/users/images/0f7e07cc-b946-4870-9a47-55545925da0c_1695450256.1034126.png)\\nwe can see that `2` out of `3` predecessor exist in our words list which are `da` and `aa` so we will continue our chain to look for furthur predecessor. and we can see that the longest chain if we make `ada` is the last word in it is `3`.\\uD83E\\uDD2F\\n\\nNow, let\\'s see what can we do for word `aba`\\n![image.png](https://assets.leetcode.com/users/images/fc9b41d3-2bcf-4d5c-89c8-5e920595143c_1695450481.2220874.png)\\nwe can see that `2` out of `3` predecessor exist in our words list which are `ab` and `aa` so we will continue our chain to look for furthur predecessor. and we can see that the longest chain if we make `aba` is the last word in it is `3`.\\uD83E\\uDD2F\\n\\nInteresting, I think we are catching something.\\uD83E\\uDD29\\nYes, Our approach is the right one but we will have to **repeat** many steps like we saw in the two examples each of them need to calculate the largest chain for word `aa`.\\uD83D\\uDE14\\n\\nHere comes the **hero** of the day **Dynamic Programming**.\\uD83D\\uDC31\\u200D\\uD83C\\uDFCD\\uD83D\\uDC31\\u200D\\uD83C\\uDFCD\\nWhat will we do is once we calculated the largest chain for any string we will **cache** it in a `hashmap` for that string so we don\\'t have to recalculate it again.\\n\\nThis will **reduce** the time needed to solve our problem. and the two approached of Dynamic Programming are the same the main difference that one is starting from the larger word and search for all of its predecessors (Top-Down) and the other builds our `hashmap` from the shorter words (Bottom-Up).\\n\\nAnd this is the solution for our today problem I hope that you understood it\\uD83D\\uDE80\\uD83D\\uDE80\\n\\n---\\n\\n\\n# Proposed Solutions\\n## 1. Recursive Approach (Top-Down)\\n### Approach\\n1. Create two empty dictionaries: `chain_lengths` to store chain lengths (DP) and `word_set` to track word existence.\\n2. Calculate Chain Length:\\n    - If the word is **not** in `word_set`, return `0` (word doesn\\'t exist in the set).\\n    - If the chain length for the word is already **calculated**, return the stored chain length (DP).\\n    - **Iterate** through each character in the word:\\n        - Create a new word by **removing** the current character.\\n        - Recur and calculate chain length for the **new** word.\\n        - Update chain_length.\\n    - Return the final chain_length.\\n3. Longest Word Chain:\\n    - Add the word to the `word_set` and mark it as existing.\\n    - Initialize `max_chain_length` to `-1` (no chain found yet).\\n    - Iterate through each word in the input list:\\n        - **Calculate** the chain length for the current word.\\n        - Update `max_chain_length`.\\n    - Return the final `max_chain_length`.\\n\\n### Complexity\\n- **Time complexity:** $$O(N * M)$$\\nSince we are iterating over all the `N` words and in each word we try all possible predecessor by removing one character a time then the time complexity is `O(N * M)`.\\nWhere `N` is the **number** of words in our array and `M` is the **length** of the word.\\nremember that we eleminated redundant calls by using `DP`.\\n- **Space complexity:** $$O(N)$$\\nWe store two `HashMaps` each of size `N` then the space we are storing is `2 * N` then the space complexity it `O(N)`.\\n\\n---\\n\\n\\n## 2. Iterative Approach (Bottom-Up)\\n### Approach\\n1. **Sort** the words in the input vector based on their **lengths** in ascending order.\\n2. Initialize a map called `longestChainLength` to store the **longest** chain length for each word.\\n3. Initialize a variable `maxChainLength` to -1 to (no chain found yet).\\n4. Iterate through **each word** in the sorted list of words:\\n    - Initialize the **chain length** for the current word as `1` (The word itself).\\n6. remove **one character** at a time and check if the resulting word exists.\\n7. If the resulted word **exists** in the map:\\n    - **Update** the chain length.\\n    - **Update** the maximum chain length seen so far.\\n8. **Return** Maximum Chain Length.\\n\\n### Complexity\\n- **Time complexity:** $$O(N * (log(N) + M))$$\\nSince we are sorting the array of words then iterating over all the `N` words and in each word we try all possible predecessor by removing one character a time then the time complexity is `O(N * log(N) + N * M)`.\\nWhere `N` is the **number** of words in our array and `M` is the **length** of the word.\\nremember that we eleminated redundant calls by using `DP`;`\\n- **Space complexity:** $$O(N)$$\\nWe store one `HashMaps` of size `N` then the space we are storing is `N` then the space complexity it `O(N)`.\\n\\n---\\n\\n\\n# Code\\n## 1. Recursive Approach (Top-Down)\\n```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> chain_lengths;\\n    unordered_map<string, bool> word_set;\\n\\n    int calculateChainLength(const string &word) {\\n        // If the word doesn\\'t exist in the set\\n        if (word_set.find(word) == word_set.end())\\n            return 0;\\n\\n        // If chain length for the word is already calculated\\n        if (chain_lengths.find(word) != chain_lengths.end())\\n            return chain_lengths[word];\\n\\n        int chain_length = 1;\\n\\n        // Try removing one character at a time from the word and calculate chain length\\n        for (int i = 0; i < word.size(); i++) {\\n            string new_word = word.substr(0, i) + word.substr(i + 1);\\n            chain_length = max(chain_length, 1 + calculateChainLength(new_word));\\n        }\\n\\n        chain_lengths[word] = chain_length;\\n        return chain_length;\\n    }\\n\\npublic:\\n    int longestStrChain(vector<string> &words) {\\n        for (const auto &word : words) {\\n            word_set[word] = true;\\n        }\\n\\n        int max_chain_length = -1;\\n\\n        // Calculate the maximum chain length for each word\\n        for (const auto &word : words) {\\n            max_chain_length = max(max_chain_length, calculateChainLength(word));\\n        }\\n\\n        return max_chain_length;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private Map<String, Integer> chainLengths = new HashMap<>();\\n    private Map<String, Boolean> wordSet = new HashMap<>();\\n\\n    private int calculateChainLength(String word) {\\n        // If the word doesn\\'t exist in the set\\n        if (!wordSet.containsKey(word) || !wordSet.get(word))\\n            return 0;\\n\\n        // If chain length for the word is already calculated\\n        if (chainLengths.containsKey(word))\\n            return chainLengths.get(word);\\n\\n        int chainLength = 1;\\n\\n        // Try removing one character at a time from the word and calculate chain length\\n        for (int i = 0; i < word.length(); i++) {\\n            String newWord = word.substring(0, i) + word.substring(i + 1);\\n            chainLength = Math.max(chainLength, 1 + calculateChainLength(newWord));\\n        }\\n\\n        chainLengths.put(word, chainLength);\\n        return chainLength;\\n    }\\n\\n    public int longestStrChain(String[] words) {\\n        for (String word : words) {\\n            wordSet.put(word, true);\\n        }\\n\\n        int maxChainLength = -1;\\n\\n        // Calculate the maximum chain length for each word\\n        for (String word : words) {\\n            maxChainLength = Math.max(maxChainLength, calculateChainLength(word));\\n        }\\n\\n        return maxChainLength;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.chain_lengths = {}\\n        self.word_set = {}\\n\\n    def calculate_chain_length(self, word) -> int:\\n        # If the word doesn\\'t exist in the set\\n        if word not in self.word_set or not self.word_set[word]:\\n            return 0\\n\\n        # If chain length for the word is already calculated\\n        if word in self.chain_lengths:\\n            return self.chain_lengths[word]\\n\\n        chain_length = 1\\n\\n        # Try removing one character at a time from the word and calculate chain length\\n        for i in range(len(word)):\\n            new_word = word[:i] + word[i + 1:]\\n            chain_length = max(chain_length, 1 + self.calculate_chain_length(new_word))\\n\\n        self.chain_lengths[word] = chain_length\\n        return chain_length\\n\\n    def longestStrChain(self, words) -> int:\\n        for word in words:\\n            self.word_set[word] = True\\n\\n        max_chain_length = -1\\n\\n        # Calculate the maximum chain length for each word\\n        for word in words:\\n            max_chain_length = max(max_chain_length, self.calculate_chain_length(word))\\n\\n        return max_chain_length\\n```\\n\\n## 2. Iterative Approach (Bottom-Up) \\n```C++ []\\nclass Solution {\\npublic:\\n\\n    int longestStrChain(vector<string>& words) {\\n        // Sort the words by their lengths\\n        sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n            return a.length() < b.length();\\n        });\\n\\n        // Map to store the longest chain length for each word\\n        unordered_map<string, int> longestChainLength;\\n\\n        // Initialize the answer\\n        int maxChainLength = -1;\\n\\n        for(auto &word: words){\\n            // Initialize the chain length for the current word\\n            longestChainLength[word] = 1;\\n\\n            // Try removing one character at a time from the word and check if the resulting word exists\\n            for(int i = 0 ; i < word.size() ; i++){\\n                string reducedWord = word.substr(0, i) + word.substr(i + 1) ;\\n\\n                // If the reduced word exists in the map\\n                if(longestChainLength.find(reducedWord) != longestChainLength.end())\\n                    // Update the chain length for the current word\\n                    longestChainLength[word] = max(longestChainLength[word], longestChainLength[reducedWord] + 1) ;\\n            }\\n\\n            // Update the maximum chain length seen so far\\n            maxChainLength = max(maxChainLength, longestChainLength[word]) ;\\n        }\\n\\n        return maxChainLength;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Sort the words by their lengths\\n        Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));\\n\\n        // Map to store the longest chain length for each word\\n        Map<String, Integer> longestChainLength = new HashMap<>();\\n\\n        // Initialize the answer\\n        int maxChainLength = -1;\\n\\n        for (String word : words) {\\n            // Initialize the chain length for the current word\\n            longestChainLength.put(word, 1);\\n\\n            // Try removing one character at a time from the word and check if the resulting word exists\\n            for (int i = 0; i < word.length(); i++) {\\n                String reducedWord = word.substring(0, i) + word.substring(i + 1);\\n\\n                // If the reduced word exists in the map\\n                if (longestChainLength.containsKey(reducedWord))\\n                    // Update the chain length for the current word\\n                    longestChainLength.put(word, Math.max(longestChainLength.get(word), longestChainLength.get(reducedWord) + 1));\\n            }\\n\\n            // Update the maximum chain length seen so far\\n            maxChainLength = Math.max(maxChainLength, longestChainLength.get(word));\\n        }\\n\\n        return maxChainLength;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def longestStrChain(self, words) -> int:\\n        # Sort the words by their lengths\\n        words.sort(key=len)\\n\\n        # Dictionary to store the longest chain length for each word\\n        longest_chain_length = {}\\n\\n        # Initialize the answer\\n        max_chain_length = -1\\n\\n        for word in words:\\n            # Initialize the chain length for the current word\\n            longest_chain_length[word] = 1\\n\\n            # Try removing one character at a time from the word and check if the resulting word exists\\n            for i in range(len(word)):\\n                reduced_word = word[:i] + word[i + 1:]\\n\\n                # If the reduced word exists in the dictionary\\n                if reduced_word in longest_chain_length:\\n                    # Update the chain length for the current word\\n                    longest_chain_length[word] = max(longest_chain_length[word], longest_chain_length[reduced_word] + 1)\\n\\n            # Update the maximum chain length seen so far\\n            max_chain_length = max(max_chain_length, longest_chain_length[word])\\n\\n        return max_chain_length\\n```\\n\\n\\n---\\n\\n\\n\\n\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/5f6aee89-454b-47ff-93c9-7030eb5d3673_1694227000.9068315.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> chain_lengths;\\n    unordered_map<string, bool> word_set;\\n\\n    int calculateChainLength(const string &word) {\\n        // If the word doesn\\'t exist in the set\\n        if (word_set.find(word) == word_set.end())\\n            return 0;\\n\\n        // If chain length for the word is already calculated\\n        if (chain_lengths.find(word) != chain_lengths.end())\\n            return chain_lengths[word];\\n\\n        int chain_length = 1;\\n\\n        // Try removing one character at a time from the word and calculate chain length\\n        for (int i = 0; i < word.size(); i++) {\\n            string new_word = word.substr(0, i) + word.substr(i + 1);\\n            chain_length = max(chain_length, 1 + calculateChainLength(new_word));\\n        }\\n\\n        chain_lengths[word] = chain_length;\\n        return chain_length;\\n    }\\n\\npublic:\\n    int longestStrChain(vector<string> &words) {\\n        for (const auto &word : words) {\\n            word_set[word] = true;\\n        }\\n\\n        int max_chain_length = -1;\\n\\n        // Calculate the maximum chain length for each word\\n        for (const auto &word : words) {\\n            max_chain_length = max(max_chain_length, calculateChainLength(word));\\n        }\\n\\n        return max_chain_length;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private Map<String, Integer> chainLengths = new HashMap<>();\\n    private Map<String, Boolean> wordSet = new HashMap<>();\\n\\n    private int calculateChainLength(String word) {\\n        // If the word doesn\\'t exist in the set\\n        if (!wordSet.containsKey(word) || !wordSet.get(word))\\n            return 0;\\n\\n        // If chain length for the word is already calculated\\n        if (chainLengths.containsKey(word))\\n            return chainLengths.get(word);\\n\\n        int chainLength = 1;\\n\\n        // Try removing one character at a time from the word and calculate chain length\\n        for (int i = 0; i < word.length(); i++) {\\n            String newWord = word.substring(0, i) + word.substring(i + 1);\\n            chainLength = Math.max(chainLength, 1 + calculateChainLength(newWord));\\n        }\\n\\n        chainLengths.put(word, chainLength);\\n        return chainLength;\\n    }\\n\\n    public int longestStrChain(String[] words) {\\n        for (String word : words) {\\n            wordSet.put(word, true);\\n        }\\n\\n        int maxChainLength = -1;\\n\\n        // Calculate the maximum chain length for each word\\n        for (String word : words) {\\n            maxChainLength = Math.max(maxChainLength, calculateChainLength(word));\\n        }\\n\\n        return maxChainLength;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.chain_lengths = {}\\n        self.word_set = {}\\n\\n    def calculate_chain_length(self, word) -> int:\\n        # If the word doesn\\'t exist in the set\\n        if word not in self.word_set or not self.word_set[word]:\\n            return 0\\n\\n        # If chain length for the word is already calculated\\n        if word in self.chain_lengths:\\n            return self.chain_lengths[word]\\n\\n        chain_length = 1\\n\\n        # Try removing one character at a time from the word and calculate chain length\\n        for i in range(len(word)):\\n            new_word = word[:i] + word[i + 1:]\\n            chain_length = max(chain_length, 1 + self.calculate_chain_length(new_word))\\n\\n        self.chain_lengths[word] = chain_length\\n        return chain_length\\n\\n    def longestStrChain(self, words) -> int:\\n        for word in words:\\n            self.word_set[word] = True\\n\\n        max_chain_length = -1\\n\\n        # Calculate the maximum chain length for each word\\n        for word in words:\\n            max_chain_length = max(max_chain_length, self.calculate_chain_length(word))\\n\\n        return max_chain_length\\n```\n```C++ []\\nclass Solution {\\npublic:\\n\\n    int longestStrChain(vector<string>& words) {\\n        // Sort the words by their lengths\\n        sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n            return a.length() < b.length();\\n        });\\n\\n        // Map to store the longest chain length for each word\\n        unordered_map<string, int> longestChainLength;\\n\\n        // Initialize the answer\\n        int maxChainLength = -1;\\n\\n        for(auto &word: words){\\n            // Initialize the chain length for the current word\\n            longestChainLength[word] = 1;\\n\\n            // Try removing one character at a time from the word and check if the resulting word exists\\n            for(int i = 0 ; i < word.size() ; i++){\\n                string reducedWord = word.substr(0, i) + word.substr(i + 1) ;\\n\\n                // If the reduced word exists in the map\\n                if(longestChainLength.find(reducedWord) != longestChainLength.end())\\n                    // Update the chain length for the current word\\n                    longestChainLength[word] = max(longestChainLength[word], longestChainLength[reducedWord] + 1) ;\\n            }\\n\\n            // Update the maximum chain length seen so far\\n            maxChainLength = max(maxChainLength, longestChainLength[word]) ;\\n        }\\n\\n        return maxChainLength;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Sort the words by their lengths\\n        Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));\\n\\n        // Map to store the longest chain length for each word\\n        Map<String, Integer> longestChainLength = new HashMap<>();\\n\\n        // Initialize the answer\\n        int maxChainLength = -1;\\n\\n        for (String word : words) {\\n            // Initialize the chain length for the current word\\n            longestChainLength.put(word, 1);\\n\\n            // Try removing one character at a time from the word and check if the resulting word exists\\n            for (int i = 0; i < word.length(); i++) {\\n                String reducedWord = word.substring(0, i) + word.substring(i + 1);\\n\\n                // If the reduced word exists in the map\\n                if (longestChainLength.containsKey(reducedWord))\\n                    // Update the chain length for the current word\\n                    longestChainLength.put(word, Math.max(longestChainLength.get(word), longestChainLength.get(reducedWord) + 1));\\n            }\\n\\n            // Update the maximum chain length seen so far\\n            maxChainLength = Math.max(maxChainLength, longestChainLength.get(word));\\n        }\\n\\n        return maxChainLength;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def longestStrChain(self, words) -> int:\\n        # Sort the words by their lengths\\n        words.sort(key=len)\\n\\n        # Dictionary to store the longest chain length for each word\\n        longest_chain_length = {}\\n\\n        # Initialize the answer\\n        max_chain_length = -1\\n\\n        for word in words:\\n            # Initialize the chain length for the current word\\n            longest_chain_length[word] = 1\\n\\n            # Try removing one character at a time from the word and check if the resulting word exists\\n            for i in range(len(word)):\\n                reduced_word = word[:i] + word[i + 1:]\\n\\n                # If the reduced word exists in the dictionary\\n                if reduced_word in longest_chain_length:\\n                    # Update the chain length for the current word\\n                    longest_chain_length[word] = max(longest_chain_length[word], longest_chain_length[reduced_word] + 1)\\n\\n            # Update the maximum chain length seen so far\\n            max_chain_length = max(max_chain_length, longest_chain_length[word])\\n\\n        return max_chain_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213767,
                "title": "python-short-dp-explained",
                "content": "The idea in this problem is to start from the longest word and find an answer for this word using the answers for smaller words. For example if we have word `apple`, then we need to check if we have words `pple, aple, appe, appl` in our list of words. To make it work fast we need to put all words into set: `set_words = set(words)`. Then all we need to do is to check all words with one letter removed.\\n\\n#### Complexity\\nTime complexity is `O(n*L*L)`, where `n` is number of words and `L` is the biggest length of the word: for word of length `L` we need to check `L-1` candidates, all of them with length `L-1`. Space complexity is `L(n*L*L)`, because we actually keep a lot of neighbors of our words in lru cache.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def longestStrChain(self, words):\\n        set_words = set(words)\\n        \\n        @lru_cache(None)\\n        def dp(word):\\n            if word not in set_words: return 0\\n            return max(dp(word[:i] + word[i+1:]) for i in range(len(word))) + 1\\n           \\n        return max(dp(word) for word in words)\\n```\\n\\n#### Update\\nThere is update from @rkmd with `O(n*L)` space complexity\\n\\n```python\\ndef dp(word):\\n    return max((dp(test) for i in range(len(word)) if (test := word[:i] + word[i+1:]) in set_words), default=0) + 1\\n```\\n\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def longestStrChain(self, words):\\n        set_words = set(words)\\n        \\n        @lru_cache(None)\\n        def dp(word):\\n            if word not in set_words: return 0\\n            return max(dp(word[:i] + word[i+1:]) for i in range(len(word))) + 1\\n           \\n        return max(dp(word) for word in words)\\n```\n```python\\ndef dp(word):\\n    return max((dp(test) for i in range(len(word)) if (test := word[:i] + word[i+1:]) in set_words), default=0) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756217,
                "title": "lcs-lis-sorting-easiest-to-understand-among-all-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int lcs( string X,string Y)  \\n{  \\n    int m = X.length();\\n    int n = Y.length();  \\n    int L[m + 1][n + 1];  \\n    int i, j;  \\n    for (i = 0; i <= m; i++)  \\n    {  \\n        for (j = 0; j <= n; j++)  \\n        {  \\n        if (i == 0 || j == 0)  \\n            L[i][j] = 0;  \\n      \\n        else if (X[i - 1] == Y[j - 1])  \\n            L[i][j] = L[i - 1][j - 1] + 1;  \\n      \\n        else\\n            L[i][j] = max(L[i - 1][j], L[i][j - 1]);  \\n        }  \\n    }  \\n    return L[m][n];  \\n}  \\n    \\n     static bool compare(const string &s1, const string &s2) {\\n        return s1.length() < s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> dp(n,1);\\n        sort(words.begin(),words.end(),compare);\\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(words[i].length()-words[j].length()==1 && lcs(words[i],words[j])==words[j].length() && dp[i]<dp[j]+1)\\n                    dp[i] = dp[j] + 1;\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs( string X,string Y)  \\n{  \\n    int m = X.length();\\n    int n = Y.length();  \\n    int L[m + 1][n + 1];  \\n    int i, j;  \\n    for (i = 0; i <= m; i++)  \\n    {  \\n        for (j = 0; j <= n; j++)  \\n        {  \\n        if (i == 0 || j == 0)  \\n            L[i][j] = 0;  \\n      \\n        else if (X[i - 1] == Y[j - 1])  \\n            L[i][j] = L[i - 1][j - 1] + 1;  \\n      \\n        else\\n            L[i][j] = max(L[i - 1][j], L[i][j - 1]);  \\n        }  \\n    }  \\n    return L[m][n];  \\n}  \\n    \\n     static bool compare(const string &s1, const string &s2) {\\n        return s1.length() < s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> dp(n,1);\\n        sort(words.begin(),words.end(),compare);\\n        for(int i = 1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(words[i].length()-words[j].length()==1 && lcs(words[i],words[j])==words[j].length() && dp[i]<dp[j]+1)\\n                    dp[i] = dp[j] + 1;\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152870,
                "title": "java-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nFIrstly ```sort``` the given array on basis of length of words. Such that for a word **i** we would be checking words having length smaller than **i**\\n\\nCreate a ```dictionary``` or ```mapping``` to store the chain length till that words.\\nWhen chain of bigger word is to be found , it will be -> ``` 1 + smaller_length_of_chain```.\\n\\nInitialize the chain length of each word to be ***1***.\\n\\nAs ```word.length <= 16```, it is easy to create all combinations by taking out one character.\\n\\nForm different words ```successor``` by deleting a letter and check if that word has a larger chain length.\\n\\nKeep updating and select maximum chain length from ```mapping``` / ```dictionary```.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n\\t    if(words == null || words.length == 0) {\\n            return 0;\\n        }\\n\\t\\n        int res = 0;\\n\\t\\n        Arrays.sort(words, (a,b)-> a.length()-b.length());\\n\\t    HashMap<String, Integer> map = new HashMap(); \\n\\t    \\n        for(String w : words) {                            \\n\\t\\t    map.put(w, 1);                                  \\n\\t\\t\\n            for(int i=0; i<w.length(); i++) {  \\n                \\n    \\t\\t\\tStringBuilder sb = new StringBuilder(w);\\n\\t    \\t\\tString next = sb.deleteCharAt(i).toString();\\n                \\n\\t\\t    \\tif(map.containsKey(next) && map.get(next)+1 > map.get(w))\\n\\t\\t\\t    \\tmap.put(w, map.get(next)+1);       \\n        \\t\\t}\\n\\t\\t    res = Math.max(res, map.get(w));          \\n\\t    }\\n\\t    return res;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/28742883-9ee2-483c-9c37-fde403ac4580_1655252708.6167986.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```sort```\n```dictionary```\n```mapping```\n``` 1 + smaller_length_of_chain```\n```word.length <= 16```\n```successor```\n```mapping```\n```dictionary```\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n\\t    if(words == null || words.length == 0) {\\n            return 0;\\n        }\\n\\t\\n        int res = 0;\\n\\t\\n        Arrays.sort(words, (a,b)-> a.length()-b.length());\\n\\t    HashMap<String, Integer> map = new HashMap(); \\n\\t    \\n        for(String w : words) {                            \\n\\t\\t    map.put(w, 1);                                  \\n\\t\\t\\n            for(int i=0; i<w.length(); i++) {  \\n                \\n    \\t\\t\\tStringBuilder sb = new StringBuilder(w);\\n\\t    \\t\\tString next = sb.deleteCharAt(i).toString();\\n                \\n\\t\\t    \\tif(map.containsKey(next) && map.get(next)+1 > map.get(w))\\n\\t\\t\\t    \\tmap.put(w, map.get(next)+1);       \\n        \\t\\t}\\n\\t\\t    res = Math.max(res, map.get(w));          \\n\\t    }\\n\\t    return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154190,
                "title": "graph-topological-sort",
                "content": "* We can consider each string in array to be a node. \\n* And create a directed edge to its successor. \\n* This will create a **DAG** (directed acylic graph) and from this we need to find the node with most number of predecessors \\n* This is prefect for topological sort. (Finding a node with most number of prerequisites) \\n\\n\\n\\n\\nExample 1 from question --> <img src=\"https://assets.leetcode.com/users/images/237d4480-9bce-44a5-80e1-773230d859dc_1655281779.3950415.jpeg\" alt=\"drawing\" width=\"200\"/>\\n\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<HashSet<String>> mapOfWords = new ArrayList<>();\\n        Map<String,Integer> inDegree = new HashMap<>();\\n        for(int i=0;i<=16;i++) mapOfWords.add(new HashSet<>());\\n        for(String word: words){\\n            mapOfWords.get(word.length()).add(word);\\n            inDegree.put(word,0);\\n        }\\n        Map<String,List<String>> graph = new HashMap<>();\\n        for(int i=1;i<16;i++) {\\n            HashSet<String> setOfNextWords = mapOfWords.get(i+1);\\n            for(String word: mapOfWords.get(i)){\\n                graph.put(word,new ArrayList<>());\\n                for(String nextWord: setOfNextWords){\\n                    if(isPredecessor(word,nextWord)) {\\n                        List<String> list = graph.get(word);\\n                        list.add(nextWord);\\n                        graph.put(word,list);\\n                        inDegree.put(nextWord,inDegree.get(nextWord)+1);\\n                    }\\n                }\\n            }\\n        }\\n        for(String longestWord: mapOfWords.get(16)) graph.put(longestWord,new ArrayList<>());\\n        Queue<String> queue = new ArrayDeque<>();\\n        for(String string: inDegree.keySet()){\\n            if(inDegree.get(string)==0) queue.offer(string);\\n        }\\n        int depth = 1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int s=0;s<size;s++){\\n                String cur = queue.remove();\\n                List<String> successorList = graph.get(cur);\\n                for(String successor: successorList){\\n                    inDegree.put(successor,inDegree.get(successor)-1);\\n                    if(inDegree.get(successor) == 0) queue.offer(successor);\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth-1;\\n    }\\n    private boolean isPredecessor(String pre, String target){\\n        for(int i=0;i<target.length();i++) if((target.substring(0,i)+target.substring(i+1)).equals(pre)) return true;\\n        return false;\\n    }\\n\\n}\\n\\n```\\nMaking nodes from string is not that fast as compared to integers. As instead of array we have to use maps.. \\nBut still this solution is giving around 400ms as input size is not that big\\n\\nIf you like this approach than please upvote",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<HashSet<String>> mapOfWords = new ArrayList<>();\\n        Map<String,Integer> inDegree = new HashMap<>();\\n        for(int i=0;i<=16;i++) mapOfWords.add(new HashSet<>());\\n        for(String word: words){\\n            mapOfWords.get(word.length()).add(word);\\n            inDegree.put(word,0);\\n        }\\n        Map<String,List<String>> graph = new HashMap<>();\\n        for(int i=1;i<16;i++) {\\n            HashSet<String> setOfNextWords = mapOfWords.get(i+1);\\n            for(String word: mapOfWords.get(i)){\\n                graph.put(word,new ArrayList<>());\\n                for(String nextWord: setOfNextWords){\\n                    if(isPredecessor(word,nextWord)) {\\n                        List<String> list = graph.get(word);\\n                        list.add(nextWord);\\n                        graph.put(word,list);\\n                        inDegree.put(nextWord,inDegree.get(nextWord)+1);\\n                    }\\n                }\\n            }\\n        }\\n        for(String longestWord: mapOfWords.get(16)) graph.put(longestWord,new ArrayList<>());\\n        Queue<String> queue = new ArrayDeque<>();\\n        for(String string: inDegree.keySet()){\\n            if(inDegree.get(string)==0) queue.offer(string);\\n        }\\n        int depth = 1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int s=0;s<size;s++){\\n                String cur = queue.remove();\\n                List<String> successorList = graph.get(cur);\\n                for(String successor: successorList){\\n                    inDegree.put(successor,inDegree.get(successor)-1);\\n                    if(inDegree.get(successor) == 0) queue.offer(successor);\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth-1;\\n    }\\n    private boolean isPredecessor(String pre, String target){\\n        for(int i=0;i<target.length();i++) if((target.substring(0,i)+target.substring(i+1)).equals(pre)) return true;\\n        return false;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154053,
                "title": "c-use-sorting-dp-efficient-solution-with-explanation-dlc-june-day-15",
                "content": "**Approach:** Use hashmap for storing string and length of word chain. Let\\'s take Example-1 and understand it more clearly.\\n\\n**Example-1:**\\n\\n\\twords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\t\\n\\tBefore any step we need to sort vector \\'words\\' on the basis of the size of a string.\\n\\tNow we cover we word in the vector one-by-one.\\n\\n\\t1) word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n\\t2) word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n\\t3) word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\n\\tHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n\\t4) word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n\\t5) word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n\\t6) word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4 which is the answer.\\n\\t\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    static bool compare(string s1, string s2)\\n    {\\n        return s1.size()<s2.size();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) \\n    {\\n        unordered_map<string, int> dp; //it stores predecessor word and chain size\\n        \\n        //sort(words.begin(), words.end(), [](const string &s1, const string &s2){ return s1.length()<s2.length();});\\n        sort(words.begin(), words.end(), compare);\\n        \\n        int len = 1; \\n        for(auto word:words) \\n        {\\n            dp[word]=1; \\n            for(int i=0; i<word.length(); i++) \\n            {\\n                //removing ith alphabet from the string and check remaining string is available in the dp \\n                string pred = word.substr(0,i) + word.substr(i+1); \\n                \\n                if(dp.find(pred) != dp.end()) \\n                {\\n                    dp[word] = max(dp[word], dp[pred]+1); \\n                    len = max(len, dp[word]);\\n                }\\n            }\\n        }\\n        return len;    \\n    }\\n};\\n```\\n\\n**Time Complexity:** O(Nlog(N) + NMM)\\nO(Nlog(N)) for sorting\\nO(NMM): N for 1st loop, M for inner loop and M for string concatenation.\\n\\n**Space Complexity:** O(N) for both storing strings in hashmap.\\n\\n**Please upvote if it helps \\uD83D\\uDE0A\\u2764\\uFE0F**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(string s1, string s2)\\n    {\\n        return s1.size()<s2.size();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) \\n    {\\n        unordered_map<string, int> dp; //it stores predecessor word and chain size\\n        \\n        //sort(words.begin(), words.end(), [](const string &s1, const string &s2){ return s1.length()<s2.length();});\\n        sort(words.begin(), words.end(), compare);\\n        \\n        int len = 1; \\n        for(auto word:words) \\n        {\\n            dp[word]=1; \\n            for(int i=0; i<word.length(); i++) \\n            {\\n                //removing ith alphabet from the string and check remaining string is available in the dp \\n                string pred = word.substr(0,i) + word.substr(i+1); \\n                \\n                if(dp.find(pred) != dp.end()) \\n                {\\n                    dp[word] = max(dp[word], dp[pred]+1); \\n                    len = max(len, dp[word]);\\n                }\\n            }\\n        }\\n        return len;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153914,
                "title": "c-sort-dp-daily-leetcoding-challenge-june-day-15",
                "content": "* Sort vector in increasing order of string lengths.\\n* At each index `i`, find maximum possible predecessor chain for `words[i]`. This can be done by forming all possible predecessors for `words[i]`.\\n* Predecessors for `words[i]` can be found by deleting character at each index of the string.\\n* If a predecessor exists, find the length of longest string chain which end at index `i`.\\n* **TC :O(NlogN + N*M^2) | SC : O(N)**\\n\\n```\\nclass Solution {\\n    static bool compare(string &s1, string &s2){\\n        return s1.length() < s2.length();\\n    }\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n        int ans = 1;\\n        int n = words.size();\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> dp;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            dp[words[i]] = 1;\\n            int maxPosSubChain = 0;\\n            for(int j = 0 ; j < words[i].length(); j++){\\n                string predecessor  = words[i].substr(0, j) + words[i].substr(j+1);\\n                if(dp.find(predecessor)!=dp.end()){\\n                    maxPosSubChain = max(maxPosSubChain, dp[predecessor]);\\n                }\\n            }\\n            dp[words[i]] += maxPosSubChain;\\n            ans = max(ans, dp[words[i]]);\\n        }        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool compare(string &s1, string &s2){\\n        return s1.length() < s2.length();\\n    }\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n        int ans = 1;\\n        int n = words.size();\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> dp;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            dp[words[i]] = 1;\\n            int maxPosSubChain = 0;\\n            for(int j = 0 ; j < words[i].length(); j++){\\n                string predecessor  = words[i].substr(0, j) + words[i].substr(j+1);\\n                if(dp.find(predecessor)!=dp.end()){\\n                    maxPosSubChain = max(maxPosSubChain, dp[predecessor]);\\n                }\\n            }\\n            dp[words[i]] += maxPosSubChain;\\n            ans = max(ans, dp[words[i]]);\\n        }        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294919,
                "title": "c-brute-force-dfs",
                "content": "I thought I needed memoisation, but the solution below was accepted. We first group the words by length, and then run DFS.\\n```\\nbool isChain(string &prev, string &cur) {\\n  for (auto i = 0, j = 0; i < prev.size(); ++j) {\\n    if (prev[i] == \\' \\' || prev[i] == cur[j]) ++i;\\n    if (j - i == 2) return false;\\n  }\\n  return true;\\n}\\nint dfs(vector<vector<string>> &w, string pr) {\\n  int res = pr.size();\\n  if (res == w.size()) return res;\\n  for (auto word : w[pr.size()]) {\\n    if (isChain(pr, word)) res = max(res, dfs(w, word));\\n  }\\n  return res;\\n}\\nint longestStrChain(vector<string>& words, int res = 1) {\\n  vector<vector<string>> w(16, vector<string>());\\n  for (auto word : words) w[word.size() - 1].push_back(word);\\n  for (auto i = 0; i < 16; ++i) res = max(res, dfs(w, string(i, \\' \\')) - i);\\n  return res;\\n}\\n```\\nHere is the same solution with the memoisation added. The runtime went down from 120 ms to 48 ms.\\n\\n> Update: this is not actually a memoisation. We just track visited \"nodes\" (words) in a set.\\n\\n```\\nunordered_set<string> s;\\nbool isChain(string &prev, string &cur) {\\n  for (auto i = 0, j = 0; i < prev.size(); ++j) {\\n    if (prev[i] == \\' \\' || prev[i] == cur[j]) ++i;\\n    if (j - i == 2) return false;\\n  }\\n  return true;\\n}\\nint dfs(vector<vector<string>> &w, string pr) {\\n  int res = pr.size();\\n  if (res == w.size()) return res;\\n  if (!s.insert(pr).second) return 0;\\n  for (auto word : w[pr.size()]) {\\n    if (isChain(pr, word)) res = max(res, dfs(w, word));\\n  }\\n  return res;\\n}\\nint longestStrChain(vector<string>& words, int res = 1) {\\n  vector<vector<string>> w(16, vector<string>());\\n  for (auto word : words) w[word.size() - 1].push_back(word);\\n  for (auto i = 0; i < 16; ++i) res = max(res, dfs(w, string(i, \\' \\')) - i);\\n  return res;\\n}\\n```\\n**Complexity Analysis**\\nTime: O(n), where *n* is the number of words. We process each word only once, and then mark it as \"visited\".\\nMemory: O(n), to store words by groups.",
                "solutionTags": [],
                "code": "```\\nbool isChain(string &prev, string &cur) {\\n  for (auto i = 0, j = 0; i < prev.size(); ++j) {\\n    if (prev[i] == \\' \\' || prev[i] == cur[j]) ++i;\\n    if (j - i == 2) return false;\\n  }\\n  return true;\\n}\\nint dfs(vector<vector<string>> &w, string pr) {\\n  int res = pr.size();\\n  if (res == w.size()) return res;\\n  for (auto word : w[pr.size()]) {\\n    if (isChain(pr, word)) res = max(res, dfs(w, word));\\n  }\\n  return res;\\n}\\nint longestStrChain(vector<string>& words, int res = 1) {\\n  vector<vector<string>> w(16, vector<string>());\\n  for (auto word : words) w[word.size() - 1].push_back(word);\\n  for (auto i = 0; i < 16; ++i) res = max(res, dfs(w, string(i, \\' \\')) - i);\\n  return res;\\n}\\n```\n```\\nunordered_set<string> s;\\nbool isChain(string &prev, string &cur) {\\n  for (auto i = 0, j = 0; i < prev.size(); ++j) {\\n    if (prev[i] == \\' \\' || prev[i] == cur[j]) ++i;\\n    if (j - i == 2) return false;\\n  }\\n  return true;\\n}\\nint dfs(vector<vector<string>> &w, string pr) {\\n  int res = pr.size();\\n  if (res == w.size()) return res;\\n  if (!s.insert(pr).second) return 0;\\n  for (auto word : w[pr.size()]) {\\n    if (isChain(pr, word)) res = max(res, dfs(w, word));\\n  }\\n  return res;\\n}\\nint longestStrChain(vector<string>& words, int res = 1) {\\n  vector<vector<string>> w(16, vector<string>());\\n  for (auto word : words) w[word.size() - 1].push_back(word);\\n  for (auto i = 0; i < 16; ++i) res = max(res, dfs(w, string(i, \\' \\')) - i);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213856,
                "title": "longest-string-chain-js-python-java-fast-set-dp-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nA naive approach would be to check every word against every other word looking for predecessors, but that would lead to a **TLE** result. The first important realization that we should be able to make is that while a **word** may have many **26 * (word.length + 1)** possible successors, it can only have **word.length** predecessors.\\n\\nSo rather than iterating from small to large words and checking every combination for a link, we can store the words in a **set** and only check the few possible predecessors while iterating from large to small. To aid in that, we can actually separate words into an array of sets (**W**) indexed by word length, so that we can directly access batches of words by their length.\\n\\n_(**Note**: As we iterate backward through **W**, if we find that **W[i-1]** is empty, we don\\'t need to process the words in **W[i]**, since there cannot possibly be a predecessor match.)_\\n\\nThen we can use a **dynamic programming** (**DP**) approach to eliminate some common subproblems. We can define a **hashmap** (**dp**) where **dp[word]** is the length of the longest chain ending at **word** found so far.\\n\\nSo at each **word**, we\\'ll iterate through each of its predecessors (**pred**) and check the appropriate set in **W** for a match. If we find a match, we can update **dp[pred]** if **dp[word] + 1** is better, increasing the chain by one. We should also separately keep track of the **best** chain length we\\'ve seen, so that once we reach the end, we can just **return best**.\\n\\n - _**Time Complexity: O(N*M)** where **N** is the length of **words** and **M** is the average length of the words in **words**._\\n - _**Space Complexity: O(N + P)** where **P** is the number of predecessors found and stored in **dp**._\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 45.8MB** (beats 100% / 75%).\\n```javascript\\nvar longestStrChain = function(words) {\\n    let W = Array.from({length: 17}, _ => new Set())\\n    for (let i = 0; i < words.length; i++) \\n        W[words[i].length].add(words[i])\\n    let dp = new Map(), best = 1\\n    for (let i = 16; i; i--) {\\n        if (!W[i-1].size) continue\\n        for (let word of W[i]) {\\n            let wVal = dp.get(word) || 1\\n            for (let j = 0; j < word.length; j++) {\\n                let pred = word.slice(0,j) + word.slice(j+1)\\n                if (W[i-1].has(pred) && wVal >= (dp.get(pred) || 1)) {\\n                    dp.set(pred, wVal + 1)\\n                    best = Math.max(best, wVal + 1)\\n                }\\n            }\\n        }\\n    }\\n    return best\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **84ms / 14.5MB** (beats 100% / 90%).\\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        W = [set() for _ in range(17)]\\n        for word in words:\\n            W[len(word)].add(word)\\n        dp, best = defaultdict(lambda:1), 1\\n        for i in range(16,0,-1):\\n            if len(W[i-1]) == 0: continue\\n            for word in W[i]:\\n                wVal = dp[word]\\n                for j in range(len(word)):\\n                    pred = word[0:j] + word[j+1:]\\n                    if pred in W[i-1] and wVal >= (dp.get(pred) or 1):\\n                        dp[pred] = wVal + 1\\n                        best = max(best, wVal + 1)\\n        return best\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **20ms / 38.8MB** (beats 92% / 91%).\\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<Set<String>> W = new ArrayList<>(17);\\n        for (int i = 0; i < 17; i++)\\n            W.add(new HashSet<>());\\n        for (String word : words) \\n            W.get(word.length()).add(word);\\n        Map<String, Integer> dp = new HashMap<>();\\n        int best = 1;\\n        for (int i = 16; i > 0; i--) {\\n            if (W.get(i-1).isEmpty()) continue;\\n            for (String word : W.get(i)) {\\n                int wVal = dp.getOrDefault(word, 1);\\n                for (int j = 0; j < word.length(); j++) {\\n                    String pred = word.substring(0,j) + word.substring(j+1);\\n                    if (W.get(i-1).contains(pred) && wVal >= dp.getOrDefault(pred,1)) {\\n                        dp.put(pred, wVal + 1);\\n                        best = Math.max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **52ms / 31.2MB** (beats 91% / 27%).\\n```c++\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar longestStrChain = function(words) {\\n    let W = Array.from({length: 17}, _ => new Set())\\n    for (let i = 0; i < words.length; i++) \\n        W[words[i].length].add(words[i])\\n    let dp = new Map(), best = 1\\n    for (let i = 16; i; i--) {\\n        if (!W[i-1].size) continue\\n        for (let word of W[i]) {\\n            let wVal = dp.get(word) || 1\\n            for (let j = 0; j < word.length; j++) {\\n                let pred = word.slice(0,j) + word.slice(j+1)\\n                if (W[i-1].has(pred) && wVal >= (dp.get(pred) || 1)) {\\n                    dp.set(pred, wVal + 1)\\n                    best = Math.max(best, wVal + 1)\\n                }\\n            }\\n        }\\n    }\\n    return best\\n};\\n```\n```python\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        W = [set() for _ in range(17)]\\n        for word in words:\\n            W[len(word)].add(word)\\n        dp, best = defaultdict(lambda:1), 1\\n        for i in range(16,0,-1):\\n            if len(W[i-1]) == 0: continue\\n            for word in W[i]:\\n                wVal = dp[word]\\n                for j in range(len(word)):\\n                    pred = word[0:j] + word[j+1:]\\n                    if pred in W[i-1] and wVal >= (dp.get(pred) or 1):\\n                        dp[pred] = wVal + 1\\n                        best = max(best, wVal + 1)\\n        return best\\n```\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        List<Set<String>> W = new ArrayList<>(17);\\n        for (int i = 0; i < 17; i++)\\n            W.add(new HashSet<>());\\n        for (String word : words) \\n            W.get(word.length()).add(word);\\n        Map<String, Integer> dp = new HashMap<>();\\n        int best = 1;\\n        for (int i = 16; i > 0; i--) {\\n            if (W.get(i-1).isEmpty()) continue;\\n            for (String word : W.get(i)) {\\n                int wVal = dp.getOrDefault(word, 1);\\n                for (int j = 0; j < word.length(); j++) {\\n                    String pred = word.substring(0,j) + word.substring(j+1);\\n                    if (W.get(i-1).contains(pred) && wVal >= dp.getOrDefault(pred,1)) {\\n                        dp.put(pred, wVal + 1);\\n                        best = Math.max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213820,
                "title": "c-3-approaches-why-it-looks-like-lis-pattern-easy-comments-memoized-dp-best-solution",
                "content": "Just to let you know, this was asked by Google\\nBefore you see the solution below, you need to understand how one can come up with the idea that this question can be solved with the concept of LIS(Longest increasing subsequence) ?\\nLook for the keywords in the question. (comparison below)\\n```\\n\\t\\t(This qn)                                         (LIS)\\n-You have to find the longest chain            -Longest length of subsequence\\n-nums[prev] < nums[curr]                       -words[prev] is predecessor of words[curr]\\n\\nI think these two points are enough to give LIS a chance. That\\'s how it clicked me atleast.\\nIf you have any other explanation, please feel free to share. I am looking for multiple solutions/explanations to a question.\\n```\\n\\n```\\nBut, why I have sorted the input (in solutions below)?\\nBecause in LIS, we needed the longest subsequence.\\nBut here in this question, we need the longest chain no matter which word you put where (i.e. order doens\\'t matter).\\nSo, the best solution will come (longest) when you sort the input in ascending order of length. This will ensure you get the longest chain.\\n```\\n\\n```\\n//Approach-1 (Recusrion + Memoized)\\nclass Solution {\\npublic:\\n    int t[1001][1001];\\n\\t//This function is simple just follow how question defines a predecessor\\n    bool predecessor(string& prev, string& curr) {\\n        int m = prev.length();\\n        int n = curr.length();\\n        \\n        if(n-m != 1 || m >= n)\\n            return false;\\n        \\n        int i = 0, j = 0;\\n\\t\\t//prev should be a subsequence of curr\\n        while(i < m && j < n) {\\n            if(prev[i] == curr[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i==m;\\n    }\\n\\t//This is nothing but \"Longest Increasing Subsequence\"\\n    int modifiedLIS(vector<string>& words, int prev, int curr) {\\n        if(curr ==  words.size())\\n            return 0;\\n        if(t[prev+1][curr] != -1)\\n            return t[prev+1][curr];\\n        int taken = 0;\\n\\t\\t/*\\n\\t\\t\\tRemember, in LIS, we used to check only\\n\\t\\t\\tnums[prev] < nums[curr]. But here just condition is\\n\\t\\t\\tchanged as per the question\\n\\t\\t*/\\n\\t\\t\\n        if(prev < 0 || predecessor(words[prev], words[curr])) {\\n            taken = 1 + modifiedLIS(words, curr, curr+1);\\n        }\\n        \\n        int not_taken = modifiedLIS(words, prev, curr+1);\\n        \\n        return t[prev+1][curr] = max(taken, not_taken);\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), myFunction); //Why ? Reason at the top\\n        int n = words.size();\\n        int prev = -1;\\n        int curr = 0;\\n        memset(t, -1, sizeof(t));\\n        return modifiedLIS(words, prev, curr);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 - (DP version of above) [ Time : O(N^2 * L) ]\\nclass Solution {\\npublic:\\n\\t//This function is simple just follow how question defines a predecessor\\n    bool predecessor(string& prev, string& curr) {\\n        int m = prev.length();\\n        int n = curr.length();\\n        \\n        if(n-m != 1 || m >= n)\\n            return false;\\n        \\n        int i = 0, j = 0;\\n\\t\\t//prev should be a subsequence of curr\\n        while(i < m && j < n) {\\n            if(prev[i] == curr[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i==m;\\n    }\\n    int modifiedLIS(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> t(n, 1);\\n        //t[i] = LIS ending at index i\\n        int result = 1;\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\tRemember, in LIS, we used to check only\\n\\t\\t\\t\\t\\tnums[j] < nums[i]. But here just condition is\\n\\t\\t\\t\\t\\tchanged as per the question\\n\\t\\t\\t\\t*/\\n                if(predecessor(words[j], words[i])) {\\n                    t[i] = max(t[i], 1 + t[j]);\\n                    result = max(result, t[i]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    static bool myFunction(string& s1, string& s2) {\\n        return s1.length() < s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), myFunction); //Why ? Reason at the top\\n        \\n        return modifiedLIS(words);\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 Using HashMap [Time : O(NlogN+(N*L^2)) ]\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        \\n\\t\\t//lambda function for sorting\\n        auto myFunction = [&](string& s1, string& s2) {\\n            return s1.length() < s2.length();\\n        };\\n        \\n        sort(begin(words), end(words), myFunction);  //O(N*logN)\\n        \\n        int maxChain = 0;\\n        for(string &word:words) { O(N)\\n            int chain_word = 1;\\n            \\n            for(int i = 0; i < (int) word.length(); i++) {  // O(L)\\n                /*\\n\\t\\t\\t\\t\\tFind all possible predecessors of word by removing one character\\n\\t\\t\\t\\t\\tI you see that we have that predecessor, then we add +1 to the \\n\\t\\t\\t\\t\\tpredecessor chain to reach to current word.\\n\\t\\t\\t\\t\\tSimilarly, for all possible predecessors, find the maximum chain to reach\\n\\t\\t\\t\\t\\tcurrent word.\\n\\t\\t\\t\\t*/\\n                string s = word.substr(0, i) + word.substr(i+1);  // O(L)\\n                auto it = mp.find(s);\\n            \\n                if(it != mp.end()) {\\n                    //find best predecessor\\n                    chain_word = max(chain_word, mp[s]+1);\\n                }\\n            }\\n            \\n            mp[word] = chain_word; //select the maximum chain for word\\n\\t\\t\\t//And at last find the maximum for all the words\\n            maxChain = max(maxChain, chain_word); //update the maximum chain obtained\\n        }\\n        \\n        return maxChain;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t(This qn)                                         (LIS)\\n-You have to find the longest chain            -Longest length of subsequence\\n-nums[prev] < nums[curr]                       -words[prev] is predecessor of words[curr]\\n\\nI think these two points are enough to give LIS a chance. That\\'s how it clicked me atleast.\\nIf you have any other explanation, please feel free to share. I am looking for multiple solutions/explanations to a question.\\n```\n```\\nBut, why I have sorted the input (in solutions below)?\\nBecause in LIS, we needed the longest subsequence.\\nBut here in this question, we need the longest chain no matter which word you put where (i.e. order doens\\'t matter).\\nSo, the best solution will come (longest) when you sort the input in ascending order of length. This will ensure you get the longest chain.\\n```\n```\\n//Approach-1 (Recusrion + Memoized)\\nclass Solution {\\npublic:\\n    int t[1001][1001];\\n\\t//This function is simple just follow how question defines a predecessor\\n    bool predecessor(string& prev, string& curr) {\\n        int m = prev.length();\\n        int n = curr.length();\\n        \\n        if(n-m != 1 || m >= n)\\n            return false;\\n        \\n        int i = 0, j = 0;\\n\\t\\t//prev should be a subsequence of curr\\n        while(i < m && j < n) {\\n            if(prev[i] == curr[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i==m;\\n    }\\n\\t//This is nothing but \"Longest Increasing Subsequence\"\\n    int modifiedLIS(vector<string>& words, int prev, int curr) {\\n        if(curr ==  words.size())\\n            return 0;\\n        if(t[prev+1][curr] != -1)\\n            return t[prev+1][curr];\\n        int taken = 0;\\n\\t\\t/*\\n\\t\\t\\tRemember, in LIS, we used to check only\\n\\t\\t\\tnums[prev] < nums[curr]. But here just condition is\\n\\t\\t\\tchanged as per the question\\n\\t\\t*/\\n\\t\\t\\n        if(prev < 0 || predecessor(words[prev], words[curr])) {\\n            taken = 1 + modifiedLIS(words, curr, curr+1);\\n        }\\n        \\n        int not_taken = modifiedLIS(words, prev, curr+1);\\n        \\n        return t[prev+1][curr] = max(taken, not_taken);\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), myFunction); //Why ? Reason at the top\\n        int n = words.size();\\n        int prev = -1;\\n        int curr = 0;\\n        memset(t, -1, sizeof(t));\\n        return modifiedLIS(words, prev, curr);\\n    }\\n};\\n```\n```\\n//Approach-2 - (DP version of above) [ Time : O(N^2 * L) ]\\nclass Solution {\\npublic:\\n\\t//This function is simple just follow how question defines a predecessor\\n    bool predecessor(string& prev, string& curr) {\\n        int m = prev.length();\\n        int n = curr.length();\\n        \\n        if(n-m != 1 || m >= n)\\n            return false;\\n        \\n        int i = 0, j = 0;\\n\\t\\t//prev should be a subsequence of curr\\n        while(i < m && j < n) {\\n            if(prev[i] == curr[j]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i==m;\\n    }\\n    int modifiedLIS(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> t(n, 1);\\n        //t[i] = LIS ending at index i\\n        int result = 1;\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\tRemember, in LIS, we used to check only\\n\\t\\t\\t\\t\\tnums[j] < nums[i]. But here just condition is\\n\\t\\t\\t\\t\\tchanged as per the question\\n\\t\\t\\t\\t*/\\n                if(predecessor(words[j], words[i])) {\\n                    t[i] = max(t[i], 1 + t[j]);\\n                    result = max(result, t[i]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    static bool myFunction(string& s1, string& s2) {\\n        return s1.length() < s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), myFunction); //Why ? Reason at the top\\n        \\n        return modifiedLIS(words);\\n    }\\n};\\n```\n```\\n//Approach-3 Using HashMap [Time : O(NlogN+(N*L^2)) ]\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        \\n\\t\\t//lambda function for sorting\\n        auto myFunction = [&](string& s1, string& s2) {\\n            return s1.length() < s2.length();\\n        };\\n        \\n        sort(begin(words), end(words), myFunction);  //O(N*logN)\\n        \\n        int maxChain = 0;\\n        for(string &word:words) { O(N)\\n            int chain_word = 1;\\n            \\n            for(int i = 0; i < (int) word.length(); i++) {  // O(L)\\n                /*\\n\\t\\t\\t\\t\\tFind all possible predecessors of word by removing one character\\n\\t\\t\\t\\t\\tI you see that we have that predecessor, then we add +1 to the \\n\\t\\t\\t\\t\\tpredecessor chain to reach to current word.\\n\\t\\t\\t\\t\\tSimilarly, for all possible predecessors, find the maximum chain to reach\\n\\t\\t\\t\\t\\tcurrent word.\\n\\t\\t\\t\\t*/\\n                string s = word.substr(0, i) + word.substr(i+1);  // O(L)\\n                auto it = mp.find(s);\\n            \\n                if(it != mp.end()) {\\n                    //find best predecessor\\n                    chain_word = max(chain_word, mp[s]+1);\\n                }\\n            }\\n            \\n            mp[word] = chain_word; //select the maximum chain for word\\n\\t\\t\\t//And at last find the maximum for all the words\\n            maxChain = max(maxChain, chain_word); //update the maximum chain obtained\\n        }\\n        \\n        return maxChain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505507,
                "title": "javascript-dp-solution-javascript",
                "content": "FYI I\\'m writing this as a mental note for myself. I will come back later and refine the explanation. \\n\\n1. sort the words by length, shortst to longest, `array.sort((a,b) => a.length - b.length))`\\n2. For every word, we check if the predecesor that makes up this word exists. If no, we set the chain value for this word to 1, if yes, we\\'ll increase it by one. \\n\\nFor example, with the array of words `[\\'a\\', \\'b\\', \\'ba\\', \\'bca\\', \\'bda\\', \\'bdca\\']`, for the first word `a`, since it\\'s length is only 1, there is no predecor that can make this current word, hence we set in our memory `a:1`, same with b. \\n\\nNow when we get to `ba`, we remove `b` from `ba`, and we can imagine the word as no `_ a`, we ask ourselves, does `a` exist in memory? \\nyes it does, which means, we have a letter in memory that could complete the full word `ba` (It might look like we are trying to fill in the blank for the letter `b`, but we are actually saying, \\'okay, if we have the value b already, does `a` exist in memory?\\' \\n\\nsince it does, our chain value for `ba` is 2, because `a` --> `ba`\\n```\\nvar longestStrChain = function(words) {\\n   var memory = {}; \\n    words.sort((a,b) => a.length - b.length)\\n    for (var word of words){\\n        var longest = 0; \\n        for (var i =0; i<word.length; i++){\\n            var pre = word.slice(0,i) + word.slice(i+1);\\n            longest = Math.max(longest, (memory[pre] || 0)+1)\\n        }\\n        memory[word] = longest\\n    }\\n    return Math.max(...Object.values(memory));\\n};\\n```\\n\\nSome of my own questions that occured to me while looking at other people\\'s solutions: \\n1. What\\'s the difference between `string.slice()` and `string.substring()` : https://stackoverflow.com/questions/2243824/what-is-the-difference-between-string-slice-and-string-substring",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar longestStrChain = function(words) {\\n   var memory = {}; \\n    words.sort((a,b) => a.length - b.length)\\n    for (var word of words){\\n        var longest = 0; \\n        for (var i =0; i<word.length; i++){\\n            var pre = word.slice(0,i) + word.slice(i+1);\\n            longest = Math.max(longest, (memory[pre] || 0)+1)\\n        }\\n        memory[word] = longest\\n    }\\n    return Math.max(...Object.values(memory));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483103,
                "title": "python-8-lines-dfs-with-memoization",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def dfs(word):\\n            if word not in dp:\\n                return 0\\n            if not dp[word]:\\n                dp[word] = max([dfs(word[:i]+word[i+1:]) + 1 for i in range(len(word))])\\n            return dp[word]\\n\\t\\t\\t\\n        dp = {word: None for word in words}\\n        return max([dfs(word) for word in dp if not dp[word]])\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def dfs(word):\\n            if word not in dp:\\n                return 0\\n            if not dp[word]:\\n                dp[word] = max([dfs(word[:i]+word[i+1:]) + 1 for i in range(len(word))])\\n            return dp[word]\\n\\t\\t\\t\\n        dp = {word: None for word in words}\\n        return max([dfs(word) for word in dp if not dp[word]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442231,
                "title": "java-dfs-memo-solution",
                "content": "[updated with `fuxian` \\'s StringBuilder usage suggestion]\\n```\\nclass Solution {\\n    \\n    public int dfs(HashSet<String> words, HashMap<String, Integer> cache, String s) {\\n        \\n        if(cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i = 0; i<s.length(); i++) {\\n\\t\\t\\t// creating all possible strings with one character taken out\\n            sb.deleteCharAt(i);\\n            String ns = sb.toString();\\n            if(words.contains(ns)){\\n                max = Math.max(max, dfs(words, cache, ns));\\n            }\\n\\t\\t\\t// insertng it back for next iteration\\n            sb.insert(i, s.charAt(i));\\n        }\\n        cache.put(s, ++max);\\n        \\n        return max;\\n    }\\n    \\n    public int longestStrChain(String[] words) {\\n        HashMap<String, Integer> cache = new HashMap<>();\\n        \\n        HashSet<String> wordSet = new HashSet<>();\\n        for(String s: words) wordSet.add(s);\\n        \\n        int max = 0; \\n        for(String w: words) {\\n            max = Math.max(max, dfs(wordSet, cache, w));\\n            //System.out.println(w+ \" - \"+max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int dfs(HashSet<String> words, HashMap<String, Integer> cache, String s) {\\n        \\n        if(cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i = 0; i<s.length(); i++) {\\n\\t\\t\\t// creating all possible strings with one character taken out\\n            sb.deleteCharAt(i);\\n            String ns = sb.toString();\\n            if(words.contains(ns)){\\n                max = Math.max(max, dfs(words, cache, ns));\\n            }\\n\\t\\t\\t// insertng it back for next iteration\\n            sb.insert(i, s.charAt(i));\\n        }\\n        cache.put(s, ++max);\\n        \\n        return max;\\n    }\\n    \\n    public int longestStrChain(String[] words) {\\n        HashMap<String, Integer> cache = new HashMap<>();\\n        \\n        HashSet<String> wordSet = new HashSet<>();\\n        for(String s: words) wordSet.add(s);\\n        \\n        int max = 0; \\n        for(String w: words) {\\n            max = Math.max(max, dfs(wordSet, cache, w));\\n            //System.out.println(w+ \" - \"+max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153013,
                "title": "c-dp-solution-full-explanation-step-by-step",
                "content": "***Upvote if helpful***\\n\\nTime Complexity : O(n*n), Space Complexity : O(n)\\n\\n1. At first  the array is `sorted according to length of the words`, so that another word after a word can not be its predecessor.\\n\\n2. A `dp array is declared` for storing the maximum number of predecessor present in the array for a word in the array words.\\n\\n3. An iterative dp is run for each element (`curr`). In it for each curr a loop is run from start of the array to the curr element (`prev`) where it `checks if prev is the predecessor of curr`  using function predecessor() and stores the `maximun of dp[curr] and 1+dp[prev`]. Max is stored because there can be `multiple predecessor of curr` before it.\\n\\n4. The ans is updated as `max of ans and dp[curr]` after each loop so that it store the longest word chain of predecessor and is returned at the end.\\n\\n```\\nclass Solution {\\npublic:\\n\\tbool predecessor(string &prev, string &curr) {\\n\\t\\tint n = prev.size(), m = curr.size();\\n        \\n        // as only 1 character can be added to prev to get curr\\n\\t\\tif (n+1 != m) {\\n            return false;\\n        }\\n\\n        int i=0, j=0;\\n\\t\\twhile (j < m) {\\n\\t\\t\\tif (prev[i] == curr[j]) {\\n\\t\\t\\t\\ti++, j++;\\n\\t\\t\\t}\\n\\t\\t\\telse j++;\\n\\t\\t}\\n\\n        // if the prev doesn\\'t reach its end then its not predecessor\\n\\t\\treturn i==n;\\n\\t}\\n    \\n    //compare function for sorting\\n    static bool compare (string& first, string& second) {\\n        return first.size() < second.size();\\n    }\\n    \\n\\tint longestStrChain(vector<string>& words) {\\n        \\n        //1. sorting according to length.\\n\\t\\tsort(words.begin(), words.end(), compare);\\n        \\n        //2. Declaration of dp\\n        //Min value of ans and dp element is 1(the word itself).\\n\\t\\tvector<int> dp(words.size(), 1);\\n\\t\\tint ans = 1; \\n        \\n\\t\\t//3. Iterative dp\\n\\t\\tfor (int curr = 0; curr < words.size(); curr++) {\\n\\t\\t\\tfor (int prev = 0; prev < curr; prev++) {\\n\\t\\t\\t\\tif (predecessor(words[prev], words[curr])) {\\n                    dp[curr] = max(dp[curr], dp[prev]+1);\\n                }\\n\\t\\t\\t}\\n\\t\\t\\t//4. Updating ans\\n\\t\\t\\tans = max(ans, dp[curr]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool predecessor(string &prev, string &curr) {\\n\\t\\tint n = prev.size(), m = curr.size();\\n        \\n        // as only 1 character can be added to prev to get curr\\n\\t\\tif (n+1 != m) {\\n            return false;\\n        }\\n\\n        int i=0, j=0;\\n\\t\\twhile (j < m) {\\n\\t\\t\\tif (prev[i] == curr[j]) {\\n\\t\\t\\t\\ti++, j++;\\n\\t\\t\\t}\\n\\t\\t\\telse j++;\\n\\t\\t}\\n\\n        // if the prev doesn\\'t reach its end then its not predecessor\\n\\t\\treturn i==n;\\n\\t}\\n    \\n    //compare function for sorting\\n    static bool compare (string& first, string& second) {\\n        return first.size() < second.size();\\n    }\\n    \\n\\tint longestStrChain(vector<string>& words) {\\n        \\n        //1. sorting according to length.\\n\\t\\tsort(words.begin(), words.end(), compare);\\n        \\n        //2. Declaration of dp\\n        //Min value of ans and dp element is 1(the word itself).\\n\\t\\tvector<int> dp(words.size(), 1);\\n\\t\\tint ans = 1; \\n        \\n\\t\\t//3. Iterative dp\\n\\t\\tfor (int curr = 0; curr < words.size(); curr++) {\\n\\t\\t\\tfor (int prev = 0; prev < curr; prev++) {\\n\\t\\t\\t\\tif (predecessor(words[prev], words[curr])) {\\n                    dp[curr] = max(dp[curr], dp[prev]+1);\\n                }\\n\\t\\t\\t}\\n\\t\\t\\t//4. Updating ans\\n\\t\\t\\tans = max(ans, dp[curr]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079115,
                "title": "c-java-python-javascript",
                "content": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article : https://www.nileshblog.tech/leetcode-1048-longest-string-chain/\\n\\nExplanation Eg.\\n\\nDyanamic Programming Approach\\nTime Complexity:\\n\\nTime Complexity: O(N*M) .\\nSpace Complexity: O(N + P) .\\n\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/leetcode-1048-longest-string-chain/\\n\\n![image](https://assets.leetcode.com/users/images/3fb38049-4e31-4427-a9ae-3695b80f4d12_1695446837.1962926.png)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article : https://www.nileshblog.tech/leetcode-1048-longest-string-chain/\\n\\nExplanation Eg.\\n\\nDyanamic Programming Approach\\nTime Complexity:\\n\\nTime Complexity: O(N*M) .\\nSpace Complexity: O(N + P) .\\n\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/leetcode-1048-longest-string-chain/\\n\\n![image](https://assets.leetcode.com/users/images/3fb38049-4e31-4427-a9ae-3695b80f4d12_1695446837.1962926.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1112878,
                "title": "c-using-hash-map-easy-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n\\t//sort the vector on the basis of the length of each word\\n    std::sort(words.begin(), words.end(), [](const std::string& first, const std::string& second)\\n\\t{\\n        return first.size() < second.size();\\n\\t});\\n        map<string,int> m;\\n        int res = 0;\\n        for(string word:words)\\n        {\\n            int longest =0;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                string sub = word.substr(0,i) + word.substr(i+1,word.length()+1);\\n                longest = max(longest,m[sub]+1);   \\n            }\\n            m[word] = longest;\\n            res = max(res,longest);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n\\t//sort the vector on the basis of the length of each word\\n    std::sort(words.begin(), words.end(), [](const std::string& first, const std::string& second)\\n\\t{\\n        return first.size() < second.size();\\n\\t});\\n        map<string,int> m;\\n        int res = 0;\\n        for(string word:words)\\n        {\\n            int longest =0;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                string sub = word.substr(0,i) + word.substr(i+1,word.length()+1);\\n                longest = max(longest,m[sub]+1);   \\n            }\\n            m[word] = longest;\\n            res = max(res,longest);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747138,
                "title": "easy-java-solution-with-description",
                "content": "**Overview: \\n###### Create a map with the count of each occurence of the substring present in word array as we proceed through the word array. We sort it because we need increasing order of each word length for this algorithm to work. We identify single letter words as parents and find what children we have or what children have these single letters as parents. Also, we keep a track of the maximum we see everytime to return it ultimately.\\n\\n**Example walkthrough: \\n###### For the first example, we have words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]. Let\\'s identify this with first letter \"a\" (let\\'s call it parent). Now I need to check what is the next one, \"b\" (call it parent, as it is a single letter). Add both to the HashMap. Now, next we have \"ba\". We check if we have a parent, either \"b\" or \"a\" and if yes, we call it child and store it by adding 1. Similarly we traverse through all and we will have in our HashMap this structure.\\n\\n###### map after all traversals  **{a=1, bca=3, b=1, bda=3, bdca=4, ba=2}**\\n###### As you can see, we have identified which child is what level to the parent, i.e. single letter. Also, everytime, we do this, let\\'s keep a count of the max level of child we have seen through the loop and ultimately return that.\\n\\n**Code: \\n\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        if(words == null || words.length == 0) {\\n            return 0;\\n        }\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        Map<String, Integer> map = new HashMap();\\n        int max = 0;\\n        for(String word: words) {\\n            int longestSubstring = 0;\\n            for(int i = 0; i < word.length(); i++) {\\n                String subWord = word.substring(0, i) + word.substring(i+1);\\n                longestSubstring = Math.max(longestSubstring, map.getOrDefault(subWord, 0) + 1);\\n            }\\n            map.put(word, longestSubstring);\\n            max = Math.max(max, longestSubstring);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        if(words == null || words.length == 0) {\\n            return 0;\\n        }\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        Map<String, Integer> map = new HashMap();\\n        int max = 0;\\n        for(String word: words) {\\n            int longestSubstring = 0;\\n            for(int i = 0; i < word.length(); i++) {\\n                String subWord = word.substring(0, i) + word.substring(i+1);\\n                longestSubstring = Math.max(longestSubstring, map.getOrDefault(subWord, 0) + 1);\\n            }\\n            map.put(word, longestSubstring);\\n            max = Math.max(max, longestSubstring);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152972,
                "title": "c-lis-easy-to-understand-explanation-greater-than-93-88-ms-tc-o-n-m-sc-n-p",
                "content": "1. We have to sort the words by word\\'s length. ( apply bucket sort)\\n2. For each word, loop on all possible previous word with 1 letter missing.\\n3. If we have seen this previous word, update the longest chain for the current word.\\n4. Then finally return the longest word chain.\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n         vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```\\n\\nIF YOU LIKED THIS SOLUTION, PLEASE PLEASE PLEASE UPVOTE IT!!!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n         vector<unordered_set<string>> W(17);\\n        for (auto word : words) \\n            W[word.size()].insert(word);\\n        unordered_map<string, int> dp;\\n        int best = 1;\\n        for (int i = 16; i; i--) {\\n            if (W[i-1].empty()) continue;\\n            for (auto word : W[i]) {\\n                int wVal = dp[word] ? dp[word] : 1;\\n                for (int j = 0; j < word.size(); j++) {\\n                    string pred = word.substr(0,j) + word.substr(j+1);\\n                    int pVal = dp[pred] ? dp[pred] : 1;\\n                    if (W[i-1].find(pred) != W[i-1].end() && wVal >= pVal) {\\n                        dp[pred] = wVal + 1;\\n                        best = max(best, wVal + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152903,
                "title": "python-dp-2-approaches-using-dp",
                "content": "The problem can be solved using **DP** as it\\'s asking to find the longest string chain which means we have to go through all the possible paths to find the optimial solutions. We also need a way to define the overlapping subproblems and cache it. \\n\\n\\n## \\u2714\\uFE0F*Solution I - Memoization - Top Down*\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        n=len(words)\\n        words_set={w:idx for idx, w in enumerate(words)}\\n        \\n        @cache\\n        def dp(i):                 \\n            curr=words[i]\\n            max_length=0\\n            for idx in range(len(curr)):\\n                new_wc = curr[:idx] + curr[idx+1:]\\n                if new_wc in words_set:\\n                    max_length=max(max_length, 1 + dp(words_set[new_wc]))\\n        \\n            return max_length\\n        \\n        return max(dp(i)+1 for i in range(n))\\n```\\nA more concise variation shared by [atorre](https://leetcode.com/atorre/)\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        w_set = set(words)\\n        @cache\\n        def dp(w:str) -> int:\\n            return 1 + max((dp(s) for i in range(len(w)) if (s:=w[:i]+w[i+1:]) in w_set), default=0)\\n        return max(dp(w) for w in words)\\n```\\n\\nif `N` is length of `words` and `L` is the max length of a word in `words`,\\n\\n**Time - O(N * L * L )** - first `L` is for the loop to find new words by deleting one character and the second `L` is to generate the new word. \\n**Space - O(N * L)** - space required for `words_set`.\\n\\n\\n---\\n\\n## \\u2714\\uFE0F*Solution I I - Tabulation - Bottom Up*\\nA more concise version only possible because it\\'s python :)\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:                \\n        words.sort(key=len)\\n        dp={}\\n        for w in words:\\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\\n        return max(dp.values())\\n```\\n\\nif `N` is length of `words` and `L` is the max length of a word in `words`,\\n\\n**Time - O(NlogN + N * L * L )** - first `L` is for the loop to find new words by deleting one character and the second `L` is to generate the new word. \\n**Space - O(N * L)** - space required for `dp`.\\n\\n---\\n\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        n=len(words)\\n        words_set={w:idx for idx, w in enumerate(words)}\\n        \\n        @cache\\n        def dp(i):                 \\n            curr=words[i]\\n            max_length=0\\n            for idx in range(len(curr)):\\n                new_wc = curr[:idx] + curr[idx+1:]\\n                if new_wc in words_set:\\n                    max_length=max(max_length, 1 + dp(words_set[new_wc]))\\n        \\n            return max_length\\n        \\n        return max(dp(i)+1 for i in range(n))\\n```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        w_set = set(words)\\n        @cache\\n        def dp(w:str) -> int:\\n            return 1 + max((dp(s) for i in range(len(w)) if (s:=w[:i]+w[i+1:]) in w_set), default=0)\\n        return max(dp(w) for w in words)\\n```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:                \\n        words.sort(key=len)\\n        dp={}\\n        for w in words:\\n            dp[w] = max(dp.get(w[:i] + w[i + 1:], 0) + 1 for i in range(len(w)))\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168211,
                "title": "javascript-solution",
                "content": "```\\nvar longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    \\n    const map = new Map();\\n    \\n    let res = 1;\\n    \\n    for (const word of words) {\\n        const n = word.length;\\n        let max = 1;\\n        \\n        for (let i = 0; i < n; i++) {\\n            const front = word.substring(0, i);\\n            const back = word.substring(i + 1);\\n            \\n            const removed = front + back;\\n            \\n            if (map.has(removed)) {\\n                max = Math.max(max, map.get(removed) + 1);\\n            }\\n        }\\n        \\n        map.set(word, max);\\n        \\n        res = Math.max(res, max);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestStrChain = function(words) {\\n    words.sort((a, b) => a.length - b.length);\\n    \\n    const map = new Map();\\n    \\n    let res = 1;\\n    \\n    for (const word of words) {\\n        const n = word.length;\\n        let max = 1;\\n        \\n        for (let i = 0; i < n; i++) {\\n            const front = word.substring(0, i);\\n            const back = word.substring(i + 1);\\n            \\n            const removed = front + back;\\n            \\n            if (map.has(removed)) {\\n                max = Math.max(max, map.get(removed) + 1);\\n            }\\n        }\\n        \\n        map.set(word, max);\\n        \\n        res = Math.max(res, max);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 522827,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words):\\n        dp = {}\\n        for w in sorted(words, key=len):\\n            tmp = [0]\\n            for i in range(len(w)):\\n                if w[:i] + w[i+1:] in dp:\\n                    tmp.append(dp[w[:i] + w[i+1:]])\\n                dp[w] = max(tmp) + 1\\n        return max(dp.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words):\\n        dp = {}\\n        for w in sorted(words, key=len):\\n            tmp = [0]\\n            for i in range(len(w)):\\n                if w[:i] + w[i+1:] in dp:\\n                    tmp.append(dp[w[:i] + w[i+1:]])\\n                dp[w] = max(tmp) + 1\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479539,
                "title": "python3-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution:\\n\\tdef longestStrChain(self, words: List[str]) -> int:\\n\\t\\twords.sort(key=len)\\n\\t\\tdp = {}\\n\\t\\tfor word in words:\\n\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\tif word not in dp:\\n\\t\\t\\t\\t\\tdp[word]=dp.get(word[:i]+word[i+1:],0)+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[word]=max(dp.get(word[:i]+word[i+1:],0)+1,dp[word])\\n\\t\\treturn max(dp.values())\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\tdef longestStrChain(self, words: List[str]) -> int:\\n\\t\\twords.sort(key=len)\\n\\t\\tdp = {}\\n\\t\\tfor word in words:\\n\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\tif word not in dp:\\n\\t\\t\\t\\t\\tdp[word]=dp.get(word[:i]+word[i+1:],0)+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[word]=max(dp.get(word[:i]+word[i+1:],0)+1,dp[word])\\n\\t\\treturn max(dp.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566658,
                "title": "java-simple-recursion-memoization-solution-with-explanation",
                "content": "Firstly, we add all the words to Hashmap for quick checking.\\nThen we start from a word and start deleting the letters to form a word with 1 less character and continue our recursion if we find the new word in our hashmap.\\n\\n```\\nclass Solution {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    HashMap<String, Integer> memo = new HashMap<>();\\n    public int longestStrChain(String[] words) {\\n        for (String word : words) {\\n            map.put(word, 1);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for (String word : words) {\\n            res = Math.max(res, 1 + dfs(word));\\n        }\\n        return res;\\n    }\\n    \\n    public int dfs(String sb) {\\n        if (sb.length() == 0) {\\n            return 0;\\n        }\\n        if (memo.containsKey(sb)) return memo.get(sb);\\n        int max = 0;\\n        for (int i = 0; i < sb.length(); i++) {\\n            StringBuilder tmp = new StringBuilder(sb);\\n            tmp.deleteCharAt(i);\\n            int res = 0;\\n            if (map.containsKey(tmp.toString())) {\\n                res += 1 + dfs(tmp.toString());\\n            }\\n            max = Math.max(max, res);\\n        }\\n        memo.put(sb, max);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    HashMap<String, Integer> memo = new HashMap<>();\\n    public int longestStrChain(String[] words) {\\n        for (String word : words) {\\n            map.put(word, 1);\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for (String word : words) {\\n            res = Math.max(res, 1 + dfs(word));\\n        }\\n        return res;\\n    }\\n    \\n    public int dfs(String sb) {\\n        if (sb.length() == 0) {\\n            return 0;\\n        }\\n        if (memo.containsKey(sb)) return memo.get(sb);\\n        int max = 0;\\n        for (int i = 0; i < sb.length(); i++) {\\n            StringBuilder tmp = new StringBuilder(sb);\\n            tmp.deleteCharAt(i);\\n            int res = 0;\\n            if (map.containsKey(tmp.toString())) {\\n                res += 1 + dfs(tmp.toString());\\n            }\\n            max = Math.max(max, res);\\n        }\\n        memo.put(sb, max);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456015,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Use DP (Bottom Up) tabulation, gradually build our results from the shortest string to the longest\\n2. The DP table saves the maximum chains for a given word\\n3. For every word, we try to remove each character and find the maximum predecessor chain + 1\\n``` javascript\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestStrChain = function(words) {\\n    let dp = {};\\n    words = words.sort((a,b)=>a.length - b.length);\\n    for (let word of words) {\\n        let longest = 0;\\n        for (let i=0;i<word.length;i++) {\\n            let pre = word.slice(0,i) + word.slice(i+1);\\n            longest = Math.max(longest, (dp[pre]||0) + 1);\\n        }\\n        dp[word] = longest;\\n    }\\n    return Math.max(...Object.values(dp));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestStrChain = function(words) {\\n    let dp = {};\\n    words = words.sort((a,b)=>a.length - b.length);\\n    for (let word of words) {\\n        let longest = 0;\\n        for (let i=0;i<word.length;i++) {\\n            let pre = word.slice(0,i) + word.slice(i+1);\\n            longest = Math.max(longest, (dp[pre]||0) + 1);\\n        }\\n        dp[word] = longest;\\n    }\\n    return Math.max(...Object.values(dp));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155234,
                "title": "python-solution-intuitive-and-suggestions-for-better-approach",
                "content": "# For code, scroll down\\nSo, guys, if you approach it in the recursive way,  (Top-down) you would most likely get an memorey limit exceeded error, So, here i\\'ll explain my intuition behind the logic as well as how i converted it to bottom up and a suggestion foor an even optimised solution.\\n\\nSo practically we need words in increasing order of their length,, that indicates we can sort our words list,\\nafter sorting it\\nbasically problem breaks down to two major conditions\\nyou wanna include this current word, or you dont\\n\\nso if you dont want to include the current word, simply  explore for the word in next index\\nthen, in case your current word meets the criteria of string chain, i.e 1 letter would be extra than its immediate preious, and rest all are letters match(in same order), then you can proceed by including this element and moving on to next index,\\nnow you canuse your dp to store the maximum of either including or not including, and thus return.\\n\\n\\nnow due to the limits in recursive call, you would probably get an error, so in the bottom up way :\\nprev acts as row, so from lastword to the beginning iterate\\ncurr acts as column take it from last word to word just behind after prev\\nrest the logic remains same\\n\\nYou could further optimise it by taking 2 1d dps\\nIf our dp depends on current row and just the previous row, we can use 2 dps, one for curr iteration and 1 storing values of previous iteration, here just make the row iterations as curr and column iterations as previous and just make changes accordingly.\\n\\nIf you feel something can be added on , I\\'m open to suggestions.\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        \\n        dp = {}\\n        @lru_cache(None)\\n        def iSvalidInclusion(word1,word2):\\n            if not (len(word2)==len(word1)+1):   \\n                return False\\n            i =0\\n            count =1\\n            \\n            while i<len(word1):\\n                \\n                if count==1:\\n                    if word2[i]==word1[i]:\\n                        i+=1\\n                    else:\\n                        count=0\\n                elif count==0:\\n                    if word2[i+1] ==  word1[i]:\\n                        i+=1\\n                    else: return False\\n            return True\\n\\'\\'\\'            \\n    RECURSIVE \\n\\n        def formChain(prev,curr):\\n            \\n            if curr >= len(words)+1:\\n                return 0\\n            \\n            if (prev,curr) in dp:\\n                return dp[(prev,curr)]\\n            \\n             basically im not including that word\\n            ans = formChain(prev,curr+1)\\n             im either starting go form chain or im including the word\\n            if prev ==0 or (prev>=1 and iSvalidInclusion(words[prev-1],words[curr-1])):\\n                ans = max(ans,1+formChain(curr,curr+1))\\n            dp[(prev,curr)] = ans\\n            return ans\\n        return formChain(0,1)\\n        \\n\\'\\'\\'\\n        dp = [[0]*(len(words)+2) for i in range(len(words)+2)]\\n        \\n        for prev in range(len(words),-1,-1):\\n            for curr in range(len(words)+1,prev,-1):\\n                if curr >= len(words)+1:\\n                    dp[prev][curr] = 0\\n                    continue\\n                ans = dp[prev][curr+1]\\n#             im either starting go form chain or im including the word\\n                if prev ==0 or (prev>=1 and iSvalidInclusion(words[prev-1],words[curr-1])):\\n                    ans = max(ans,1+dp[curr][curr+1])\\n                dp[prev][curr] = ans\\n        return dp[0][1]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        \\n        dp = {}\\n        @lru_cache(None)\\n        def iSvalidInclusion(word1,word2):\\n            if not (len(word2)==len(word1)+1):   \\n                return False\\n            i =0\\n            count =1\\n            \\n            while i<len(word1):\\n                \\n                if count==1:\\n                    if word2[i]==word1[i]:\\n                        i+=1\\n                    else:\\n                        count=0\\n                elif count==0:\\n                    if word2[i+1] ==  word1[i]:\\n                        i+=1\\n                    else: return False\\n            return True\\n\\'\\'\\'            \\n    RECURSIVE \\n\\n        def formChain(prev,curr):\\n            \\n            if curr >= len(words)+1:\\n                return 0\\n            \\n            if (prev,curr) in dp:\\n                return dp[(prev,curr)]\\n            \\n             basically im not including that word\\n            ans = formChain(prev,curr+1)\\n             im either starting go form chain or im including the word\\n            if prev ==0 or (prev>=1 and iSvalidInclusion(words[prev-1],words[curr-1])):\\n                ans = max(ans,1+formChain(curr,curr+1))\\n            dp[(prev,curr)] = ans\\n            return ans\\n        return formChain(0,1)\\n        \\n\\'\\'\\'\\n        dp = [[0]*(len(words)+2) for i in range(len(words)+2)]\\n        \\n        for prev in range(len(words),-1,-1):\\n            for curr in range(len(words)+1,prev,-1):\\n                if curr >= len(words)+1:\\n                    dp[prev][curr] = 0\\n                    continue\\n                ans = dp[prev][curr+1]\\n#             im either starting go form chain or im including the word\\n                if prev ==0 or (prev>=1 and iSvalidInclusion(words[prev-1],words[curr-1])):\\n                    ans = max(ans,1+dp[curr][curr+1])\\n                dp[prev][curr] = ans\\n        return dp[0][1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153589,
                "title": "dp-recurrence-memoization-cpp-well-commented",
                "content": "**Recurrence**\\n```\\n\\tint solve(int i, vector<string> &words, unordered_map<string,int> &mpp){ \\n      // if no other word is found shortest word chain will be of length 1\\n      int len= 1;\\n      string str= words[i];\\n      for(int j=0; j<str.size(); ++j){\\n        string new_str= str;\\n        new_str.erase(j, 1); // erase the character at index j \\n        if(mpp[new_str]>0){ // if the new word exists, find solve ahead and take the maximum\\n          len= max(1+solve(mpp[new_str]-1, words, mpp), len);\\n        }\\n      }\\n      // return maximum length of word chain possible at index i\\n      return len; \\n    }\\n  \\n    int longestStrChain(vector<string>& words) {\\n        int n= words.size();\\n        // hashmap to keep track of word positions\\n        unordered_map<string,int> mpp;\\n        for(int i=0; i<n; ++i) mpp[words[i]]= i+1;\\n        \\n        // try all indices as starting index to find maximum word chain\\n        int maxi= 1;\\n        for(int i=0; i<n; ++i) maxi= max(maxi, solve(i, words, mpp));\\n      \\n        return maxi;\\n    }\\n```\\n\\n**Memoization**\\n\\n```\\n\\tint solve(int i, vector<string> &words, unordered_map<string,int> &mpp, vector<int> &dp){ \\n      // if dp contains the ans return\\n      if(dp[i]!=-1) return dp[i];\\n      // if no other word is found shortest word chain will be of length 1\\n      int len= 1;\\n      string str= words[i];\\n      for(int j=0; j<str.size(); ++j){\\n        string new_str= str;\\n        new_str.erase(j, 1); // erase the character at index j \\n        if(mpp[new_str]>0){ // if the new word exists, find solve ahead and take the maximum\\n          len= max(1+solve(mpp[new_str]-1, words, mpp, dp), len);\\n        }\\n      }\\n      // return maximum length of word chain possible at index i\\n      return dp[i]= len; \\n    }\\n  \\n    int longestStrChain(vector<string>& words) {\\n        int n= words.size();\\n        // hashmap to keep track of word positions\\n        unordered_map<string,int> mpp;\\n        for(int i=0; i<n; ++i) mpp[words[i]]= i+1;\\n      \\n        // initialize dp vector\\n        vector<int> dp(n, -1);\\n      \\n        // try all indices as starting index to find maximum word chain\\n        int maxi= 1;\\n        for(int i=0; i<n; ++i) maxi= max(maxi, solve(i, words, mpp, dp));\\n      \\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\tint solve(int i, vector<string> &words, unordered_map<string,int> &mpp){ \\n      // if no other word is found shortest word chain will be of length 1\\n      int len= 1;\\n      string str= words[i];\\n      for(int j=0; j<str.size(); ++j){\\n        string new_str= str;\\n        new_str.erase(j, 1); // erase the character at index j \\n        if(mpp[new_str]>0){ // if the new word exists, find solve ahead and take the maximum\\n          len= max(1+solve(mpp[new_str]-1, words, mpp), len);\\n        }\\n      }\\n      // return maximum length of word chain possible at index i\\n      return len; \\n    }\\n  \\n    int longestStrChain(vector<string>& words) {\\n        int n= words.size();\\n        // hashmap to keep track of word positions\\n        unordered_map<string,int> mpp;\\n        for(int i=0; i<n; ++i) mpp[words[i]]= i+1;\\n        \\n        // try all indices as starting index to find maximum word chain\\n        int maxi= 1;\\n        for(int i=0; i<n; ++i) maxi= max(maxi, solve(i, words, mpp));\\n      \\n        return maxi;\\n    }\\n```\n```\\n\\tint solve(int i, vector<string> &words, unordered_map<string,int> &mpp, vector<int> &dp){ \\n      // if dp contains the ans return\\n      if(dp[i]!=-1) return dp[i];\\n      // if no other word is found shortest word chain will be of length 1\\n      int len= 1;\\n      string str= words[i];\\n      for(int j=0; j<str.size(); ++j){\\n        string new_str= str;\\n        new_str.erase(j, 1); // erase the character at index j \\n        if(mpp[new_str]>0){ // if the new word exists, find solve ahead and take the maximum\\n          len= max(1+solve(mpp[new_str]-1, words, mpp, dp), len);\\n        }\\n      }\\n      // return maximum length of word chain possible at index i\\n      return dp[i]= len; \\n    }\\n  \\n    int longestStrChain(vector<string>& words) {\\n        int n= words.size();\\n        // hashmap to keep track of word positions\\n        unordered_map<string,int> mpp;\\n        for(int i=0; i<n; ++i) mpp[words[i]]= i+1;\\n      \\n        // initialize dp vector\\n        vector<int> dp(n, -1);\\n      \\n        // try all indices as starting index to find maximum word chain\\n        int maxi= 1;\\n        for(int i=0; i<n; ++i) maxi= max(maxi, solve(i, words, mpp, dp));\\n      \\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152401,
                "title": "c-easy-solution-longest-increasing-subsequence-type-dp",
                "content": "**C++ Code:\\nTime Complexity : O(n*n length)**\\n**Space Complexity : O(n)**\\n\\n```\\nbool check(string &s1, string &s2)\\n{\\n    if(s1.length()-s2.length()!=1) return false;\\n    int i=0,j=0;\\n    while(i<s1.length())\\n    {\\n        if(s1[i]==s2[j])\\n        {\\n            i++;j++;\\n        }\\n        else\\n            i++;\\n    }\\n    if(i==s1.length() && j== s2.length()) return true;\\n    else return false;\\n}\\nstatic bool comp(string &s1,string &s2)\\n{\\n    if(s1.length()<s2.length()) return true;\\n    else return false;\\n}\\n    int longestStrChain(vector<string>& words) {\\n    int n = words.size();\\n    sort(words.begin(),words.end(),comp);\\n    vector<int>dp(n,1);\\n    int maxi = 0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int prev=0;prev<i;prev++)\\n        {\\n            if(check(words[i],words[prev]) && dp[i]<dp[prev]+1)\\n            {\\n                dp[i] =1+dp[prev];\\n            }\\n        }\\n       maxi = max(maxi,dp[i]); \\n    }\\n    return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool check(string &s1, string &s2)\\n{\\n    if(s1.length()-s2.length()!=1) return false;\\n    int i=0,j=0;\\n    while(i<s1.length())\\n    {\\n        if(s1[i]==s2[j])\\n        {\\n            i++;j++;\\n        }\\n        else\\n            i++;\\n    }\\n    if(i==s1.length() && j== s2.length()) return true;\\n    else return false;\\n}\\nstatic bool comp(string &s1,string &s2)\\n{\\n    if(s1.length()<s2.length()) return true;\\n    else return false;\\n}\\n    int longestStrChain(vector<string>& words) {\\n    int n = words.size();\\n    sort(words.begin(),words.end(),comp);\\n    vector<int>dp(n,1);\\n    int maxi = 0;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int prev=0;prev<i;prev++)\\n        {\\n            if(check(words[i],words[prev]) && dp[i]<dp[prev]+1)\\n            {\\n                dp[i] =1+dp[prev];\\n            }\\n        }\\n       maxi = max(maxi,dp[i]); \\n    }\\n    return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964329,
                "title": "c-easy-lis-based",
                "content": "```\\nclass Solution {\\n    bool compare(string &s1, string &s2) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = s1.size(), n2 = s2.size();\\n        if(n2 - 1 != n1) return false;\\n        while(j < n2) {\\n            if(s1[i] == s2[j])\\n                i++, j++;\\n            else \\n                j++;\\n        }\\n        \\n        if(i == n1 and j == n2)\\n            return true;\\n        \\n        return false;\\n    }\\npublic:\\n    static bool comp(string &s1, string &s2) {\\n        return s1.size() < s2.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), comp);\\n      \\n        int maxi = 1;\\n        int n = words.size();\\n        vector<int> dp(n, 1);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n\\n                if(compare(words[j], words[i]) and dp[i] < dp[j] + 1)\\n                    dp[i] = dp[j] + 1;\\n            }\\n            maxi = max(maxi, dp[i]);\\n\\n\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    bool compare(string &s1, string &s2) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = s1.size(), n2 = s2.size();\\n        if(n2 - 1 != n1) return false;\\n        while(j < n2) {\\n            if(s1[i] == s2[j])\\n                i++, j++;\\n            else \\n                j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 972707,
                "title": "python-dp-solution-and-dfs-solution-explained",
                "content": "```\\nfrom collections import defaultdict\\nfrom functools import lru_cache as cache\\n\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        \\'\\'\\'\\n        DFS Solution\\n        \\n        Build a graph.\\n            Turn words into a set for fast lookups.\\n            For each word, generate every possible previous word by removing each letter.\\n                If the previous word is in the set, do graph[prev].add(word)\\n        \\n        DFS the graph and keep track of longest path. \\n        We need to DFS from every word, to handle the case of unconnected components of the graph.\\n        If we cache response from the DFS function, we save significant runtime.\\n        \\n        Analysis:\\n        Time:\\n            - Building the graph: O(n * k) where k is the biggest word length in words. \\n                For each word we do len(word) operations to build the graph.\\n            - Traversing the graph: O(n) since we visit each node in the graph once and use a cache afterwards.\\n        Space:\\n            - Building the graph: O(n^2) since the worst case could have every word be a neighbor with every word.\\n            - Traversing the graph: O(n) recursion stack if the graph was just one long line.\\n        \\'\\'\\'\\n        \\n#         graph = defaultdict(set)\\n#         words = set(words)\\n        \\n#         for word in words:\\n#             if len(word) > 1: # one-letter words have no predecessors\\n#                 for i in range(len(word)):\\n#                     prev = word[:i] + word[i+1:]\\n#                     if prev in words:\\n#                         graph[prev].add(word)\\n        \\n#         @cache(None)\\n#         def dfs(word):\\n            \\n#             # if the word has no neighbors, it is a sequence of a length 1, and we can never have a sequence of length 0.\\n#             answer = 1 \\n            \\n#             for nei in graph[word]:\\n#                 answer = max(answer, 1 + dfs(nei))\\n                \\n#             return answer\\n        \\n#         return max(dfs(word) for word in words)\\n\\n        \\'\\'\\'\\n        DP Solution\\n        \\n        d[word] is the longest chain ending at word.\\n        We sort the words by length, iterate through them, and generate all predecessors by removing letters.\\n        If a predecessor p is in d, d[word] = max(1 + d[p], d[word])\\n        We can track the max value along the way as well.\\n        \\n        Analysis\\n        Time:\\n            - Building the DP dictionary: O(n * k) where k is the biggest word length in words. \\n                For each word we do len(word) operations to calculate predecessors.\\n                Lookups and updates to the dict are O(1), so our total time is O(n * k).\\n        Space:\\n            - Building the DP dictionary: O(n), since we have 1 entry for each word. O(n) overall.\\n        \\'\\'\\'\\n    \\n        words.sort(key=lambda word: len(word))\\n        d = {word: 1 for word in words}\\n        answer = 1 # Impossible to have a sequence of length 0.\\n        \\n        for word in words:\\n            for i in range(len(word)):\\n                prev = word[:i] + word[i+1:]\\n                if prev in d:\\n                    d[word] = max(1 + d[prev], d[word])\\n                    answer = max(answer, d[word])\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import lru_cache as cache\\n\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        \\'\\'\\'\\n        DFS Solution\\n        \\n        Build a graph.\\n            Turn words into a set for fast lookups.\\n            For each word, generate every possible previous word by removing each letter.\\n                If the previous word is in the set, do graph[prev].add(word)\\n        \\n        DFS the graph and keep track of longest path. \\n        We need to DFS from every word, to handle the case of unconnected components of the graph.\\n        If we cache response from the DFS function, we save significant runtime.\\n        \\n        Analysis:\\n        Time:\\n            - Building the graph: O(n * k) where k is the biggest word length in words. \\n                For each word we do len(word) operations to build the graph.\\n            - Traversing the graph: O(n) since we visit each node in the graph once and use a cache afterwards.\\n        Space:\\n            - Building the graph: O(n^2) since the worst case could have every word be a neighbor with every word.\\n            - Traversing the graph: O(n) recursion stack if the graph was just one long line.\\n        \\'\\'\\'\\n        \\n#         graph = defaultdict(set)\\n#         words = set(words)\\n        \\n#         for word in words:\\n#             if len(word) > 1: # one-letter words have no predecessors\\n#                 for i in range(len(word)):\\n#                     prev = word[:i] + word[i+1:]\\n#                     if prev in words:\\n#                         graph[prev].add(word)\\n        \\n#         @cache(None)\\n#         def dfs(word):\\n            \\n#             # if the word has no neighbors, it is a sequence of a length 1, and we can never have a sequence of length 0.\\n#             answer = 1 \\n            \\n#             for nei in graph[word]:\\n#                 answer = max(answer, 1 + dfs(nei))\\n                \\n#             return answer\\n        \\n#         return max(dfs(word) for word in words)\\n\\n        \\'\\'\\'\\n        DP Solution\\n        \\n        d[word] is the longest chain ending at word.\\n        We sort the words by length, iterate through them, and generate all predecessors by removing letters.\\n        If a predecessor p is in d, d[word] = max(1 + d[p], d[word])\\n        We can track the max value along the way as well.\\n        \\n        Analysis\\n        Time:\\n            - Building the DP dictionary: O(n * k) where k is the biggest word length in words. \\n                For each word we do len(word) operations to calculate predecessors.\\n                Lookups and updates to the dict are O(1), so our total time is O(n * k).\\n        Space:\\n            - Building the DP dictionary: O(n), since we have 1 entry for each word. O(n) overall.\\n        \\'\\'\\'\\n    \\n        words.sort(key=lambda word: len(word))\\n        d = {word: 1 for word in words}\\n        answer = 1 # Impossible to have a sequence of length 0.\\n        \\n        for word in words:\\n            for i in range(len(word)):\\n                prev = word[:i] + word[i+1:]\\n                if prev in d:\\n                    d[word] = max(1 + d[prev], d[word])\\n                    answer = max(answer, d[word])\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785733,
                "title": "well-explained-solution-o-n-3-c-solution-using-the-lis-algo",
                "content": "This solution uses the idea of LIS and instead of using LCS with LIS which would make the complexity of the solution O(N^4), a simple check function is implemented which would make the solution better with time complexity O(N^3). I found that the initial time taken with O(N^4) solution(LCS + LIS) was ~1800ms, but with O(N^3) the solution became 9 times faster resulting in ~220-240ms.\\n\\nIDEA : It is same as LIS, which can be easily understood, let me explain the use of check function. The check function would take the 2 strings and as mentioned in the question, the successive string only differs by 1 character. This modification allows the idea of O(N) complexity of helper/check function. The check function would simply count the difference in number of characters of the two strings. If the difference is 1, then it returns true and the condition holds true, and returns false otherwise.\\n\\n```\\n// using the idea of LIS\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    \\n    int check(string s, string t){\\n        int m = s.length(), n = t.length(), i = 0, j = 0, missing = 0;\\n        if(n != m+1) return false;\\n        for(int i=0; i<n; i++){\\n            if(t[i] == s[j]) j++;\\n            else{\\n\\t\\t\\t// if no character is missing, continue to check\\n\\t\\t\\t// if we found a missing character, update the variable\\n                if(!missing) missing = 1;\\n\\t\\t\\t\\t// if number of missing character is >=2 return false\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    static bool cmp(const string& s, const string t){\\n        return s.length() < t.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& v) {\\n        if(v.empty()) return 0;\\n        sort(v.begin(), v.end(), cmp);\\n        vector<int> dp(v.size(), 1);\\n        int ans = 0;\\n        for(int i=1; i<v.size(); i++){\\n            for(int j=0; j<i; j++){\\n                int x = v[i].length(), y = v[j].length();\\n                if(y+1 == x && check(v[j], v[i]) && dp[i] < dp[j]+1) dp[i] = dp[j]+1;\\n                ans = max(ans, dp[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// using the idea of LIS\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    \\n    int check(string s, string t){\\n        int m = s.length(), n = t.length(), i = 0, j = 0, missing = 0;\\n        if(n != m+1) return false;\\n        for(int i=0; i<n; i++){\\n            if(t[i] == s[j]) j++;\\n            else{\\n\\t\\t\\t// if no character is missing, continue to check\\n\\t\\t\\t// if we found a missing character, update the variable\\n                if(!missing) missing = 1;\\n\\t\\t\\t\\t// if number of missing character is >=2 return false\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    static bool cmp(const string& s, const string t){\\n        return s.length() < t.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& v) {\\n        if(v.empty()) return 0;\\n        sort(v.begin(), v.end(), cmp);\\n        vector<int> dp(v.size(), 1);\\n        int ans = 0;\\n        for(int i=1; i<v.size(); i++){\\n            for(int j=0; j<i; j++){\\n                int x = v[i].length(), y = v[j].length();\\n                if(y+1 == x && check(v[j], v[i]) && dp[i] < dp[j]+1) dp[i] = dp[j]+1;\\n                ans = max(ans, dp[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 516417,
                "title": "go-golang-clean-solution",
                "content": "```go\\nfunc longestStrChain(words []string) int {\\n    sort.Slice(words, func(a, b int) bool { return len(words[a]) < len(words[b]) })\\n    mem, res := make(map[string]int), 0\\n    for _, v := range words {\\n        for i := 0; i < len(v); i++ {\\n            pre := v[:i] + v[i + 1:]\\n            mem[v] = max(mem[v], mem[pre] + 1)\\n        }\\n        res = max(res, mem[v])\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc longestStrChain(words []string) int {\\n    sort.Slice(words, func(a, b int) bool { return len(words[a]) < len(words[b]) })\\n    mem, res := make(map[string]int), 0\\n    for _, v := range words {\\n        for i := 0; i < len(v); i++ {\\n            pre := v[:i] + v[i + 1:]\\n            mem[v] = max(mem[v], mem[pre] + 1)\\n        }\\n        res = max(res, mem[v])\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868312,
                "title": "python3-dp-lis",
                "content": "Does this look familiar to longest increasing subsequence? \\nThe first thing to notice is, we need to sort the words according to their length. Then, we could use the similar thought process as LIS to solve this problem.\\nThe dp[i] = longest sequence ending with words[i]. For each word, we check all possible subsequences of it, and if we could find one, then chek that subsequence is in dp. This part is equivalent to the process when we check if we cound find a number that is smaller than current number in the dict as in the LIS problem.\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        dp = {word: 1 for word in words}\\n        for i in range(len(words)):\\n            word = words[i]\\n            for j in range(len(word)):\\n                tmp = word[: j] + word[j + 1:]\\n                if tmp in dp:\\n                    dp[word] = max(dp[tmp] + 1, dp[word])\\n\\n        return max(dp.values())\\n```\\nPlease upvote if you find it helpful. Thanks!",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        dp = {word: 1 for word in words}\\n        for i in range(len(words)):\\n            word = words[i]\\n            for j in range(len(word)):\\n                tmp = word[: j] + word[j + 1:]\\n                if tmp in dp:\\n                    dp[word] = max(dp[tmp] + 1, dp[word])\\n\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592889,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),[](string a, string b){return a.size() < b.size();});\\n        map<string, int> dp;\\n        int res = 0;\\n        for(string s : words){\\n            for(int i = 0; i<s.size(); i++ ){\\n                dp[s] = max(dp[s.substr(0,i) + s.substr(i+1)] + 1, dp[s]);\\n            }\\n            res = max(res, dp[s]);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),[](string a, string b){return a.size() < b.size();}",
                "codeTag": "Java"
            },
            {
                "id": 380056,
                "title": "java-dynamic-programming-map-explained",
                "content": "Solution is based on DP. \\nIf we sort the array then sequence can only increase if we go from 0 to len(array). Also if we checked this word previously then we can re-use it\\'s sequence score if this word can be formed from longer word. \\n\\nThese are key ideas, now build the solution. Sort words by length, then start iterating on word\\'s array. For every word we met store it\\'s best scoe in the map <word>-<score>. For every word remove it chars one by one and check if met this new word before, if so - for current word the score will be score<shorter_word> + 1. Otherwise this word starts the new sequence so the score is 1. In Java we can remove one char effectively using StringBuilder. \\n\\nWe keep the overall best score and check for every word from array if it can give us better one.\\n\\nComplexity - O(nlgn) for sorting, O(n x avg_len) for checking every char in every word, so the main factor will be O(n x avg_len). We need O(n x avg_len) memory to store scores for every sub-word.\\n\\n```\\n    public int longestStrChain(String[] words) {\\n        //sort words by length\\n        Arrays.sort(words,  new Comparator<String>(){\\n            public int compare(String s0, String s1) {\\n                return s0.length() - s1.length();\\n            }\\n        });\\n        //map is required to store the best sequence length for each word\\n        Map<String, Integer> map = new HashMap();\\n        //final result\\n        int res = 0;\\n        //iterate over words, because they are sorted we may assume that at each next word\\n        //can only increase the sequence\\n        for (String word : words) {\\n            int cur = 1;\\n            //try to remove every char in word one by one, check in the map for every removed char\\n            StringBuilder sb = new StringBuilder(word);\\n            int N = word.length();\\n            for (int i = 0; i < N; i++) {\\n                char ch = sb.charAt(i);\\n                sb.deleteCharAt(i);\\n                //this is our word without char at position i-th\\n                String possible = sb.toString();\\n                //if we met this word before - get it\\'s sequence count from map, otherwise it\\'s 1\\n                if (map.containsKey(possible)) {\\n                    cur = Math.max(cur, map.get(possible) + 1);\\n                }\\n                //this is to restore deleted char for next iteration\\n                if (i < N - 1)\\n                    sb.insert(i, ch);\\n            }\\n            //store the best sequence score for this word\\n            map.put(word, cur);\\n            //update overall result if needed\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int longestStrChain(String[] words) {\\n        //sort words by length\\n        Arrays.sort(words,  new Comparator<String>(){\\n            public int compare(String s0, String s1) {\\n                return s0.length() - s1.length();\\n            }\\n        });\\n        //map is required to store the best sequence length for each word\\n        Map<String, Integer> map = new HashMap();\\n        //final result\\n        int res = 0;\\n        //iterate over words, because they are sorted we may assume that at each next word\\n        //can only increase the sequence\\n        for (String word : words) {\\n            int cur = 1;\\n            //try to remove every char in word one by one, check in the map for every removed char\\n            StringBuilder sb = new StringBuilder(word);\\n            int N = word.length();\\n            for (int i = 0; i < N; i++) {\\n                char ch = sb.charAt(i);\\n                sb.deleteCharAt(i);\\n                //this is our word without char at position i-th\\n                String possible = sb.toString();\\n                //if we met this word before - get it\\'s sequence count from map, otherwise it\\'s 1\\n                if (map.containsKey(possible)) {\\n                    cur = Math.max(cur, map.get(possible) + 1);\\n                }\\n                //this is to restore deleted char for next iteration\\n                if (i < N - 1)\\n                    sb.insert(i, ch);\\n            }\\n            //store the best sequence score for this word\\n            map.put(word, cur);\\n            //update overall result if needed\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078748,
                "title": "c-dp-using-unordered-map-array-beats-97-50",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLook at the constraint ```1 <= words[i].length <= 16```. There are many ways of DP.\\n\\nVarying the ```words[i]``` is easier and quicker! In fact there are len(words[i]) substrings with length=len(words[i])-1 \\n\\nUse an array over ```unordered_set<string, int> mp```\\n\\nThe index for ```mp[i]``` denote the length of string.\\n# Why not just unordered_set<string, int>?\\nAlthough the C++ unodered_map is in average O(1) for inserting & updating an element, but in worst case it is a linear time O(k) where k=size of the container. So breaking it into an array of smaller unordered sets may save time! \\n\\nThe array for unordered_maps may be changed into array for maps when n is small, and it might make code for small n more efficient.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. ```vector<unordered_map<string, int>>``` is a declaration that defines a vector containing elements of type ```unordered_map<string, int>```. Each element in the vector is an unordered map that associates strings with integer values.\\n2. ```mp``` is the name of the vector of unordered maps.\\n3. Vector ```mp``` is initialized with 17 elements (length of 0~16). Each element represents a different word length.\\n4. if ```mp[5][\"apple\"]``` is 3, it means that the longest chain that can be formed using words of length 5 includes \"apple\" and two other words.\\n5. ```vector<unordered_map<string, int>> mp(17);```is used to maintain a data structure that organizes words by their lengths and keeps track of the longest chain that can be formed for each word length. It\\'s a crucial part of the dynamic programming approach used to solve the problem of finding the longest string chain.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(len(word)*16+n\\\\log n)=O(n\\\\log n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(len(word))\\n# Code runtime 54ms\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        if (n == 1) return 1;\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n        vector<unordered_map<string, int>> mp(17);\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0;\\n\\n        for (auto& w : words) {\\n            int sz = w.size();\\n            if (sz == 1) continue;\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); \\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2] + 1);\\n                }\\n            }\\n            ans = max(ans, mp[sz][w]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n# Code with Explanation in Comments\\n```\\n// Define a class Solution, typically used for solving a problem.\\n\\nclass Solution {\\npublic:\\n    // Define the function longestStrChain, which takes a vector of strings as input.\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size(); // Get the number of words in the input vector.\\n\\n        // If there is only one word in the input, return 1 as the result.\\n        if (n == 1) return 1;\\n\\n        // Sort the words in the input vector in ascending order of their lengths.\\n        // A lambda function is used for the comparison, ensuring shorter words come first.\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n\\n        // Create a vector of unordered_maps with a size of 17, each for words of a specific length.\\n        vector<unordered_map<string, int>> mp(17);\\n\\n        // Populate the maps with words from the input, associating each word with a count of 1.\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0; // Initialize a variable to store the maximum chain length.\\n\\n        // Iterate through each word in the input.\\n        for (auto& w : words) {\\n            int sz = w.size(); // Get the length of the current word.\\n\\n            // If the word has a length of 1, skip it as it cannot be part of a chain.\\n            if (sz == 1) continue;\\n\\n            // Iterate through all possible substrings of the current word by removing one character at a time.\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); // Create a new word by removing one character.\\n\\n                // Check if the previous length (sz-1) contains the newly created word (w2).\\n                // If it does, update the current length\\'s map with the maximum chain length.\\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2] + 1);\\n                }\\n            }\\n\\n            // Update the maximum chain length based on the current word\\'s chain length.\\n            ans = max(ans, mp[sz][w]);\\n        }\\n\\n        // Return the maximum chain length found in the input vector of words.\\n        return ans;\\n    }\\n};\\n\\n```\\n# Code using map<string, int> mp[17] runtime 76ms\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        if (n == 1) return 1;\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n        map<string, int> mp[17];\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0;\\n\\n        for (auto& w : words) {\\n            int sz = w.size();\\n            if (sz == 1) continue;\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); \\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2]+1);\\n                }\\n            }\\n            ans = max(ans, mp[sz][w]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```1 <= words[i].length <= 16```\n```words[i]```\n```unordered_set<string, int> mp```\n```mp[i]```\n```vector<unordered_map<string, int>>```\n```unordered_map<string, int>```\n```mp```\n```mp```\n```mp[5][\"apple\"]```\n```vector<unordered_map<string, int>> mp(17);```\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        if (n == 1) return 1;\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n        vector<unordered_map<string, int>> mp(17);\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0;\\n\\n        for (auto& w : words) {\\n            int sz = w.size();\\n            if (sz == 1) continue;\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); \\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2] + 1);\\n                }\\n            }\\n            ans = max(ans, mp[sz][w]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```\n```\\n// Define a class Solution, typically used for solving a problem.\\n\\nclass Solution {\\npublic:\\n    // Define the function longestStrChain, which takes a vector of strings as input.\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size(); // Get the number of words in the input vector.\\n\\n        // If there is only one word in the input, return 1 as the result.\\n        if (n == 1) return 1;\\n\\n        // Sort the words in the input vector in ascending order of their lengths.\\n        // A lambda function is used for the comparison, ensuring shorter words come first.\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n\\n        // Create a vector of unordered_maps with a size of 17, each for words of a specific length.\\n        vector<unordered_map<string, int>> mp(17);\\n\\n        // Populate the maps with words from the input, associating each word with a count of 1.\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0; // Initialize a variable to store the maximum chain length.\\n\\n        // Iterate through each word in the input.\\n        for (auto& w : words) {\\n            int sz = w.size(); // Get the length of the current word.\\n\\n            // If the word has a length of 1, skip it as it cannot be part of a chain.\\n            if (sz == 1) continue;\\n\\n            // Iterate through all possible substrings of the current word by removing one character at a time.\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); // Create a new word by removing one character.\\n\\n                // Check if the previous length (sz-1) contains the newly created word (w2).\\n                // If it does, update the current length\\'s map with the maximum chain length.\\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2] + 1);\\n                }\\n            }\\n\\n            // Update the maximum chain length based on the current word\\'s chain length.\\n            ans = max(ans, mp[sz][w]);\\n        }\\n\\n        // Return the maximum chain length found in the input vector of words.\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        if (n == 1) return 1;\\n        sort(words.begin(), words.end(), [&](string& x, string& y) {\\n            return x.size() < y.size(); \\n        });\\n        map<string, int> mp[17];\\n        for (auto& w : words)\\n            mp[w.size()][w] = 1;\\n\\n        int ans = 0;\\n\\n        for (auto& w : words) {\\n            int sz = w.size();\\n            if (sz == 1) continue;\\n            for (int i = 0; i < sz; i++) {\\n                string w2 = w.substr(0, i) + w.substr(i+1); \\n                if (mp[sz-1].count(w2) != 0) {\\n                    mp[sz][w] = max(mp[sz][w], mp[sz-1][w2]+1);\\n                }\\n            }\\n            ans = max(ans, mp[sz][w]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078608,
                "title": "python-3-8-lines-w-comments-t-s-97-94",
                "content": "\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        d = defaultdict(int)                # The keys for d are words. The values    \\n                                            # are the # of predecessors of that word\\n        for word in sorted(words,key = len):\\n            n, d[word] = len(word), 1\\n\\n            for i in range(n):              # Check which larger words are predecessors\\n                w = word[:i] + word[i+1:]   # and determine the max length path\\n\\n                if w in d:\\n                    d[word] = max(d[word], d[w] + 1)\\n\\n        return max(d.values())   \\n```\\n[https://leetcode.com/problems/longest-string-chain/submissions/1056706538/?envType=daily-question&envId=2023-09-23](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(*MN*), in which *N* ~ `len(words)` *M* ~ maximum length of elements in`words`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        d = defaultdict(int)                # The keys for d are words. The values    \\n                                            # are the # of predecessors of that word\\n        for word in sorted(words,key = len):\\n            n, d[word] = len(word), 1\\n\\n            for i in range(n):              # Check which larger words are predecessors\\n                w = word[:i] + word[i+1:]   # and determine the max length path\\n\\n                if w in d:\\n                    d[word] = max(d[word], d[w] + 1)\\n\\n        return max(d.values())   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153172,
                "title": "easiest-solution-with-dp-bottom-up-two-pointer-c",
                "content": "**First of all I suggest to observe the constraints clearly **\\n**Constraints:\\n1 <= words.length <= 1000\\n1 <= words[i].length <= 16\\nwords[i] only consists of lowercase English letters.**\\n\\nmaximum length of string words[i] can be 16 so we use this to solve this problem, and we also know that the answer **(string chain)** of 15 lenght words[i] came from the answer **(string chain)** of length 14 length of words[i].\\n**So make vector<pair<string,int>> V[17] where string part contain the words[i] and int part contain answer(longest string chain till that string) and vector is of only size 17 because max length of words[i] can be 16.** \\n\\n\\nclass Solution {\\n    \\n    bool Match(string s1, string s2)\\n    { \\n\\t    // This function check wheter string s1 is predecessor of s2 or not using two pointer approach.\\n        int val=0;\\n        int n=s1.size(),m=s2.size();\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(s1[i]!=s2[j] && val>0)\\n            {\\n                return false;                // if more than one charcter are different not predecessor so return false.\\n            }\\n            else if(s1[i]!=s2[j] && val==0)\\n            {\\n                i++;\\n                val++;                    //  if only one charcter is differ then allowed.\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return true;    // s1 is predecessor of s2.\\n    }\\n    \\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        \\n        int  n=words.size();\\n        vector<pair<string,int>> V[17];    //  store <word[i] , ans-till-that-string> .\\n        for(int i=0;i<n;i++)\\n        {\\n            int size=words[i].size();\\n            V[size].push_back({words[i],1});    //  find size of word[i] and push at V[size] with initiall answer 1.\\n        }\\n        \\n        int ans=1;           //   maintaining the longest string chain.\\n        \\n        for(int i=2;i<=16;i++)       \\n        {   // trying to compute answer of i length string from i-1 length string.\\n            for(int j=0;j<V[i].size();j++)   // iterate over i length string.\\n            {\\n                for(int k=0;k<V[i-1].size();k++)   // iterate over i-1 length string.\\n                {\\n                    bool isMatch=Match(V[i][j].first,V[i-1][k].first);   // check if i length string is predecessor of i-1 length string or not.\\n                    if(isMatch==true)         // if yess then,\\n                    {\\n                        int val=1+V[i-1][k].second;\\n                        V[i][j].second=max(V[i][j].second,val);     //Computed answer from i-1 string  put in second part(int part) of V[i][j].\\n                        ans=max(ans,V[i][j].second);     // maintaining the max ot longest string chain.\\n                    }\\n                    else        // if No then maintianing the answer only.\\n                    {\\n                        ans=max(ans,V[i][j].second);   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;       //  return the longest string chain.\\n        \\n    }\\n};\\n\\n\\n**Time Complexity = O(N^2)**\\n**Space Complexity = O(N), Where N is length of  vector word.**\\n\\n**IF FIND IT HELPFULL PLEASE SHARE IT AND UPVOTE.**",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\n    \\n    bool Match(string s1, string s2)\\n    { \\n\\t    // This function check wheter string s1 is predecessor of s2 or not using two pointer approach.\\n        int val=0;\\n        int n=s1.size(),m=s2.size();\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(s1[i]!=s2[j] && val>0)\\n            {\\n                return false;                // if more than one charcter are different not predecessor so return false.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1215980,
                "title": "c-top-down-dp-with-memo-bonus-tle-bfs-solution",
                "content": "**Top Down DP Solution**\\nTime Complexity: O(N * S)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int longestChainLen = 1;\\n        sort(begin(words), end(words), [] (string &a, string &b) { return a.size() < b.size(); });\\n        int memo[1001];\\n        memset(memo, -1, sizeof(memo));\\n        // For all words, start dfs\\n        for (int i = 0; i < words.size(); i++) {\\n            longestChainLen = max(dfs(i, words, memo), longestChainLen);\\n        }\\n        return longestChainLen;\\n    }\\n    \\n    int dfs(int prev, vector<string> &words, int memo[]) {\\n        if (memo[prev] != -1) {\\n            return memo[prev];\\n        }\\n        int answer = 1;\\n        for (int i = prev + 1; i < words.size(); i++) {\\n            if (words[i].size() - words[prev].size() > 1) {\\n                break;\\n            }\\n            if ((words[prev].size() + 1) == words[i].size() && isBPredecessorOfA(words[prev], words[i])) {\\n                answer = max(1 + dfs(i, words, memo), answer);\\n            }\\n        }\\n        // memoize the result\\n        memo[prev] = answer;\\n        return answer;\\n    }\\n    \\n    // Checks if B predecessor of A\\n    bool isBPredecessorOfA(string &a, string &b) {\\n        int i = 0;\\n        // Find first non-matching letter\\n        for (; i < a.size(); i++) {\\n            if (a[i] != b[i]) {\\n                break;\\n            }\\n        }\\n        for (int ai = i, bi = i + 1; ai < a.size(); ai++, bi++) {\\n            if (a[ai] != b[bi]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**BFS Solution GOT TLE**\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<vector<string>> map(17);\\n        int longestChainLen = 1;\\n        queue<pair<string, int>> todo;\\n        for (string &word : words) {\\n            map[word.size()].push_back(word);\\n            todo.push({word, 1});\\n        }\\n        while (!todo.empty()) {\\n            pair<string, int> cur = todo.front();\\n            todo.pop();\\n            longestChainLen = max(longestChainLen, cur.second);\\n            if (cur.first.size() + 1 < map.size()) {\\n                for (string &possiblePredecessor : map[cur.first.size() + 1]) {\\n                    if (isBPredecessorOfA(cur.first, possiblePredecessor)) {\\n                        todo.push({possiblePredecessor, cur.second + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return longestChainLen;\\n    }\\n    \\n    // Checks if B predecessor of A\\n    bool isBPredecessorOfA(string &a, string &b) {\\n        int i = 0;\\n        // Find first non-matching letter\\n        for (; i < a.size(); i++) {\\n            if (a[i] != b[i]) {\\n                break;\\n            }\\n        }\\n        for (int ai = i, bi = i + 1; ai < a.size(); ai++, bi++) {\\n            if (a[ai] != b[bi]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        int longestChainLen = 1;\\n        sort(begin(words), end(words), [] (string &a, string &b) { return a.size() < b.size(); });\\n        int memo[1001];\\n        memset(memo, -1, sizeof(memo));\\n        // For all words, start dfs\\n        for (int i = 0; i < words.size(); i++) {\\n            longestChainLen = max(dfs(i, words, memo), longestChainLen);\\n        }\\n        return longestChainLen;\\n    }\\n    \\n    int dfs(int prev, vector<string> &words, int memo[]) {\\n        if (memo[prev] != -1) {\\n            return memo[prev];\\n        }\\n        int answer = 1;\\n        for (int i = prev + 1; i < words.size(); i++) {\\n            if (words[i].size() - words[prev].size() > 1) {\\n                break;\\n            }\\n            if ((words[prev].size() + 1) == words[i].size() && isBPredecessorOfA(words[prev], words[i])) {\\n                answer = max(1 + dfs(i, words, memo), answer);\\n            }\\n        }\\n        // memoize the result\\n        memo[prev] = answer;\\n        return answer;\\n    }\\n    \\n    // Checks if B predecessor of A\\n    bool isBPredecessorOfA(string &a, string &b) {\\n        int i = 0;\\n        // Find first non-matching letter\\n        for (; i < a.size(); i++) {\\n            if (a[i] != b[i]) {\\n                break;\\n            }\\n        }\\n        for (int ai = i, bi = i + 1; ai < a.size(); ai++, bi++) {\\n            if (a[ai] != b[bi]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        vector<vector<string>> map(17);\\n        int longestChainLen = 1;\\n        queue<pair<string, int>> todo;\\n        for (string &word : words) {\\n            map[word.size()].push_back(word);\\n            todo.push({word, 1});\\n        }\\n        while (!todo.empty()) {\\n            pair<string, int> cur = todo.front();\\n            todo.pop();\\n            longestChainLen = max(longestChainLen, cur.second);\\n            if (cur.first.size() + 1 < map.size()) {\\n                for (string &possiblePredecessor : map[cur.first.size() + 1]) {\\n                    if (isBPredecessorOfA(cur.first, possiblePredecessor)) {\\n                        todo.push({possiblePredecessor, cur.second + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return longestChainLen;\\n    }\\n    \\n    // Checks if B predecessor of A\\n    bool isBPredecessorOfA(string &a, string &b) {\\n        int i = 0;\\n        // Find first non-matching letter\\n        for (; i < a.size(); i++) {\\n            if (a[i] != b[i]) {\\n                break;\\n            }\\n        }\\n        for (int ai = i, bi = i + 1; ai < a.size(); ai++, bi++) {\\n            if (a[ai] != b[bi]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213689,
                "title": "rust-dp-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn longest_str_chain(words: Vec<String>) -> i32 {\\n        let mut words = words;\\n        words.sort_by_cached_key(String::len);\\n        let mut hm = HashMap::new();\\n        let mut answer = 0;\\n        for word in &words {\\n            let max = (0..word.len())\\n                .filter_map(|i| hm.get(&(String::new() + &word[0..i] + &word[i + 1..])))\\n                .max()\\n                .unwrap_or(&0)\\n                + 1;\\n            hm.insert(word, max);\\n            answer = answer.max(max);\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn longest_str_chain(words: Vec<String>) -> i32 {\\n        let mut words = words;\\n        words.sort_by_cached_key(String::len);\\n        let mut hm = HashMap::new();\\n        let mut answer = 0;\\n        for word in &words {\\n            let max = (0..word.len())\\n                .filter_map(|i| hm.get(&(String::new() + &word[0..i] + &word[i + 1..])))\\n                .max()\\n                .unwrap_or(&0)\\n                + 1;\\n            hm.insert(word, max);\\n            answer = answer.max(max);\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876260,
                "title": "explained-solution-using-graph-dfs-and-memoization",
                "content": "**Approach**\\n\\n1. Build a dictionary for words of same length (Idea is a word can be a predecessor if the len of the word is  greater than the previous word). Dictionary helps in faster access\\n2. Function to check if the words is a predecessor\\n3. Using the above function build a graph. Use the length dictionary to get only words one greater than current word\\n4. Finally apply dfs with memoization to get the longest path\\n\\nGraph for the example [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n{u\\'a\\': [u\\'ba\\'], u\\'b\\': [u\\'ba\\'], u\\'bda\\': [u\\'bdca\\'], u\\'ba\\': [u\\'bca\\', u\\'bda\\'], u\\'bca\\': [u\\'bdca\\']})\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        len_dict = defaultdict(list)\\n        for word in words:\\n            len_dict[len(word)].append(word)\\n        \\n        graph = defaultdict(list)\\n        \\n        \\n        def is_pre(word1, word2):\\n            i, j = 0, 0\\n            found = False\\n            while i < len(word1) and j < len(word2):\\n                if word1[i] != word2[j]:\\n                    if found:\\n                        return False\\n                    else:\\n                        found = True\\n                        j += 1\\n                        continue\\n                i += 1\\n                j += 1\\n            \\n            return True\\n        \\n        for word in words:\\n            for word1 in len_dict[len(word) + 1]:\\n                if is_pre(word, word1):\\n                    graph[word].append(word1)\\n        \\n        self.hash_map = {}\\n        def dfs(word):\\n            count = 0\\n            if word in self.hash_map:\\n                return self.hash_map[word]\\n            for word1 in graph[word]:\\n                count = max(count, 1 + dfs(word1))\\n            \\n            self.hash_map[word] = count\\n            return count\\n        ans = 0\\n        for word in words:\\n            ans = max(ans, 1 + dfs(word))\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Graph",
                    "Memoization"
                ],
                "code": "class Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        len_dict = defaultdict(list)\\n        for word in words:\\n            len_dict[len(word)].append(word)\\n        \\n        graph = defaultdict(list)\\n        \\n        \\n        def is_pre(word1, word2):\\n            i, j = 0, 0\\n            found = False\\n            while i < len(word1) and j < len(word2):\\n                if word1[i] != word2[j]:\\n                    if found:\\n                        return False\\n                    else:\\n                        found = True\\n                        j += 1\\n                        continue\\n                i += 1\\n                j += 1\\n            \\n            return True\\n        \\n        for word in words:\\n            for word1 in len_dict[len(word) + 1]:\\n                if is_pre(word, word1):\\n                    graph[word].append(word1)\\n        \\n        self.hash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 799977,
                "title": "clean-java-solutions-faster-than-90",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int longest = 1;\\n        HashMap<String, Integer> word_max = new HashMap<String, Integer>();\\n        Arrays.sort(words, (a, b)->a.length() - b.length());\\n        for(int i = 0;i < words.length;++i) {\\n            String word = words[i];\\n            int longer = 1;\\n            for(int j = 0;j < word.length();++j) {\\n                String last = new StringBuilder(word).deleteCharAt(j).toString();\\n                longer = Math.max(longer, word_max.getOrDefault(last, 0) + 1);\\n            }\\n            word_max.put(word, longer);\\n            longest = Math.max(longest, longer);\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int longest = 1;\\n        HashMap<String, Integer> word_max = new HashMap<String, Integer>();\\n        Arrays.sort(words, (a, b)->a.length() - b.length());\\n        for(int i = 0;i < words.length;++i) {\\n            String word = words[i];\\n            int longer = 1;\\n            for(int j = 0;j < word.length();++j) {\\n                String last = new StringBuilder(word).deleteCharAt(j).toString();\\n                longer = Math.max(longer, word_max.getOrDefault(last, 0) + 1);\\n            }\\n            word_max.put(word, longer);\\n            longest = Math.max(longest, longer);\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600656,
                "title": "optimal-python-solution-in-11-lines-thought-process",
                "content": "The key idea here is that we can think of all the words we have, as a **directed graph, where each node represents a word, and each node points to all nodes that are just one deletion away.**\\n\\nSo in the first test case we\\'ll have \"bdca\" pointing to both [bca,bda] because we can reach both strings by removing one character from \"bdca\".\\n\\nWe can then think of the problem as trying to find the longest path in the graph. This can be achieved by doing N dfs-s starting from each node, and taking the max path from each source node.\\n\\nThe problem with this approach is that we\\'re repeating so much work. If we visited \"ba\" for instance in the dfs starting from \"bca\", and then visited it again in the dfs starting from \"bda\", we\\'ll be repeating the same work for \"ba\". \\n\\nThis brings up the idea of using memoization. Why not build a memo with longest path starting from each node. We can even build on this idea and argue that we don\\'t need to build a graph at all. We can just simply simulate a DFS without building a graph.\\n\\n**The overall time complexity will be O(NLL) where L is the length of the longest string.**\\nWe\\'re basically filling up the memo for N words using recursive calls, and each call does O(L^2) work to generate the potential child words.\\n\\nSpace complexity is just O(NL) as we\\'re basically storing all words.\\n\\nHere is the code:\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo={}\\n        words=set(words)\\n        def longestChain(word):\\n            if not word in memo:\\n                memo[word]=1\\n                for i in range(len(word)):\\n                    child=word[:i]+word[i+1:]\\n                    if child in words:\\n                        memo[word]=max(memo[word],longestChain(child)+1)\\n            return memo[word]\\n        return max(longestChain(word) for word in words) #start DFS from each word\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo={}\\n        words=set(words)\\n        def longestChain(word):\\n            if not word in memo:\\n                memo[word]=1\\n                for i in range(len(word)):\\n                    child=word[:i]+word[i+1:]\\n                    if child in words:\\n                        memo[word]=max(memo[word],longestChain(child)+1)\\n            return memo[word]\\n        return max(longestChain(word) for word in words) #start DFS from each word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434604,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        ## DP,   TC: O(n*k) k is the lenght of each word.    SC: O(n)\\n        if not words:\\n            return 0\\n        \\n        words = sorted(words, key=len)\\n  \\n        dic = {}\\n        n = len(words)\\n        dp = [0] * n\\n        for i in range(n):\\n            cur = words[i]\\n            l = len(cur)\\n           \\n            cnt = float(\\'-inf\\')\\n            for j in range(l):\\n                tmp = cur[:j]+cur[j+1:]\\n               \\n                if tmp in dic:\\n                    cnt = max(cnt, dic[tmp]+1)\\n            if cnt == float(\\'-inf\\'):\\n                cnt = 1\\n            dp[i] = cnt\\n            dic[cur] = cnt\\n        \\n        return max(dp)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        ## DP,   TC: O(n*k) k is the lenght of each word.    SC: O(n)\\n        if not words:\\n            return 0\\n        \\n        words = sorted(words, key=len)\\n  \\n        dic = {}",
                "codeTag": "Java"
            },
            {
                "id": 413348,
                "title": "easiest-solution-available-on-internet-dfs-memo",
                "content": "It is always easy to think in terms of recursion then write pseudo code of it, whenever there is an optimal substructure just use some extra space to avoid recomputation.\\nHere the approach is to find the largest length possible starting with any word and maintain a global ans.\\nSo, we start with every word with initial length 1, one by one remove every character at ith location (one at a time) and if the new word is present in the dictionary we recur with this new word to find max length possible with this word and add 1 to the existing word\\'s ans, also taking max for every recursion.\\n\\n->function and DS used\\nmemo is used to find longest length starting with any word;\\nm is used to memorize {string, length} for every string;\\nunordered_set s is used to ans query for new string in O(1) time.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> m;\\n    unordered_set<string> s;\\n    \\n    int memo(string a){\\n        if(m.count(a)) return m[a];\\n        int ans=1;\\n        for(int i=0;i<a.length();i++){\\n            string tmp=a;\\n            tmp.erase(i,1);\\n            if(s.count(tmp))\\n                ans = max(ans,1+memo(tmp));\\n        }\\n        m[a]=ans;\\n        return m[a];\\n    }\\n    \\n    int longestStrChain(vector<string>& w) {\\n        m.clear(); s.clear();int ans = 0;\\n        for(int i=0;i<w.size();i++) s.insert(w[i]);\\n        for(int i=0;i<w.size();i++) ans = max(memo(w[i]), ans);            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> m;\\n    unordered_set<string> s;\\n    \\n    int memo(string a){\\n        if(m.count(a)) return m[a];\\n        int ans=1;\\n        for(int i=0;i<a.length();i++){\\n            string tmp=a;\\n            tmp.erase(i,1);\\n            if(s.count(tmp))\\n                ans = max(ans,1+memo(tmp));\\n        }\\n        m[a]=ans;\\n        return m[a];\\n    }\\n    \\n    int longestStrChain(vector<string>& w) {\\n        m.clear(); s.clear();int ans = 0;\\n        for(int i=0;i<w.size();i++) s.insert(w[i]);\\n        for(int i=0;i<w.size();i++) ans = max(memo(w[i]), ans);            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407071,
                "title": "java-trie-solution-47ms",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> b.length()-a.length());\\n        int max = 0;\\n        Trie t = new Trie();\\n\\n        for (String w : words) {\\n            int cur = 1 + t.find(w, 0, false);\\n            t.addWord(w, 0, cur);\\n            max = Math.max(max, cur);\\n        }\\n\\n        return max;\\n    }\\n\\n    class Trie {\\n        Trie[] next = new Trie[26];\\n        boolean end = false;\\n        int chain = 0;\\n\\n        void addWord(String w, int pos, int chain) {\\n            if (pos == w.length()) {\\n                end = true;\\n                this.chain = chain;\\n                return;\\n            }\\n            char c = w.charAt(pos);\\n            if (next[c - \\'a\\'] == null) next[c - \\'a\\'] = new Trie();\\n            next[c - \\'a\\'].addWord(w, pos+1, chain);\\n        }\\n\\n        int find(String w, int pos, boolean added) {\\n            if (pos == w.length() && added) return chain;\\n\\n            int max = 0;\\n            for (int i = 0; i < 26 && !added; i++) {\\n                if (next[i] == null) continue;\\n                max = Math.max(max, next[i].find(w, pos, true));\\n            }\\n\\n            if (pos == w.length()) return max;\\n\\n            char c = w.charAt(pos);\\n            if (next[c - \\'a\\'] != null) max = Math.max(max, next[c - \\'a\\'].find(w, pos+1, added));\\n            return max;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b) -> b.length()-a.length());\\n        int max = 0;\\n        Trie t = new Trie();\\n\\n        for (String w : words) {\\n            int cur = 1 + t.find(w, 0, false);\\n            t.addWord(w, 0, cur);\\n            max = Math.max(max, cur);\\n        }\\n\\n        return max;\\n    }\\n\\n    class Trie {\\n        Trie[] next = new Trie[26];\\n        boolean end = false;\\n        int chain = 0;\\n\\n        void addWord(String w, int pos, int chain) {\\n            if (pos == w.length()) {\\n                end = true;\\n                this.chain = chain;\\n                return;\\n            }\\n            char c = w.charAt(pos);\\n            if (next[c - \\'a\\'] == null) next[c - \\'a\\'] = new Trie();\\n            next[c - \\'a\\'].addWord(w, pos+1, chain);\\n        }\\n\\n        int find(String w, int pos, boolean added) {\\n            if (pos == w.length() && added) return chain;\\n\\n            int max = 0;\\n            for (int i = 0; i < 26 && !added; i++) {\\n                if (next[i] == null) continue;\\n                max = Math.max(max, next[i].find(w, pos, true));\\n            }\\n\\n            if (pos == w.length()) return max;\\n\\n            char c = w.charAt(pos);\\n            if (next[c - \\'a\\'] != null) max = Math.max(max, next[c - \\'a\\'].find(w, pos+1, added));\\n            return max;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088978,
                "title": "simple-java-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int longestStrChain(String[] words)\\n    {\\n       Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        HashMap<String, Integer> dp = new HashMap<>();\\n\\n        int maxChain = 1;\\n        \\n        for (String word : words) {\\n            int best = 0;\\n            for (int i = 0; i < word.length(); ++i) {\\n                StringBuilder temp = new StringBuilder(word);\\n                String prev = temp.deleteCharAt(i).toString();\\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\\n            }\\n            dp.put(word, best);\\n            maxChain = Math.max(maxChain, best);\\n        }\\n        \\n        return maxChain;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/4ae9f82f-a6fa-435e-8971-5104f3e398d7_1695651227.4338148.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public static int longestStrChain(String[] words)\\n    {\\n       Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        HashMap<String, Integer> dp = new HashMap<>();\\n\\n        int maxChain = 1;\\n        \\n        for (String word : words) {\\n            int best = 0;\\n            for (int i = 0; i < word.length(); ++i) {\\n                StringBuilder temp = new StringBuilder(word);\\n                String prev = temp.deleteCharAt(i).toString();\\n                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);\\n            }\\n            dp.put(word, best);\\n            maxChain = Math.max(maxChain, best);\\n        }\\n        \\n        return maxChain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152918,
                "title": "python-dp-o-16-2-n",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = defaultdict(int)\\n        for w in sorted(words,key=len):\\n            dp[w] = max( dp[w[:i]+w[i+1:]] + 1 for i in range(len(w)))\\n        return max(dp.values())",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = defaultdict(int)\\n        for w in sorted(words,key=len):\\n            dp[w] = max( dp[w[:i]+w[i+1:]] + 1 for i in range(len(w)))\\n        return max(dp.values())",
                "codeTag": "Java"
            },
            {
                "id": 1213800,
                "title": "longest-string-chain-c-commented",
                "content": "**CODE:**\\n```\\nclass Solution {\\npublic:\\n    bool isSubseq(string &s1, string &s2){\\n        // to check whether s1 is subsequence of s2\\n        int i=0,j=0;\\n        while(i<s1.length() and j<s2.length())\\n        {\\n            if(s1[i]==s2[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                j++;\\n        }\\n        return (i==s1.length());\\n    }\\n    \\n    // written a function to sort the words vector according to the length\\n    static bool bylength(string &s1, string &s2){\\n        return s1.length()<s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        sort(words.begin(), words.end(), bylength);\\n        \\n        int res=1; // since every word will form a chain of itself so when no chain forms answer would be 1\\n        int longestBeforeHere[n];  // array to store the longest chain formed before the ith point (and including it) at index i\\n        longestBeforeHere[0] = 1;  // every word forms 1 length chain\\n    \\n        for(int i=1;i<words.size();i++){\\n            int curr=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(words[i].length()==words[j].length()+1 and isSubseq(words[j],words[i])) // condition to increase chain size\\n                    curr=max(curr,longestBeforeHere[j]+1); // update the length of longest chain starting with i and before it\\n            }\\n            longestBeforeHere[i]=curr; // we store the value of curr at ith index for future use\\n            res=max(res,curr); // every time we update res by finding the final maximum value\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nDO **UPVOTE** IF YOU LIKED IT!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubseq(string &s1, string &s2){\\n        // to check whether s1 is subsequence of s2\\n        int i=0,j=0;\\n        while(i<s1.length() and j<s2.length())\\n        {\\n            if(s1[i]==s2[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                j++;\\n        }\\n        return (i==s1.length());\\n    }\\n    \\n    // written a function to sort the words vector according to the length\\n    static bool bylength(string &s1, string &s2){\\n        return s1.length()<s2.length();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        sort(words.begin(), words.end(), bylength);\\n        \\n        int res=1; // since every word will form a chain of itself so when no chain forms answer would be 1\\n        int longestBeforeHere[n];  // array to store the longest chain formed before the ith point (and including it) at index i\\n        longestBeforeHere[0] = 1;  // every word forms 1 length chain\\n    \\n        for(int i=1;i<words.size();i++){\\n            int curr=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(words[i].length()==words[j].length()+1 and isSubseq(words[j],words[i])) // condition to increase chain size\\n                    curr=max(curr,longestBeforeHere[j]+1); // update the length of longest chain starting with i and before it\\n            }\\n            longestBeforeHere[i]=curr; // we store the value of curr at ith index for future use\\n            res=max(res,curr); // every time we update res by finding the final maximum value\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428354,
                "title": "python-2-approaches-dfs-memo-dp-with-complexity-analysis",
                "content": "**1. DFS + Memo**\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def helper(memo, set, w):\\n            if w in memo: return memo[w]\\n            count = 0\\n            for i in range(len(w)):\\n                pre = w[:i] + w[i+1:]\\n                if pre in s:\\n                    count = max(count, helper(memo, s, pre))\\n            memo[w] = 1 + count\\n            return 1 + count\\n\\n        ans = 0\\n        memo = {}\\n        s = set()\\n        for w in words: s.add(w)\\n        for w in words:\\n            ans = max(ans, helper(memo, s, w))\\n        return ans\\n```\\n* Time: O(N + N * M^2), where N is length of `words` and M is the average length of each word.\\n* Space: O(N)\\n\\n**2. DP**\\n\\n**Algorithm:**\\n\\n*define a dictionary: `d = {word: longest length of its string chain}`\\n* sort the input array `words` by length\\n* For each word\\n\\t* generating its all possible predecessor (a shorter word with exactly one letter missing)\\n\\t* if one of the predecessor already exsit in the dp array, which means we already calculated the longest string chain for its precessor, we add the current word to the word chain by increament the length of the longest string chain by 1. \\n\\t* We do this for all the predecessor of the current word. i.e. we update the longest string chain of each branch (each predecessor) for the current word by adding the current word. \\n\\t*The longest string chain for current word is the maximum of the longest string chains of all branches. \\n\\n* we can find the word with the longest string chain by calling dp[-1], no, just kidding, by finding the largest value in this dictionary, which is the longest string chain existing in `words`.\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = {}\\n        for w in sorted(words, key = len):\\n            maxLen = 0\\n            for i in range(len(w)):\\n                predecessor = w[:i] + w[i+1:]\\n                maxLen = max(maxLen, dp.get(predecessor, 0) + 1)\\n            dp[w] = maxLen\\n        return max(dp.values())\\n```\\n**Complexity (Updated) :**\\n* Time: O(N log N + N * M^2 ): **<--- Correct**\\n\\t* O(NlogN) for sorting `words`.  (just sorted once and we\\'re done)\\n\\t* O(N) for looping throught the sorted array\\n\\t\\t* for each word, for all possible position `i` in this word (O(M))\\n\\t\\t\\t* forming all possible predecessor by using string slicing function [i:] and [i+1:], either of them has time cost of O(L) where L is the length of the slice, and together they cost O(M)\\n\\t* ==> O(NlogN) + O(N * M * M)  ==> O(N log N + N * M^2)\\n* Time: O(N log N * M): **<--- Incorrect**\\n\\t  O(NlogN) for sorting `words`. \\n\\t  O(M) for forming all possible predecessor for each word. \\n\\t  \\n* Space: O(N * M) sorted() function returns a newly created list which has N words in it and each word has an average length of M.\\n\\n**Takeaways:**\\n* find optimal subproblems first. \\n\\t* Find my previous word\\'s longest string chain length, the current longest string chain length of my predecessor if I was added to the chain is my predecessor\\'s longest string chain length plus 1. \\n\\t* How many predescessors do I have?  My longest string chain length is the maximum among all of my predescessors\\u2019 longest longest string chain lengths.\\n\\n* think about when to use dp array, when to use dp diction\\n\\t* dp array: \\n\\t\\t* 1D for liner data structure or optimized matrix problem\\n\\t\\t* 2D for sub-optimal matrix problem\\n\\t* dp dictionary:\\n\\t\\t* rememer when you first learn the word `whose`? Use dp array when the meaning of `whose` appied to the problem. For example, you have a element and its attributes and you want to find the optimal solution of this attribute by first finding the optimal solution of a(or many) sub-problem(s) of this element, i.e. the optimal (longest string chain) length(s) for all of its predecessor(s)\\n\\n------------\\n**Longest Increasing Subsequence:** \\n\\nIntuitively similar to other DP problems (longest increasing subsequence, etc). \\nhttps://leetcode.com/problems/longest-increasing-subsequence/discuss/429079/Python-4-Approaches%3A-Recursion-Recur-%2B-Memo-DP-DP-%2B-Binary-Search\\n\\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\\n\\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        dp = {}\\n        for i, num in enumerate(nums):\\n            maxLongest = 1\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    curLongest = dp.get(nums[j], 0) + 1\\n                    maxLongest = max(maxLongest, curLongest)\\n            dp[num] = maxLongest\\n        return max(dp.values())\\n```\\n* Time: O(N^2)\\n* Space: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def helper(memo, set, w):\\n            if w in memo: return memo[w]\\n            count = 0\\n            for i in range(len(w)):\\n                pre = w[:i] + w[i+1:]\\n                if pre in s:\\n                    count = max(count, helper(memo, s, pre))\\n            memo[w] = 1 + count\\n            return 1 + count\\n\\n        ans = 0\\n        memo = {}\\n        s = set()\\n        for w in words: s.add(w)\\n        for w in words:\\n            ans = max(ans, helper(memo, s, w))\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = {}\\n        for w in sorted(words, key = len):\\n            maxLen = 0\\n            for i in range(len(w)):\\n                predecessor = w[:i] + w[i+1:]\\n                maxLen = max(maxLen, dp.get(predecessor, 0) + 1)\\n            dp[w] = maxLen\\n        return max(dp.values())\\n```\n```\\nclass Solution:\\n    def lengthOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        dp = {}\\n        for i, num in enumerate(nums):\\n            maxLongest = 1\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    curLongest = dp.get(nums[j], 0) + 1\\n                    maxLongest = max(maxLongest, curLongest)\\n            dp[num] = maxLongest\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384701,
                "title": "1048-longest-string-chain-javascript-lee215-80ms",
                "content": "```js\\nvar longestStrChain = function(words) {\\n    let map = new Map();\\n    let res = 0;\\n    words.sort((a, b) => a.length - b.length);\\n\\n    for(let word of words){\\n        let level = 1;\\n        for(let i = 0; i < word.length; i++){\\n            let prev = word.slice(0, i) + word.slice(i + 1);\\n            if(map.has(prev)){\\n                level = map.get(prev) + 1;\\n                break;\\n            } \\n        }\\n        map.set(word, level);\\n        res = Math.max(res, level);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nvar longestStrChain = function(words) {\\n    let map = new Map();\\n    let res = 0;\\n    words.sort((a, b) => a.length - b.length);\\n\\n    for(let word of words){\\n        let level = 1;\\n        for(let i = 0; i < word.length; i++){\\n            let prev = word.slice(0, i) + word.slice(i + 1);\\n            if(map.has(prev)){\\n                level = map.get(prev) + 1;\\n                break;\\n            } \\n        }\\n        map.set(word, level);\\n        res = Math.max(res, level);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294900,
                "title": "another-kind-of-lis-problem",
                "content": "The method of processing strings is inspired by [word ladder](https://leetcode.com/problems/word-ladder/)\\nfirst we sort the words by length, then it becomes a LIS problem.\\n\\nfor example, s = \\'bca\\'\\nwe can add one letter to make it be the form of `_bca, b_ca, bc_a, bca_` (`_` represents the added letter)\\n\\nfor s = \\'bca\\', we can find last element by the form of `_ca, b_a, _ca`\\n\\n```python\\nclass Solution:\\n    def longestStrChain(self, words):\\n        words.sort(key=lambda x:len(x))\\n        d = collections.defaultdict(list)\\n        for index, word in enumerate(words):\\n            for i in range(len(word)+1):\\n                s = word[:i] + \\'_\\' + word[i:]\\n                d[s].append(index)\\n        \\n        n = len(words)\\n        dp = [1] * n\\n        for i, word in enumerate(words):\\n            for j in range(len(word)):\\n                s = word[:j] + \\'_\\' + word[j+1:]\\n                if s in d:\\n                    for index in d[s]:\\n                        if index >= i: break\\n                        dp[i] = max(dp[i], dp[index]+1)\\n        return max(dp)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestStrChain(self, words):\\n        words.sort(key=lambda x:len(x))\\n        d = collections.defaultdict(list)\\n        for index, word in enumerate(words):\\n            for i in range(len(word)+1):\\n                s = word[:i] + \\'_\\' + word[i:]\\n                d[s].append(index)\\n        \\n        n = len(words)\\n        dp = [1] * n\\n        for i, word in enumerate(words):\\n            for j in range(len(word)):\\n                s = word[:j] + \\'_\\' + word[j+1:]\\n                if s in d:\\n                    for index in d[s]:\\n                        if index >= i: break\\n                        dp[i] = max(dp[i], dp[index]+1)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078898,
                "title": "java-dynamic-programming-explanation-time-o-n-k-space-o-n-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The longest word chain problem can be solved efficiently using dynamic programming.\\n- We can sort the words by their lengths, ensuring that shorter words are processed before longer ones.\\n- For each word, we iterate through its characters and try to build word chains by removing one character at a time.\\n- We maintain a HashMap (`dp`) to store the longest chain length for each word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the `words` array by length, ensuring shorter words come first.\\n2. Initialize a HashMap `dp` to store word-to-length relationships.\\n3. Initialize `maxPath` to 1, representing the maximum chain length.\\n4. Iterate through each word in the sorted array.\\n5. For each word, iterate through its characters and create potential predecessor words by removing characters.\\n6. Calculate the current word\\'s chain length (`currLength`) by comparing it with its predecessor\\'s chain length.\\n7. Update currLength using `Math.max` to find the maximum chain length for the current word.\\n8. Store the current word and its chain length in the `dp` HashMap\\n9. Update `maxPath` if `currLength` is greater than the `current maxPath`.\\n10. After processing all words, return `maxPath` as the length of the longest word chain.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Sorting the words array takes `O(n log n)`, where n is the number of words.\\n- Iterating through the words and characters takes `O(n * k)`, where k is the average word length.\\n- Overall, the time complexity is `O(n * k + n log n)`, which simplifies to `O(n * k)`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity is `O(n)` for the dp HashMap, where `n` is the number of words.\\n- Additional space is used for variables like `maxPath`.\\n- Overall, the space complexity is `O(n)`.\\n\\n***Youtube Solution Link:***\\n\\n[https://youtu.be/HnePYVbw9Jo]()\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Step 1: Sort the words array by length.\\n        Arrays.sort(words, (String a, String b) -> a.length() - b.length());\\n\\n        // Step 2: Create a HashMap to store word-to-length relationships.\\n        Map<String, Integer> dp = new HashMap<>();\\n\\n        // Initialize the maximum path length to 1 (a single word).\\n        int maxPath = 1;\\n\\n        // Step 3: Iterate through the words.\\n        for (String word : words) {\\n            int currLength = 1; // Initialize the current word length to 1.\\n            StringBuilder sb = new StringBuilder(word);\\n\\n            // Step 4: Iterate through each character of the current word.\\n            for (int i = 0; i < word.length(); i++) {\\n                sb.deleteCharAt(i); // Remove the current character.\\n                String prevWord = sb.toString(); // Get the predecessor word.\\n\\n                // Update the current word length using dynamic programming.\\n                currLength = Math.max(currLength, dp.getOrDefault(prevWord, 0) + 1);\\n\\n                // Restore the original word for the next iteration.\\n                sb.insert(i, word.charAt(i));\\n            }\\n\\n            // Step 5: Store the current word and its calculated length in the map.\\n            dp.put(word, currLength);\\n\\n            // Update the maximum path length if necessary.\\n            maxPath = Math.max(maxPath, currLength);\\n        }\\n\\n        // Step 6: Return the maximum path length.\\n        return maxPath;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Step 1: Sort the words array by length.\\n        Arrays.sort(words, (String a, String b) -> a.length() - b.length());\\n\\n        // Step 2: Create a HashMap to store word-to-length relationships.\\n        Map<String, Integer> dp = new HashMap<>();\\n\\n        // Initialize the maximum path length to 1 (a single word).\\n        int maxPath = 1;\\n\\n        // Step 3: Iterate through the words.\\n        for (String word : words) {\\n            int currLength = 1; // Initialize the current word length to 1.\\n            StringBuilder sb = new StringBuilder(word);\\n\\n            // Step 4: Iterate through each character of the current word.\\n            for (int i = 0; i < word.length(); i++) {\\n                sb.deleteCharAt(i); // Remove the current character.\\n                String prevWord = sb.toString(); // Get the predecessor word.\\n\\n                // Update the current word length using dynamic programming.\\n                currLength = Math.max(currLength, dp.getOrDefault(prevWord, 0) + 1);\\n\\n                // Restore the original word for the next iteration.\\n                sb.insert(i, word.charAt(i));\\n            }\\n\\n            // Step 5: Store the current word and its calculated length in the map.\\n            dp.put(word, currLength);\\n\\n            // Update the maximum path length if necessary.\\n            maxPath = Math.max(maxPath, currLength);\\n        }\\n\\n        // Step 6: Return the maximum path length.\\n        return maxPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078838,
                "title": "easy-to-understand-memoization-solution-beginner-friendly-explanation",
                "content": "![Screenshot 2023-09-23 085712.png](https://assets.leetcode.com/users/images/980754f8-f5fa-4fe8-ba39-1a7a80353b8b_1695439652.8564568.png)\\n# Intuition\\nInstead of Additive approach (i.e., add characters one by one), we will try to do Subtractive approach (take the larger word and remove one)\\n\\n# Approach\\nIt explores word chains by removing one character at a time, checking if the resulting word is in the list, and stores computed results to avoid redundant calculations.\\n\\n# Complexity\\n- Time complexity:\\nWorst Case : $$O(n*m^2)$$\\nBest Case : $$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int length(string word, unordered_set<string>& s, unordered_map<string, int>& mp) {\\n        if (word.length() == 0) // checking if the word is \"\" i.e., empty string\\n            return 0;\\n        if (mp.find(word) != mp.end()) //Memoization using Map\\n            return mp[word];\\n        int answer = 0;\\n\\n        //Removing all characters of the word one by one\\n        for (int i = 0; i < word.length(); i++) {\\n            string aux = word.substr(0, i) + word.substr(i + 1);\\n            //Removing character\\n            //ex - abcd --> aux =  abcd.substr(0, 0)+abcd.substr(1) -- \"\" + \"bcd\" = \"bcd\"\\n            if (s.find(aux) != s.end())\\n                answer = max(answer, 1 + length(aux, s, mp)); // Calling the function with the word with Removed character\\n        }\\n        mp[word] = answer;\\n        return answer;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        unordered_set<string> s;\\n        for (string x : words)\\n            s.insert(x);\\n        int ans = 0;\\n\\n        unordered_map<string, int> mp;\\n        // Checking for each word, taking it as last word.\\n        for (int i = 0; i < words.size(); i++) {\\n            string w = words[i];\\n            ans = max(ans, length(w, s, mp));\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(string word, unordered_set<string>& s, unordered_map<string, int>& mp) {\\n        if (word.length() == 0) // checking if the word is \"\" i.e., empty string\\n            return 0;\\n        if (mp.find(word) != mp.end()) //Memoization using Map\\n            return mp[word];\\n        int answer = 0;\\n\\n        //Removing all characters of the word one by one\\n        for (int i = 0; i < word.length(); i++) {\\n            string aux = word.substr(0, i) + word.substr(i + 1);\\n            //Removing character\\n            //ex - abcd --> aux =  abcd.substr(0, 0)+abcd.substr(1) -- \"\" + \"bcd\" = \"bcd\"\\n            if (s.find(aux) != s.end())\\n                answer = max(answer, 1 + length(aux, s, mp)); // Calling the function with the word with Removed character\\n        }\\n        mp[word] = answer;\\n        return answer;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        unordered_set<string> s;\\n        for (string x : words)\\n            s.insert(x);\\n        int ans = 0;\\n\\n        unordered_map<string, int> mp;\\n        // Checking for each word, taking it as last word.\\n        for (int i = 0; i < words.size(); i++) {\\n            string w = words[i];\\n            ans = max(ans, length(w, s, mp));\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276413,
                "title": "c-easy-solution-dp-memoization-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//by dp and memorization\\n//tc=o(n*n) n=size of words\\n//sc=o(n*n)+o(n) n=stack space \\nint dp[1001][1001];\\n   \\n    bool cheak(string &s1,string &s2)\\n    {\\n        if(s1.size()==s2.size())  return false;\\n        if(s1.size()>s2.size()+1) return false;\\n         int i=0;\\n         int j=0;\\n        while(i<s1.size())\\n            if(j<s2.size() && s1[i]==s2[j])\\n                i++,j++;\\n            else\\n                i++;\\n        if(i==s1.size() && j==s2.size())\\n            return true;\\n        else\\n            return false;\\n    }\\n    int find(int i,int pre,vector<string>& words){\\n        if(i==-1){\\n            return 0;\\n        }\\n        if(dp[i][pre+1]!=-1){\\n            return dp[i][pre+1];\\n        }\\n        //take\\n        int take=0,not_take=0;\\n        if(pre==-1 || cheak(words[pre],words[i])==true){\\n            take=1+find(i-1,i,words);\\n        }\\n        //not take\\n        not_take=find(i-1,pre,words);\\n        return dp[i][pre+1]=max(take,not_take);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        memset(dp,-1,sizeof(dp));\\n        sort(words.begin(),words.end(),com);\\n        return find(n-1,-1,words);\\n    }\\n    private:\\n    static bool com(string& a,string& b){\\n        return a.size()<b.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//by dp and memorization\\n//tc=o(n*n) n=size of words\\n//sc=o(n*n)+o(n) n=stack space \\nint dp[1001][1001];\\n   \\n    bool cheak(string &s1,string &s2)\\n    {\\n        if(s1.size()==s2.size())  return false;\\n        if(s1.size()>s2.size()+1) return false;\\n         int i=0;\\n         int j=0;\\n        while(i<s1.size())\\n            if(j<s2.size() && s1[i]==s2[j])\\n                i++,j++;\\n            else\\n                i++;\\n        if(i==s1.size() && j==s2.size())\\n            return true;\\n        else\\n            return false;\\n    }\\n    int find(int i,int pre,vector<string>& words){\\n        if(i==-1){\\n            return 0;\\n        }\\n        if(dp[i][pre+1]!=-1){\\n            return dp[i][pre+1];\\n        }\\n        //take\\n        int take=0,not_take=0;\\n        if(pre==-1 || cheak(words[pre],words[i])==true){\\n            take=1+find(i-1,i,words);\\n        }\\n        //not take\\n        not_take=find(i-1,pre,words);\\n        return dp[i][pre+1]=max(take,not_take);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        memset(dp,-1,sizeof(dp));\\n        sort(words.begin(),words.end(),com);\\n        return find(n-1,-1,words);\\n    }\\n    private:\\n    static bool com(string& a,string& b){\\n        return a.size()<b.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661012,
                "title": "python-99-faster-88-less-memory",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        def one():\\n            return 1\\n        \\n        d = defaultdict(set)\\n        for w in words:\\n            d[len(w)].add(w)\\n        mi, ma = min(d.keys()), max(d.keys())\\n        m = defaultdict(one)\\n    \\n        for i in range(mi,ma):\\n            for nw in d[i+1]:\\n                for j in range(len(nw)):\\n                    w = nw[:j]+nw[j+1:]\\n                    if w in d[i]:\\n                        m[nw]  = max(m[nw], m[w]+1)\\n        return 1 if len(m) == 0 else max(m.values())\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        def one():\\n            return 1\\n        \\n        d = defaultdict(set)\\n        for w in words:\\n            d[len(w)].add(w)\\n        mi, ma = min(d.keys()), max(d.keys())\\n        m = defaultdict(one)\\n    \\n        for i in range(mi,ma):\\n            for nw in d[i+1]:\\n                for j in range(len(nw)):\\n                    w = nw[:j]+nw[j+1:]\\n                    if w in d[i]:\\n                        m[nw]  = max(m[nw], m[w]+1)\\n        return 1 if len(m) == 0 else max(m.values())\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2299864,
                "title": "java-solution-dp-based-on-longest-increasing-subsequence",
                "content": "The solution is same as Longest Increasing Subsequence Problem.\\nThe only change is in \\'if\\' statement\\n```\\nclass SortbyLen implements Comparator<String> { \\n    public int compare(String a, String b) \\n    { \\n        return a.length() - b.length(); \\n    } \\n} \\n\\nclass Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr, new SortbyLen()); \\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        int maxi = 1;\\n        Arrays.fill(dp , 1);\\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = 0 ; j < i ; j++){\\n                if(compare(arr[i] , arr[j]) && dp[j] + 1 > dp[i])\\n                    dp[i] = dp[j] + 1;\\n            }\\n            if(dp[i] > maxi)\\n                maxi = dp[i];\\n        }\\n        return maxi;  \\n    }\\n    \\n    boolean compare(String s1 , String s2){\\n        int l1 = s1.length();\\n        int l2 = s2.length();\\n        \\n        if(l1 != l2+1)\\n            return false;\\n        \\n        int f = 0;\\n        int s = 0;\\n        while(f < l1)\\n        {\\n            if(s < l2 && s1.charAt(f) == s2.charAt(s)){\\n                f = f+1;\\n                s = s+1;\\n            }\\n            else\\n                f = f+1;\\n        }\\n        \\n        if(f == l1 && s == l2)\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```\\nIf you like the solution,  then please UPVOTE :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass SortbyLen implements Comparator<String> { \\n    public int compare(String a, String b) \\n    { \\n        return a.length() - b.length(); \\n    } \\n} \\n\\nclass Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr, new SortbyLen()); \\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        int maxi = 1;\\n        Arrays.fill(dp , 1);\\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = 0 ; j < i ; j++){\\n                if(compare(arr[i] , arr[j]) && dp[j] + 1 > dp[i])\\n                    dp[i] = dp[j] + 1;\\n            }\\n            if(dp[i] > maxi)\\n                maxi = dp[i];\\n        }\\n        return maxi;  \\n    }\\n    \\n    boolean compare(String s1 , String s2){\\n        int l1 = s1.length();\\n        int l2 = s2.length();\\n        \\n        if(l1 != l2+1)\\n            return false;\\n        \\n        int f = 0;\\n        int s = 0;\\n        while(f < l1)\\n        {\\n            if(s < l2 && s1.charAt(f) == s2.charAt(s)){\\n                f = f+1;\\n                s = s+1;\\n            }\\n            else\\n                f = f+1;\\n        }\\n        \\n        if(f == l1 && s == l2)\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154197,
                "title": "c-easy-to-understand-well-explained-dp-daily-leetcoding-challenge-june-day-15",
                "content": "**Please Upvote If It Helps \\uD83D\\uDE0A\\u2764\\uFE0F**\\n\\n**Example-1:**\\n\\n```\\nwords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\nBefore any step we need to sort vector \\'words\\' on the basis of size of the string.\\nNow we cover we word in the vector one-by-one.\\n\\n1) word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n2) word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n3) word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\nHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n4) word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n5) word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n6) word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4 which is the answer.\\n```\\n\\n```\\nclass Solution {\\npublic:  \\n    // do compariosn based on size\\n    static bool compare(string s1, string s2)\\n    {\\n        return s1.size()<s2.size();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) \\n    {\\n        //it will store predecessor word and their chain size\\n        unordered_map<string, int> dp; \\n        \\n        //sort(words.begin(), words.end() based of the word size\\n        sort(words.begin(), words.end(), compare);\\n        \\n        // initially word chain size will be 1\\n        int len = 1; \\n        \\n        for(auto word:words)           // iterate over the given words \\n        {\\n            dp[word]=1;\\n            \\n            // check for the characters of current word\\n            for(int i=0; i<word.length(); i++) \\n            {\\n                //removing ith alphabet from the string and check remaining string is available in the dp \\n                string pred = word.substr(0,i) + word.substr(i+1); \\n                \\n                // if it is available in dp then take that max len and go for next\\n                if(dp.find(pred) != dp.end()) \\n                {\\n                    dp[word] = dp[pred]+1;                // updated\\n                    len = max(len, dp[word]);             // storing max one\\n                }\\n            }\\n        }\\n        return len;    \\n    }\\n};\\n```\\n\\n\\n**Time Complexity:** O(Nlog(N) + NMM)\\nO(Nlog(N)) for **sorting**\\nO(NMM): N for 1st loop, M for inner loop and M for string concatenation.\\n\\n**Space Complexity:** O(N) for both storing strings in hashmap.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nwords = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\nBefore any step we need to sort vector \\'words\\' on the basis of size of the string.\\nNow we cover we word in the vector one-by-one.\\n\\n1) word = \"a\", prev = \"\", dp = {\"a\": 1}; It means that ending with \"a\", the max size of chain is 1.\\n2) word = \"b\", prev = \"\", dp = {\"a\": 1, \"b\": 1}; It means that ending with \"b\", the max size of chain is 1.\\n3) word = \"ba\", prev = \"a\" or \"b\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2}; It means that ending with \"ba\", the max size of chain is 2.\\nHere, both \"a\" and \"b\" can be the predecessor. We are interested only in length not the actual chain!\\n4) word = \"bca\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3}; It means that ending with \"bca\", the max size of chain is 3.\\n5) word = \"bda\", prev = \"ba\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3}; It means that ending with \"bda\", the max size of chain is 3.\\n6) word = \"bdca\", prev = \"bda\" or \"bca\", dp = {\"a\": 1, \"b\": 1, \"ba\": 2, \"bca\":3, \"bda\": 3, \"bdca\": 4}; It means that ending with \"bdca\", the max size of chain is 4 which is the answer.\\n```\n```\\nclass Solution {\\npublic:  \\n    // do compariosn based on size\\n    static bool compare(string s1, string s2)\\n    {\\n        return s1.size()<s2.size();\\n    }\\n    \\n    int longestStrChain(vector<string>& words) \\n    {\\n        //it will store predecessor word and their chain size\\n        unordered_map<string, int> dp; \\n        \\n        //sort(words.begin(), words.end() based of the word size\\n        sort(words.begin(), words.end(), compare);\\n        \\n        // initially word chain size will be 1\\n        int len = 1; \\n        \\n        for(auto word:words)           // iterate over the given words \\n        {\\n            dp[word]=1;\\n            \\n            // check for the characters of current word\\n            for(int i=0; i<word.length(); i++) \\n            {\\n                //removing ith alphabet from the string and check remaining string is available in the dp \\n                string pred = word.substr(0,i) + word.substr(i+1); \\n                \\n                // if it is available in dp then take that max len and go for next\\n                if(dp.find(pred) != dp.end()) \\n                {\\n                    dp[word] = dp[pred]+1;                // updated\\n                    len = max(len, dp[word]);             // storing max one\\n                }\\n            }\\n        }\\n        return len;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153514,
                "title": "c-clean-top-down-linq",
                "content": "```\\npublic class Solution\\n{\\n    public int LongestStrChain(string[] words)\\n    {\\n        HashSet<string> wordsAsHashSet = words.ToHashSet();\\n        Dictionary<string, int> dp = new();\\n        return words.Max(GetLongestChain);\\n\\n        int GetLongestChain(string word)\\n        {\\n            int longestChain = 0;\\n            for (int index = 0; index < word.Length; index++)\\n            {\\n                string predecessor = word[..index] + word[(index + 1)..];\\n                if (wordsAsHashSet.Contains(predecessor) is false) continue;\\n\\n                int chain = dp.ContainsKey(predecessor)\\n                    ? dp[predecessor]\\n                    : dp[predecessor] = GetLongestChain(predecessor);\\n\\n                if (chain > longestChain) longestChain = chain;\\n            }\\n\\n            return 1 + longestChain;\\n        }\\n    }\\n}\\n```\\n\\nWith LINQ\\n```\\npublic class Solution\\n{\\n    public int LongestStrChain(string[] words)\\n    {\\n        HashSet<string> wordsAsHashSet = words.ToHashSet();\\n        Dictionary<string, int> dp = new();\\n        return words.Max(GetLongestChain);\\n\\n        int GetLongestChain(string word)\\n            => 1 + Enumerable.Range(0, word.Length)\\n                    .Select(index => word[..index] + word[(index + 1)..])\\n                    .Where(predecessor => wordsAsHashSet.Contains(predecessor))\\n                    .Select(predecessor => dp.ContainsKey(predecessor) ? dp[predecessor] : dp[predecessor] = GetLongestChain(predecessor))\\n                    .Append(0)\\n                    .Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int LongestStrChain(string[] words)\\n    {\\n        HashSet<string> wordsAsHashSet = words.ToHashSet();\\n        Dictionary<string, int> dp = new();\\n        return words.Max(GetLongestChain);\\n\\n        int GetLongestChain(string word)\\n        {\\n            int longestChain = 0;\\n            for (int index = 0; index < word.Length; index++)\\n            {\\n                string predecessor = word[..index] + word[(index + 1)..];\\n                if (wordsAsHashSet.Contains(predecessor) is false) continue;\\n\\n                int chain = dp.ContainsKey(predecessor)\\n                    ? dp[predecessor]\\n                    : dp[predecessor] = GetLongestChain(predecessor);\\n\\n                if (chain > longestChain) longestChain = chain;\\n            }\\n\\n            return 1 + longestChain;\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int LongestStrChain(string[] words)\\n    {\\n        HashSet<string> wordsAsHashSet = words.ToHashSet();\\n        Dictionary<string, int> dp = new();\\n        return words.Max(GetLongestChain);\\n\\n        int GetLongestChain(string word)\\n            => 1 + Enumerable.Range(0, word.Length)\\n                    .Select(index => word[..index] + word[(index + 1)..])\\n                    .Where(predecessor => wordsAsHashSet.Contains(predecessor))\\n                    .Select(predecessor => dp.ContainsKey(predecessor) ? dp[predecessor] : dp[predecessor] = GetLongestChain(predecessor))\\n                    .Append(0)\\n                    .Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666395,
                "title": "python3",
                "content": "class Solution:\\n\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=lambda x: len(x))\\n        result=0\\n        mem={}\\n        for word in words:\\n            mem[word]=1\\n            for i in range(len(word)):\\n                trunc=word[:i]+word[i+1:]\\n                if trunc in mem:\\n                    mem[word]=max(mem[word],1+mem[trunc])\\n            result=max(result,mem[word])\\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=lambda x: len(x))\\n        result=0\\n        mem={}",
                "codeTag": "Java"
            },
            {
                "id": 1645553,
                "title": "java-dp-2-approaches-lis-memoization",
                "content": "**Solution 1 : Using Tabulation (LIS)**\\n\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n        // Sort the words in the ascending order of their length\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());        \\n        int n = words.length;\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        int max = 1;\\n        \\n        // Perform LIS\\n        for(int i=1; i < n; i++){\\n            dp[i] = 1;\\n            String currWord = words[i];\\n            for(int j=0; j < i; j++){\\n                String prevWord = words[j];\\n                // If curr word is of 1 length greater than prev word &&\\n                // LCS between curr and prev words is having length same as prev word\\n                // then we have a string chain of prev and curr word\\n                if((currWord.length() - prevWord.length() == 1) && \\n                   (prevWord.length() == lcs(prevWord, currWord)))\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }\\n\\n    int lcs(String prev, String curr){\\n        int p = prev.length();\\n        int c = curr.length();\\n        int i=0, j=0;\\n        while(i < p && j < c){\\n            if(prev.charAt(i) == curr.charAt(j))\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }    \\n}\\n```\\n\\n<br/>\\n\\n**Solution 2: Using memoization**\\n\\n```\\nclass Solution {\\n    \\n    Map<Integer, List<String>> wordsListMap = new HashMap<>();\\n    \\n    public int longestStrChain(String[] words) {\\n        // Sort words[] by length\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        \\n\\t\\t// Keep track of all words on a particular length\\n        Map<String,Integer> map = new HashMap<>();\\n        for(String word : words){\\n            int len = word.length();\\n            wordsListMap.putIfAbsent(len, new ArrayList<>());\\n            wordsListMap.get(len).add(word);\\n        }\\n        \\n        int globalMax = 1;\\n\\t\\t\\n\\t\\t// Consider each word as the starting word of the longest sequence and find the max possible sequence for each.\\n\\t\\t// At the end update the globalMax, if the current longest sequence is greater than globalMax\\n        for(String word : words)\\n            globalMax = Math.max(globalMax, longest(word, map));\\n        return globalMax;\\n    }\\n    \\n    int longest(String word, Map<String,Integer> dp){\\n\\t\\t// If there are no words of length greater than current word length, \\n\\t\\t// then the maximum possible sequence for the current word is the current word itself, hence it is returning 1\\n        if(!wordsListMap.containsKey(word.length() + 1)) \\n            return 1;\\n        \\n        if(dp.containsKey(word))\\n            return dp.get(word);\\n        \\n\\t\\t// Fetch all words that are greater than 1 character and check if it is a successor then explore further\\n        List<String> words = wordsListMap.get(word.length() + 1);\\n        int max = 0;\\n        for(String curr : words){\\n            if(isSuccessor(word, curr))\\n                max = Math.max(max, longest(curr, dp));\\n        }\\n        \\n        dp.put(word, max + 1);\\n        return dp.get(word);\\n    }\\n    \\n    boolean isSuccessor(String word1, String word2){\\n        boolean firstTime = true;\\n        for(int i=0, j=0; i < word1.length() && j < word2.length(); j++){\\n            if(word1.charAt(i) != word2.charAt(j)) {\\n                if(firstTime){\\n                    firstTime = false;\\n                    continue;\\n                } else\\n                    return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n        // Sort the words in the ascending order of their length\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());        \\n        int n = words.length;\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        int max = 1;\\n        \\n        // Perform LIS\\n        for(int i=1; i < n; i++){\\n            dp[i] = 1;\\n            String currWord = words[i];\\n            for(int j=0; j < i; j++){\\n                String prevWord = words[j];\\n                // If curr word is of 1 length greater than prev word &&\\n                // LCS between curr and prev words is having length same as prev word\\n                // then we have a string chain of prev and curr word\\n                if((currWord.length() - prevWord.length() == 1) && \\n                   (prevWord.length() == lcs(prevWord, currWord)))\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }\\n\\n    int lcs(String prev, String curr){\\n        int p = prev.length();\\n        int c = curr.length();\\n        int i=0, j=0;\\n        while(i < p && j < c){\\n            if(prev.charAt(i) == curr.charAt(j))\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }    \\n}\\n```\n```\\nclass Solution {\\n    \\n    Map<Integer, List<String>> wordsListMap = new HashMap<>();\\n    \\n    public int longestStrChain(String[] words) {\\n        // Sort words[] by length\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        \\n\\t\\t// Keep track of all words on a particular length\\n        Map<String,Integer> map = new HashMap<>();\\n        for(String word : words){\\n            int len = word.length();\\n            wordsListMap.putIfAbsent(len, new ArrayList<>());\\n            wordsListMap.get(len).add(word);\\n        }\\n        \\n        int globalMax = 1;\\n\\t\\t\\n\\t\\t// Consider each word as the starting word of the longest sequence and find the max possible sequence for each.\\n\\t\\t// At the end update the globalMax, if the current longest sequence is greater than globalMax\\n        for(String word : words)\\n            globalMax = Math.max(globalMax, longest(word, map));\\n        return globalMax;\\n    }\\n    \\n    int longest(String word, Map<String,Integer> dp){\\n\\t\\t// If there are no words of length greater than current word length, \\n\\t\\t// then the maximum possible sequence for the current word is the current word itself, hence it is returning 1\\n        if(!wordsListMap.containsKey(word.length() + 1)) \\n            return 1;\\n        \\n        if(dp.containsKey(word))\\n            return dp.get(word);\\n        \\n\\t\\t// Fetch all words that are greater than 1 character and check if it is a successor then explore further\\n        List<String> words = wordsListMap.get(word.length() + 1);\\n        int max = 0;\\n        for(String curr : words){\\n            if(isSuccessor(word, curr))\\n                max = Math.max(max, longest(curr, dp));\\n        }\\n        \\n        dp.put(word, max + 1);\\n        return dp.get(word);\\n    }\\n    \\n    boolean isSuccessor(String word1, String word2){\\n        boolean firstTime = true;\\n        for(int i=0, j=0; i < word1.length() && j < word2.length(); j++){\\n            if(word1.charAt(i) != word2.charAt(j)) {\\n                if(firstTime){\\n                    firstTime = false;\\n                    continue;\\n                } else\\n                    return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540030,
                "title": "c-dfs-dp-explained-with-diagrams",
                "content": "Created a map of length and corrosponding strings then iterated over all the strings and for **i**`th`  string tries to find its correct successor in the map of **length**  for `size = string.size() + 1`\\nand then it does a dfs repeating above step and ofc memoizes the sub problem while doing DFS \\n![image](https://assets.leetcode.com/users/images/a8b228d4-2cd4-4d2f-85b4-41a3b72037c8_1635165375.3149137.png)\\n![image](https://assets.leetcode.com/users/images/1e1f565a-2eff-42fe-8557-dc7343774cfe_1635166371.457233.png)![image](https://assets.leetcode.com/users/images/9c23c0f5-93f2-497b-bf68-8e23a21fa493_1635166774.0857623.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string , int> dp;\\n    unordered_map<int , vector<string>> length;\\n    int maxi = INT_MIN;\\n    \\n    bool check(string curr , string tocheck){\\n        int error=0,i=0,j=0;\\n        while(i < curr.length() && j < tocheck.length()){\\n            while(i < curr.length() && j < tocheck.length() &&curr[i] != tocheck[j]){\\n                error++;\\n                j++;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if(error == 1  || error == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(string curr , int tofind){\\n        \\n        int val=0;\\n         if(length.find(tofind) != length.end()){\\n            for(auto x : length[tofind]){\\n                if(check(curr , x)){\\n                    if(dp[x] > 1){\\n                    return dp[curr] += dp[x];\\n                   }\\n                    val = max(dfs(x , x.size()+1) , val);\\n                }\\n            }\\n         }\\n        return  dp[curr] += val;\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        \\n        sort(words.begin(), words.end(), [](const string &x, const string &y) {\\n            return x.size() < y.size();  \\n        });\\n        \\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            length[words[i].length()].push_back(words[i]);\\n            if(dp[words[i]] == 0){\\n                dp[words[i]] = 1;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(dp[words[i]] == 1){\\n                dfs(words[i] , words[i].size() + 1);\\n                maxi = max(dp[words[i]] , maxi);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string , int> dp;\\n    unordered_map<int , vector<string>> length;\\n    int maxi = INT_MIN;\\n    \\n    bool check(string curr , string tocheck){\\n        int error=0,i=0,j=0;\\n        while(i < curr.length() && j < tocheck.length()){\\n            while(i < curr.length() && j < tocheck.length() &&curr[i] != tocheck[j]){\\n                error++;\\n                j++;\\n            }\\n            i++;\\n            j++;\\n        }\\n        if(error == 1  || error == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(string curr , int tofind){\\n        \\n        int val=0;\\n         if(length.find(tofind) != length.end()){\\n            for(auto x : length[tofind]){\\n                if(check(curr , x)){\\n                    if(dp[x] > 1){\\n                    return dp[curr] += dp[x];\\n                   }\\n                    val = max(dfs(x , x.size()+1) , val);\\n                }\\n            }\\n         }\\n        return  dp[curr] += val;\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        \\n        sort(words.begin(), words.end(), [](const string &x, const string &y) {\\n            return x.size() < y.size();  \\n        });\\n        \\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            length[words[i].length()].push_back(words[i]);\\n            if(dp[words[i]] == 0){\\n                dp[words[i]] = 1;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(dp[words[i]] == 1){\\n                dfs(words[i] , words[i].size() + 1);\\n                maxi = max(dp[words[i]] , maxi);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214748,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        \\n        if(words == null || words.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(words, (w1, w2) => w1.Length - w2.Length);\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n        int maxLen = 0;\\n        foreach(var word in words)\\n        {     \\n            if(!dic.ContainsKey(word))\\n            {\\n                int currLen = 1;\\n                for(int i = 0; i < word.Length; i++)\\n                {\\n                    StringBuilder sb = new StringBuilder(word); \\n                    sb.Remove(i,1);\\n                    string modifiedWord = sb.ToString();\\n                    int modifiedLen = dic.ContainsKey(modifiedWord)? dic[modifiedWord] + 1 : 1;\\n                    currLen = Math.Max(currLen, modifiedLen);\\n                }\\n\\n                dic.Add(word,currLen);\\n                maxLen = Math.Max(maxLen, currLen);\\n            }     \\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        \\n        if(words == null || words.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(words, (w1, w2) => w1.Length - w2.Length);\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n        int maxLen = 0;\\n        foreach(var word in words)\\n        {     \\n            if(!dic.ContainsKey(word))\\n            {\\n                int currLen = 1;\\n                for(int i = 0; i < word.Length; i++)\\n                {\\n                    StringBuilder sb = new StringBuilder(word); \\n                    sb.Remove(i,1);\\n                    string modifiedWord = sb.ToString();\\n                    int modifiedLen = dic.ContainsKey(modifiedWord)? dic[modifiedWord] + 1 : 1;\\n                    currLen = Math.Max(currLen, modifiedLen);\\n                }\\n\\n                dic.Add(word,currLen);\\n                maxLen = Math.Max(maxLen, currLen);\\n            }     \\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213783,
                "title": "longest-string-chain-c-explanation-with-pictures",
                "content": "**Explanation:**\\n\\n***Intuition:***\\nFirst thing that comes to our mind is to take every string and try to place character (\\'a\\' to \\'z\\') in the string at different position and check if the string formed by concatenating one character is present in given array or not.\\nIf its present then we can say we have found chain of 2 strings.\\n\\nBut the above approach takes more time and also we are unnecessarily generating redundant strings in between.\\n\\nLet us look at two things:\\n1) Can we optimise above approach.\\n2) How to have relationship between two different strings(How to know whether two strings are part of chain or not).\\n\\n***Thinking in terms of graph***\\nAs of now, we are sure that there should be some linking between two strings if they are part of chain, right!!\\nNext step is to identify how we can link two strings.\\n\\nLet us take an example:\\n[\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\\n\\nconsider string \"bca\"\\nNow try to remove only one character at each step :\\n1) delete b from bca then bca ----> ca (check if ca is present in the given array? NO)\\n2) delete c from bca then bca ----> ba (check is ba is present in the given array? YES)\\n\\tif it is present then link bca--->ba or ba-->bca (it doesn\\'t matter)\\nsimilarly we can link different string with each other.\\nlet us see in below image all the relationship between different strings.\\n\\n![image](https://assets.leetcode.com/users/images/15d6221f-8521-49f0-aee5-11b208686c20_1621245658.2108808.jpeg)\\n\\nAs we can clearly see, it is graph of strings where string is vertex.\\n\\nNow the main step is to identify how far we can go from each Vertex.(That we can easily do using DFS).\\n\\n**Note:** Single Vertex will be considered as chain of 1 string.\\n\\n\\n**Code: C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<int> maxChain;\\n    \\n    int getMaxChain(int src)\\n    {\\n        if(maxChain[src]>0)\\n            return maxChain[src];\\n        maxChain[src]=1;\\n        for(auto child:graph[src])\\n        {\\n            maxChain[src]=max(maxChain[src],1+getMaxChain(child));\\n        }\\n        return maxChain[src];\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]=i;\\n        }\\n        graph.clear();\\n        maxChain.clear();\\n        graph.resize(n);\\n        maxChain.resize(n);\\n        \\n        for(int i=0;i<size(words);i++)\\n        {\\n            string currentString=words[i];\\n            for(int j=0;j<size(currentString);j++)\\n            {\\n                string removeOneCharacter = currentString.substr(0,j)+currentString.substr(j+1);\\n                if(!mp.count(removeOneCharacter))\\n                {\\n                    continue;\\n                }\\n                graph[i].push_back(mp[removeOneCharacter]);\\n            }\\n        }\\n        int maximumChain = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maximumChain = max(maximumChain,getMaxChain(i));\\n        }\\n        return maximumChain;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<int> maxChain;\\n    \\n    int getMaxChain(int src)\\n    {\\n        if(maxChain[src]>0)\\n            return maxChain[src];\\n        maxChain[src]=1;\\n        for(auto child:graph[src])\\n        {\\n            maxChain[src]=max(maxChain[src],1+getMaxChain(child));\\n        }\\n        return maxChain[src];\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]=i;\\n        }\\n        graph.clear();\\n        maxChain.clear();\\n        graph.resize(n);\\n        maxChain.resize(n);\\n        \\n        for(int i=0;i<size(words);i++)\\n        {\\n            string currentString=words[i];\\n            for(int j=0;j<size(currentString);j++)\\n            {\\n                string removeOneCharacter = currentString.substr(0,j)+currentString.substr(j+1);\\n                if(!mp.count(removeOneCharacter))\\n                {\\n                    continue;\\n                }\\n                graph[i].push_back(mp[removeOneCharacter]);\\n            }\\n        }\\n        int maximumChain = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maximumChain = max(maximumChain,getMaxChain(i));\\n        }\\n        return maximumChain;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013746,
                "title": "python3-dp",
                "content": "**Algo**\\nScan through `words` and for each word, remove a letter to get a `key` and check if it has been seen before. If so, 1 + its length becomes a candidate of the string chain ending at the current word. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        seen = {}\\n        for word in sorted(words, key=len): \\n            seen[word] = 1\\n            for i in range(len(word)): \\n                key = word[:i] + word[i+1:]\\n                if key in seen: \\n                    seen[word] = max(seen[word], 1 + seen[key])\\n        return max(seen.values())\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        seen = {}\\n        for word in sorted(words, key=len): \\n            seen[word] = 1\\n            for i in range(len(word)): \\n                key = word[:i] + word[i+1:]\\n                if key in seen: \\n                    seen[word] = max(seen[word], 1 + seen[key])\\n        return max(seen.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558552,
                "title": "dynamic-programming-solution-without-sorting",
                "content": "### Solution\\nHave two maps \\n1. Map of string size and set of string of that size\\n2. Map of each string and the longest chain formed till that string\\n\\nStart loop from the size = lowestWordSize+1. \\nFor every word is current size, check if the setOfStrings with size-1 has a chain word\\nIf yes, update lenTillCurrentWord = 1 + lenTillClippedWord\\n\\nReturn max of lenTillCurrentWord\\n\\n##### Time Complexity = O(N*S*S)\\n##### Space Complexity = O(N*S)\\n\\n```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int maxChainSize = 1;\\n        int startSize = Integer.MAX_VALUE;\\n        Map<Integer, Set<String>> sizeMap = new HashMap<>();\\n        Map<String, Integer> sizeTillStringMap = new HashMap<>();\\n        \\n        for (String word: words){\\n            int size = word.length();\\n            startSize = Math.min(startSize, size);\\n            \\n            Set<String> setOfStrings = sizeMap.getOrDefault(size, new HashSet<>());\\n            setOfStrings.add(word);\\n            sizeMap.put(size, setOfStrings);\\n        }\\n        \\n        while(sizeMap.containsKey(++startSize)){\\n            Set<String> prevListOfStrings = sizeMap.get(startSize-1);\\n            for (String word: sizeMap.get(startSize)){\\n                int maxLen = 1;\\n                for (int i=0; i<word.length(); i++){\\n                    String clippedWord = word.substring(0, i) + word.substring(i+1, word.length());\\n                    if (prevListOfStrings.contains(clippedWord)){\\n                        maxLen = Math.max(maxLen, sizeTillStringMap.getOrDefault(clippedWord,1) + 1);\\n                    }\\n                }\\n                sizeTillStringMap.put(word, maxLen);\\n                maxChainSize = Math.max(maxChainSize, maxLen);\\n            }\\n        }\\n        \\n        return maxChainSize;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int maxChainSize = 1;\\n        int startSize = Integer.MAX_VALUE;\\n        Map<Integer, Set<String>> sizeMap = new HashMap<>();\\n        Map<String, Integer> sizeTillStringMap = new HashMap<>();\\n        \\n        for (String word: words){\\n            int size = word.length();\\n            startSize = Math.min(startSize, size);\\n            \\n            Set<String> setOfStrings = sizeMap.getOrDefault(size, new HashSet<>());\\n            setOfStrings.add(word);\\n            sizeMap.put(size, setOfStrings);\\n        }\\n        \\n        while(sizeMap.containsKey(++startSize)){\\n            Set<String> prevListOfStrings = sizeMap.get(startSize-1);\\n            for (String word: sizeMap.get(startSize)){\\n                int maxLen = 1;\\n                for (int i=0; i<word.length(); i++){\\n                    String clippedWord = word.substring(0, i) + word.substring(i+1, word.length());\\n                    if (prevListOfStrings.contains(clippedWord)){\\n                        maxLen = Math.max(maxLen, sizeTillStringMap.getOrDefault(clippedWord,1) + 1);\\n                    }\\n                }\\n                sizeTillStringMap.put(word, maxLen);\\n                maxChainSize = Math.max(maxChainSize, maxLen);\\n            }\\n        }\\n        \\n        return maxChainSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533530,
                "title": "simple-solution-with-explanation-o-n-log-n-n-w-time-and-space-python",
                "content": "The problem asks us to find the longest chain of strings.  A chain is formed if each element has an extra letter than the preceding one.\\n\\nWhenever I see this kind of problems, I think about:\\n* [tries](https://leetcode.com/tag/trie/): it helps with string prefix, but doesn\\'t help here, as the letter can be applied anywhere in the string\\n* [backtracking](https://leetcode.com/tag/backtracking/): I\\'ve noticed it helps with problems that require a full exploration of the space (e.g., find all possible chains). It would be an overkill here.\\n* [dp](https://leetcode.com/tag/dynamic-programming/): it helps with problems that are incremental in nature (e.g., find a short chain, see which ones can be used towards building the longer chain). (TIP: look at the post [Dynamic Programming Patterns](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns).\\n\\nSo picking DP as the main approach, I made the observation that it would be simpler to build the chain from shortest to longest word  -- doing the opposite is possible, but finding the next word is more expensive.\\n\\n```\\n    def longestStrChain(self, words: List[str]) -> int:\\n\\n\\t\\twords.sort(key=len)                 # Put shortest words first. Equivalent to words.sort(key=lambda x: len(x))\\n        \\n        dp = {}                             # Map(word, length of chain that ends with word)\\n        longest = 0                         # Longest chain found\\n        \\n        for w in words:\\n            parent = 0\\n            for i in range(len(w)):         # Find potential preceeding words, by removing 1 letter at a time\\n                pw = w[:i] + w[i+1:]\\n                if pw in dp:\\n                    parent = max(parent, dp[pw])  # See if this is the longest parent we can have\\n\\n            dp[w] = 1 + parent              # The chain that ends here is as long as the parent, plus us\\n\\n            longest = max(longest, dp[w])   # Keep track of longest chaing\\n\\n        return longest\\n```\\n\\nAs we can see from the code above, the function has 2 tasks: sort the input array, and compute the *dp* array. Sorting is `O(N log N)`. Computing the *dp* array has 2 loops: the first one depending on `N` (number of words), and the inner one depending on `W` (length of the word). \\n\\nThus the complexity in time is `O( N log N + W*N )`. We can argue the complexity on space (hash map/dictionary) is the same.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def longestStrChain(self, words: List[str]) -> int:\\n\\n\\t\\twords.sort(key=len)                 # Put shortest words first. Equivalent to words.sort(key=lambda x: len(x))\\n        \\n        dp = {}                             # Map(word, length of chain that ends with word)\\n        longest = 0                         # Longest chain found\\n        \\n        for w in words:\\n            parent = 0\\n            for i in range(len(w)):         # Find potential preceeding words, by removing 1 letter at a time\\n                pw = w[:i] + w[i+1:]\\n                if pw in dp:\\n                    parent = max(parent, dp[pw])  # See if this is the longest parent we can have\\n\\n            dp[w] = 1 + parent              # The chain that ends here is as long as the parent, plus us\\n\\n            longest = max(longest, dp[w])   # Keep track of longest chaing\\n\\n        return longest\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 465848,
                "title": "python-easy-to-read-dp-solution",
                "content": "```\\nfrom collections import *\\n\\nclass Solution:\\n    \\n    def longestStrChain(self, words: List[str]) -> int:\\n\\n        words.sort(key=len)\\n        word_dict = defaultdict(int)\\n        \\n        total_max = 0\\n        \\n        for w in words:\\n            for i in range(len(w)):\\n                wc = w[:i] + w[i+1:]\\n                word_dict[w] = max(word_dict[wc] + 1, word_dict[w])\\n            total_max = max(total_max, word_dict[w])\\n    \\n        return total_max\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import *\\n\\nclass Solution:\\n    \\n    def longestStrChain(self, words: List[str]) -> int:\\n\\n        words.sort(key=len)\\n        word_dict = defaultdict(int)\\n        \\n        total_max = 0\\n        \\n        for w in words:\\n            for i in range(len(w)):\\n                wc = w[:i] + w[i+1:]\\n                word_dict[w] = max(word_dict[wc] + 1, word_dict[w])\\n            total_max = max(total_max, word_dict[w])\\n    \\n        return total_max\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295186,
                "title": "java-topological-sort-bfs",
                "content": "The problem can be reduced to finding the length of the longest path in a DAG. It can be done by using [Kahn\\'s algorithm](https://en.wikipedia.org/wiki/Topological_sorting#Kahn\\'s_algorithm). A directed edge exists between a node and its predecessor.\\n```\\npublic int longestStrChain(String[] words) {\\n    int[] indegree = new int[words.length];\\n    List<Integer>[] graph = buildDigraph(words, indegree);\\n    return bfs(graph, indegree);\\n}\\n\\nprivate int bfs(List<Integer>[] graph, int[] indegree) {\\n    Queue<Integer> q = new ArrayDeque<>();\\n    for (int i = 0; i < graph.length; i++) {\\n        if (indegree[i] == 0) {\\n            q.add(i);\\n        }\\n    }\\n\\n    int len = 0;\\n    for (; !q.isEmpty(); len++) {\\n        for (int sz = q.size(); sz > 0; sz--) {\\n            for (int adj : graph[q.poll()]) {\\n                indegree[adj]--;\\n                if (indegree[adj] == 0) {\\n                    q.add(adj);\\n                }\\n            }\\n        }\\n    }\\n    return len;\\n}\\n\\nprivate List<Integer>[] buildDigraph(String[] words, int[] indegree) {\\n    Arrays.sort(words, new StringByLengthComparator());\\n\\n    List<Integer>[] graph = new List[words.length];\\n    for (int i = 0; i < words.length; i++) {\\n        graph[i] = new ArrayList<>();\\n    }\\n\\n    for (int i = 0; i < words.length; i++) {\\n        for (int j = i + 1; j < words.length && words[j].length() - words[i].length() <= 1; j++) {\\n            if (isPredecessor(words[i], words[j])) {\\n                graph[i].add(j);\\n                indegree[j]++;   \\n            }\\n        }\\n    }\\n\\n    return graph;\\n}\\n\\n private boolean isPredecessor(String s1, String s2) {\\n    if (s2.length() == s1.length()) return false;\\n    int diff = 0;\\n    for (int i = 0, j = 0; i < s1.length(); ) {\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            i++;\\n            j++;\\n        } else {\\n            diff++;\\n            if (diff > 1) return false;\\n            j++;\\n        }\\n    }\\n    return true;\\n}\\n\\nprivate static class StringByLengthComparator implements Comparator<String> {\\n    public int compare(String s1, String s2) {\\n        return Integer.compare(s1.length(), s2.length());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestStrChain(String[] words) {\\n    int[] indegree = new int[words.length];\\n    List<Integer>[] graph = buildDigraph(words, indegree);\\n    return bfs(graph, indegree);\\n}\\n\\nprivate int bfs(List<Integer>[] graph, int[] indegree) {\\n    Queue<Integer> q = new ArrayDeque<>();\\n    for (int i = 0; i < graph.length; i++) {\\n        if (indegree[i] == 0) {\\n            q.add(i);\\n        }\\n    }\\n\\n    int len = 0;\\n    for (; !q.isEmpty(); len++) {\\n        for (int sz = q.size(); sz > 0; sz--) {\\n            for (int adj : graph[q.poll()]) {\\n                indegree[adj]--;\\n                if (indegree[adj] == 0) {\\n                    q.add(adj);\\n                }\\n            }\\n        }\\n    }\\n    return len;\\n}\\n\\nprivate List<Integer>[] buildDigraph(String[] words, int[] indegree) {\\n    Arrays.sort(words, new StringByLengthComparator());\\n\\n    List<Integer>[] graph = new List[words.length];\\n    for (int i = 0; i < words.length; i++) {\\n        graph[i] = new ArrayList<>();\\n    }\\n\\n    for (int i = 0; i < words.length; i++) {\\n        for (int j = i + 1; j < words.length && words[j].length() - words[i].length() <= 1; j++) {\\n            if (isPredecessor(words[i], words[j])) {\\n                graph[i].add(j);\\n                indegree[j]++;   \\n            }\\n        }\\n    }\\n\\n    return graph;\\n}\\n\\n private boolean isPredecessor(String s1, String s2) {\\n    if (s2.length() == s1.length()) return false;\\n    int diff = 0;\\n    for (int i = 0, j = 0; i < s1.length(); ) {\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            i++;\\n            j++;\\n        } else {\\n            diff++;\\n            if (diff > 1) return false;\\n            j++;\\n        }\\n    }\\n    return true;\\n}\\n\\nprivate static class StringByLengthComparator implements Comparator<String> {\\n    public int compare(String s1, String s2) {\\n        return Integer.compare(s1.length(), s2.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295062,
                "title": "step-by-step-dfs-memoization-c-beat-100",
                "content": "My explannation and might be a little wordy, but I will try my best.\\n**Step1 (simple) : Is one string the predecessor of another?**\\nWe create the function isProd(s1, s2), to determine whether s1 is the pred of s2.\\n```\\n    bool isProd(string& s1, string& s2) {\\n        int i = 0;\\n        int j = 0;\\n        if (s2.length() != s1.length() + 1) return false;\\n        int m = s1.length();\\n        int n = s2.length();\\n        int diff = 0;\\n        while (i < m && j < n) {\\n            if (s1[i] == s2[j]) {\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            else {\\n                j++;\\n                diff++;\\n                if (diff > 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n**Step2 (simple) : For all the strings in the list, we need to determine the pred relation** of one and another (for all of them), using the function in Step1. Store them in the matrix called *dp*.\\n```\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector<vector<int>> dp(n);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == j) continue;\\n                if (isProd(words[i], words[j])) dp[i].push_back(j);\\n            }\\n        }\\n\\t\\t// -------------- Above code for Step2 ------------------\\n        vector<int> mem(n, 0);\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            res = max(1 + maxPath(dp, mem, i), res);\\n        }\\n        return res;\\n    }\\n```\\n**Step3: The maxPath() function above that has not beed implemented.**\\nWith the relation matrix dp, we need to come up with the maxPath with DFS. Also, for the sake of efficiency we need a *mem* vector to store values that has already been computed.\\n```\\n    int maxPath(vector<vector<int>>& dp, vector<int>& mem, int start) {\\n        if (mem[start] != 0) return mem[start];\\n        int res = 0;\\n        for (int i = 0; i < dp[start].size(); ++i) {\\n            int temp = maxPath(dp, mem, dp[start][i]);\\n            res = max(res, 1 + temp);\\n        }\\n        mem[start] = res;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isProd(string& s1, string& s2) {\\n        int i = 0;\\n        int j = 0;\\n        if (s2.length() != s1.length() + 1) return false;\\n        int m = s1.length();\\n        int n = s2.length();\\n        int diff = 0;\\n        while (i < m && j < n) {\\n            if (s1[i] == s2[j]) {\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            else {\\n                j++;\\n                diff++;\\n                if (diff > 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector<vector<int>> dp(n);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == j) continue;\\n                if (isProd(words[i], words[j])) dp[i].push_back(j);\\n            }\\n        }\\n\\t\\t// -------------- Above code for Step2 ------------------\\n        vector<int> mem(n, 0);\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            res = max(1 + maxPath(dp, mem, i), res);\\n        }\\n        return res;\\n    }\\n```\n```\\n    int maxPath(vector<vector<int>>& dp, vector<int>& mem, int start) {\\n        if (mem[start] != 0) return mem[start];\\n        int res = 0;\\n        for (int i = 0; i < dp[start].size(); ++i) {\\n            int temp = maxPath(dp, mem, dp[start][i]);\\n            res = max(res, 1 + temp);\\n        }\\n        mem[start] = res;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294927,
                "title": "c-dp-similar-to-word-break-logic-dfs",
                "content": "\\tclass Solution {\\n\\t\\tstatic bool compare(string s1 , string s2) {\\n\\t\\t\\treturn s1.length() < s2.length();\\n\\t\\t}\\n\\n\\t\\tbool isPredecessor(string &s1, string &s2) {\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tbool flag = false;\\n\\n\\t\\t\\twhile(i < s1.length() and j < s2.length()) {\\n\\t\\t\\t\\tif(s1[i] != s2[j]) {\\n\\t\\t\\t\\t\\tif(flag)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn (flag and i == s1.length() and j == s2.length()) or (!flag and i == (s1.length() - 1) and j == s2.length());\\n\\t\\t}\\n\\tpublic:\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tvector<int> mem(words.size(), 1);\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tsort(words.begin(), words.end(), compare);\\n\\t\\t\\tfor(int i = 1; i < words.size(); i++) {\\n\\t\\t\\t\\tint len = words[i].length();\\n\\t\\t\\t\\tfor(int j = i - 1; j >= 0; j--) {\\n\\t\\t\\t\\t\\tif((len - words[j].length()) > 1)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tif(isPredecessor(words[i], words[j]))\\n\\t\\t\\t\\t\\t\\tmem[i] = max(mem[i], mem[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = max(res, mem[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tstatic bool compare(string s1 , string s2) {\\n\\t\\t\\treturn s1.length() < s2.length();\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4083621,
                "title": "easy-dp-solution",
                "content": "# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n# **Approach**\\n`longestStrChain `function that takes a vector of strings words as input and returns the length of the longest string chain. A string chain is a sequence of words where each word differs from the previous word by exactly one character insertion.\\n\\nHere\\'s a breakdown of the code:\\n\\n- `comparee`is a static member function that compares two strings based on their lengths. It is used as a custom comparison function for sorting the words in ascending order of length.\\n\\n- check is a member function that checks if s1 is a valid successor of s2 in a string chain. It returns true if s1 has a length one greater than s2 and can be obtained by adding one character to s2. It uses two pointers (first and second) to compare characters in both strings.\\n\\n- In the `longestStrChain `function:\\n\\n1. The words vector is sorted in ascending order of length using the `comparee`function as the custom comparator. This ensures that shorter words come before longer words.\\n2. An array dp is initialized with the same size as the input vector words. Each element in dp represents the length of the longest chain ending with the word at the corresponding index in words. Initially, each word is considered a chain of length 1.\\n3. The variable `maxi` is used to keep track of the `maxi`mum chain length found so far.\\n4. Two nested loops iterate over the words in the words vector. For each word at index i, an inner loop iterates over all previous words (at indices prev) to check if words[i] can be a successor of words[prev]. If it can, and extending the chain by adding words[i] results in a longer chain than what was previously stored in dp[i], the chain length is updated.\\n5. Finally, the `maxi`mum chain length (`maxi`) is returned as the result.\\nOverall, this code efficiently computes the length of the longest string chain using dynamic programming and custom sorting to optimize the process.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**$O(N^2)$**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:***0(N)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     static bool comparee(const string& s1, const string& s2) {\\n        return s1.size() < s2.size();\\n    }\\n\\n    bool check(string &s1, string &s2) {\\n        if (s1.size() != s2.size() + 1) {\\n            return false;\\n        }\\n        int first = 0;\\n        int second = 0;\\n        while (first < s1.size()) {\\n            if (s1[first] == s2[second]) {\\n                first++;\\n                second++;\\n            } else {\\n                first++;\\n            }\\n        }\\n        if (first == s1.size() && second == s2.size()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), comparee);\\n\\n        int n = words.size();\\n        vector<int> dp(n, 1); // Initialize dp array with 1 for each word\\n        int maxi = 1;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int prev = 0; prev < i; prev++) {\\n                if (check(words[i], words[prev]) && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                }\\n            }\\n            if (dp[i] > maxi) {\\n                maxi = dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     static bool comparee(const string& s1, const string& s2) {\\n        return s1.size() < s2.size();\\n    }\\n\\n    bool check(string &s1, string &s2) {\\n        if (s1.size() != s2.size() + 1) {\\n            return false;\\n        }\\n        int first = 0;\\n        int second = 0;\\n        while (first < s1.size()) {\\n            if (s1[first] == s2[second]) {\\n                first++;\\n                second++;\\n            } else {\\n                first++;\\n            }\\n        }\\n        if (first == s1.size() && second == s2.size()) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), comparee);\\n\\n        int n = words.size();\\n        vector<int> dp(n, 1); // Initialize dp array with 1 for each word\\n        int maxi = 1;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int prev = 0; prev < i; prev++) {\\n                if (check(words[i], words[prev]) && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                }\\n            }\\n            if (dp[i] > maxi) {\\n                maxi = dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081321,
                "title": "c-solution-for-longest-string-chain-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind this solution is to use dynamic programming to find the longest word chain for each word. We start by sorting the words by their length to ensure we process shorter words before longer ones. For each word, we try to find its predecessors (words that can be formed by inserting a single character) and calculate the longest chain ending at the current word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.\\tSort the words based on their length to process shorter words first.\\n2.\\tInitialize a dictionary (wordChainLengths) to store the longest chain for each word.\\n3.\\tIterate through each word:\\n    a. For each word, generate its possible predecessors by removing one character at a time.\\n    b. Check if the predecessor exists in the dictionary and update the longest chain for the current word accordingly.\\n    c. Update the longest chain length overall.\\n4.\\tReturn the longest chain length found.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the total number of words and k be the average length of the words.\\n\\n\\u2022\\tSorting the words takes O(n log n) time.\\n\\u2022\\tThe main loop iterates through each word and, for each word, can generate up to O(k) predecessors, and we do a constant-time operation for each predecessor.\\n\\u2022\\tOverall, the time complexity is O(n * k^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\u2022\\tThe space complexity is O(n) for the wordChainLengths dictionary, where n is the number of words.\\n\\u2022\\tAdditional space is used for variables and temporary storage, which is O(1).\\n\\u2022\\tTherefore, the overall space complexity is O(n).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        // Sort the words based on their length\\n        Array.Sort(words, (a, b) => a.Length - b.Length);\\n\\n        Dictionary<string, int> wordChainLengths = new Dictionary<string, int>();\\n        int longestChain = 1;\\n\\n        foreach (var word in words) {\\n            wordChainLengths[word] = 1; // Default chain length for each word is 1\\n\\n            // Find predecessors of the current word\\n            for (int i = 0; i < word.Length; i++) {\\n                StringBuilder pred = new StringBuilder(word);\\n                pred.Remove(i, 1);\\n                string predecessor = pred.ToString();\\n\\n                // Check if the predecessor exists in the dictionary\\n                if (wordChainLengths.ContainsKey(predecessor)) {\\n                    wordChainLengths[word] = Math.Max(wordChainLengths[word], wordChainLengths[predecessor] + 1);\\n                    longestChain = Math.Max(longestChain, wordChainLengths[word]);\\n                }\\n            }\\n        }\\n\\n        return longestChain;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestStrChain(string[] words) {\\n        // Sort the words based on their length\\n        Array.Sort(words, (a, b) => a.Length - b.Length);\\n\\n        Dictionary<string, int> wordChainLengths = new Dictionary<string, int>();\\n        int longestChain = 1;\\n\\n        foreach (var word in words) {\\n            wordChainLengths[word] = 1; // Default chain length for each word is 1\\n\\n            // Find predecessors of the current word\\n            for (int i = 0; i < word.Length; i++) {\\n                StringBuilder pred = new StringBuilder(word);\\n                pred.Remove(i, 1);\\n                string predecessor = pred.ToString();\\n\\n                // Check if the predecessor exists in the dictionary\\n                if (wordChainLengths.ContainsKey(predecessor)) {\\n                    wordChainLengths[word] = Math.Max(wordChainLengths[word], wordChainLengths[predecessor] + 1);\\n                    longestChain = Math.Max(longestChain, wordChainLengths[word]);\\n                }\\n            }\\n        }\\n\\n        return longestChain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079645,
                "title": "c-simple-precise-solution-dp-day-23",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool check(string& s1, string& s2){\\n\\n    if(s1.size() != s2.size() + 1) return false;\\n    \\n    int first = 0;\\n    int second = 0;\\n    \\n    while(first < s1.size()){\\n        if(second < s2.size() && s1[first] == s2[second]){\\n            first ++;\\n            second ++;\\n        }\\n        else first ++;\\n    }\\n    if(first == s1.size() && second == s2.size()) return true;\\n    else return false; \\n}\\n\\n    static bool comp(string& s1, string& s2){\\n        return s1.size() < s2.size();\\n    }\\n\\n    int longestStrChain(vector<string>& words) {   // based on LIS if observed carefully! \\n        \\n        int n = words.size();\\n        //sorting accordin to the size of each word using comparator!\\n  //IMP -> SORT\\n  sort( words.begin(), words.end(), comp );\\n        vector<int> dp(n,1);\\n        int maxi = 1;\\n\\n        for(int i=0; i<n; i++){\\n            for(int prev=0; prev<i; prev++){\\n\\n                if(check(words[i],words[prev]) && dp[i]<dp[prev]+1){\\n                    dp[i]=dp[prev]+1;\\n                }\\n            }\\n            maxi = max(maxi,dp[i]);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool check(string& s1, string& s2){\\n\\n    if(s1.size() != s2.size() + 1) return false;\\n    \\n    int first = 0;\\n    int second = 0;\\n    \\n    while(first < s1.size()){\\n        if(second < s2.size() && s1[first] == s2[second]){\\n            first ++;\\n            second ++;\\n        }\\n        else first ++;\\n    }\\n    if(first == s1.size() && second == s2.size()) return true;\\n    else return false; \\n}\\n\\n    static bool comp(string& s1, string& s2){\\n        return s1.size() < s2.size();\\n    }\\n\\n    int longestStrChain(vector<string>& words) {   // based on LIS if observed carefully! \\n        \\n        int n = words.size();\\n        //sorting accordin to the size of each word using comparator!\\n  //IMP -> SORT\\n  sort( words.begin(), words.end(), comp );\\n        vector<int> dp(n,1);\\n        int maxi = 1;\\n\\n        for(int i=0; i<n; i++){\\n            for(int prev=0; prev<i; prev++){\\n\\n                if(check(words[i],words[prev]) && dp[i]<dp[prev]+1){\\n                    dp[i]=dp[prev]+1;\\n                }\\n            }\\n            maxi = max(maxi,dp[i]);\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079496,
                "title": "most-optimised-code-with-100-runtime-and-memory-efficient-today-s-potd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the longest word chain possible from a given list of words. A word chain is a sequence of words where each word is a predecessor of the next word, which means you can insert exactly one letter anywhere in a word to make it equal to the next word. To solve this problem, we can use dynamic programming to find the longest chain length for each word.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the given list of words based on their lengths. This sorting is important because we want to process shorter words before longer ones, ensuring that we have information about potential predecessors when processing longer words.\\n\\n2. Initialize a dp (dynamic programming) map to store the length of the longest chain for each word. Initialize a variable maxLength to keep track of the maximum chain length found.\\n\\n3. Iterate through each word in the sorted order:\\n\\n4. Initialize currentLength to 1, as a single word forms a chain of length 1.\\nFor each possible predecessor of the current word (by removing one character at a time), check if the predecessor is in the dp map.\\nIf the predecessor is in the map, update currentLength to be the maximum of its current value and the length of the chain for the predecessor (from the dp map) plus 1.\\nUpdate the dp map for the current word with the calculated currentLength.\\n\\n5. Update maxLength to be the maximum of its current value and the currentLength for the current word.\\n\\n6. Continue this process for all words.\\n\\n7. Finally, return the maxLength as the length of the longest word chain.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting the words takes O(N log N), where N is the number of words.\\nThe main loop iterates through each word, and for each word, it generates all possible predecessors by removing characters. This inner loop can take up to O(L) time, where L is the maximum length of a word.\\nTherefore, the overall time complexity is O(N log N + NL), which simplifies to O(NL + N log N).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. We use a dp map to store the chain lengths for each word, which can take up to O(N) space.\\n2. Other variables used in the algorithm have constant space requirements.\\n3. Hence, the overall space complexity is O(N).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        // Sort the words by their length\\n        sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n            return a.size() < b.size();\\n        });\\n        \\n        unordered_map<string, int> dp; // Stores the length of the longest chain for each word\\n        \\n        int maxLength = 1; // Initialize the maximum length of the chain\\n        \\n        // Iterate through each word in the sorted order\\n        for (const string& word : words) {\\n            int currentLength = 1; // Initialize the chain length for the current word\\n            \\n            // Generate all possible predecessors of the current word\\n            for (int i = 0; i < word.size(); ++i) {\\n                string predecessor = word.substr(0, i) + word.substr(i + 1);\\n                \\n                // Check if the predecessor is in the dp map\\n                if (dp.count(predecessor)) {\\n                    currentLength = max(currentLength, dp[predecessor] + 1);\\n                }\\n            }\\n            \\n            // Update the dp map for the current word\\n            dp[word] = currentLength;\\n            \\n            // Update the maximum length of the chain\\n            maxLength = max(maxLength, currentLength);\\n        }\\n        \\n        return maxLength;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        // Sort the words by their length\\n        sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n            return a.size() < b.size();\\n        });\\n        \\n        unordered_map<string, int> dp; // Stores the length of the longest chain for each word\\n        \\n        int maxLength = 1; // Initialize the maximum length of the chain\\n        \\n        // Iterate through each word in the sorted order\\n        for (const string& word : words) {\\n            int currentLength = 1; // Initialize the chain length for the current word\\n            \\n            // Generate all possible predecessors of the current word\\n            for (int i = 0; i < word.size(); ++i) {\\n                string predecessor = word.substr(0, i) + word.substr(i + 1);\\n                \\n                // Check if the predecessor is in the dp map\\n                if (dp.count(predecessor)) {\\n                    currentLength = max(currentLength, dp[predecessor] + 1);\\n                }\\n            }\\n            \\n            // Update the dp map for the current word\\n            dp[word] = currentLength;\\n            \\n            // Update the maximum length of the chain\\n            maxLength = max(maxLength, currentLength);\\n        }\\n        \\n        return maxLength;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079178,
                "title": "java-1d-dp-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider any 1 element of array , compare that element with all the before elements and check if it is precedure of the selected element or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake 1D dp and store maximum length of words up to that index that can be choosen to become longest predecessor.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int n = words.length;\\n        int dp[] = new int [n+1];\\n        Arrays.sort(words,(a,b)->Integer.compare(a.length(), b.length()));\\n        System.out.println(Arrays.toString(words));\\n        Arrays.fill(dp,1);\\n        int ans = 1;\\n        for(int i = 1;i < n; i++){\\n            for(int j = i-1;j >= 0; j--){\\n                if(isPossible(words,i,j)){\\n                    dp[i] = Math.max(1+dp[j],dp[i]);\\n                    ans = Math.max(ans,dp[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isPossible(String[] words,int i,int j){\\n        String s = words[i];\\n        String p = words[j];\\n        if(s.length() - p.length() == 1){\\n            boolean bool = false;\\n            for(int first = 0,second = 0;first < s.length() && second < p.length(); first++,second++){\\n                if(s.charAt(first) != p.charAt(second)){\\n                    if(bool)return false;\\n                    bool = true;\\n                    second--;\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        int n = words.length;\\n        int dp[] = new int [n+1];\\n        Arrays.sort(words,(a,b)->Integer.compare(a.length(), b.length()));\\n        System.out.println(Arrays.toString(words));\\n        Arrays.fill(dp,1);\\n        int ans = 1;\\n        for(int i = 1;i < n; i++){\\n            for(int j = i-1;j >= 0; j--){\\n                if(isPossible(words,i,j)){\\n                    dp[i] = Math.max(1+dp[j],dp[i]);\\n                    ans = Math.max(ans,dp[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isPossible(String[] words,int i,int j){\\n        String s = words[i];\\n        String p = words[j];\\n        if(s.length() - p.length() == 1){\\n            boolean bool = false;\\n            for(int first = 0,second = 0;first < s.length() && second < p.length(); first++,second++){\\n                if(s.charAt(first) != p.charAt(second)){\\n                    if(bool)return false;\\n                    bool = true;\\n                    second--;\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078905,
                "title": "simple-c-code-longest-increasing-subsequence-variant",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to involve finding the longest chain of strings where each string in the chain can be obtained by deleting a single character from the previous string. To solve this, we could sort the strings by their lengths in ascending order. Then, we can use dynamic programming to compute the longest chain for each string, starting from the shortest string and building up to the longest.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the input strings in ascending order of their lengths.\\n2. Initialize an array `dp` of size n (number of input strings) to store the length of the longest chain ending at each string. Initialize all elements of dp to 1, as the minimum chain length for any string is 1 (the string itself).\\n3. Iterate through each string in the sorted order. For each string, iterate through all previous strings to check if the current string can be obtained by deleting a character from the previous string. If yes, update the dp value for the current string to be the `maximum of its current value and 1 plus` the dp value of the previous string.\\n4. Keep track of the maximum chain length seen so far and return it as the result.\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private:\\n  bool compare(string &s1 , string &s2){\\n    if(s1.size() != s2.size()+1) return false;\\n    int i(0) , j(0);\\n    while(i<s1.size()){\\n      if(j<s2.size() and s1[i] == s2[j]){\\n        i++;\\n        j++;\\n      }\\n      else i++;\\n    }\\n    if(i == s1.size() and j == s2.size()) return true;\\n    return false;\\n\\n  }\\n \\npublic:\\n static bool cmp(string&s1 , string&s2){\\n    return s1.size()<s2.size();\\n  }\\n    int longestStrChain(vector<string>& nums) {\\n        sort(nums.begin() , nums.end(),cmp);\\n        int n = nums.size();\\n        vector<int>dp(n, 1) ;\\n        int maxi = 1;\\n        for(int i = 0; i<n; i++){\\n         \\n            for(int j = 0; j<i; j++){\\n                if(compare(nums[i]  , nums[j])  &&  1 + dp[j] > dp[i]){\\n                    dp[i] = 1+ dp[j];\\n                }\\n            }\\n            // maxi = max(maxi , dp[i]); // last index of lIS will be max-lengthed index\\n            if(dp[i] > maxi) {\\n                maxi = dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  private:\\n  bool compare(string &s1 , string &s2){\\n    if(s1.size() != s2.size()+1) return false;\\n    int i(0) , j(0);\\n    while(i<s1.size()){\\n      if(j<s2.size() and s1[i] == s2[j]){\\n        i++;\\n        j++;\\n      }\\n      else i++;\\n    }\\n    if(i == s1.size() and j == s2.size()) return true;\\n    return false;\\n\\n  }\\n \\npublic:\\n static bool cmp(string&s1 , string&s2){\\n    return s1.size()<s2.size();\\n  }\\n    int longestStrChain(vector<string>& nums) {\\n        sort(nums.begin() , nums.end(),cmp);\\n        int n = nums.size();\\n        vector<int>dp(n, 1) ;\\n        int maxi = 1;\\n        for(int i = 0; i<n; i++){\\n         \\n            for(int j = 0; j<i; j++){\\n                if(compare(nums[i]  , nums[j])  &&  1 + dp[j] > dp[i]){\\n                    dp[i] = 1+ dp[j];\\n                }\\n            }\\n            // maxi = max(maxi , dp[i]); // last index of lIS will be max-lengthed index\\n            if(dp[i] > maxi) {\\n                maxi = dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078775,
                "title": "simple-intuitive-c-solution-using-sort-and-dp-tc-o-nxn-sc-o-n",
                "content": "# Intuition\\n1. Sort the vector according to size so that while traversing we have to check in just one direction. \\n2. Pick a string, while traversing through vector check whether it picked string is subsequence or not, if its a subsequence then this is a part of string chain.    \\n\\n\\n# Complexity\\n- Time complexity: O(nxn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(string a, string b){\\n        return a.length()<b.length();\\n    }\\n    bool isSubsequence(string s, string t) {\\n        int j=0;\\n        for(int i=0; i<t.length();i++){\\n            if(t[i]==s[j]){\\n                j++;\\n            }\\n        }\\n        if(s.length()==j)return true;\\n        return false;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),cmp);\\n        int n=words.size();\\n        vector<int> dp(n, 1);\\n        int maxLen = 1;\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(isSubsequence(words[j], words[i]) && words[j].length()+1==words[i].length()){\\n                    dp[i] = max(dp[i], dp[j]+1);\\n                }\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string a, string b){\\n        return a.length()<b.length();\\n    }\\n    bool isSubsequence(string s, string t) {\\n        int j=0;\\n        for(int i=0; i<t.length();i++){\\n            if(t[i]==s[j]){\\n                j++;\\n            }\\n        }\\n        if(s.length()==j)return true;\\n        return false;\\n    }\\n\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),cmp);\\n        int n=words.size();\\n        vector<int> dp(n, 1);\\n        int maxLen = 1;\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(isSubsequence(words[j], words[i]) && words[j].length()+1==words[i].length()){\\n                    dp[i] = max(dp[i], dp[j]+1);\\n                }\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602346,
                "title": "easy-lis-approach-explanation-c-little-modification-in-striver-s-approach",
                "content": "# Intuition\\nHere we see the length of the words in the output sequence is increasing by one, So we can try some LIS(longest increasing sequence) kind approach.\\n\\n# Approach\\nOnly thing we need to take care about is the new characters are insersted at any index and the relative order of characters needs to be retained, we can create a separate check function for this purpose\\n\\nwe can simply use the LIS code, and replace the condition arr[i]>arr[j], with check function\\n\\nonly thing we need to be careful about is the words should be sorted, in order to form an increasing sequence by length, we can use a comparator function for this same purpose.\\n\\n# Complexity\\n- Time complexity:\\nO(N*N*cmp), where cmp is the time complexity of comparator function\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(const string& a, const string& b) {\\n        if (b.size() + 1 != a.size()) return false;\\n        int n = a.size();\\n        while (n--) {\\n            string temp = a;\\n            if (temp.erase(n, 1) == b) return true;\\n        }\\n        return false;\\n    }\\n\\nstruct cmp {\\n    bool operator()(string& a, string& b) {\\n        return a.size() < b.size();\\n    }\\n};\\n\\nint longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        sort(words.begin(), words.end(), cmp());\\n        vector<int> dp(n, 1);\\n        int maxi = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (check(words[i], words[j]) && dp[i] < 1 + dp[j]) dp[i] = 1 + dp[j];\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(const string& a, const string& b) {\\n        if (b.size() + 1 != a.size()) return false;\\n        int n = a.size();\\n        while (n--) {\\n            string temp = a;\\n            if (temp.erase(n, 1) == b) return true;\\n        }\\n        return false;\\n    }\\n\\nstruct cmp {\\n    bool operator()(string& a, string& b) {\\n        return a.size() < b.size();\\n    }\\n};\\n\\nint longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        sort(words.begin(), words.end(), cmp());\\n        vector<int> dp(n, 1);\\n        int maxi = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (check(words[i], words[j]) && dp[i] < 1 + dp[j]) dp[i] = 1 + dp[j];\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303517,
                "title": "lcs-lis-code-python",
                "content": "# Intuition\\nThe intuition that for every curr string (s2) check with its previous one string(s1) that whether s2 completely contains s2 or not.\\nconditions:-\\n`1. If length of s2 - s1 != 1 => False (because we are allowed to add only one different char)`\\n`2. If s2 doesnt contain complete s1 => False (j < 0 but i != 0)`\\n\\nPerform this lcs for every curr word with its previously added word (By LIS method).\\n\\nI tried to find similar solution on Solutions sections by others but as it is not very efficient way to solve didnt find any.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        # Choices -> notpick ; found LCS => pick , notpick\\n        words.sort(key=len)\\n        def LCS(i, j, s1, s2, memo):\\n            if len(s2) - len(s1) != 1:\\n                memo[(i, j)] = False\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            if i < 0:\\n                memo[(i, j)] = True\\n            elif j < 0 and i >= 0:\\n                memo[(i, j)] = False\\n            elif s1[i] == s2[j]:\\n                memo[(i, j)] = LCS(i-1, j-1, s1, s2, memo)\\n            else:\\n                memo[(i, j)] = LCS(i, j-1, s1, s2, memo)\\n            return memo[(i, j)]\\n\\n        dp = [1] * len(words)\\n        for i in range(len(words)):\\n            for prev in range(i):\\n                m = len(words[prev])\\n                n = len(words[i])\\n                memo = {}\\n                if LCS(m -1, n-1, words[prev], words[i], memo):\\n                    dp[i] = max(dp[i], 1 + dp[prev])\\n        return max(dp)\\n        \\n        \\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        # Choices -> notpick ; found LCS => pick , notpick\\n        words.sort(key=len)\\n        def LCS(i, j, s1, s2, memo):\\n            if len(s2) - len(s1) != 1:\\n                memo[(i, j)] = False\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            if i < 0:\\n                memo[(i, j)] = True\\n            elif j < 0 and i >= 0:\\n                memo[(i, j)] = False\\n            elif s1[i] == s2[j]:\\n                memo[(i, j)] = LCS(i-1, j-1, s1, s2, memo)\\n            else:\\n                memo[(i, j)] = LCS(i, j-1, s1, s2, memo)\\n            return memo[(i, j)]\\n\\n        dp = [1] * len(words)\\n        for i in range(len(words)):\\n            for prev in range(i):\\n                m = len(words[prev])\\n                n = len(words[i])\\n                memo = {}\\n                if LCS(m -1, n-1, words[prev], words[i], memo):\\n                    dp[i] = max(dp[i], 1 + dp[prev])\\n        return max(dp)\\n        \\n        \\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420998,
                "title": "python-dynamic-programming-faster-than-95",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        answer = -1\\n        words_set = set(words)\\n        words.sort(key=lambda x: -len(x))\\n        \\n        @cache\\n        def dp(word):\\n            max_p = 1\\n            for i in range(len(word)):\\n                new_w = word[:i] + word[i+1:]\\n                if new_w in words_set:\\n                    max_p = max(max_p, 1+dp(new_w))\\n            \\n            return max_p\\n        \\n        for word in words:\\n            answer = max(answer, dp(word))\\n            \\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        answer = -1\\n        words_set = set(words)\\n        words.sort(key=lambda x: -len(x))\\n        \\n        @cache\\n        def dp(word):\\n            max_p = 1\\n            for i in range(len(word)):\\n                new_w = word[:i] + word[i+1:]\\n                if new_w in words_set:\\n                    max_p = max(max_p, 1+dp(new_w))\\n            \\n            return max_p\\n        \\n        for word in words:\\n            answer = max(answer, dp(word))\\n            \\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206492,
                "title": "lis-logic-dp-solution-c-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool compare(string &a, string &b){\\n        if(a.size()-1 != b.size()) return false;\\n        int i=0, j=0;\\n        while(i<a.size()){\\n            if(a[i] == b[j]){\\n                i++; j++;\\n            }\\n            else i++;\\n        }\\n        if(i==a.size() && j==b.size()) return true;\\n        return false;\\n    }\\n\\n    static bool len(string &a, string &b){\\n        return a.size() < b.size();\\n    }\\npublic:\\n    //we need to sort string acc to their length, and then we can apply logic of longest increasing subsequence\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size(), maxi=0;\\n        sort(words.begin(), words.end(), len);\\n        \\n        vector<int> dp(n, 1);\\n        for(int i=0;i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(compare(words[i], words[j]) && dp[i]<dp[j]+1){\\n                    dp[i] = 1 + dp[j];\\n                }\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool compare(string &a, string &b){\\n        if(a.size()-1 != b.size()) return false;\\n        int i=0, j=0;\\n        while(i<a.size()){\\n            if(a[i] == b[j]){\\n                i++; j++;\\n            }\\n            else i++;\\n        }\\n        if(i==a.size() && j==b.size()) return true;\\n        return false;\\n    }\\n\\n    static bool len(string &a, string &b){\\n        return a.size() < b.size();\\n    }\\npublic:\\n    //we need to sort string acc to their length, and then we can apply logic of longest increasing subsequence\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size(), maxi=0;\\n        sort(words.begin(), words.end(), len);\\n        \\n        vector<int> dp(n, 1);\\n        for(int i=0;i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(compare(words[i], words[j]) && dp[i]<dp[j]+1){\\n                    dp[i] = 1 + dp[j];\\n                }\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162475,
                "title": "easy-dp-solution-w-explanation-dp-explained",
                "content": "We need to find the longest chain of strings.\\nLet\\'s take an example the words: `[\"a\", \"b\", \"ba\"]`\\n\\nWhat is the longest chain of strings for word `\"a\"`? It\\'s 1 because there is only 1 letter.\\nWhat is the lognest chain of strings for the word `\"ba\"`? It\\'s the longest of all possible predecessors + 1 (or 1 if there is no chain from the predecessors)\\nWhat are the possible predecessors? `\"a\"` or `\"b\"`. We simply remove 1 letter at a time. So it\\'s `1 + \"a\" longest chain which is also 1 => 1+1 (or \"b\" longest chain which is also 1)`\\n\\nIf we extend this, what is the longest chain for \"bca\"? `max(dp[\"bc\"], dp[\"ca\"], dp[\"ba\"]) + 1`.\\nNote: we must sort the words array in order to know the previous answers.\\n\\nLet\\'s just code it :)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        dp = defaultdict(int)\\n        MAX = 1\\n        \\n        for word in words:\\n            if len(word) == 1:\\n                dp[word] = 1\\n                continue\\n            for i in range(len(word)):\\n                possible_predecessor = word[:i] + word[i+1:]\\n                dp[word] = max(dp[possible_predecessor] + 1, dp[word])\\n                MAX = max(MAX, dp[word])\\n                \\n        return MAX\\n```\\n\\n# Complexity analysis\\nTime: `O(nlogn*l)` - where `n` is the words list length, and `l` is the longest string.\\nspace: `O(n)`\\n\\n# Top-bottom DP memo solution\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo = {}\\n        available_words = set(words)\\n        MAX = 1\\n        for word in words:\\n            if word not in memo:\\n                MAX = max(MAX, self.recurse(words, word, available_words, memo))\\n        return MAX\\n        \\n    def recurse(self, words: List[str], word: str, available_words, memo):\\n        if len(word) == 1:\\n            memo[word] = 1\\n            return 1\\n        \\n        if word in memo:\\n            return memo[word]\\n        \\n        MAX = 1\\n        for i in range(len(word)):\\n            possible_predecessor = word[:i] + word[i+1:]\\n            if possible_predecessor in available_words:\\n                MAX = max(MAX, self.recurse(words, possible_predecessor, available_words, memo) + 1)\\n            \\n        memo[word] = MAX\\n        return MAX\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key = lambda x: len(x))\\n        dp = defaultdict(int)\\n        MAX = 1\\n        \\n        for word in words:\\n            if len(word) == 1:\\n                dp[word] = 1\\n                continue\\n            for i in range(len(word)):\\n                possible_predecessor = word[:i] + word[i+1:]\\n                dp[word] = max(dp[possible_predecessor] + 1, dp[word])\\n                MAX = max(MAX, dp[word])\\n                \\n        return MAX\\n```\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo = {}\\n        available_words = set(words)\\n        MAX = 1\\n        for word in words:\\n            if word not in memo:\\n                MAX = max(MAX, self.recurse(words, word, available_words, memo))\\n        return MAX\\n        \\n    def recurse(self, words: List[str], word: str, available_words, memo):\\n        if len(word) == 1:\\n            memo[word] = 1\\n            return 1\\n        \\n        if word in memo:\\n            return memo[word]\\n        \\n        MAX = 1\\n        for i in range(len(word)):\\n            possible_predecessor = word[:i] + word[i+1:]\\n            if possible_predecessor in available_words:\\n                MAX = max(MAX, self.recurse(words, possible_predecessor, available_words, memo) + 1)\\n            \\n        memo[word] = MAX\\n        return MAX\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162309,
                "title": "c-longest-string-chain-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool sortByLength(string &s1, string &s2){\\n        \\n        return s1.length() < s2.length();  \\n        // eg s1 = \"ab\", s2 = \"abc\" -> return true -> no swap\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        \\n        int n = words.size();\\n        \\n        // Sort all the words in ascending order of their length\\n        sort(words.begin(), words.end(), sortByLength);\\n        \\n        unordered_map<string, int> dp(n);\\n        int len = 0;\\n        \\n        for(int i=0; i < n; i++){\\n            \\n            dp[words[i]] = 1;   // can form by itself\\n            \\n             // deleting char by char and checking if predecessor exists\\n            for(int j=0; j < words[i].size(); j++){  \\n                \\n                string predecessor = words[i].substr(0, j) + words[i].substr(j+1);\\n                dp[words[i]] = max(dp[words[i]] , 1 + dp[predecessor]);\\n            }\\n            \\n            len = max(len, dp[words[i]]);\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortByLength(string &s1, string &s2){\\n        \\n        return s1.length() < s2.length();  \\n        // eg s1 = \"ab\", s2 = \"abc\" -> return true -> no swap\\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        \\n        int n = words.size();\\n        \\n        // Sort all the words in ascending order of their length\\n        sort(words.begin(), words.end(), sortByLength);\\n        \\n        unordered_map<string, int> dp(n);\\n        int len = 0;\\n        \\n        for(int i=0; i < n; i++){\\n            \\n            dp[words[i]] = 1;   // can form by itself\\n            \\n             // deleting char by char and checking if predecessor exists\\n            for(int j=0; j < words[i].size(); j++){  \\n                \\n                string predecessor = words[i].substr(0, j) + words[i].substr(j+1);\\n                dp[words[i]] = max(dp[words[i]] , 1 + dp[predecessor]);\\n            }\\n            \\n            len = max(len, dp[words[i]]);\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154668,
                "title": "python-easy-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)\\n        d = {}\\n        for i in words:\\n            d[i] = 1\\n            for j in range(len(i)):\\n                successor = i[:j] + i[j+1:]\\n                \\n                if successor in d:\\n                    d[i] = max(d[i], 1 + d[successor])\\n        return max(d.values())\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words.sort(key=len)\\n        d = {}\\n        for i in words:\\n            d[i] = 1\\n            for j in range(len(i)):\\n                successor = i[:j] + i[j+1:]\\n                \\n                if successor in d:\\n                    d[i] = max(d[i], 1 + d[successor])\\n        return max(d.values())\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154240,
                "title": "c-easy-to-understand-solution-without-sorting",
                "content": "***Loop-based Cpp solution***\\n```\\nclass Solution {\\npublic:\\n    bool check(int cur, int prev, vector<string>& words){\\n        int diff=0,i=0,j=0;\\n        while(i<words[cur].size() && j<words[prev].size()){\\n            if(words[cur][i]==words[prev][j]){\\n                i++;j++;\\n            }\\n            else{\\n                i++;\\n                diff++;\\n            }\\n        }\\n        return diff<2;\\n    }\\n\\t\\n    int longestStrChain(vector<string>& words) {\\n        vector<pair<int,int>> a[17];\\n        for(int i=0;i<words.size();i++){\\n            a[words[i].size()].push_back({i,1});\\n        }\\n        int ans=1;\\n        for(int i=2;i<17;i++){\\n            for(int j=0;j<a[i].size();j++){\\n                for(int k=0;k<a[i-1].size();k++){\\n                    if(check(a[i][j].first,a[i-1][k].first,words))\\n\\t\\t\\t\\t\\t\\ta[i][j].second=max(a[i][j].second,a[i-1][k].second+1);\\n                }\\n                ans=max(ans,a[i][j].second);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool check(int cur, int prev, vector<string>& words){\\n        int diff=0,i=0,j=0;\\n        while(i<words[cur].size() && j<words[prev].size()){\\n            if(words[cur][i]==words[prev][j]){\\n                i++;j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2153352,
                "title": "simple-java-solution-using-a-hashmap-w-comments",
                "content": "```\\nclass Solution {\\n    int longest = 1;\\n    public int longestStrChain(String[] words) {\\n        \\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        sort(words);\\n    \\n        for (int i = 0; i < words.length; i++) {\\n            String curr = words[i];\\n            \\n            if (!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            }\\n            \\n            // loop over the entire string and delete each character one by one.\\n            // if the resulting string was already found, then insert the current string + 1\\n            // of the previous value.  That is signifying the string chain \\n            for (int j = 0; j < curr.length(); j++) {\\n                StringBuilder sb = new StringBuilder(curr);\\n                sb.deleteCharAt(j);\\n                \\n                String newString = sb.toString();\\n                if (map.containsKey(newString)) {\\n                    map.put(curr, map.get(newString) + 1);\\n                }   \\n                longest = Math.max(longest, map.get(curr));\\n            }\\n        }\\n        return longest;\\n    }\\n    \\n    // sort array by length of string (smallest -> largest)\\n    public void sort(String[] words) {\\n        Arrays.sort(words, (a,b)->Integer.valueOf(a.length()).compareTo(Integer.valueOf(b.length())));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int longest = 1;\\n    public int longestStrChain(String[] words) {\\n        \\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        sort(words);\\n    \\n        for (int i = 0; i < words.length; i++) {\\n            String curr = words[i];\\n            \\n            if (!map.containsKey(curr)) {\\n                map.put(curr, 1);\\n            }\\n            \\n            // loop over the entire string and delete each character one by one.\\n            // if the resulting string was already found, then insert the current string + 1\\n            // of the previous value.  That is signifying the string chain \\n            for (int j = 0; j < curr.length(); j++) {\\n                StringBuilder sb = new StringBuilder(curr);\\n                sb.deleteCharAt(j);\\n                \\n                String newString = sb.toString();\\n                if (map.containsKey(newString)) {\\n                    map.put(curr, map.get(newString) + 1);\\n                }   \\n                longest = Math.max(longest, map.get(curr));\\n            }\\n        }\\n        return longest;\\n    }\\n    \\n    // sort array by length of string (smallest -> largest)\\n    public void sort(String[] words) {\\n        Arrays.sort(words, (a,b)->Integer.valueOf(a.length()).compareTo(Integer.valueOf(b.length())));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153318,
                "title": "c-2-approaches-lcs-lis-lis",
                "content": "**1. Using LCS + LIS**\\n\\nIn this approach, we will find the length of longest common subsequence and if the number of remaining character in 2nd string is 1 then we can say that these two strings can form a chain.  After this we will update the maximum chain length accordingly.\\n\\n**CODE:**\\n\\n\\t // Using LCS + LIS  *** Will Give TLE ***\\n\\t\\tstatic bool comp(string & a, string &b){\\n\\t\\t\\tif(a.size() < b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint lcs_len(string word1, string word2) {\\n\\t\\t\\tint m = word1.size();\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<int>>dp(m + 1, vector<int>(n + 1, 0));\\n\\t\\t\\tfor(int idx1 = 1; idx1 <= m; idx1++) {\\n\\t\\t\\t\\tfor(int idx2 = 1; idx2 <= n; idx2++) {\\n\\t\\t\\t\\t\\tif(word1[idx1 - 1] == word2[idx2 - 1])\\n\\t\\t\\t\\t\\t\\tdp[idx1][idx2] = 1 + dp[idx1 - 1][idx2 - 1]; \\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tdp[idx1][idx2] = max(dp[idx1 - 1][idx2], dp[idx1][idx2 - 1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[m][n];\\n\\t\\t}\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tsort(words.begin(), words.end(), comp);\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\t\\t\\tif(words[i].size() == words[j].size() + 1 && lcs_len(words[i], words[j]) == words[j].size()){\\n\\t\\t\\t\\t\\t\\tif(dp[i] < dp[j] + 1)\\n\\t\\t\\t\\t\\t\\t\\tdp[i] = dp[j] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn *max_element(dp.begin(),  dp.end());\\n\\t\\t}\\n\\n**2. Using LIS**\\n\\nIn this approach, instead of finding the length of longest common subsequence, we will compare two strings by using two pointer approach. If both pointers reach the end at the same time then we can say that these two strings can form a chain.  After this we will update the maximum chain length accordingly.\\n\\n**CODE:**\\n\\n\\t// Using LIS\\n\\t\\tstatic bool comp(string & a, string &b){\\n\\t\\t\\tif(a.size() < b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tbool isValid(string &a, string &b) {\\n\\t\\t\\tif(a.size() != b.size() + 1)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\twhile(i < a.size()) {\\n\\t\\t\\t\\tif(a[i] == b[j]) \\n\\t\\t\\t\\t\\ti++, j++;\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif(i == a.size() && j == b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tsort(words.begin(), words.end(), comp);\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\tfor(int i = 0; i < words.size(); i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\t\\t\\tif(isValid(words[i],words[j]) && dp[i] < dp[j] + 1) {\\n\\t\\t\\t\\t\\t\\tdp[i] = dp[j] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans, dp[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "**1. Using LCS + LIS**\\n\\nIn this approach, we will find the length of longest common subsequence and if the number of remaining character in 2nd string is 1 then we can say that these two strings can form a chain.  After this we will update the maximum chain length accordingly.\\n\\n**CODE:**\\n\\n\\t // Using LCS + LIS  *** Will Give TLE ***\\n\\t\\tstatic bool comp(string & a, string &b){\\n\\t\\t\\tif(a.size() < b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint lcs_len(string word1, string word2) {\\n\\t\\t\\tint m = word1.size();\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<int>>dp(m + 1, vector<int>(n + 1, 0));\\n\\t\\t\\tfor(int idx1 = 1; idx1 <= m; idx1++) {\\n\\t\\t\\t\\tfor(int idx2 = 1; idx2 <= n; idx2++) {\\n\\t\\t\\t\\t\\tif(word1[idx1 - 1] == word2[idx2 - 1])\\n\\t\\t\\t\\t\\t\\tdp[idx1][idx2] = 1 + dp[idx1 - 1][idx2 - 1]; \\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tdp[idx1][idx2] = max(dp[idx1 - 1][idx2], dp[idx1][idx2 - 1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[m][n];\\n\\t\\t}\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tsort(words.begin(), words.end(), comp);\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tfor(int i = 1; i < n; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\t\\t\\tif(words[i].size() == words[j].size() + 1 && lcs_len(words[i], words[j]) == words[j].size()){\\n\\t\\t\\t\\t\\t\\tif(dp[i] < dp[j] + 1)\\n\\t\\t\\t\\t\\t\\t\\tdp[i] = dp[j] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn *max_element(dp.begin(),  dp.end());\\n\\t\\t}\\n\\n**2. Using LIS**\\n\\nIn this approach, instead of finding the length of longest common subsequence, we will compare two strings by using two pointer approach. If both pointers reach the end at the same time then we can say that these two strings can form a chain.  After this we will update the maximum chain length accordingly.\\n\\n**CODE:**\\n\\n\\t// Using LIS\\n\\t\\tstatic bool comp(string & a, string &b){\\n\\t\\t\\tif(a.size() < b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tbool isValid(string &a, string &b) {\\n\\t\\t\\tif(a.size() != b.size() + 1)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\twhile(i < a.size()) {\\n\\t\\t\\t\\tif(a[i] == b[j]) \\n\\t\\t\\t\\t\\ti++, j++;\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif(i == a.size() && j == b.size())\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tsort(words.begin(), words.end(), comp);\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\tfor(int i = 0; i < words.size(); i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\t\\t\\tif(isValid(words[i],words[j]) && dp[i] < dp[j] + 1) {\\n\\t\\t\\t\\t\\t\\tdp[i] = dp[j] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans, dp[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2152993,
                "title": "c-top-down-dp-spaghetti-code",
                "content": "```\\nclass Solution {\\n    \\n    bool isValid(string& s1, string& s2) {\\n        \\n        int diff = 0;\\n        \\n        int i = 0;\\n        int j = 0;\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n        \\n        while(i < n1 && j < n2) {\\n            if(s1[i] == s2[j]) {\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n                diff++;\\n            }\\n        }\\n\\n        if(j == n2 -1 && i == n1 && diff == 0) return true;\\n        \\n        if(diff != 1) return false;\\n        return i == n1 && j == n2;\\n    }\\n    \\n    int dfs(unordered_map<int, vector<string>>& um, string& cur, unordered_map<string, int>& cashMoney) {\\n        int n = cur.length();\\n        \\n        if(cashMoney.find(cur) != cashMoney.end()) {\\n            return cashMoney[cur];\\n        }\\n        int best = 1;\\n        for(auto& s : um[n+1]) {\\n            if(isValid(cur, s)) {\\n                int maybe = 1 + dfs(um, s, cashMoney);\\n                best = max(maybe, best);\\n            }\\n        }\\n        return cashMoney[cur] = best;\\n    }\\n    \\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<int, vector<string>> um;\\n        unordered_map<string, int> cashMoney;\\n        int mn = INT_MAX;\\n        for(auto& s : words) {\\n            int n = s.length();\\n            mn = min(n, mn);\\n            um[n].push_back(s);\\n        }\\n        int ans = 0;\\n        for(auto& s : words) {\\n            ans = max(ans, dfs(um, s, cashMoney));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    bool isValid(string& s1, string& s2) {\\n        \\n        int diff = 0;\\n        \\n        int i = 0;\\n        int j = 0;\\n        int n1 = s1.length();\\n        int n2 = s2.length();\\n        \\n        while(i < n1 && j < n2) {\\n            if(s1[i] == s2[j]) {\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n                diff++;\\n            }\\n        }\\n\\n        if(j == n2 -1 && i == n1 && diff == 0) return true;\\n        \\n        if(diff != 1) return false;\\n        return i == n1 && j == n2;\\n    }\\n    \\n    int dfs(unordered_map<int, vector<string>>& um, string& cur, unordered_map<string, int>& cashMoney) {\\n        int n = cur.length();\\n        \\n        if(cashMoney.find(cur) != cashMoney.end()) {\\n            return cashMoney[cur];\\n        }\\n        int best = 1;\\n        for(auto& s : um[n+1]) {\\n            if(isValid(cur, s)) {\\n                int maybe = 1 + dfs(um, s, cashMoney);\\n                best = max(maybe, best);\\n            }\\n        }\\n        return cashMoney[cur] = best;\\n    }\\n    \\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        unordered_map<int, vector<string>> um;\\n        unordered_map<string, int> cashMoney;\\n        int mn = INT_MAX;\\n        for(auto& s : words) {\\n            int n = s.length();\\n            mn = min(n, mn);\\n            um[n].push_back(s);\\n        }\\n        int ans = 0;\\n        for(auto& s : words) {\\n            ans = max(ans, dfs(um, s, cashMoney));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994057,
                "title": "python-easy-solution-faster-than-99-dictionary-o-nlog-n",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:       \\n        n = len(words)\\n        words.sort(key = lambda x : len(x)) # Sort the words according to their length\\n        \\n        dit = {w:1 for w in words} # Store the longest word chain length till key word\\n        \\n        for i in range(1,n):\\n            w = words[i]\\n            for j in range(len(w)):  # Max len(w) will be 16 \\n                new_w = w[:j]+w[j+1:]  # new word after removing j-th  character\\n            \\n                if new_w in dit and dit[new_w]+1>dit[w]:\\n                    dit[w] = dit[new_w]+1\\n                \\n        return max(dit.values())    \\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:       \\n        n = len(words)\\n        words.sort(key = lambda x : len(x)) # Sort the words according to their length\\n        \\n        dit = {w:1 for w in words}",
                "codeTag": "Java"
            },
            {
                "id": 1830813,
                "title": "python-dfs-simple-solution",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo = {}\\n        words_set = set(words)    \\n        \\n        def get_next_word(word, index):\\n            return word[:index] + word[index + 1:]\\n        \\n        def dfs(word):\\n            if word in memo:\\n                return memo[word]\\n            \\n            total_length = 1\\n            for i in range(len(word)):\\n                next_word = get_next_word(word, i)\\n                if next_word in words_set:\\n                    current_length = 1 + dfs(next_word)\\n                    total_length = max(total_length, current_length)\\n            memo[word] = total_length\\n            return total_length\\n            \\n        \\n        ans = 0\\n        for word in words_set:\\n            ans = max(ans, dfs(word))\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        memo = {}\\n        words_set = set(words)    \\n        \\n        def get_next_word(word, index):\\n            return word[:index] + word[index + 1:]\\n        \\n        def dfs(word):\\n            if word in memo:\\n                return memo[word]\\n            \\n            total_length = 1\\n            for i in range(len(word)):\\n                next_word = get_next_word(word, i)\\n                if next_word in words_set:\\n                    current_length = 1 + dfs(next_word)\\n                    total_length = max(total_length, current_length)\\n            memo[word] = total_length\\n            return total_length\\n            \\n        \\n        ans = 0\\n        for word in words_set:\\n            ans = max(ans, dfs(word))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794947,
                "title": "swift-dp",
                "content": "```\\nclass Solution {\\n    func longestStrChain(_ words: [String]) -> Int {\\n        var dp: Dictionary<String, Int> = [:]\\n        var words = words.sorted(by: {$0.count < $1.count})\\n        var longest = 1\\n        for word in words {\\n            var presentLength = 1\\n            for i in 0 ..< word.count {\\n                var newStr = Array(word)\\n                newStr.remove(at: i)\\n                let prevL = dp[String(newStr), default: 0]\\n                presentLength = max(prevL + 1,presentLength)\\n            }  \\n            dp[word] = presentLength\\n            longest = longest < presentLength ? presentLength : longest\\n        }\\n        return longest \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func longestStrChain(_ words: [String]) -> Int {\\n        var dp: Dictionary<String, Int> = [:]\\n        var words = words.sorted(by: {$0.count < $1.count})\\n        var longest = 1\\n        for word in words {\\n            var presentLength = 1\\n            for i in 0 ..< word.count {\\n                var newStr = Array(word)\\n                newStr.remove(at: i)\\n                let prevL = dp[String(newStr), default: 0]\\n                presentLength = max(prevL + 1,presentLength)\\n            }  \\n            dp[word] = presentLength\\n            longest = longest < presentLength ? presentLength : longest\\n        }\\n        return longest \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237926,
                "title": "lis-sorting-72-ms-93-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string &first, string &second) {\\n        return first.length() < second.length();\\n    }    \\n\\n    bool preceds(string &predecessor, string &word) {\\n        if (predecessor.length() != word.length()-1)\\n            return false;\\n        int first = 0, second = 0, misMatches = 0;\\n        while (first < predecessor.length() && misMatches <= 1) \\n            if (predecessor[first] != word[second]) {\\n                second++;\\n                misMatches++;\\n            } else {\\n                first++;\\n                second++;\\n            }\\n        return misMatches <= 1;\\n        \\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), cmp);\\n        vector<int> lis(words.size(), 1);\\n        int ans = 1;\\n        for (int i = 1; i < words.size(); i++)\\n            for (int j = 0; j < i; j++) \\n                if (preceds(words[j], words[i])) {\\n                    lis[i] = max(lis[i], lis[j]+1);\\n                    ans = max(ans,lis[i]);                    \\n                }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string &first, string &second) {\\n        return first.length() < second.length();\\n    }    \\n\\n    bool preceds(string &predecessor, string &word) {\\n        if (predecessor.length() != word.length()-1)\\n            return false;\\n        int first = 0, second = 0, misMatches = 0;\\n        while (first < predecessor.length() && misMatches <= 1) \\n            if (predecessor[first] != word[second]) {\\n                second++;\\n                misMatches++;\\n            } else {\\n                first++;\\n                second++;\\n            }\\n        return misMatches <= 1;\\n        \\n    }\\n    \\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), cmp);\\n        vector<int> lis(words.size(), 1);\\n        int ans = 1;\\n        for (int i = 1; i < words.size(); i++)\\n            for (int j = 0; j < i; j++) \\n                if (preceds(words[j], words[i])) {\\n                    lis[i] = max(lis[i], lis[j]+1);\\n                    ans = max(ans,lis[i]);                    \\n                }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227367,
                "title": "simple-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    HashMap<String,Integer> hmp = new HashMap<>();\\n    HashSet<String> hst = new HashSet<>();\\n    private int dfs(String str) {\\n        if(str.length() == 0 || hst.contains(str) == false) return 0;\\n        if(hmp.get(str)!=null) return hmp.get(str);\\n        int temp = 0;\\n        for(int i=0;i<str.length();i++) {\\n            StringBuilder tmpStr = new StringBuilder(str);\\n            tmpStr.deleteCharAt(i);\\n            temp = Math.max(temp,1+dfs(tmpStr.toString()));\\n        }\\n        hmp.put(str,temp);\\n        return temp;\\n    }\\n    public int longestStrChain(String[] words) {\\n        int ans = 0;\\n        for(String str : words) {\\n            hst.add(str);\\n        }\\n        for(String str : words) {\\n            ans = Math.max(ans,dfs(str));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String,Integer> hmp = new HashMap<>();\\n    HashSet<String> hst = new HashSet<>();\\n    private int dfs(String str) {\\n        if(str.length() == 0 || hst.contains(str) == false) return 0;\\n        if(hmp.get(str)!=null) return hmp.get(str);\\n        int temp = 0;\\n        for(int i=0;i<str.length();i++) {\\n            StringBuilder tmpStr = new StringBuilder(str);\\n            tmpStr.deleteCharAt(i);\\n            temp = Math.max(temp,1+dfs(tmpStr.toString()));\\n        }\\n        hmp.put(str,temp);\\n        return temp;\\n    }\\n    public int longestStrChain(String[] words) {\\n        int ans = 0;\\n        for(String str : words) {\\n            hst.add(str);\\n        }\\n        for(String str : words) {\\n            ans = Math.max(ans,dfs(str));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098384,
                "title": "python-hashtable-dp",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        #hash table to store (word: length of longest possible word chain up to the word)\\n        ht={}\\n        \\n        #sort words by length first\\n        words.sort(key=lambda x: len(x))\\n\\n        for word in words:\\n            maxcnt=0\\n            for i in range(len(word)):\\n                \\n                #check if subsequence is in hash table\\n                if word[:i]+word[i+1:] in ht:\\n                    maxcnt=max(maxcnt, ht[word[:i]+word[i+1:]])\\n                    \\n            ht[word]=1+maxcnt\\n\\n        #return maximum length in the hashtable\\n        return max(ht.items(), key=lambda x: x[1])[1]\\n\\'\\'\\'\\n\\nTime complexity O(NC), C is the length of the longest word. Space complexity O(N) for hashtable",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        #hash table to store (word: length of longest possible word chain up to the word)\\n        ht={}",
                "codeTag": "Java"
            },
            {
                "id": 1090001,
                "title": "c-dynamic-programming-solution",
                "content": "1. Sort the input sequence by string length, keep the sequence in increasing order in terms of string length\\n2. Use a hash table, where the [key, value] pair is [string, the length of longest word chan this string participated in]\\n3. loop through the sorted sequence to build the hash table from the shortest string\\n4. For every input string, we try remove exactly one letter at index i from the string, where 0 <= i <string length\\n5. Check if the substring formed by the reset of letters exist in the table.\\n6. Keep track of the maximum length.\\n```\\nint longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](string &a, string &b){\\n            return (b.size() > a.size()) ? (true) : (false);\\n        });\\n        \\n        unordered_map<string, int> tbl;\\n        int ret = 1;\\n        for (auto s:words) {\\n            for (int i = 0; i < s.size(); i++) {\\n                string tmp = s.substr(0, i) + s.substr(i+1, s.size() - i);\\n                if (tbl.count(tmp))\\n                    tbl[s] = max(tbl[s], tbl[tmp] + 1);\\n            }\\n            tbl[s] = max(tbl[s], 1);\\n            ret = max(ret, tbl[s]);\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](string &a, string &b){\\n            return (b.size() > a.size()) ? (true) : (false);\\n        });\\n        \\n        unordered_map<string, int> tbl;\\n        int ret = 1;\\n        for (auto s:words) {\\n            for (int i = 0; i < s.size(); i++) {\\n                string tmp = s.substr(0, i) + s.substr(i+1, s.size() - i);\\n                if (tbl.count(tmp))\\n                    tbl[s] = max(tbl[s], tbl[tmp] + 1);\\n            }\\n            tbl[s] = max(tbl[s], 1);\\n            ret = max(ret, tbl[s]);\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 931142,
                "title": "98-03-time-python-dp-solution",
                "content": "This is an O(nm^2) time complexity solution (where n is the number of words in the input and m is the length of the largest word). \\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        words.sort(key = lambda x: len(x))        \\n        \\n        memo = {}\\n        global_max_len = -1\\n        \\n        for word in words:\\n            curr_max_len = 1\\n            for i in range(len(word)):\\n                word_minus_char = word[:i] + word[i+1:]\\n                if word_minus_char in memo:\\n                    curr_max_len = max(curr_max_len, memo[word_minus_char] + 1)\\n            memo[word] = curr_max_len\\n            global_max_len = max(global_max_len, curr_max_len)\\n                    \\n        \\n        return global_max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        \\n        words.sort(key = lambda x: len(x))        \\n        \\n        memo = {}\\n        global_max_len = -1\\n        \\n        for word in words:\\n            curr_max_len = 1\\n            for i in range(len(word)):\\n                word_minus_char = word[:i] + word[i+1:]\\n                if word_minus_char in memo:\\n                    curr_max_len = max(curr_max_len, memo[word_minus_char] + 1)\\n            memo[word] = curr_max_len\\n            global_max_len = max(global_max_len, curr_max_len)\\n                    \\n        \\n        return global_max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922140,
                "title": "c-lis-based-self-explanatory-code-and-easy-to-understand-dp",
                "content": "For those Struggling about the problem \\nPlease Solve \\n[300. Longest Increasing Subsequence Problem](https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isDifferByOne(string &a, string &b)\\n    {\\n      \\n      int i = 0, j = 0, counter = 0;\\n      \\n      while(i < a.size() and j < b.size())\\n      {\\n        if(a[i] == b[j])\\n        {\\n          i++; j++;\\n        }\\n        \\n        else\\n        { i++;  \\n         counter++; \\n        }\\n      }\\n      return (counter <= 1);\\n    }\\n  \\n    int longestStrChain(vector<string>& words) \\n    { \\n      int n = words.size();\\n      \\n      \\n      vector<int> dp(n, 1);\\n      int maxm = 0;\\n      \\n      sort(words.begin(), words.end(), [](string &s1, string &s2)\\n     {\\n       return s1.size() < s2.size();\\n     });\\n      \\n      for(int i = 0; i < n; i++) {\\n                \\n        for(int j = 0; j < i; j++)\\n        {             \\n          if(words[i].size() == 1 + words[j].size() and isDifferByOne(words[i], words[j]) && dp[i] < dp[j] + 1 )\\n            dp[i] = dp[j] + 1;\\n        }\\n        maxm = max(maxm, dp[i]);\\n      }\\n\\n      return maxm;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isDifferByOne(string &a, string &b)\\n    {\\n      \\n      int i = 0, j = 0, counter = 0;\\n      \\n      while(i < a.size() and j < b.size())\\n      {\\n        if(a[i] == b[j])\\n        {\\n          i++; j++;\\n        }\\n        \\n        else\\n        { i++;  \\n         counter++; \\n        }\\n      }\\n      return (counter <= 1);\\n    }\\n  \\n    int longestStrChain(vector<string>& words) \\n    { \\n      int n = words.size();\\n      \\n      \\n      vector<int> dp(n, 1);\\n      int maxm = 0;\\n      \\n      sort(words.begin(), words.end(), [](string &s1, string &s2)\\n     {\\n       return s1.size() < s2.size();\\n     });\\n      \\n      for(int i = 0; i < n; i++) {\\n                \\n        for(int j = 0; j < i; j++)\\n        {             \\n          if(words[i].size() == 1 + words[j].size() and isDifferByOne(words[i], words[j]) && dp[i] < dp[j] + 1 )\\n            dp[i] = dp[j] + 1;\\n        }\\n        maxm = max(maxm, dp[i]);\\n      }\\n\\n      return maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838617,
                "title": "swift-dp-solution",
                "content": "The key concept of DP is to cache previous work, here I used a Dictionay for that purpose.\\n\\n```\\nclass Solution {\\n    \\n    private func findSubstrings(_ word: String) -> [String] {\\n        var subStrings = [String]()\\n\\n        for removeIndex in 0..<word.count {\\n            var word = word\\n            word.remove(at: word.index(word.startIndex, offsetBy: removeIndex))\\n            subStrings.append(word)\\n        }\\n\\n        return subStrings\\n    }\\n\\n    func longestStrChain(_ words: [String]) -> Int {\\n        var map = Dictionary<String, Int>()\\n        var maxLength = 0, words = words.sorted()\\n\\n        for word in words {\\n            let subStrings = findSubstrings(word)\\n            var longest = 0\\n            for subString in subStrings {\\n                longest = max(longest, map[subString, default: 0] + 1)\\n            }\\n            map[word] = longest\\n            maxLength = max(maxLength, longest)\\n        }\\n        return maxLength\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private func findSubstrings(_ word: String) -> [String] {\\n        var subStrings = [String]()\\n\\n        for removeIndex in 0..<word.count {\\n            var word = word\\n            word.remove(at: word.index(word.startIndex, offsetBy: removeIndex))\\n            subStrings.append(word)\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 837638,
                "title": "python-simple-dp-faster-than-99",
                "content": "time complexity: O(N * M^2), where N is the number of words provided, and M is the length of the longest word.\\nReason for N * M^2:\\n* N - cost of outer loop\\n* M - cost of inner loop\\n* M - cost of string slicing\\n\\nspace complexity: O(N)\\n\\n```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        words.sort(key=len)\\n        graph = {}\\n        max_dist = 0\\n        for word in words:\\n            length = len(word)\\n            dist = 0\\n            for i in range(length):\\n                if (check := word[:i] + word[i+1:]) in graph:\\n                    dist = max(graph[check], dist)\\n                graph[word] = dist+1\\n                max_dist = max(max_dist, graph[word])\\n        return max_dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestStrChain(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        words.sort(key=len)\\n        graph = {}\\n        max_dist = 0\\n        for word in words:\\n            length = len(word)\\n            dist = 0\\n            for i in range(length):\\n                if (check := word[:i] + word[i+1:]) in graph:\\n                    dist = max(graph[check], dist)\\n                graph[word] = dist+1\\n                max_dist = max(max_dist, graph[word])\\n        return max_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820578,
                "title": "simple-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b){\\n        int count = 0;\\n        int index = 0;\\n        for(int i = 0 ; i < a.size() and index < b.size(); i++,index++){\\n            if(a[i] != b[index]){\\n                count++;\\n                i--;\\n            }\\n            if(count > 1) return false;\\n        }\\n        return count <= 1;\\n    }\\n    static bool comp(string a, string b){\\n        return a.size() < b.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int ans = 1;\\n        vector<int> dp(words.size(),1);\\n        sort(words.begin(),words.end(),comp);\\n        for(int i = 0 ; i < words.size() ; i++)\\n            for(int j = i - 1 ; j >= 0 and words[j].size() + 1 >= words[i].size() ; j--)\\n                if(words[j].size() == words[i].size() - 1)\\n                    if(check(words[j],words[i]))\\n                        dp[i] = max(dp[j] + 1,dp[i]);\\n        for(int i = 0 ; i < words.size() ; i++)\\n            ans = max(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b){\\n        int count = 0;\\n        int index = 0;\\n        for(int i = 0 ; i < a.size() and index < b.size(); i++,index++){\\n            if(a[i] != b[index]){\\n                count++;\\n                i--;\\n            }\\n            if(count > 1) return false;\\n        }\\n        return count <= 1;\\n    }\\n    static bool comp(string a, string b){\\n        return a.size() < b.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int ans = 1;\\n        vector<int> dp(words.size(),1);\\n        sort(words.begin(),words.end(),comp);\\n        for(int i = 0 ; i < words.size() ; i++)\\n            for(int j = i - 1 ; j >= 0 and words[j].size() + 1 >= words[i].size() ; j--)\\n                if(words[j].size() == words[i].size() - 1)\\n                    if(check(words[j],words[i]))\\n                        dp[i] = max(dp[j] + 1,dp[i]);\\n        for(int i = 0 ; i < words.size() ; i++)\\n            ans = max(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647248,
                "title": "dfs-with-memoization-use-delete-instead-of-add-character",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            map.put(word, 0);\\n        }\\n        \\n        int res = 0;\\n        for(String s : map.keySet()) {\\n            res = Math.max(res, dfs(s, map));\\n        }\\n        return res;    \\n    }\\n    \\n    private int dfs(String s, Map<String, Integer> map) {\\n        if(!map.containsKey(s)) return 0;\\n        if(map.get(s) != 0) return map.get(s);\\n        \\n        int res = 1;\\n        for(int j = 0; j < s.length(); j++) {\\n            StringBuilder sb = new StringBuilder(s);\\n            res = Math.max(res, 1 + dfs(sb.deleteCharAt(j).toString(), map));\\n        }\\n            \\n        map.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            map.put(word, 0);\\n        }\\n        \\n        int res = 0;\\n        for(String s : map.keySet()) {\\n            res = Math.max(res, dfs(s, map));\\n        }\\n        return res;    \\n    }\\n    \\n    private int dfs(String s, Map<String, Integer> map) {\\n        if(!map.containsKey(s)) return 0;\\n        if(map.get(s) != 0) return map.get(s);\\n        \\n        int res = 1;\\n        for(int j = 0; j < s.length(); j++) {\\n            StringBuilder sb = new StringBuilder(s);\\n            res = Math.max(res, 1 + dfs(sb.deleteCharAt(j).toString(), map));\\n        }\\n            \\n        map.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538369,
                "title": "java-99-runtime-solution",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<Integer, List<String>> lengthToWords = new HashMap<>();\\n        for (String word : words) {\\n            lengthToWords.putIfAbsent(word.length(), new ArrayList<>());\\n            lengthToWords.get(word.length()).add(word);\\n        }\\n        int max = 0;\\n        Map<String, Integer> seen = new HashMap<>();\\n        for (String word : words) {\\n            max = Math.max(max, longestStrChain(word, lengthToWords, seen));\\n        }\\n        return max;\\n    }\\n    \\n    private int longestStrChain(String word, Map<Integer, List<String>> lengthToWords, Map<String, Integer> seen) {\\n        if (!lengthToWords.containsKey(word.length() - 1)) return 1;\\n        if (seen.containsKey(word)) return seen.get(word);\\n        int max = 1;\\n        for (String curr : lengthToWords.get(word.length() - 1)) {\\n            if (!isPred(word, curr)) continue;\\n            max = Math.max(max, longestStrChain(curr, lengthToWords, seen) + 1);\\n        }\\n        seen.put(word, max);\\n        return max;\\n    }\\n    \\n    private boolean isPred(String word1, String word2) {\\n        for (int i = 0, j = 0, diff = 0; i < word1.length() && j < word2.length(); i++) {\\n            if (word1.charAt(i) == word2.charAt(j)) j++;\\n            else {\\n                diff++;\\n                if (diff > 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<Integer, List<String>> lengthToWords = new HashMap<>();\\n        for (String word : words) {\\n            lengthToWords.putIfAbsent(word.length(), new ArrayList<>());\\n            lengthToWords.get(word.length()).add(word);\\n        }\\n        int max = 0;\\n        Map<String, Integer> seen = new HashMap<>();\\n        for (String word : words) {\\n            max = Math.max(max, longestStrChain(word, lengthToWords, seen));\\n        }\\n        return max;\\n    }\\n    \\n    private int longestStrChain(String word, Map<Integer, List<String>> lengthToWords, Map<String, Integer> seen) {\\n        if (!lengthToWords.containsKey(word.length() - 1)) return 1;\\n        if (seen.containsKey(word)) return seen.get(word);\\n        int max = 1;\\n        for (String curr : lengthToWords.get(word.length() - 1)) {\\n            if (!isPred(word, curr)) continue;\\n            max = Math.max(max, longestStrChain(curr, lengthToWords, seen) + 1);\\n        }\\n        seen.put(word, max);\\n        return max;\\n    }\\n    \\n    private boolean isPred(String word1, String word2) {\\n        for (int i = 0, j = 0, diff = 0; i < word1.length() && j < word2.length(); i++) {\\n            if (word1.charAt(i) == word2.charAt(j)) j++;\\n            else {\\n                diff++;\\n                if (diff > 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442932,
                "title": "java-dp-solution-easy-to-understand",
                "content": "General DP idea is to store results of subproblem. In this case, the subproblem is the chain that can be formed ending at the current word, if any previously found word is a predecessor of the current word. At each index, store the longest known chain of words ending at that index. \\n\\nIn the end, just return the maximum value in the dp array, which means the max chain length found at any given point in the above process.\\n\\n```\\nclass Solution {\\n    \\n    private boolean isPred(String a, String b) {\\n        int diff = 0;\\n        if(a.length() != b.length()-1) return false;\\n        for(int i = 0 , j = 0;i<a.length() && j<b.length() ;) {\\n            if(a.charAt(i) == b.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                if(diff>0) return  false;\\n                diff++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    public int longestStrChain(String[] words) {\\n        int[] dp = new int[words.length];\\n        Integer max = Integer.MIN_VALUE;\\n        for(int i = 0;i<dp.length;i++) dp[i]=1;\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare(String s1, String s2) {\\n                return s1.length() - s2.length();\\n            }\\n        });\\n        for(int j = 1; j<words.length;j++) {\\n            for(int i = 0;i<j; i++) {\\n                if(isPred(words[i], words[j])) {\\n                    dp[j] = Math.max(dp[j], 1+dp[i]);\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n        }\\n        return Math.max(1, max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isPred(String a, String b) {\\n        int diff = 0;\\n        if(a.length() != b.length()-1) return false;\\n        for(int i = 0 , j = 0;i<a.length() && j<b.length() ;) {\\n            if(a.charAt(i) == b.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                if(diff>0) return  false;\\n                diff++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    public int longestStrChain(String[] words) {\\n        int[] dp = new int[words.length];\\n        Integer max = Integer.MIN_VALUE;\\n        for(int i = 0;i<dp.length;i++) dp[i]=1;\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare(String s1, String s2) {\\n                return s1.length() - s2.length();\\n            }\\n        });\\n        for(int j = 1; j<words.length;j++) {\\n            for(int i = 0;i<j; i++) {\\n                if(isPred(words[i], words[j])) {\\n                    dp[j] = Math.max(dp[j], 1+dp[i]);\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n        }\\n        return Math.max(1, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417306,
                "title": "python-dp-solutions",
                "content": "We sort the words by length, then it becomes a problem like LIS.\\n```python\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def predecessor(word1, word2):\\n            if len(word2) - len(word1) != 1:\\n                return False\\n            diff_distance = 0\\n            i = j = 0\\n            while i < len(word1):\\n                if word1[i] != word2[j]:\\n                    if diff_distance:\\n                        return False\\n                    diff_distance = 1\\n                    j += 1\\n                else:\\n                    i += 1\\n                    j += 1\\n            return True\\n                    \\n\\t\\twords = sorted(words,key=lambda x:len(x))\\n        dp = [1]*len(words)\\n        for i in range(len(words)):\\n            for j in range(i):\\n                if predecessor(words[j],words[i]):\\n                    dp[i] = max(dp[j]+1,dp[i])\\n        return max(dp)\\n```\\nUse hashmap to reduce time complexity.\\n```python\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words = sorted(words,key=lambda x:len(x))\\n        dp = [1]*len(words)\\n        record = {}\\n        for i, word in enumerate(words):\\n            for j in range(len(word)):\\n                predecessor = word[:j]+word[j+1:]\\n                if predecessor in record:\\n                    dp[i] = max(dp[record[predecessor]]+1,dp[i])\\n            record[word] = i\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def predecessor(word1, word2):\\n            if len(word2) - len(word1) != 1:\\n                return False\\n            diff_distance = 0\\n            i = j = 0\\n            while i < len(word1):\\n                if word1[i] != word2[j]:\\n                    if diff_distance:\\n                        return False\\n                    diff_distance = 1\\n                    j += 1\\n                else:\\n                    i += 1\\n                    j += 1\\n            return True\\n                    \\n\\t\\twords = sorted(words,key=lambda x:len(x))\\n        dp = [1]*len(words)\\n        for i in range(len(words)):\\n            for j in range(i):\\n                if predecessor(words[j],words[i]):\\n                    dp[i] = max(dp[j]+1,dp[i])\\n        return max(dp)\\n```\n```python\\n    def longestStrChain(self, words: List[str]) -> int:\\n        words = sorted(words,key=lambda x:len(x))\\n        dp = [1]*len(words)\\n        record = {}\\n        for i, word in enumerate(words):\\n            for j in range(len(word)):\\n                predecessor = word[:j]+word[j+1:]\\n                if predecessor in record:\\n                    dp[i] = max(dp[record[predecessor]]+1,dp[i])\\n            record[word] = i\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 399538,
                "title": "java-trie-solution-18ms-97-runtime-100-space",
                "content": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] map;\\n        int length;\\n        public TrieNode() {\\n            map = new TrieNode[26];\\n            length = 0;\\n        }\\n    }\\n    public int longestStrChain(String[] words) {\\n        int maxWordLength = 0;\\n        Map<Integer, Set<String>> map = new HashMap<>();\\n        for(String word: words) {\\n            int length = word.length();\\n            if(!map.containsKey(length)) {\\n                maxWordLength = Math.max(maxWordLength, length);\\n                map.put(length, new HashSet<String>());\\n            }\\n            map.get(length).add(word);\\n        }\\n        int max = 0;\\n        TrieNode root = new TrieNode();\\n        for(int len = 1; len <= maxWordLength; len++) {\\n            if(!map.containsKey(len)) {\\n                continue;\\n            }\\n            Set<String> set = map.get(len);\\n            for(String str: set) {\\n                //check if previous word exists in trie\\n                char[] strArr = str.toCharArray();\\n                int prevLen = find(root, strArr, 0, false);\\n                TrieNode current = root;\\n                for(char c: strArr) {\\n                    if(current.map[c - \\'a\\'] == null) {\\n                        current.map[c - \\'a\\'] = new TrieNode();\\n                    }\\n                    current = current.map[c - \\'a\\'];\\n                }\\n                max = Math.max(max, (current.length = prevLen + 1));\\n            }\\n        }\\n        return max;\\n    }\\n    int find(TrieNode root, char[]str, int index, boolean hasSeen) {\\n        if(index == str.length) {\\n            return root.length;\\n        } else if(root == null) {\\n            return 0;\\n        } else if(root.map[str[index] - \\'a\\'] == null) {\\n            if(hasSeen) {\\n                return 0;\\n            } else {\\n                return find(root, str, index+1, true);\\n            }\\n        }\\n        int straightPath = find(root.map[str[index] - \\'a\\'], str, index+1, hasSeen);\\n        return straightPath == 0 ? find(root, str, index+1, true) : straightPath;\\n    }\\n}\\n```\\n\\n**Explanation**\\n1. Create a map to bucket sort strings by length.\\n2. Iterating from 1 to maximum length (which is 16 for this problem), see if previous word is in Trie.\\n3. Add the new word to the Trie - with `length 1` if a previous word wasn\\'t found, or `length previous+1` if it has. Store the length at the tail TrieNode of the word.\\n4. If the current length is bigger than max, update max.\\n\\n**Complexity**\\n- Time: `O(N * S^2)`\\n- Space: `O(N * S)`\\n\\n**Advantage of this Method**\\n- In the average, reasonable case, the DFS of the Trie shouldn\\'t branch out multipe times, and will be much closer to `O(S)` per run. There will always be exactly `N distinct` additions of `size S`, making the average case complexity realistically closer to `O(N * S)`.\\n- This method is adventagous over other `Java` solutions due to the nature of Java\\'s poor String manipulation due to the immutability property of Strings, which realistically make the comparisons in the most popular method `O(S)` for each concat, with `O(S)` concats and `O(N)` words, totalling `O(N * S^2)`.\\n\\n**Disadvantage of this Method**\\n- As previously stated, this algorithm\\'s `worst case` time complexity is `O(N * S^2)`. The worst case is if there are 1000 16 letter words that are as different as possible (of course they all can\\'t be distinct as there are only 26 letters, but this can still get very bad).\\n- The spacial complexity is `strictly worse` for this method, and can also get very bad due to the nature of creating an object that wraps an array for each \\'letter\\' of the tree. Luckily, the maximum size of these arrays is 26 characters, which is slightly above 26 bytes overall.",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] map;\\n        int length;\\n        public TrieNode() {\\n            map = new TrieNode[26];\\n            length = 0;\\n        }\\n    }\\n    public int longestStrChain(String[] words) {\\n        int maxWordLength = 0;\\n        Map<Integer, Set<String>> map = new HashMap<>();\\n        for(String word: words) {\\n            int length = word.length();\\n            if(!map.containsKey(length)) {\\n                maxWordLength = Math.max(maxWordLength, length);\\n                map.put(length, new HashSet<String>());\\n            }\\n            map.get(length).add(word);\\n        }\\n        int max = 0;\\n        TrieNode root = new TrieNode();\\n        for(int len = 1; len <= maxWordLength; len++) {\\n            if(!map.containsKey(len)) {\\n                continue;\\n            }\\n            Set<String> set = map.get(len);\\n            for(String str: set) {\\n                //check if previous word exists in trie\\n                char[] strArr = str.toCharArray();\\n                int prevLen = find(root, strArr, 0, false);\\n                TrieNode current = root;\\n                for(char c: strArr) {\\n                    if(current.map[c - \\'a\\'] == null) {\\n                        current.map[c - \\'a\\'] = new TrieNode();\\n                    }\\n                    current = current.map[c - \\'a\\'];\\n                }\\n                max = Math.max(max, (current.length = prevLen + 1));\\n            }\\n        }\\n        return max;\\n    }\\n    int find(TrieNode root, char[]str, int index, boolean hasSeen) {\\n        if(index == str.length) {\\n            return root.length;\\n        } else if(root == null) {\\n            return 0;\\n        } else if(root.map[str[index] - \\'a\\'] == null) {\\n            if(hasSeen) {\\n                return 0;\\n            } else {\\n                return find(root, str, index+1, true);\\n            }\\n        }\\n        int straightPath = find(root.map[str[index] - \\'a\\'], str, index+1, hasSeen);\\n        return straightPath == 0 ? find(root, str, index+1, true) : straightPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383298,
                "title": "simple-python-solution",
                "content": "Pretty simple, O(nlogn) because of the sorting, O(n * k) because of individual letter scan (k=length of a word)\\n\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = collections.defaultdict(int)\\n        words.sort(key=lambda x:len(x))\\n        for w in words:\\n            dp[w] = 1\\n            for i in range(len(w)):\\n                newW = w[:i]+w[i+1:]\\n                if newW in dp:\\n                    dp[w] = max(dp[w],dp[newW]+1)\\n                \\n            \\n        return max(dp.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp = collections.defaultdict(int)\\n        words.sort(key=lambda x:len(x))\\n        for w in words:\\n            dp[w] = 1\\n            for i in range(len(w)):\\n                newW = w[:i]+w[i+1:]\\n                if newW in dp:\\n                    dp[w] = max(dp[w],dp[newW]+1)\\n                \\n            \\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295704,
                "title": "dp-c-readable-implementation",
                "content": "```\\n public static int LongestStrChain(string[] words)\\n        {\\n            var dic = new Dictionary<string, int>();\\n            foreach (var word in words.OrderBy(w => w.Length))\\n                for (int i = 0; i < word.Length; i++)\\n                {\\n                    string word2 = word.Remove(i,1);\\n                    dic[word] = Math.Max(dic.ContainsKey(word) ? dic[word] : 1,\\n                        dic.ContainsKey(word2) ? dic[word2] + 1 : 1);\\n                }\\n\\n            return dic.Values.Max();\\n        }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n public static int LongestStrChain(string[] words)\\n        {\\n            var dic = new Dictionary<string, int>();\\n            foreach (var word in words.OrderBy(w => w.Length))\\n                for (int i = 0; i < word.Length; i++)\\n                {\\n                    string word2 = word.Remove(i,1);\\n                    dic[word] = Math.Max(dic.ContainsKey(word) ? dic[word] : 1,\\n                        dic.ContainsKey(word2) ? dic[word2] + 1 : 1);\\n                }\\n\\n            return dic.Values.Max();\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295409,
                "title": "java-topological-sort-with-a-graph-faster-than-dp",
                "content": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Set<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        Map<String, Set<String>> map = new HashMap<>();\\n        \\n        for(String s : words){\\n            if(map.containsKey(s)) continue;\\n            map.put(s, new HashSet<>());\\n            Set<String> nodes = map.get(s);\\n            StringBuilder sb = null;\\n            \\n            for(int i = 0; i <= s.length(); ++i){\\n                for(char c = \\'a\\'; c <= \\'z\\'; ++c){\\n                    sb = new StringBuilder(s);\\n                    sb.insert(i, c);\\n                    String k = sb.toString();\\n                    if(wordSet.contains(k)){\\n                        nodes.add(sb.toString());\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        Map<String, Integer> inDegree = new HashMap<>();\\n        for(String k : map.keySet()){\\n            Set<String> nodes = map.get(k);\\n            for(String q : nodes){\\n                inDegree.put(q, inDegree.getOrDefault(q, 0) + 1);\\n            }\\n        }\\n        \\n        Queue<String> q = new LinkedList<>();\\n        for(String str : words){\\n            if(!inDegree.containsKey(str)){\\n                q.offer(str);\\n            }\\n        }\\n        \\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; ++i){\\n                String str = q.poll();\\n                for(String next : map.get(str)){\\n                    inDegree.put(next, inDegree.get(next) - 1);\\n                    if(inDegree.get(next) == 0){\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        \\n        \\n        return level;\\n    }\\n}\\n```\\n\\nEffectively this is a graph problem,  I know the dynamic programming solution exists but here is another perspective. This is faster than the dynamic programming solution (494 ms vs 600 ms).\\n\\n\\nThe idea is to build a graph then do a topological sort, clearly this works because we have a directed acyclic graph structure and we need to find the longest path in this DAG. The way to find a longest path in a DAG is to do a topological sort using indegree breadth first search. Hope you like this solution!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Set<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        Map<String, Set<String>> map = new HashMap<>();\\n        \\n        for(String s : words){\\n            if(map.containsKey(s)) continue;\\n            map.put(s, new HashSet<>());\\n            Set<String> nodes = map.get(s);\\n            StringBuilder sb = null;\\n            \\n            for(int i = 0; i <= s.length(); ++i){\\n                for(char c = \\'a\\'; c <= \\'z\\'; ++c){\\n                    sb = new StringBuilder(s);\\n                    sb.insert(i, c);\\n                    String k = sb.toString();\\n                    if(wordSet.contains(k)){\\n                        nodes.add(sb.toString());\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        Map<String, Integer> inDegree = new HashMap<>();\\n        for(String k : map.keySet()){\\n            Set<String> nodes = map.get(k);\\n            for(String q : nodes){\\n                inDegree.put(q, inDegree.getOrDefault(q, 0) + 1);\\n            }\\n        }\\n        \\n        Queue<String> q = new LinkedList<>();\\n        for(String str : words){\\n            if(!inDegree.containsKey(str)){\\n                q.offer(str);\\n            }\\n        }\\n        \\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; ++i){\\n                String str = q.poll();\\n                for(String next : map.get(str)){\\n                    inDegree.put(next, inDegree.get(next) - 1);\\n                    if(inDegree.get(next) == 0){\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        \\n        \\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295008,
                "title": "python-graph-dfs",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def dfs(w1, size):\\n            return max([dfs(w2, size + 1) for w2 in graph[w1]], default = size)\\n        graph = collections.defaultdict(list)\\n        for w in words:\\n            graph[len(w)].append(w)\\n        for w1 in words:\\n            for w2 in graph[len(w1) + 1]:\\n                for i in range(len(w2)):\\n                    if w2[:i] + w2[i + 1:] == w1:\\n                        graph[w1].append(w2)\\n        return max(dfs(w, 1) for w in words)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        def dfs(w1, size):\\n            return max([dfs(w2, size + 1) for w2 in graph[w1]], default = size)\\n        graph = collections.defaultdict(list)\\n        for w in words:\\n            graph[len(w)].append(w)\\n        for w1 in words:\\n            for w2 in graph[len(w1) + 1]:\\n                for i in range(len(w2)):\\n                    if w2[:i] + w2[i + 1:] == w1:\\n                        graph[w1].append(w2)\\n        return max(dfs(w, 1) for w in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294905,
                "title": "java-dp",
                "content": "View this problem as: \\nIn each step, remove one letter from any word such that doing so produces another word which is present in the array.\\nWe have to figure out the longest possible chain of such steps.\\n\\nExample :  (ba)---remove a--->(b) {Length :1}\\n              (bca) --- remove c--->(ba) {length:2}.. so on\\n\\n```\\npublic int longestStrChain(String[] words) {\\n        Map<String,Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(words));\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        int max = Integer.MIN_VALUE;\\n        for(String s : words) {\\n            if(s.length()>1) {\\n                int len = util(s,map,set);\\n                max = Math.max(max,len);\\n            } else {\\n                map.put(s,1);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int util(String S,Map<String,Integer> map,Set<String> set) {\\n\\n        if(map.containsKey(S)) {\\n            return map.get(S);\\n        }\\n        int max=0;\\n        for(int i=0;i<S.length();i++) {\\n            String next = S.substring(0,i)+S.substring(i+1);\\n            if(set.contains(next)) {\\n                max = Math.max(max,util(next,map,set));\\n            }\\n        }\\n        map.put(S,max+1);\\n        return max+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestStrChain(String[] words) {\\n        Map<String,Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(words));\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        int max = Integer.MIN_VALUE;\\n        for(String s : words) {\\n            if(s.length()>1) {\\n                int len = util(s,map,set);\\n                max = Math.max(max,len);\\n            } else {\\n                map.put(s,1);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int util(String S,Map<String,Integer> map,Set<String> set) {\\n\\n        if(map.containsKey(S)) {\\n            return map.get(S);\\n        }\\n        int max=0;\\n        for(int i=0;i<S.length();i++) {\\n            String next = S.substring(0,i)+S.substring(i+1);\\n            if(set.contains(next)) {\\n                max = Math.max(max,util(next,map,set));\\n            }\\n        }\\n        map.put(S,max+1);\\n        return max+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080755,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, approach and complexity discussed in detail in video solution\\nhttps://youtu.be/5r30UDyPuoM\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& str1, const string& str2)->bool{\\n            return str1.size() < str2.size();\\n        });\\n        unordered_map<string, int> chainLen;\\n        int maxLen = 0;\\n        for (string & word : words) {\\n            for (int indx = 0; indx < word.size(); indx++) {\\n                string pred = word.substr(0, indx) + word.substr(indx + 1);\\n                chainLen[word] = max(chainLen[word], chainLen.find(pred) == chainLen.end() ? 1 : chainLen[pred] + 1);\\n            }\\n            maxLen = max(maxLen, chainLen[word]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b)-> a.length() - b.length());\\n        HashMap<String, Integer> chainLen = new HashMap<>();\\n        int maxLen = 0;\\n        for (var word : words) {\\n            for (int indx = 0; indx < word.length(); indx++) {\\n                String pred = word.substring(0, indx) + word.substring(indx + 1);\\n                chainLen.put(word, Math.max(chainLen.getOrDefault(word, 0), (!chainLen.containsKey(pred)) ? 1 : chainLen.get(pred) + 1));\\n            }\\n            maxLen = Math.max(maxLen, chainLen.get(word));\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& str1, const string& str2)->bool{\\n            return str1.size() < str2.size();\\n        });\\n        unordered_map<string, int> chainLen;\\n        int maxLen = 0;\\n        for (string & word : words) {\\n            for (int indx = 0; indx < word.size(); indx++) {\\n                string pred = word.substr(0, indx) + word.substr(indx + 1);\\n                chainLen[word] = max(chainLen[word], chainLen.find(pred) == chainLen.end() ? 1 : chainLen[pred] + 1);\\n            }\\n            maxLen = max(maxLen, chainLen[word]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Arrays.sort(words, (a, b)-> a.length() - b.length());\\n        HashMap<String, Integer> chainLen = new HashMap<>();\\n        int maxLen = 0;\\n        for (var word : words) {\\n            for (int indx = 0; indx < word.length(); indx++) {\\n                String pred = word.substring(0, indx) + word.substring(indx + 1);\\n                chainLen.put(word, Math.max(chainLen.getOrDefault(word, 0), (!chainLen.containsKey(pred)) ? 1 : chainLen.get(pred) + 1));\\n            }\\n            maxLen = Math.max(maxLen, chainLen.get(word));\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079803,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }\\n            }\\n            ans = Math.max(ans,hp.get(s));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }\\n            }\\n            ans = Math.max(ans,hp.get(s));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079779,
                "title": "hindi-explanations-jano-intuition-in-easy-lang",
                "content": "# Intuition\\nit is clear from question statement that in string chain we will add next word if it has same chars as previous and one char that is diff from previous chars can be added anywhere.\\ntoh apn sort kr lete by length.jisse hmara search path km ho jayega and efficient bhi ho jayega.\\nnow, chain kisi bhi position se start ho skti hai toh we have call memo func from every pos and store the max ans. in memo func just check that is both words are vaild for chain if yss search for next word that can be added to chain.\\nhn ans+1 kr rhe cuz in this soln we r counting words pairs like a,b,c words me we r adding 1 for a,b and 1 for b,c so we have to add one to get exact ans;\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1000]; // An array to memoize intermediate results\\n\\n    // A static comparison function for sorting words by length\\n    static bool mysort(string &a, string &b) {\\n        return a.length() < b.length();\\n    }\\n\\n    // Function to check if two strings can form a valid chain\\n    bool check(string &a, string &b) {\\n        if (a.length() != b.length() - 1) return false;\\n        int count = 0;\\n        int i = 0, j = 0;\\n        while (i < a.length() && j < b.length()) {\\n            if (a[i] != b[j]) {\\n                if (count == 1) return false;\\n                count = 1;\\n            } else {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return true;\\n    }\\n\\n    // Recursive memoization function to find the longest chain\\n    int memo(int i, vector<string> &words, int n) {\\n        if (i >= n) return 0; // Base case: If we are out of words, return 0\\n        if (dp[i] != -1) return dp[i]; // If result is already memoized, return it\\n        int ans = 0;\\n        for (int j = i + 1; j < n; j++) {\\n            if (check(words[i], words[j])) {\\n                ans = max(ans, 1 + memo(j, words, n)); // Recursively find chain length\\n            }\\n        }\\n        return dp[i] = ans; // Memoize and return the result\\n    }\\n\\n    // Main function to find the length of the longest string chain\\n    int longestStrChain(vector<string> &words) {\\n        sort(words.begin(), words.end(), mysort); // Sort words by length\\n        int n = words.size();\\n        int ans = 0; // Initialize the maximum chain length to 0\\n\\n        // Iterate through each word and find the maximum chain length\\n        for (int i = 0; i < n; i++) {\\n            memset(dp, -1, sizeof dp); // Initialize the memoization array\\n            ans = max(ans, memo(i, words, n)); // Update the maximum chain length\\n        }\\n        return ans + 1; // Return the length of the longest chain\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1000]; // An array to memoize intermediate results\\n\\n    // A static comparison function for sorting words by length\\n    static bool mysort(string &a, string &b) {\\n        return a.length() < b.length();\\n    }\\n\\n    // Function to check if two strings can form a valid chain\\n    bool check(string &a, string &b) {\\n        if (a.length() != b.length() - 1) return false;\\n        int count = 0;\\n        int i = 0, j = 0;\\n        while (i < a.length() && j < b.length()) {\\n            if (a[i] != b[j]) {\\n                if (count == 1) return false;\\n                count = 1;\\n            } else {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return true;\\n    }\\n\\n    // Recursive memoization function to find the longest chain\\n    int memo(int i, vector<string> &words, int n) {\\n        if (i >= n) return 0; // Base case: If we are out of words, return 0\\n        if (dp[i] != -1) return dp[i]; // If result is already memoized, return it\\n        int ans = 0;\\n        for (int j = i + 1; j < n; j++) {\\n            if (check(words[i], words[j])) {\\n                ans = max(ans, 1 + memo(j, words, n)); // Recursively find chain length\\n            }\\n        }\\n        return dp[i] = ans; // Memoize and return the result\\n    }\\n\\n    // Main function to find the length of the longest string chain\\n    int longestStrChain(vector<string> &words) {\\n        sort(words.begin(), words.end(), mysort); // Sort words by length\\n        int n = words.size();\\n        int ans = 0; // Initialize the maximum chain length to 0\\n\\n        // Iterate through each word and find the maximum chain length\\n        for (int i = 0; i < n; i++) {\\n            memset(dp, -1, sizeof dp); // Initialize the memoization array\\n            ans = max(ans, memo(i, words, n)); // Update the maximum chain length\\n        }\\n        return ans + 1; // Return the length of the longest chain\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079737,
                "title": "python3-dp-sorting-time-96-22-space-93-85-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        res = 1\\n        words.sort(key=lambda x:len(x))\\n        dp = {word:1 for word in words}\\n\\n        for i in range(1,len(words)):\\n            w = words[i]\\n            for j in range(len(w)):\\n                if w[:j]+w[j+1:] in dp:\\n                    dp[w] = max(dp[w], 1 + dp[w[:j]+w[j+1:]])\\n            res = max(res,dp[w])\\n\\n        return res\\n\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Upvote :)\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        res = 1\\n        words.sort(key=lambda x:len(x))\\n        dp = {word:1 for word in words}\\n\\n        for i in range(1,len(words)):\\n            w = words[i]\\n            for j in range(len(w)):\\n                if w[:j]+w[j+1:] in dp:\\n                    dp[w] = max(dp[w], 1 + dp[w[:j]+w[j+1:]])\\n            res = max(res,dp[w])\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079634,
                "title": "java-easy-to-understand-use-map-stream-and-regex",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        words = Arrays.stream(words)\\n            .sorted(Comparator.comparingInt(String::length))\\n            .toArray(String[]::new);\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            int k = 1;\\n            for (Map.Entry<String, Integer> tail : map.entrySet()) {\\n                if (isPredecessor(word, tail.getKey())) {\\n                    k = Math.max(k, tail.getValue() + 1);\\n                }\\n            }\\n            map.put(word, k);\\n        }\\n        return map.values().stream().mapToInt(i -> i).max().orElse(0);\\n    }\\n    private boolean isPredecessor(String str, String substr) {\\n        if (str.length() != substr.length() + 1) {\\n            return false;\\n        }\\n        String regex = substr.chars()\\n            .mapToObj(c -> String.valueOf((char) c))\\n            .collect(Collectors.joining(\".?\", \".?\", \".?\"));\\n        return str.matches(regex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        words = Arrays.stream(words)\\n            .sorted(Comparator.comparingInt(String::length))\\n            .toArray(String[]::new);\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            int k = 1;\\n            for (Map.Entry<String, Integer> tail : map.entrySet()) {\\n                if (isPredecessor(word, tail.getKey())) {\\n                    k = Math.max(k, tail.getValue() + 1);\\n                }\\n            }\\n            map.put(word, k);\\n        }\\n        return map.values().stream().mapToInt(i -> i).max().orElse(0);\\n    }\\n    private boolean isPredecessor(String str, String substr) {\\n        if (str.length() != substr.length() + 1) {\\n            return false;\\n        }\\n        String regex = substr.chars()\\n            .mapToObj(c -> String.valueOf((char) c))\\n            .collect(Collectors.joining(\".?\", \".?\", \".?\"));\\n        return str.matches(regex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079580,
                "title": "bfs-c-solution",
                "content": "Here\\'s a simple BFS solution.\\n1. sort the string array.\\n2. Iterate with max length string.\\n*     push string to queue\\n*     check all possible combination by removing character one by one and if it exist in the array\\n*     if exist push it in queue \\n3. count the number of iteration you have to do for BFS\\nthat will be the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [&](const string &a, const string &b) {\\n            return a.length() < b.length();\\n        });\\n        int N = words.size();\\n        unordered_set<string> s(words.begin(), words.end());\\n        unordered_set<string> visited;\\n        int ans = 0;\\n        for(int i = N-1;i>=0;i--)\\n        {\\n            if(visited.find(words[i]) == visited.end()) {\\n                queue<string> Q;\\n                Q.push(words[i]);\\n                visited.insert(words[i]);\\n                int count = 0;\\n                while(!Q.empty())\\n                {\\n                    int sz = Q.size();\\n                    while(sz--)\\n                    {\\n                        string str = Q.front();\\n                        //cout<<str<<\" \";\\n                        Q.pop();\\n                        for(int j=0;j<str.length();j++)\\n                        {\\n                            string temp = str;\\n                            temp.erase(j, 1);\\n                            if(s.find(temp) != s.end() && visited.find(temp) == visited.end())\\n                            {\\n                                Q.push(temp);\\n                                visited.insert(temp);\\n                            }\\n                        }\\n                    }\\n                    count++;\\n                    ans = max(ans, count);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), [&](const string &a, const string &b) {\\n            return a.length() < b.length();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4079029,
                "title": "best-java-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // taken some help\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }\\n            }\\n            ans = Math.max(ans,hp.get(s));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // taken some help\\n    public int longestStrChain(String[] arr) {\\n        Arrays.sort(arr,(a,b)->a.length()-b.length());\\n\\n        HashMap<String,Integer> hp = new HashMap<>();\\n\\n        int ans = 0;\\n\\n        for(String s : arr){\\n            hp.put(s,1);\\n            for(int i=0; i<s.length(); i++){\\n                String str = s.substring(0,i)+s.substring(i+1);\\n\\n                if(hp.containsKey(str)){\\n                    hp.put(s,Math.max(hp.get(s),hp.get(str)+1));\\n                }\\n            }\\n            ans = Math.max(ans,hp.get(s));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078741,
                "title": "dart",
                "content": "# Code\\n```\\nimport \\'dart:collection\\';\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int longestStrChain(List<String> words) {\\n    final hashmap = HashMap<String, int>();\\n    for (final s in words) hashmap[s] = -1;\\n    \\n    int dfs(String s) {\\n      var prev = hashmap[s];\\n      if (prev == null) return 0;\\n      if (prev == -1) {\\n        prev = 1;\\n        for (int i = 0; i < s.length; i++) {\\n          final t = s.substring(0, i) + s.substring(i + 1);\\n          prev = max(prev!, 1 + dfs(t));\\n        }\\n        hashmap[s] = prev!;\\n      }\\n      return prev;\\n    }\\n    var res = 0;\\n    for (final s in words)\\n      res = max(res, dfs(s));\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int longestStrChain(List<String> words) {\\n    final hashmap = HashMap<String, int>();\\n    for (final s in words) hashmap[s] = -1;\\n    \\n    int dfs(String s) {\\n      var prev = hashmap[s];\\n      if (prev == null) return 0;\\n      if (prev == -1) {\\n        prev = 1;\\n        for (int i = 0; i < s.length; i++) {\\n          final t = s.substring(0, i) + s.substring(i + 1);\\n          prev = max(prev!, 1 + dfs(t));\\n        }\\n        hashmap[s] = prev!;\\n      }\\n      return prev;\\n    }\\n    var res = 0;\\n    for (final s in words)\\n      res = max(res, dfs(s));\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078703,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp={}\\n        for word in sorted(words,key=len):\\n            temp=[0]\\n            n=len(word)\\n            for i in range(n):\\n                if word[:i]+word[i+1:] in dp:\\n                    temp.append(dp[word[:i]+word[i+1:]])\\n                dp[word]=max(temp)+1\\n        return max(dp.values())                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        dp={}\\n        for word in sorted(words,key=len):\\n            temp=[0]\\n            n=len(word)\\n            for i in range(n):\\n                if word[:i]+word[i+1:] in dp:\\n                    temp.append(dp[word[:i]+word[i+1:]])\\n                dp[word]=max(temp)+1\\n        return max(dp.values())                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078607,
                "title": "well-commented-python-code-sort-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        # store { word : maxlen } in dp\\n        # word will be used to track predecessor later on\\n        dp = {}\\n        W = sorted(words, key = len) \\n        # sorting based on length\\n\\n        for w in W:\\n            dp[w] = 1\\n            # initialize\\n            for i in range(len(w)):\\n                # for each position of w, skip one\\n                # (to find its possible predecessor)\\n                # and check if it is available in dp.\\n                prv = w[:i] + w[i+1:]\\n                if prv in dp:\\n                    # predecessor of w was found!!\\n                    # update dp value\\n                    dp[w] = max(dp[prv] + 1, dp[w])\\n        \\n        # return max of all possible values in dp\\n        return max(dp.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        # store { word : maxlen } in dp\\n        # word will be used to track predecessor later on\\n        dp = {}\\n        W = sorted(words, key = len) \\n        # sorting based on length\\n\\n        for w in W:\\n            dp[w] = 1\\n            # initialize\\n            for i in range(len(w)):\\n                # for each position of w, skip one\\n                # (to find its possible predecessor)\\n                # and check if it is available in dp.\\n                prv = w[:i] + w[i+1:]\\n                if prv in dp:\\n                    # predecessor of w was found!!\\n                    # update dp value\\n                    dp[w] = max(dp[prv] + 1, dp[w])\\n        \\n        # return max of all possible values in dp\\n        return max(dp.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078585,
                "title": "java-4ms-100-arrays-and-optimizations-recursion-with-memorization",
                "content": "```\\nclass Solution {\\n    static final int LONGEST_WORD_LEN = 16;\\n    \\n    public int longestStrChain(String[] words) {\\n        // Calculate number of strings of each length;\\n        int longestCount = 0;\\n        int[] lenCounts = new int[LONGEST_WORD_LEN + 1];\\n        for (int i = words.length - 1; i >= 0; i--)\\n            longestCount = Math.max(longestCount, ++lenCounts[words[i].length()]);\\n        \\n        // Build an array that for each string length, has an array of indexes to words of that  \\n        // length.  Copy the words from the words[] array into the wcs[][] array.  The array wcs \\n        // is indexed by: wcs[string len][index of words of same len].  The wcs[len][0] value is \\n        // the number of words of that same length that are stored in wcs[len].\\n        int maxWordLen = 0;\\n        for (maxWordLen = LONGEST_WORD_LEN; maxWordLen >= 0 && lenCounts[maxWordLen] == 0; maxWordLen--)  { }\\n        short[][] wcs = new short[maxWordLen + 1][longestCount + 1];\\n        for (int i = words.length - 1; i >= 0; i--) {\\n            int len = words[i].length();\\n            wcs[len][++wcs[len][0]] = (short)i;\\n        }\\n        \\n        // Create an uninitialized memorization value for each word now stored as char[] arrays in wcs[][][].\\n        byte[][] memo = new byte[maxWordLen + 1][longestCount + 1];\\n\\n        // Start with the longest words and search backward (longest word to shortest word) to find the \\n        // longest string chain.  Stop searching if the longest string chain found if longer or same \\n        // length as the current word (words are processed longest to shortest), because a longer chain \\n        // is not possible.\\n        int longestFound = 1;\\n        for (int len = maxWordLen; len > 1 && len > longestFound; len--)\\n            for (int wordIdx = wcs[len][0]; wordIdx >= 1 && len > longestFound; wordIdx--)\\n                longestFound = Math.max(longestFound, findPath(len, wordIdx, wcs, memo, words));\\n        return longestFound;\\n    }\\n    \\n    \\n    // Recursively try to find a path from a word (specified by its length and its index into words of \\n    // the same length) backward through predecessors, by comparing the word to all words that are one \\n    // character shorter.  Find the longest path from this word backward through shorter words.  Memorize \\n    // the longest path from a word, so we don\\'t have to recalculate it if we try to find the path from \\n    // this word again.\\n    private int findPath(int len, int wordIdx, short[][] wcs, byte[][] memo, String[] words) {\\n        if (len == 1)  return 1;\\n        if (memo[len][wordIdx] > 0)  return memo[len][wordIdx];\\n        String curWord = words[wcs[len][wordIdx]];\\n        int longest = 0;\\n        for (int predIdx = wcs[len - 1][0]; predIdx >= 1 && longest + 1 < len; predIdx--)\\n            if (isPredecessor(curWord, words[wcs[len - 1][predIdx]]))\\n                longest = Math.max(longest, findPath(len - 1, predIdx, wcs, memo, words));\\n        memo[len][wordIdx] = (byte)(longest + 1);\\n        return longest + 1;\\n    }\\n    \\n    \\n    // Given two words as Strings, test the second word to see if it is a predecessor of the first word.  \\n    // It is a predecessor if the second word differs from the first word by having exactly one character \\n    // in the first word that does not match the characters in the second word.  The first word will be one \\n    // character longer than the second word.  The second word is a predecessor if deleting one character \\n    // from the first word can form the second word.\\n    private boolean isPredecessor(String curWord, String predWord) {\\n        int diffCount = -1;\\n        int predIdx = predWord.length() - 1;\\n        for (int curIdx = curWord.length() - 1; curIdx >= 1; curIdx--) {\\n            if (curWord.charAt(curIdx) != predWord.charAt(predIdx--)) {\\n                if (diffCount++ == 0)  return false;\\n                predIdx++;\\n            }\\n        }\\n        return (predIdx == -1) || (curWord.charAt(0) == predWord.charAt(0));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static final int LONGEST_WORD_LEN = 16;\\n    \\n    public int longestStrChain(String[] words) {\\n        // Calculate number of strings of each length;\\n        int longestCount = 0;\\n        int[] lenCounts = new int[LONGEST_WORD_LEN + 1];\\n        for (int i = words.length - 1; i >= 0; i--)\\n            longestCount = Math.max(longestCount, ++lenCounts[words[i].length()]);\\n        \\n        // Build an array that for each string length, has an array of indexes to words of that  \\n        // length.  Copy the words from the words[] array into the wcs[][] array.  The array wcs \\n        // is indexed by: wcs[string len][index of words of same len].  The wcs[len][0] value is \\n        // the number of words of that same length that are stored in wcs[len].\\n        int maxWordLen = 0;\\n        for (maxWordLen = LONGEST_WORD_LEN; maxWordLen >= 0 && lenCounts[maxWordLen] == 0; maxWordLen--)  { }\\n        short[][] wcs = new short[maxWordLen + 1][longestCount + 1];\\n        for (int i = words.length - 1; i >= 0; i--) {\\n            int len = words[i].length();\\n            wcs[len][++wcs[len][0]] = (short)i;\\n        }\\n        \\n        // Create an uninitialized memorization value for each word now stored as char[] arrays in wcs[][][].\\n        byte[][] memo = new byte[maxWordLen + 1][longestCount + 1];\\n\\n        // Start with the longest words and search backward (longest word to shortest word) to find the \\n        // longest string chain.  Stop searching if the longest string chain found if longer or same \\n        // length as the current word (words are processed longest to shortest), because a longer chain \\n        // is not possible.\\n        int longestFound = 1;\\n        for (int len = maxWordLen; len > 1 && len > longestFound; len--)\\n            for (int wordIdx = wcs[len][0]; wordIdx >= 1 && len > longestFound; wordIdx--)\\n                longestFound = Math.max(longestFound, findPath(len, wordIdx, wcs, memo, words));\\n        return longestFound;\\n    }\\n    \\n    \\n    // Recursively try to find a path from a word (specified by its length and its index into words of \\n    // the same length) backward through predecessors, by comparing the word to all words that are one \\n    // character shorter.  Find the longest path from this word backward through shorter words.  Memorize \\n    // the longest path from a word, so we don\\'t have to recalculate it if we try to find the path from \\n    // this word again.\\n    private int findPath(int len, int wordIdx, short[][] wcs, byte[][] memo, String[] words) {\\n        if (len == 1)  return 1;\\n        if (memo[len][wordIdx] > 0)  return memo[len][wordIdx];\\n        String curWord = words[wcs[len][wordIdx]];\\n        int longest = 0;\\n        for (int predIdx = wcs[len - 1][0]; predIdx >= 1 && longest + 1 < len; predIdx--)\\n            if (isPredecessor(curWord, words[wcs[len - 1][predIdx]]))\\n                longest = Math.max(longest, findPath(len - 1, predIdx, wcs, memo, words));\\n        memo[len][wordIdx] = (byte)(longest + 1);\\n        return longest + 1;\\n    }\\n    \\n    \\n    // Given two words as Strings, test the second word to see if it is a predecessor of the first word.  \\n    // It is a predecessor if the second word differs from the first word by having exactly one character \\n    // in the first word that does not match the characters in the second word.  The first word will be one \\n    // character longer than the second word.  The second word is a predecessor if deleting one character \\n    // from the first word can form the second word.\\n    private boolean isPredecessor(String curWord, String predWord) {\\n        int diffCount = -1;\\n        int predIdx = predWord.length() - 1;\\n        for (int curIdx = curWord.length() - 1; curIdx >= 1; curIdx--) {\\n            if (curWord.charAt(curIdx) != predWord.charAt(predIdx--)) {\\n                if (diffCount++ == 0)  return false;\\n                predIdx++;\\n            }\\n        }\\n        return (predIdx == -1) || (curWord.charAt(0) == predWord.charAt(0));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706963,
                "title": "q1048-accepted-c-used-dp-lis-sort-comparator-easiest",
                "content": "CRUX\\n1) We have a comparator for comparing and sorting the string\\'s according to increasing size\\'s.\\n2) Compare function to check whether the difference between two string\\'s is only of one character.\\n3) Longest Chain Chain is needed neither subsequence or subset therefore it needs sorting.\\n4) This question resemble\\'s to LIS if we talk about the size of string in the word\\'s vector.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(string &a,string &b){\\n        return a.size() < b.size();\\n    }\\n    bool Compare(string &a,string &b){\\n        int i = 0,j = 0;\\n        int m = a.size();\\n        int n = b.size();\\n        if(m != n+1)\\n            return false;\\n        while(i < m){\\n            if(a[i] == b[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        if(i == m && j == n)\\n            return true;\\n        return false;\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector <int> dp(n,1);\\n        sort(words.begin(),words.end(),comp); // Sorting according to the Size\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(Compare(words[i],words[j]) && dp[j]+1 > dp[i]) // Compare whether diff of string is of only ONE new character.\\n                    dp[i] = 1 + dp[j];\\n            }\\n            maxLen = max(maxLen,dp[i]);\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(string &a,string &b){\\n        return a.size() < b.size();\\n    }\\n    bool Compare(string &a,string &b){\\n        int i = 0,j = 0;\\n        int m = a.size();\\n        int n = b.size();\\n        if(m != n+1)\\n            return false;\\n        while(i < m){\\n            if(a[i] == b[j]){\\n                i++;\\n                j++;\\n            }\\n            else\\n                i++;\\n        }\\n        if(i == m && j == n)\\n            return true;\\n        return false;\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n = words.size();\\n        vector <int> dp(n,1);\\n        sort(words.begin(),words.end(),comp); // Sorting according to the Size\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(Compare(words[i],words[j]) && dp[j]+1 > dp[i]) // Compare whether diff of string is of only ONE new character.\\n                    dp[i] = 1 + dp[j];\\n            }\\n            maxLen = max(maxLen,dp[i]);\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554698,
                "title": "c-dp-longest-increasing-subsequence-variation",
                "content": "# Intuition\\nSort the words by their size, now apply the LIS concept if **jth string has a size == ith string size - 1** then we check for another condition whether all characters of jth string are present in ith string and in the same order. This can be checked using two pointer technique. And then the dp array will have the length of all increaing subsequences and now we can return the maximum among them as answer.\\n\\n\\n# Code\\n```\\nbool comp(string& a,string& b)\\n{\\n    return a.size()<b.size();\\n}\\nclass Solution {\\npublic:\\n    bool func(string& a,string& b)\\n    {\\n        int ptr1 = 0,ptr2 = 0;\\n        int n1 = a.size(),n2 = b.size();\\n        while(ptr1<n1 && ptr2<n2)\\n        {\\n            if(a[ptr1]==b[ptr2])\\n            {\\n                ptr1++;\\n                ptr2++;\\n            }\\n            else\\n            ptr2++;\\n        }\\n        if(ptr1==n1)\\n        return true;\\n        return false;\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),comp);\\n        int n = words.size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n        dp[i] = 1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                string tmp1 = words[i];\\n                string tmp2 = words[j];\\n                if(tmp2.size()+1==tmp1.size())\\n                {\\n                    if(func(tmp2,tmp1))\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        ans = max(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool comp(string& a,string& b)\\n{\\n    return a.size()<b.size();\\n}\\nclass Solution {\\npublic:\\n    bool func(string& a,string& b)\\n    {\\n        int ptr1 = 0,ptr2 = 0;\\n        int n1 = a.size(),n2 = b.size();\\n        while(ptr1<n1 && ptr2<n2)\\n        {\\n            if(a[ptr1]==b[ptr2])\\n            {\\n                ptr1++;\\n                ptr2++;\\n            }\\n            else\\n            ptr2++;\\n        }\\n        if(ptr1==n1)\\n        return true;\\n        return false;\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(),words.end(),comp);\\n        int n = words.size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n        dp[i] = 1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                string tmp1 = words[i];\\n                string tmp2 = words[j];\\n                if(tmp2.size()+1==tmp1.size())\\n                {\\n                    if(func(tmp2,tmp1))\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        ans = max(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311205,
                "title": "c-dp-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*n*l)+O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(string&s1, string&s2){\\n        if(s1.size()!=s2.size()+1){return false;}\\n        int i=0, j=0;\\n        while(i<s1.size()){\\n            if(s1[i]==s2[j]){\\n                i++; j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(i==s1.size() && j==s2.size()){return true;}\\n        return false;\\n    }\\n    static bool cmp(string&s1, string&s2){\\n        return s1.size()<s2.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        vector<int>dp(n, 1);\\n        sort(words.begin(), words.end(), cmp);\\n        int maxi=1;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(valid(words[i], words[j]) && dp[i]<dp[j]+1){\\n                    dp[i]=1+dp[j];\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi=dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(string&s1, string&s2){\\n        if(s1.size()!=s2.size()+1){return false;}\\n        int i=0, j=0;\\n        while(i<s1.size()){\\n            if(s1[i]==s2[j]){\\n                i++; j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        if(i==s1.size() && j==s2.size()){return true;}\\n        return false;\\n    }\\n    static bool cmp(string&s1, string&s2){\\n        return s1.size()<s2.size();\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n        vector<int>dp(n, 1);\\n        sort(words.begin(), words.end(), cmp);\\n        int maxi=1;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(valid(words[i], words[j]) && dp[i]<dp[j]+1){\\n                    dp[i]=1+dp[j];\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi=dp[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733776,
                "title": "python-o-n-time-and-space-easy-to-undersatnd-dp-solution",
                "content": "```\\ndef longestStrChain(self, words: List[str]) -> int:\\n\\tbucketsort = defaultdict(list)\\n\\tresults = {}\\n\\tfor val in words: \\n\\t\\tbucketsort[len(val)].append(val)\\n\\t\\tresults[val] = 1\\n\\tfor i in reversed(range(1,17)):#from 16 to 1 (bucket sort bounds)\\n\\t\\tfor val in bucketsort[i]:#for each value in the bucket that we are in \\n\\t\\t\\tfor i in range(len(val)):\\n\\t\\t\\t\\tpredecessor = val[:i] + val[i+1:]#all the combinations of values that we can make by deleting a char\\n\\t\\t\\t\\tif predecessor in results: #if we have this value somewhere \\n\\t\\t\\t\\t\\tresults[predecessor] = max(results[predecessor],results[val]+1)\\n\\treturn max(results.values())\\n```\\n\\n**Time complexity: O(n)\\nSpace complexity: O(n)**\\n\\n**Explaination of the algorithm: **\\nWe use bucketsort to iterate through the values with the highest length first, to the shortest length. O(n) \\nInside loop, we iterate through the words from highest length to lowest length.\\nSince the length of a word is at MOST 16, checking if all predecessor of the word exist is O(1) time.\\nIf the predecessor exists, we set it to its value.\\nAt the end of the iterations, we return the highest value that we find. \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\ndef longestStrChain(self, words: List[str]) -> int:\\n\\tbucketsort = defaultdict(list)\\n\\tresults = {}\\n\\tfor val in words: \\n\\t\\tbucketsort[len(val)].append(val)\\n\\t\\tresults[val] = 1\\n\\tfor i in reversed(range(1,17)):#from 16 to 1 (bucket sort bounds)\\n\\t\\tfor val in bucketsort[i]:#for each value in the bucket that we are in \\n\\t\\t\\tfor i in range(len(val)):\\n\\t\\t\\t\\tpredecessor = val[:i] + val[i+1:]#all the combinations of values that we can make by deleting a char\\n\\t\\t\\t\\tif predecessor in results: #if we have this value somewhere \\n\\t\\t\\t\\t\\tresults[predecessor] = max(results[predecessor],results[val]+1)\\n\\treturn max(results.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2506227,
                "title": "c-iterative-clean-easy",
                "content": "![image](https://assets.leetcode.com/users/images/cc396b88-b437-4ad7-9abe-1e0b516cd40e_1661882194.5044374.png)\\n\\n\\tbool comp(string& a,string& b){\\n\\t\\treturn b.size()>a.size();\\n\\t}\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool check(string& a,string& b){\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint m=b.size();\\n\\t\\t\\tif(m-n!=1) return false;\\n\\t\\t\\tint i=0,j=0;\\n\\t\\t\\twhile(j<m){\\n\\t\\t\\t\\tif(a[i]==b[j] && i<m){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}    \\n\\t\\t\\t\\telse j++;\\n\\t\\t\\t}\\n\\t\\t\\treturn i==n && j==m;\\n\\t\\t}\\n\\n\\t\\tint longestStrChain(vector<string>& words) {\\n\\t\\t\\tint n=words.size();\\n\\t\\t\\tsort(words.begin(),words.end(),comp);\\n\\t\\t\\tvector<int> dp(n,1);\\n\\t\\t\\tint maxi=1;\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tfor(int prev=0;prev<i;prev++){\\n\\t\\t\\t\\t\\tif(check(words[prev],words[i])) dp[i]=max(dp[i],1+dp[prev]); \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxi=max(maxi,dp[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool check(string& a,string& b){\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint m=b.size();\\n\\t\\t\\tif(m-n!=1) return false;\\n\\t\\t\\tint i=0,j=0;\\n\\t\\t\\twhile(j<m){\\n\\t\\t\\t\\tif(a[i]==b[j] && i<m){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2251531,
                "title": "c-unordered-map-soln-well-commented-complexity-analysis",
                "content": "```\\nclass Solution {\\npublic:\\n    struct comp{    //Comparator function for sorting \\n        bool operator()(string s1,string s2){\\n            return s1.size()<s2.size();\\n        }\\n    };\\n    int longestStrChain(vector<string>& arr) {\\n        sort(begin(arr),end(arr),comp());// Sort asc according to length\\n        unordered_map<string,int>mp; //to  store ans for every word \\n        int ans=1;\\n        for(auto s:arr){//check for every word in arr\\n            mp[s]=1; // string chain must have atleast one word.\\n            for(int i=0;i<s.size();i++){\\n                string temp=s.substr(0,i)+s.substr(i+1); //remove charcter one by one and check if new string (string after removing ith character) is present in map then update value in map and our answer as well.\\n                if(mp.find(temp)!=mp.end()){\\n                    mp[s]=max(mp[s],mp[temp]+1);\\n                    ans=max(ans,mp[s]); //update ans if we get more word in chain.\\n                }\\n            }\\n        }\\n        return ans;  //final\\n    }\\n};\\n\\n// T.C----> O(NlogN)+O(N* max_len_word * max_len_word)\\n// S.C---->O(N)    \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct comp{    //Comparator function for sorting \\n        bool operator()(string s1,string s2){\\n            return s1.size()<s2.size();\\n        }\\n    };\\n    int longestStrChain(vector<string>& arr) {\\n        sort(begin(arr),end(arr),comp());// Sort asc according to length\\n        unordered_map<string,int>mp; //to  store ans for every word \\n        int ans=1;\\n        for(auto s:arr){//check for every word in arr\\n            mp[s]=1; // string chain must have atleast one word.\\n            for(int i=0;i<s.size();i++){\\n                string temp=s.substr(0,i)+s.substr(i+1); //remove charcter one by one and check if new string (string after removing ith character) is present in map then update value in map and our answer as well.\\n                if(mp.find(temp)!=mp.end()){\\n                    mp[s]=max(mp[s],mp[temp]+1);\\n                    ans=max(ans,mp[s]); //update ans if we get more word in chain.\\n                }\\n            }\\n        }\\n        return ans;  //final\\n    }\\n};\\n\\n// T.C----> O(NlogN)+O(N* max_len_word * max_len_word)\\n// S.C---->O(N)    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178896,
                "title": "simple-c-code-o-strings-len-max-string",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    static bool compare(string &a, string &b)\\n    {\\n        if(a.size() < b.size())\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> um;\\n        int ans = 1;\\n        for(string &word : words)\\n        {\\n            //cout << word << \" \";\\n            if(um.count(word)) continue;\\n            um[word]++;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                string s = word;\\n                s.erase(i,1);\\n                if(um.count(s))\\n                {\\n                    int f = um[word];\\n                    um[word] = max(um[s]+1,f);\\n                }\\n            }\\n            //cout << word << \" \" << um[word] << endl;\\n            ans = max(ans,um[word]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool compare(string &a, string &b)\\n    {\\n        if(a.size() < b.size())\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int longestStrChain(vector<string>& words) {\\n        sort(words.begin(), words.end(), compare);\\n        unordered_map<string, int> um;\\n        int ans = 1;\\n        for(string &word : words)\\n        {\\n            //cout << word << \" \";\\n            if(um.count(word)) continue;\\n            um[word]++;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                string s = word;\\n                s.erase(i,1);\\n                if(um.count(s))\\n                {\\n                    int f = um[word];\\n                    um[word] = max(um[s]+1,f);\\n                }\\n            }\\n            //cout << word << \" \" << um[word] << endl;\\n            ans = max(ans,um[word]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2166896,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        #dp stores the inner elements and thier count\\n        dp = defaultdict(lambda : 0)\\n        res = 1\\n        for word in sorted(words,key = len):\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                inner = word[:i]+word[i+1:]\\n                if dp[inner]!=0:\\n                    dp[word] = max(dp[word],dp[inner]+1)\\n                    res = max(res,dp[word])\\n        return res        \\n```\\nUpvote if you like this solution :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        #dp stores the inner elements and thier count\\n        dp = defaultdict(lambda : 0)\\n        res = 1\\n        for word in sorted(words,key = len):\\n            dp[word] = 1\\n            for i in range(len(word)):\\n                inner = word[:i]+word[i+1:]\\n                if dp[inner]!=0:\\n                    dp[word] = max(dp[word],dp[inner]+1)\\n                    res = max(res,dp[word])\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156283,
                "title": "java-easy-approach-deleting-letters-to-form-a-chain-reverse-hashing",
                "content": "\\n\\n    class Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n        \\n          Arrays.sort(words,(String a, String b) -> b.length() - a.length());\\n        \\n        HashMap<String,Integer> map=new HashMap();//hash map to increase counter for a string if it can be           formed by deleting a letter from its successor\\n        int max=1;\\n        for(String word:words)\\n            map.put(word,1);//the minimum string chain for every word is 1\\n        for(String word:words){  //TC for this loop structure := O(nk) n-length of array,k-length of word\\n            for(int i=0;i<word.length();i++){\\n                \\n                String s=word.substring(0,i)+word.substring(i+1);\\n                if(map.containsKey(s)){\\n                    \\n                    //do\\n                    map.put(s,Math.max(map.get(s),map.get(word)+1)); //store the max value of string chain upto this s word till now\\n                    \\n                    \\n                }\\n            }\\n            max=Math.max(max,map.getOrDefault(word,0));\\n        }\\n        return max;\\n        \\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestStrChain(String[] words) {\\n        \\n        \\n          Arrays.sort(words,(String a, String b) -> b.length() - a.length());\\n        \\n        HashMap<String,Integer> map=new HashMap();//hash map to increase counter for a string if it can be           formed by deleting a letter from its successor\\n        int max=1;\\n        for(String word:words)\\n            map.put(word,1);//the minimum string chain for every word is 1\\n        for(String word:words){  //TC for this loop structure := O(nk) n-length of array,k-length of word\\n            for(int i=0;i<word.length();i++){\\n                \\n                String s=word.substring(0,i)+word.substring(i+1);\\n                if(map.containsKey(s)){\\n                    \\n                    //do\\n                    map.put(s,Math.max(map.get(s),map.get(word)+1)); //store the max value of string chain upto this s word till now\\n                    \\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2156011,
                "title": "a-simple-approach-with-golang",
                "content": "```\\nfunc longestStrChain(words []string) int {\\n    \\n    \\n    wordMap := make(map[string]int, len(words))\\n    \\n    // note the syntax\\n    sort.Slice(words, func(i, j int) bool {\\n        if len(words[i]) > len(words[j]) {\\n            return true\\n        }\\n        return false\\n    })\\n    \\n    // the initial chain for every word is 1 and we have it in a map for easy lookup\\n    for _, word := range words {\\n        wordMap[word] = 1\\n    }\\n    \\n    // for every word, I store the longest chain till that word, as the words are sorted in descending order\\n    // example: bdca - 1 | bda - 2 | bca - 2 | ba - 3 | b - 4 | a -4\\n    longestChain := 0\\n    for _, word := range words {\\n        \\n        for i:=0; i<len(word); i++ {\\n            newWord := word[:i] + word[i+1:]\\n            \\n            if _, ok := wordMap[newWord]; ok {\\n                wordMap[newWord] = max(wordMap[word]+1, wordMap[newWord])\\n            }\\n        }\\n        \\n        // to hold the max among all words, and we are traversing all the words so we definitely get the max\\n        longestChain = max(wordMap[word], longestChain)\\n    }\\n    \\n    return longestChain\\n}\\n\\nfunc max (a,b int) int {\\n    if b > a {\\n        return b\\n    }\\n    return a\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nfunc longestStrChain(words []string) int {\\n    \\n    \\n    wordMap := make(map[string]int, len(words))\\n    \\n    // note the syntax\\n    sort.Slice(words, func(i, j int) bool {\\n        if len(words[i]) > len(words[j]) {\\n            return true\\n        }\\n        return false\\n    })\\n    \\n    // the initial chain for every word is 1 and we have it in a map for easy lookup\\n    for _, word := range words {\\n        wordMap[word] = 1\\n    }\\n    \\n    // for every word, I store the longest chain till that word, as the words are sorted in descending order\\n    // example: bdca - 1 | bda - 2 | bca - 2 | ba - 3 | b - 4 | a -4\\n    longestChain := 0\\n    for _, word := range words {\\n        \\n        for i:=0; i<len(word); i++ {\\n            newWord := word[:i] + word[i+1:]\\n            \\n            if _, ok := wordMap[newWord]; ok {\\n                wordMap[newWord] = max(wordMap[word]+1, wordMap[newWord])\\n            }\\n        }\\n        \\n        // to hold the max among all words, and we are traversing all the words so we definitely get the max\\n        longestChain = max(wordMap[word], longestChain)\\n    }\\n    \\n    return longestChain\\n}\\n\\nfunc max (a,b int) int {\\n    if b > a {\\n        return b\\n    }\\n    return a\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2155458,
                "title": "c-dynamic-programming-largest-increasing-subsequence-concept",
                "content": "**Explanation**:\\n-  this question is based totally on **Longest Increasing subsequence** pattern. which uses **dynamic programming** concept.\\n-   in original problem, we have two numbers which we compare. instead here we are checking if two string can form a chain or not.\\n-   rest the whole code is same.\\n-   for comparing two string, \\n    - we are considering its size: there should be exactly difference of 1.\\n    - all the characters of string `a` should be in `b`.\\n\\n\\n**Space complexity**: $O(n)$\\n**time complexity**: $O(n^2 . l)$ \\n- `l` is maximum length of string.\\n- `n` is size of input array\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words)\\n    {\\n        int n = words.size();\\n\\n        sort(words.begin(), words.end(), [](string& a, string& b) {\\n            return a.size() < b.size();\\n        });\\n\\n        vector<int> lis(n, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (isChainable(words[j], words[i]) && lis[i] <= lis[j] + 1) {\\n                    lis[i] = lis[j] + 1;\\n                }\\n            }\\n        }\\n\\n        return *max_element(lis.begin(), lis.end());\\n    }\\n\\n    bool isChainable(string& a, string& b)\\n    {\\n        if (a.size() + 1 != b.size())\\n            return false;\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < a.size() && j < b.size()) {\\n            if (a[i] == b[j])\\n                i++;\\n            j++;\\n        }\\n\\n        return i == a.size();\\n    }\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestStrChain(vector<string>& words)\\n    {\\n        int n = words.size();\\n\\n        sort(words.begin(), words.end(), [](string& a, string& b) {\\n            return a.size() < b.size();\\n        });\\n\\n        vector<int> lis(n, 1);\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (isChainable(words[j], words[i]) && lis[i] <= lis[j] + 1) {\\n                    lis[i] = lis[j] + 1;\\n                }\\n            }\\n        }\\n\\n        return *max_element(lis.begin(), lis.end());\\n    }\\n\\n    bool isChainable(string& a, string& b)\\n    {\\n        if (a.size() + 1 != b.size())\\n            return false;\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < a.size() && j < b.size()) {\\n            if (a[i] == b[j])\\n                i++;\\n            j++;\\n        }\\n\\n        return i == a.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154580,
                "title": "dynamic-programming",
                "content": "First we will sort the array according to length of words because we want a chain of increasing length, Next we will create a dp array for all words where we will equal all words to one and we will start equating on all words.\\nSo in equalOrnot function, we will remove each letter of the word and will equate with any of the words in dp,\\nif present we will see which one of the two (dp[word] and 1+dp[wordwithremovedletter]) is big and we will take max of them into dp[word].\\nand at last we will return the max of dp.values()\\n\\'\\'\\'\\n*class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        @lrucache(None)\\n        def equalOrnot(s1):\\n            n=len(s1)\\n            for i in range(0,n):\\n                if i==0:\\n                    if s1[1:n] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[1:n]])\\n                if i==n-1:\\n                    if s1[0:n-1] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[0:n-1]])\\n                else:\\n                    if s1[0:i]+s1[i+1:n] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[0:i]+s1[i+1:n]])\\n        dp={}\\n        for i in words:\\n            dp[i]=1\\n        words=sorted(words,key=len)\\n        for i in range(1,len(words)):\\n                equalOrnot(words[i])\\n        return max(dp.values())\\n\\t\\t\\'\\'\\'*",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestStrChain(self, words: List[str]) -> int:\\n        @lrucache(None)\\n        def equalOrnot(s1):\\n            n=len(s1)\\n            for i in range(0,n):\\n                if i==0:\\n                    if s1[1:n] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[1:n]])\\n                if i==n-1:\\n                    if s1[0:n-1] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[0:n-1]])\\n                else:\\n                    if s1[0:i]+s1[i+1:n] in dp:\\n                        dp[s1]=max(dp[s1],1+dp[s1[0:i]+s1[i+1:n]])\\n        dp={}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2068847,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1920261,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1570714,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1568570,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1565730,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068856,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2069237,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068876,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2036438,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1576899,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068847,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1920261,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1570714,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1568570,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1565730,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068856,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2069237,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2068876,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 2036438,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1576899,
                "content": [
                    {
                        "username": "mstuebs",
                        "content": "Don\\'t submit before checking for edge cases, e.g. \\n```\\n[\"x\"]\\n[\"u\",\"v\",\"u\",\"z\",\"v\",\"v\",\"x\",\"x\",\"x\",\"x\"]\\n[\"uvvyzyuvuuxxyyz\"]\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n```\\nhttps://github.com/mquintus/l33tcode-testcase-generator#readme"
                    },
                    {
                        "username": "StarkX18",
                        "content": " [@LeetCode](/LeetCode) When I submit my solution, it show 84/84 test cases passed, but it also shows  TLE & does not show the input on which my solution failed..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Then it likely failed on the last input, this is a known bug. You should treat it as any other TLE, it is just unfortunate that you don\\'t get a testCase out of it. "
                    },
                    {
                        "username": "HarshJ25",
                        "content": "ya same"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Pattern: **Variant of LIS** \\n* Bruteforce: Backtracking - O(NlogN) + O(2^N * L) time and O(N) space\\n* Less optimal: DP - O(NlogN) + O(N\\xB2 * L) time and O(N) space\\n* Most optimal (considering L is small, ie 16) : Dp - O(NlogN) + O(N * L\\xB2) time and O(N) space\\n\\n**Code**: Most optimal code is same as LC solution 2 and Lee215 solution."
                    },
                    {
                        "username": "A5HU705H",
                        "content": "sort is convinience we don\\'t need to do that we can just declare vector<string>[16]"
                    },
                    {
                        "username": "mjmorris",
                        "content": "Hello, I got two incorrect submissions due to problems using std::sort on this question.\\n\\nThe first was a heap buffer overflow when using `sort(words.begin(), words.end(), [](string& a, string& b){return a.size() <= b.size();});`, I was able to correct this by not using references, ie, `sort(words.begin(), words.end(), [](string a, string b){return a.size() <= b.size();});`. I was unable to reproduce this error on my local computer with fsanitize=address on, and am still not really sure why this is an error on leetcode.\\n\\nThe second submission was due to the `<=` comparator. For some reason I got `terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create` when using `<=`, which went away when I used `<` comparator instead. \\n  \\n  My final sorting function is `sort(words.begin(), words.end(), [](string a, string b){return a.size() < b.size();});` which I was able to use in my accepted submission. **Can anyone tell me why the previous submissions failed?** I would like to avoid this mistake in the future."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "In C++, if the arguments are equal in comparator then always return false.\\nI really don\\'t know the main reason behind it. You can refer to this for more information https://codeforces.com/blog/entry/72525"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when somebody in discussions say what you went through code for half an hour ....[@mjmorris](/mjmorris) I feel u bro"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "[@nightcrawler0112](/nightcrawler0112) Take a look here. https://codeforces.com/blog/entry/70237"
                    },
                    {
                        "username": "nightcrawler0112",
                        "content": "[@dakshveersinghchauhan](/dakshveersinghchauhan) \\nwhy using \\'<\\' instead of \\'<=\\' works??"
                    },
                    {
                        "username": "dakshveersinghchauhan",
                        "content": "I think there is no problem with using reference. Just <= is the problematic part.\\n\\nstatic bool comp(const string &a, const string &b){\\n        return a.size()<b.size();\\n}\\nsort(words.begin(), words.end(), comp);\\n\\nThis worked for me."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-string-chain/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming (Recursion + Memoization)\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Look at the constraint 1 <= words[i].length <= 16. There are many ways of DP. \nVarying the words[i] is easier and quicker!"
                    },
                    {
                        "username": "sahil_bhore_",
                        "content": "It's a standard DP pattern based on LIS(Longest Increasing Subsequence)\nHere are some practice problem you can do:-\n1.[leetcode-300](https://leetcode.com/problems/longest-increasing-subsequence/)\n2.[leetcode-368](https://leetcode.com/problems/largest-divisible-subset/)\n3.[leetcode-673](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)"
                    },
                    {
                        "username": "ibram-reda",
                        "content": "Can anyone explain test case 70\\n**Input**: words = [\"a\",\"b\",\"ba\",\"abc\",\"abd\",\"bdca\"]\\n**Output**: 3\\n**Expected**: 2 \\n\\nI don\\'t know why it expects 2 it should be 3\\na \\u2192 <ins>b</ins>a \\u2192 b<ins>dc</ins>a"
                    },
                    {
                        "username": "JaiThakur10",
                        "content": "it expects 2 because there are only two possible case i.e \"a\" and \"ba\"\\nas you mentioned \"bdca\" thats invalid becuase in between \\'b\\' and \\'a\\' there are two letters but in the question its clearly mentioned that only one letter could be inserted "
                    },
                    {
                        "username": "aitachii",
                        "content": "Seems you already figured it out. The difference between two words in a chain should be 1 character.\\n\\na -> ba (1 new character: b)\\nba -> bdca (2 new characters: dc) <- invalid\\n\\nand their lengths should also be increasing with a difference of 1\\na -> ba -> bdca\\n1 -> 2 -> 4 (will only be valid if this is 3)"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "bruh, here 2 characters are added, it\\'s written clearly to add single character"
                    },
                    {
                        "username": "vansh22559",
                        "content": "HINT: Its just a mix up question of 0-1 knapsack and longest common subsequence , like the choice diagram of 0-1 knapsack follows here exactly and you use lcs to check whether one strings is predecessor of other string or not."
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "**How to delete/Exclude a char from the word for finding out the word chain ??**\\n\\n* `word.substring(0, i`) is the substring from` 0 to i`, where i is excluded & `word.substring(i + 1`) is the substring from `i+1` to the `end of the string.`\\n* So if we concatenate these two substr, the i\\'th character will get excluded.\\n"
                    }
                ]
            },
            {
                "id": 1938797,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 1573172,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 1570242,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069033,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069022,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2068884,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 1573041,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 1573059,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069881,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069805,
                "content": [
                    {
                        "username": "utkarshinobi",
                        "content": "When I try to use memoization I get TLE. My validChain() function takes a O(16) ~ Constant time. And I have also sorted the array in order of their lengths. So this should take O(NlogN) + O(NNL) time. What else should I try to get over the TLE?\\n\\n    int lsc(int i, int prev, vector<string> &words, vector<vector<int>> &mem){\\n        if(i == words.size()) return 0;\\n        if(mem[i][prev+1]!=-1) return mem[i][prev+1];\\n        int pick = INT_MIN;\\n        if(prev == -1 || validChain(words[i], words[prev])){\\n            pick = 1 + lsc(i+1, i, words, mem);\\n        }\\n        int notPick = lsc(i+1, prev, words, mem);\\n        return mem[i][prev+1] = max(pick, notPick);\\n    }"
                    },
                    {
                        "username": "parul_010",
                        "content": "it is getting submitted in mine are u sure ur validchain func takes constant time."
                    },
                    {
                        "username": "Matan1986",
                        "content": "Hi,\\n\\nOne of the tests to this problem is the following list of words:\\n[\"ksqvsyq\",\"ks\",\"kss\",\"czvh\",\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\",\"zcpzvh\",\"zczvh\",\"gr\",\"grukmj\",\\n        \"ksqvsq\",\"gruj\",\"kssq\",\"ksqsq\",\"grukkmj\",\"grukj\",\"zczpzfvdhx\",\"gru\"\\n    ]\\n\\t\\n\\tThe expeced answer is 7. \\n\\tCan someone please find a chain of 7 predecessor words from the list?\\n\\t\\n"
                    },
                    {
                        "username": "pranavsinghdbg",
                        "content": "[czvh, zczvh, zcpzvh, zczpzvh, zczpzvhx, zczpzvdhx, zczpzfvdhx]"
                    },
                    {
                        "username": "gustavo_bertoldi",
                        "content": "czvh --> zczvh --> zcpzvh --> zczpzvh --> zczpzvhx --> zczpzvdhx --> zczpzfvdhx"
                    },
                    {
                        "username": "RAJESHBHAVESH",
                        "content": "[\"a\",\"b\",\"ab\",\"bac\"]\\n\\nIt seems to me that\\na --> ab --> bac forms a word length of 3, but when I run the test case it is expeting length of 2. Can anybody explain this?"
                    },
                    {
                        "username": "java_run",
                        "content": "[@prompt_07](/prompt_07)yes , you are right \\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Ur transition from \"ab\"-->\"bac\" is incorrect desc clearly says without changing the order of the other characters in your case ab became ba"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Hint 1 - You can do something similar to LIS problem , but here you\\'ll have to first find if the two strings ```canBeEqual```\\nHint 2 - For each string you can make a new string of ```size - 1``` and check if it is present before.\\nexplained both approaches and visualized [here](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation-and-visualization/)"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]\\n\\noutput --> 3\\nexpected ---> 4\\n\\nwhy 4 as there are only three\\na-->ab-->abc that\\'s all \\nhow ans is 4?"
                    },
                    {
                        "username": "Gauravsanjay",
                        "content": "[@user2049D](/user2049D)  \\ngot it bro thanks\\n"
                    },
                    {
                        "username": "user2049D",
                        "content": "a-->ab-->abd-->abdd is ok"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "exactlyy i am also stuck over here, big test cases are working fine, 75/85 test cases passed"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "why editorial is locked "
                    },
                    {
                        "username": "luanct",
                        "content": "only available for premium user!"
                    },
                    {
                        "username": "pk35008",
                        "content": "words:[\"zczpzvdhx\",\"zczpzvh\",\"zczpzvhx\"]\\nwhat is the expected output for this?\\ni am getting 2 ([\"zczpzvh\",\"zczpzvhx\"] )\\nbut expected output is 3. I don\\'t understand where the 3rd word came from.\\nwhere did i go wrong?\\nNOTE: the question said **a** is predecessor to be if and only if **b** can be formed by adding one letter to **a**.  Clearly, the length of words are not in ascending order so 3 is IMPOSSIBLE!"
                    },
                    {
                        "username": "AnshChaturved",
                        "content": "the order doesn\\'t matter, thats what makes the question more difficult. this is clear in the second example"
                    },
                    {
                        "username": "galster",
                        "content": "The description clearly states that a chain is only formed by adding a single new letter to the exisitng word. However, the tests allow for chains of words which don\\'t differ by any letter."
                    },
                    {
                        "username": "cmd258",
                        "content": "Is there any way a solution could be improved with tries?"
                    },
                    {
                        "username": "chanchalbaghel60",
                        "content": "what is k here?\\n"
                    }
                ]
            },
            {
                "id": 2069773,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069747,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069614,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069587,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069523,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069460,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069432,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069341,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069327,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069275,
                "content": [
                    {
                        "username": "Amar___",
                        "content": "Understanding problem stat. and matching that hypothesis with mentioned test cases, is in itself arises a question that am I misunderstanding the question or the test case.\\nAm i the only one in this universe here . \\uD83D\\uDE0F\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "48:30\\n\\nwho all were able to solve within 50 minutes?"
                    },
                    {
                        "username": "LeetUddipta",
                        "content": "Can\\'t We Solve This Using Disjoint Set Union ?? "
                    },
                    {
                        "username": "huntxr",
                        "content": "99% Solutions submitted are same and I have no idea how they work."
                    },
                    {
                        "username": "nprabhu5",
                        "content": "Is it me or is the C# complier a little wonky? I think my solution should be slower than the Editorials but it beats 100%. Am I missing something? \\n```C#\\npublic class Solution {\\n    private int result = 1;\\n\\n    public int LongestStrChain(string[] words) {\\n        Dictionary<int, List<string>> dict = new();\\n        foreach(string word in words)\\n        {\\n            int l = word.Length;\\n            if(!dict.ContainsKey(l))\\n                dict.Add(l, new List<string>());\\n            dict[l].Add(word);\\n        }\\n        Dictionary<string, List<string>> graph = new();\\n        foreach(string word in words)\\n        {\\n            BuildGraph(word, graph, dict);\\n        }\\n\\nDictionary<string, int> heights = new();\\n        foreach(string word in words)\\n        {\\n            Dfs(word, heights, graph);\\n        }\\n        return result;\\n    }\\n\\n    private int Dfs(string current, Dictionary<string, int> heights, Dictionary<string, List<string>> graph)\\n    {\\n        if(heights.ContainsKey(current))\\n            return heights[current];\\n        heights.Add(current, 1);\\n        foreach(string child in graph[current])\\n        {\\n            int height = 1 + Dfs(child, heights, graph);\\n            heights[current] = Math.Max(heights[current], height);\\n        }\\n        if(heights[current] > result)\\n            Console.WriteLine(current);\\n        result = Math.Max(heights[current], result);\\n        return heights[current];\\n    }\\n\\n    private void BuildGraph(string current, Dictionary<string, List<string>> graph, Dictionary<int, List<string>> dict)\\n    {\\n        if(graph.ContainsKey(current))\\n            return;\\n        int nextLen = current.Length + 1;\\n        graph.Add(current, new());\\n        if(!dict.ContainsKey(nextLen))\\n            return;\\n        foreach(string nxt in dict[nextLen])\\n        {\\n            if(CheckPredecessor(current, nxt))\\n            {\\n                graph[current].Add(nxt);\\n            }\\n        }    \\n    }\\n\\n    private bool CheckPredecessor(string a, string b)\\n    {\\n        if(a.Length != b.Length - 1)\\n            return false;\\n        bool flag = false;\\n        int i = 0;\\n        while(i < a.Length)\\n        {\\n            if(flag)\\n            {\\n                if(a[i] != b[i+1])\\n                    return false;\\n                i++;\\n            }\\n            else\\n            {\\n                if(a[i] != b[i])\\n                    flag = true;\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        return a.Last() == b.Last() || !flag;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "MG261",
                        "content": "DP is quite intuitive here, but I\\'ll recommend everyone to try BFS! (and it performs better than DP in time)\\n\\nMy solution: https://leetcode.com/problems/longest-string-chain/solutions/4080840/bfs-level-order-and-hashmap-beats-99-58-in-time-28-ms/"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "Can anyone help me finding the TC for the BFS?\\nIt\\'s like word ladder but I never understood the TC?\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        Map<String, List<String>>map = new HashMap();\\n        Queue<String> q = new LinkedList();\\n        for(String s :words)\\n        {\\n            q.offer(s);\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String key = s.substring(0,i) + s.substring(i + 1);\\n                if(!map.containsKey(key))\\n                map.put(key, new ArrayList());\\n                map.get(key).add(s);\\n            }\\n        }\\n        \\n        int dist = 0;\\n        Set<String> set = new HashSet();\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            set.clear();\\n            while(size-- > 0)\\n            {\\n                String wrd = q.poll();\\n                if(!map.containsKey(wrd))continue;\\n                for(String nei : map.get(wrd))\\n                {\\n                    if(set.contains(nei))continue;\\n                    set.add(nei);\\n                    q.offer(nei);\\n                }\\n            }\\n            dist++;\\n        }\\n        return dist;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "What is the algorithm to find the longest path in a graph?"
                    },
                    {
                        "username": "Stocks_In_Mathss",
                        "content": "[@dwdrajesh](/dwdrajesh) Yes most likely (or bfs). But i ended up just solving it using LIS pattern + verification of predecessors. Not the most efficient solution, but it will do."
                    },
                    {
                        "username": "dwdrajesh",
                        "content": "what is it? DFS isnt it?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suggestions such as \"Hash Map\" or \"0/1 Knapsack\" kind of threw me for a while but once I ignored them, I was able to jag a simple algorithm that runs quite fast (63 ms - second fastest of C submissions). Since there are at most 1000 words in the list, there is no need to run a binary search based on string length.\\nI describe my algorithm here: https://leetcode.com/problems/longest-string-chain/solutions/4078821/c-simple-and-fast-solution/"
                    },
                    {
                        "username": "heda11",
                        "content": "bool isPos(string word1, string word2) {\\n        int len1 = word1.size();\\n        int len2 = word2.size();\\n        int i = 0, j = 0;\\n        int diffCount = 0;\\n        \\n        while (i < len1 && j < len2) {\\n            if (word1[i] != word2[j]) {\\n                if (diffCount > 0) {\\n                    return false; \\n                }\\n                diffCount++;\\n                j++;\\n            } else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return diffCount == 1 && (i == len1 || j == len2);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        int n=words.size();\\n         vector<int> ansN;\\n         sort(words.begin(), words.end(), [](const string& a, const string& b) {\\n        return a.size() < b.size();\\n        });\\n         for(int i=0;i<n;i++)\\n         {\\n             int x= words[i].size();\\n             ansN.push_back(x);\\n         }\\n         vector<int> fans;\\n         vector<string> s;\\n         s.push_back(words[0]);\\n         fans.push_back(ansN[0]);\\n         for(int i=1;i<n;i++)\\n         {\\n             if(ansN[i]-fans.back()==1 && isPos(words[i],s.back()))\\n             {\\n                \\n                 fans.push_back(ansN[i]);\\n                 s.push_back(words[i]);\\n             }\\n             else\\n             {\\n                \\n                int ind= lower_bound(fans.begin(),fans.end(),ansN[i])-fans.begin();\\n                if (ind == fans.size()) {\\n                fans.push_back(ansN[i]);\\n                s.push_back(words[i]); \\n                }\\n                else {\\n                fans[ind] = ansN[i];\\n                s[ind]=words[i];\\n                \\n                }   \\n             }\\n         }\\n\\n         return s.size();\\n    }\\n\\n\\nthis may be a wrong approach and we add the last element here even if its wrong, can you please help me for testcases like \\nwords =\\n[\"abcd\",\"dbqca\"]"
                    }
                ]
            },
            {
                "id": 2069264,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2069256,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2069165,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2069015,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2068946,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2068944,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2068890,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2068869,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 2049608,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            },
            {
                "id": 1963572,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I am not able to code what could be the possible reason behind this?\\n"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use DP"
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "hash it!  hash it!!  then sort on string length"
                    },
                    {
                        "username": "wave5902",
                        "content": "For 2d dp , if we carry previous index we can do prev+1 before storing as we initialize dp with -1.\\nFor check function pass parameters by ref to avoid tle\\'s.  ([leetcode](https://leetcode.com/problems/longest-string-chain/submissions/1056824733/))"
                    },
                    {
                        "username": "HarshJ25",
                        "content": "I am getting TLE for test case => \\n\\n\\n[\"a\",\"ac\",\"acy\",\"aucy\",\"abucy\",\"abaucy\",\"abacucy\",\"abacfucy\",\"abacyfucy\",\"abacyfucey\",\"vabacyfucey\",\"vabacyfbucey\",\"vaubacyfbucey\",\"vaubacyfdbucey\",\"dvaubacyfdbucey\",\"dvaubaccyfdbucey\",\"a\",\"ae\",\"aey\",\"ayey\",\"ayeyd\",\"adyeyd\",\"avdyeyd\",\"yavdyeyd\",\"yadvdyeyd\",\"yadvydyeyd\",\"yadxvydyeyd\",\"yadxvydbyeyd\",\"yaydxvydbyeyd\",\"yaydxvydbyceyd\",\"yaydxvvydbyceyd\",\"yaydxfvvydbyceyd\",\"a\",\"va\",\"ava\",\"eava\",\"euava\",\"euxava\",\"euaxava\",\"euavxava\",\"euavvxava\",\"eufavvxava\",\"eufavvxazva\",\"eufavvxcazva\",\"eufavvvxcazva\",\"eufdavvvxcazva\",\"eubfdavvvxcazva\",\"eubfdavvvxxcazva\",\"a\",\"ae\",\"eae\",\"eaze\",\"beaze\",\"ubeaze\",\"ubeavze\",\"ubeauvze\",\"ubeauuvze\",\"xubeauuvze\",\"xubeabuuvze\",\"xubeabuuvzze\",\"xubeabuuvzzze\",\"bxubeabuuvzzze\",\"bxubeabuuvzzzey\",\"bxubeabubuvzzzey\",\"a\",\"ba\",\"cba\",\"cbca\",\"cbcay\",\"cybcay\",\"cybcday\",\"cxybcday\",\"cvxybcday\",\"cvzxybcday\",\"cvzxybecday\",\"cvzxybecdayz\",\"cvzxybecddayz\",\"cvzxybeecddayz\",\"cbvzxybeecddayz\",\"cbvzxyubeecddayz\",\"a\",\"ab\",\"azb\",\"adzb\",\"adzbf\",\"adzbff\",\"adzdbff\",\"dadzdbff\",\"dadfzdbff\",\"dazdfzdbff\",\"dazdfzdzbff\",\"dazdfzdzbffb\",\"dazddfzdzbffb\",\"edazddfzdzbffb\",\"edazddfczdzbffb\",\"edazddfczdzebffb\",\"a\",\"af\",\"ayf\",\"dayf\",\"dayfz\",\"dayfzz\",\"dauyfzz\",\"ddauyfzz\",\"ddauyfzzf\",\"ddauyefzzf\",\"ddauzyefzzf\",\"ddauzyezfzzf\",\"ddauzcyezfzzf\",\"ddaduzcyezfzzf\",\"ddaduzcyezefzzf\",\"ddaduzccyezefzzf\",\"a\",\"ea\",\"eda\",\"eyda\",\"euyda\",\"euydza\",\"eudydza\",\"ueudydza\",\"ueuddydza\",\"ueuddydzaf\",\"ueuyddydzaf\",\"uveuyddydzaf\",\"uveuydbdydzaf\",\"uveuydbdydzabf\",\"uveuydbddydzabf\",\"uveuydbddydzvabf\",\"a\",\"ba\",\"baa\",\"ybaa\",\"ydbaa\",\"ydabaa\",\"ydeabaa\",\"uydeabaa\",\"fuydeabaa\",\"fuydeabaaz\",\"fuydeaabaaz\",\"fuydeaabaeaz\",\"fuydeaabaeayz\",\"fuydeaabaeayaz\",\"fuydeaabaeaayaz\",\"fuydeaabaeafayaz\",\"a\",\"ca\",\"xca\",\"xcxa\",\"xcyxa\",\"xucyxa\",\"xucyxfa\",\"xucyxxfa\",\"xucyxxfaa\",\"xucyxxfaca\",\"xucyxxfuaca\",\"xucyxxfuayca\",\"xucxyxxfuayca\",\"xucxdyxxfuayca\",\"zxucxdyxxfuayca\",\"zxucxdyxxfuaayca\",\"a\",\"au\",\"uau\",\"vuau\",\"yvuau\",\"yvuacu\",\"yvuaucu\",\"yvvuaucu\",\"yvvuauzcu\",\"yvvuazuzcu\",\"yavvuazuzcu\",\"yavvuafzuzcu\",\"yavvuafzuzcuu\",\"yavvuafzfuzcuu\",\"yadvvuafzfuzcuu\",\"yadvvuafzfuxzcuu\",\"a\",\"aa\",\"aaz\",\"eaaz\",\"eaxaz\",\"eaxavz\",\"eadxavz\",\"xeadxavz\",\"xeaduxavz\",\"xdeaduxavz\",\"xdeaduxbavz\",\"xdeaduxbavuz\",\"xdeaduxbavuyz\",\"xdeaduxbcavuyz\",\"xdeaduxbcaxvuyz\",\"xdeaduxbcaaxvuyz\",\"a\",\"ac\",\"ace\",\"avce\",\"avcea\",\"afvcea\",\"afuvcea\",\"afuvcead\",\"afuvceadd\",\"afyuvceadd\",\"afyuvceaedd\",\"afyuvceaexdd\",\"afyuvceaexddx\",\"avfyuvceaexddx\",\"avfyufvceaexddx\",\"avfyufvceaexvddx\",\"a\",\"za\",\"zya\",\"zyau\",\"zyauu\",\"zyauuv\",\"zfyauuv\",\"xzfyauuv\",\"exzfyauuv\",\"exzfyabuuv\",\"eaxzfyabuuv\",\"exaxzfyabuuv\",\"fexaxzfyabuuv\",\"fexaxzfxyabuuv\",\"fexaxzfxyabuuvy\",\"fexaxvzfxyabuuvy\",\"a\",\"ad\",\"aud\",\"aued\",\"auecd\",\"auedcd\",\"ayuedcd\",\"ayuedccd\",\"ayuedccda\",\"ayuedccdae\",\"ayuedccddae\",\"ayuedccddaex\",\"aybuedccddaex\",\"aybuedccfddaex\",\"ayvbuedccfddaex\",\"ayuvbuedccfddaex\",\"a\",\"da\",\"eda\",\"edad\",\"edazd\",\"ebdazd\",\"ebdazfd\",\"evbdazfd\",\"evfbdazfd\",\"evbfbdazfd\",\"evbfbdazfdf\",\"evbfbdazfduf\",\"zevbfbdazfduf\",\"zevbfbdazzfduf\",\"zevxbfbdazzfduf\",\"zevxbfbdazzfdufz\",\"a\",\"aa\",\"aua\",\"auau\",\"auxau\",\"auxauc\",\"auxaubc\",\"auxfaubc\",\"auzxfaubc\",\"azuzxfaubc\",\"azuezxfaubc\",\"yazuezxfaubc\",\"yazueczxfaubc\",\"yaazueczxfaubc\",\"yadazueczxfaubc\",\"yadazueczxfaubbc\",\"a\",\"xa\",\"xax\",\"xdax\",\"xdbax\",\"xdbaux\",\"xdbbaux\",\"xdabbaux\",\"xxdabbaux\",\"xxxdabbaux\",\"xxxdeabbaux\",\"xxxdeabbauxx\",\"xxxdeaxbbauxx\",\"xxxdceaxbbauxx\",\"xaxxdceaxbbauxx\",\"xaxxfdceaxbbauxx\",\"a\",\"ua\",\"uax\",\"uuax\",\"uuavx\",\"uuavxx\",\"uubavxx\",\"uubaxvxx\",\"uubaxdvxx\",\"uubaxdvyxx\",\"uucbaxdvyxx\",\"vuucbaxdvyxx\",\"vuucbuaxdvyxx\",\"vuucabuaxdvyxx\",\"vuucdabuaxdvyxx\",\"vuucdabuaxdvyxxb\",\"a\",\"ab\",\"fab\",\"fabu\",\"fabzu\",\"vfabzu\",\"vfabzau\",\"vfabzaub\",\"vfabvzaub\",\"yvfabvzaub\",\"yvfabvzauyb\",\"yvbfabvzauyb\",\"yvbfabvezauyb\",\"yvbfabveezauyb\",\"yvbfabveezauyyb\",\"yvbfabveezauyyab\",\"a\",\"ae\",\"aee\",\"aeue\",\"aeuce\",\"aeucee\",\"aeudcee\",\"aeudcaee\",\"aeudcaeee\",\"aeudcaeeee\",\"aeudcafeeee\",\"aeudcafeeeec\",\"xaeudcafeeeec\",\"xaeudcafeeeeyc\",\"xaeudcafeeeveyc\",\"xaeudcafeeeaveyc\",\"a\",\"ba\",\"fba\",\"fbda\",\"fbdva\",\"fbedva\",\"fbedbva\",\"fbcedbva\",\"fbcedbvaa\",\"fbcaedbvaa\",\"fbcaedbvaaa\",\"afbcaedbvaaa\",\"zafbcaedbvaaa\",\"zafbcavedbvaaa\",\"zafbacavedbvaaa\",\"zazfbacavedbvaaa\",\"a\",\"va\",\"yva\",\"yvya\",\"yvyda\",\"yvybda\",\"yvybdab\",\"yvybdaby\",\"yvcybdaby\",\"dyvcybdaby\",\"dyvfcybdaby\",\"dyvyfcybdaby\",\"dyvyfacybdaby\",\"adyvyfacybdaby\",\"adfyvyfacybdaby\",\"adfyvyfacybdabfy\",\"a\",\"az\",\"vaz\",\"vfaz\",\"fvfaz\",\"fvfavz\",\"fvfavza\",\"fxvfavza\",\"fxavfavza\",\"fxavvfavza\",\"fxavfvfavza\",\"xfxavfvfavza\",\"xfxcavfvfavza\",\"xfxcavfvfauvza\",\"vxfxcavfvfauvza\",\"vxfxcavfvfxauvza\",\"a\",\"za\",\"zba\",\"zaba\",\"zabda\",\"zaebda\",\"zaebday\",\"zaeabday\",\"zaeabdauy\",\"zaeabdaauy\",\"zaeabdaauyc\",\"zaeabdaauyyc\",\"zaeabdavauyyc\",\"zaezabdavauyyc\",\"zaezabdavauyycy\",\"yzaezabdavauyycy\",\"a\",\"fa\",\"fca\",\"fcav\",\"fcdav\",\"fcdaav\",\"fcdaaxv\",\"fcdaaxyv\",\"ufcdaaxyv\",\"ufcdaaxyvv\",\"ufcdaxaxyvv\",\"ufcdaxaxyvuv\",\"ufcdaxaxdyvuv\",\"ufcdaxaxdyyvuv\",\"ufcdaxaxdyyvduv\",\"ufcvdaxaxdyyvduv\",\"a\",\"ca\",\"caa\",\"caca\",\"fcaca\",\"yfcaca\",\"yfacaca\",\"yfacyaca\",\"ycfacyaca\",\"ycfacyazca\",\"ycbfacyazca\",\"ycbfacyazcca\",\"ycbfacyazecca\",\"ycbfacyazeccav\",\"ycbcfacyazeccav\",\"ycbcfacyauzeccav\"]\\n\\nBut when I run this (without submitting) it gets accepted. \\nWhat\\'s the problem??\\n \\nHere\\'s my code => \\nclass Solution {\\npublic:\\n    bool isValid(vector<string> &words, int prev, int curr) {\\n        if(prev == -1) return true;\\n        string s1 = words[prev];\\n        string s2 = words[curr];\\n\\n        if((s1.size() + 1) == s2.size()) {\\n            int i = -1, j = -1, cnt = 0;\\n            for(i = 0, j = 0; i < s1.size() && j < s2.size(); ) {\\n                if(s1[i] == s2[j]) {\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                else if(s1[i] != s2[j]) {\\n                    j++;\\n                    cnt++;\\n                    if(cnt > 1) return false;\\n                }\\n            }\\n            if(i >= s1.size()) return true;\\n        }\\n        return false;\\n    }\\n    int solve(vector<string> &words, int prev, int curr, vector<vector<int>> &dp) {\\n        if(curr == words.size()) return 0;\\n\\n        if(dp[prev + 1][curr] != -1) return dp[prev + 1][curr];\\n\\n        int pick = 0;\\n        if(prev == -1 || isValid(words, prev, curr)) {\\n            pick = 1 + solve(words, curr, curr + 1, dp);\\n        }\\n\\n        int notPick = 0 + solve(words, prev, curr + 1, dp);\\n\\n        return dp[prev + 1][curr] = max(pick, notPick);\\n    }\\n    int longestStrChain(vector<string>& words) {\\n        map<int, vector<string>> mp;\\n        for(auto &s : words) {\\n            string str = s;\\n            vector<string> w = mp[str.size()];\\n            w.push_back(str);\\n            mp[str.size()] = w;\\n        }\\n        words = {};\\n        for(auto &i : mp) {\\n            vector<string> s = i.second;\\n            sort(s.begin(), s.end());\\n            for(auto &j : s) {\\n                words.push_back(j);\\n            }\\n        }\\n        vector<vector<int>> dp (words.size(), vector<int> (words.size(), -1));\\n        int ans = solve(words, -1, 0, dp);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "neergx",
                        "content": "ordered map uses log(n) time, so due to that the code exceeds time limit\nalso the TLE is calculated for the cumulative of all test cases, so it may pass your testcase when tried seperately but cumulatively all test cases should run in the fixed time slot."
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Has anyone got this questions in an interview. Please share your experience."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "So, this question can be only solved using Tabulation dp approach, but doing it through recursion + memoization is giving TLE. Is the recursion stack space causing this issue? Can anyone tell me how to detect which question can be solved by recursion dp and which can be solved only by tabulation dp?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@neergx](/neergx) Got it, I was using map instead of vector to Cache"
                    },
                    {
                        "username": "neergx",
                        "content": "this code can be passed through recursion too! you could checkout my submission."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "String a can be chained to String b if String b.Length == String a.Length + 1, and a is a subsequence of b.\\n\\nAdditionally if you always try all the smallest strings first, then you can use a HashSet to keep track of visited strings in the chain. If you\\'ve visited a string previously you can exit out for an early return - because since you started with the smallest strings that means if you visited a string already it\\'s guaranteed to be from the longest chain that the string being visited could possibly make."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "did it with dp [here with explanation](https://leetcode.com/problems/longest-string-chain/solutions/4019585/easy-dp-solution-beats-100-with-explanation/)"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "Why does this have a chain length of 4?\\n\\n `[\"a\",\"ab\",\"ac\",\"bd\",\"abc\",\"abd\",\"abdd\"]`\\n\\nI see 2 paths - a -> ab -> abc AND bd->abd->abdd AND a->ac->abc\\n\\nMy code spits out a chain length of 3 but the testcase says it should be 4\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "iaroslavafonin",
                        "content": "[@JigglyyPuff](/JigglyyPuff) thank you!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "the longest can be a -> ab -> abd -> abdd so its 4"
                    }
                ]
            }
        ]
    }
]