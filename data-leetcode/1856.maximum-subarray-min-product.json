[
    {
        "title": "Remove Outermost Parentheses",
        "question_content": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\n\tFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n&nbsp;\nExample 1:\n\nInput: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".\n\nExample 2:\n\nInput: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".\n\nExample 3:\n\nInput: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts[i] is either '(' or ')'.\n\ts is a valid parentheses string.",
        "solutions": [
            {
                "id": 270022,
                "title": "java-c-python-count-opened-parenthesis",
                "content": "## **Intuition**\\nQuote from @shubhama,\\nPrimitive string will have equal number of opened and closed parenthesis.\\n\\n## **Explanation**:\\n`opened` count the number of opened parenthesis.\\nAdd every char to the result,\\nunless the first left parenthesis,\\nand the last right parenthesis.\\n\\n## **Time Complexity**:\\n`O(N)` Time, `O(N)` space\\n\\n<br>\\n\\n**Java:**\\n```\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder s = new StringBuilder();\\n        int opened = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\' && opened++ > 0) s.append(c);\\n            if (c == \\')\\' && opened-- > 1) s.append(c);\\n        }\\n        return s.toString();\\n    }\\n```\\n\\n**C++:**\\n```\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def removeOuterParentheses(self, S):\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        return \"\".join(res)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder s = new StringBuilder();\\n        int opened = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\' && opened++ > 0) s.append(c);\\n            if (c == \\')\\' && opened-- > 1) s.append(c);\\n        }\\n        return s.toString();\\n    }\\n```\n```\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def removeOuterParentheses(self, S):\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        return \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3551123,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        \\n        return \"\".join(res)\\n```\\n\\n```Java []\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int len = s.length();\\n        if (len <= 2) return \"\";\\n        char[] c = s.toCharArray();\\n        StringBuilder newString = new StringBuilder();\\n        int open = 1;\\n        int openLeft = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (c[i] == \\'(\\') {\\n                open++;\\n                if (open > 1) newString.append(\\'(\\');\\n            }\\n            else {\\n                if (open > 1) newString.append(\\')\\');\\n                open--;\\n            }\\n        }\\n        return newString.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int opened = 0;\\n        for (char c : S) {\\n            if (c == \\'(\\' && opened++ > 0) res += c;\\n            if (c == \\')\\' && opened-- > 1) res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res, opened = [], 0\\n        for c in S:\\n            if c == \\'(\\' and opened > 0: res.append(c)\\n            if c == \\')\\' and opened > 1: res.append(c)\\n            opened += 1 if c == \\'(\\' else -1\\n        \\n        return \"\".join(res)\\n```\n```Java []\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int len = s.length();\\n        if (len <= 2) return \"\";\\n        char[] c = s.toCharArray();\\n        StringBuilder newString = new StringBuilder();\\n        int open = 1;\\n        int openLeft = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (c[i] == \\'(\\') {\\n                open++;\\n                if (open > 1) newString.append(\\'(\\');\\n            }\\n            else {\\n                if (open > 1) newString.append(\\')\\');\\n                open--;\\n            }\\n        }\\n        return newString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165562,
                "title": "well-explained-code-in-java",
                "content": "\\n\\n# Approach\\nThis is a solution to the problem of removing outermost parentheses from a string containing only parentheses.\\n\\nThe approach used is to keep track of the parentheses using a stack. Whenever an opening parenthesis is encountered, it is pushed onto the stack. Whenever a closing parenthesis is encountered, the last opening parenthesis is popped from the stack.\\n\\nIf the stack size is greater than zero after pushing or popping, it means that the parenthesis is not an outer parenthesis, and it is added to the result string. If the stack size is zero, it means that the parenthesis is an outer parenthesis and it is not added to the result string.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input string. This is because each character in the string is processed once and the push and pop operations on the stack take O(1) time each.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is O(n), where n is the length of the input string. This is because the maximum size of the stack is n/2 (if all the parentheses are opening parentheses), and in the worst case, the result string can also have a size of n/2.\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> bracket = new Stack<>();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n                bracket.push(s.charAt(i));\\n            }else{\\n                bracket.pop();\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/150a5515-b27f-42d1-9a2e-aed10f236bca_1675969899.9073486.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> bracket = new Stack<>();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n                bracket.push(s.charAt(i));\\n            }else{\\n                bracket.pop();\\n                if(bracket.size()>0){\\n                    sb.append(s.charAt(i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270566,
                "title": "my-java-3ms-straight-forward-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int open=0, close=0, start=0;\\n        for(int i=0; i<S.length(); i++) {\\n            if(S.charAt(i) == \\'(\\') {\\n                open++;\\n            } else if(S.charAt(i) == \\')\\') {\\n                close++;\\n            }\\n            if(open==close) {\\n                sb.append(S.substring(start+1, i));\\n                start=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int open=0, close=0, start=0;\\n        for(int i=0; i<S.length(); i++) {\\n            if(S.charAt(i) == \\'(\\') {\\n                open++;\\n            } else if(S.charAt(i) == \\')\\') {\\n                close++;\\n            }\\n            if(open==close) {\\n                sb.append(S.substring(start+1, i));\\n                start=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290126,
                "title": "c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int count = 0;\\n        std::string str;\\n        for (char c : S) {\\n            if (c == \\'(\\') {\\n                if (count++) {\\n                    str += \\'(\\';\\n                }\\n            } else {\\n                if (--count) {\\n                    str += \\')\\';\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int count = 0;\\n        std::string str;\\n        for (char c : S) {\\n            if (c == \\'(\\') {\\n                if (count++) {\\n                    str += \\'(\\';\\n                }\\n            } else {\\n                if (--count) {\\n                    str += \\')\\';\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815947,
                "title": "c-two-solution-stack-and-with-out-stack-only-slight-modification-in-stack-sol",
                "content": "please **upVote** my solution if you like it.\\n\\nMy first solution is stack based and it consume more memory than with out stack solution in my second solution to elemenate stack from it so please reffer to that also \\n\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        stack<char>st;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st.size()>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'\\n\\nSolution without stack \\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        int st=0;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string removeOuterParentheses(string S) {\\n        stack<char>st;\\n        string ans;\\n        for(auto a:S)\\n        {\\n            if(a==\\'(\\')\\n            {\\n                if(st.size()>0)\\n                {\\n                    ans+=\\'(\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 299353,
                "title": "python-simple-o-n-solution-beats-97",
                "content": "```python\\ndef removeOuterParentheses(self, S):\\n\\tres = []\\n\\tbalance = 0\\n\\ti = 0\\n\\tfor j in range(len(S)):\\n\\t\\tif S[j] == \"(\":\\n\\t\\t\\tbalance += 1\\n\\t\\telif S[j] == \")\":\\n\\t\\t\\tbalance -= 1\\n\\t\\tif balance == 0:\\n\\t\\t\\tres.append(S[i+1:j])\\n\\t\\t\\ti = j+1\\n\\treturn \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef removeOuterParentheses(self, S):\\n\\tres = []\\n\\tbalance = 0\\n\\ti = 0\\n\\tfor j in range(len(S)):\\n\\t\\tif S[j] == \"(\":\\n\\t\\t\\tbalance += 1\\n\\t\\telif S[j] == \")\":\\n\\t\\t\\tbalance -= 1\\n\\t\\tif balance == 0:\\n\\t\\t\\tres.append(S[i+1:j])\\n\\t\\t\\ti = j+1\\n\\treturn \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2916928,
                "title": "one-pass-faang-sde-1-interview",
                "content": "```\\nVery Easy Beginner Friendly Solution \\uD83D\\uDCA1\\nDo not use stack to prevent more extra space.\\n\\n\\nPlease do Upvote if it helps :)\\n```\\n\\n# Complexity\\n- Time complexity: O(n) //One pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) //For resultant string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && count==0)\\n                count++;\\n            else if(s[i]==\\'(\\' && count>=1){\\n                res+=s[i];\\n                count++;\\n            }   \\n            else if(s[i]==\\')\\' && count>1){\\n                res+=s[i];\\n                count--;\\n            }\\n            else if(s[i]==\\')\\' && count==1)\\n                count--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nVery Easy Beginner Friendly Solution \\uD83D\\uDCA1\\nDo not use stack to prevent more extra space.\\n\\n\\nPlease do Upvote if it helps :)\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && count==0)\\n                count++;\\n            else if(s[i]==\\'(\\' && count>=1){\\n                res+=s[i];\\n                count++;\\n            }   \\n            else if(s[i]==\\')\\' && count>1){\\n                res+=s[i];\\n                count--;\\n            }\\n            else if(s[i]==\\')\\' && count==1)\\n                count--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319686,
                "title": "easy-to-understand-python-with-comments",
                "content": "```Python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \\'\\'\\n        stack = []\\n        \\n        # basket is used to store previous value\\n        basket = \\'\\'\\n        \\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(p)\\n            else:\\n                stack.pop()\\n            basket += p\\n            \\n            # if the stack is empty it means we have a valid\\n            # decomposition. remove the outer parentheses\\n            # and put it in the result/res. make sure to\\n            # clean up the basket though!\\n            if not stack:\\n                res += basket[1:-1]\\n                basket = \\'\\'\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```Python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \\'\\'\\n        stack = []\\n        \\n        # basket is used to store previous value\\n        basket = \\'\\'\\n        \\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(p)\\n            else:\\n                stack.pop()\\n            basket += p\\n            \\n            # if the stack is empty it means we have a valid\\n            # decomposition. remove the outer parentheses\\n            # and put it in the result/res. make sure to\\n            # clean up the basket though!\\n            if not stack:\\n                res += basket[1:-1]\\n                basket = \\'\\'\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428396,
                "title": "java-beats-98-simple-iterative-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273884,
                "title": "ridiculously-simple-java-o-n-solution-explanation-0ms-beats-100-time-memory",
                "content": "**Explanation:**\\nSince the input String only consists of parentheses we don\\'t even have to mainatain a Stack. We can simply maintain a counter which is O(1) and keep incrementing and decrementing it\\'s value based on the opening/closing bracket.\\n\\n**Algorithm:**\\n1. Convert the given input String to a `char` array and start scanning.\\n2. Maintain a `sum` counter (Initially 0) and for every following character in the input char array,\\n3. When, `(` check whether **sum** is greater than **zero** and if yes, add this char to your String Builder; Also, increment the **sum** by **1** \\n4. When, `)` decrement the **sum** by **1** and then, check whether **sum** is greater than **zero** and if yes, add this char to your String Builder;\\n5. Return the string from your builder.\\n\\n**Code:**\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif (chr[i] == \\'(\\') {\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t\\tsum += 1;\\n\\t\\t} else {\\n\\t\\t\\tsum -= 1;\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```\\n\\n**Compressed Version:**\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif ((chr[i] == \\'(\\' && sum++ > 0) || (chr[i] == \\')\\' && --sum > 0)) {\\n\\t\\t\\tbuilder.append(chr[i]);\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif (chr[i] == \\'(\\') {\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t\\tsum += 1;\\n\\t\\t} else {\\n\\t\\t\\tsum -= 1;\\n\\t\\t\\tif (sum > 0) { builder.append(chr[i]); }\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder builder = new StringBuilder();\\n\\tchar[] chr = S.toCharArray();\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < chr.length; i++) {\\n\\t\\tif ((chr[i] == \\'(\\' && sum++ > 0) || (chr[i] == \\')\\' && --sum > 0)) {\\n\\t\\t\\tbuilder.append(chr[i]);\\n\\t\\t}\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269956,
                "title": "c-two-pointers",
                "content": "# Intuition\\nWhen the number of ```open``` parentheses equals ```closed```, we found a primitive string.\\n# Solution\\nUse two pointers to track primitive strings; when ```open == close```, remove outermost parentheses and add the string to the result.\\n```\\nstring removeOuterParentheses(string S, string res = \"\") {\\n  for (auto p1 = 0, p2 = 0, open = 0, close = 0; p2 < S.size(); ++p2) {\\n    if (S[p2] == \\'(\\') ++open;\\n    else ++close;\\n    if (open == close) {\\n      res += S.substr(p1 + 1, p2 - p1 - 1);\\n      p1 = p2 + 1;\\n    }\\n  }\\n  return res;\\n}\\n```\\n# Complexity Analysis\\nRuntime: O(n).\\nMemory: O(n) to store the result.",
                "solutionTags": [],
                "code": "```open```\n```closed```\n```open == close```\n```\\nstring removeOuterParentheses(string S, string res = \"\") {\\n  for (auto p1 = 0, p2 = 0, open = 0, close = 0; p2 < S.size(); ++p2) {\\n    if (S[p2] == \\'(\\') ++open;\\n    else ++close;\\n    if (open == close) {\\n      res += S.substr(p1 + 1, p2 - p1 - 1);\\n      p1 = p2 + 1;\\n    }\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262840,
                "title": "c-stack-and-without-stack-solutions",
                "content": "**Stack implementation**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char>sc;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(sc.size() > 0)\\n                {\\n                    ans += i;\\n                }\\n                sc.push(i);\\n            }\\n            else\\n            {\\n                if(sc.size() > 1)\\n                {\\n                    ans += i;\\n                }\\n                sc.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Without stack implementation**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        int count = 0;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(count > 0)\\n                {\\n                    ans += i;\\n                }\\n                count++;\\n            }\\n            else\\n            {\\n                if(count > 1)\\n                {\\n                    ans += i;\\n                }\\n                count--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char>sc;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(sc.size() > 0)\\n                {\\n                    ans += i;\\n                }\\n                sc.push(i);\\n            }\\n            else\\n            {\\n                if(sc.size() > 1)\\n                {\\n                    ans += i;\\n                }\\n                sc.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        int count = 0;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(i == \\'(\\')\\n            {\\n                if(count > 0)\\n                {\\n                    ans += i;\\n                }\\n                count++;\\n            }\\n            else\\n            {\\n                if(count > 1)\\n                {\\n                    ans += i;\\n                }\\n                count--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594405,
                "title": "python-super-easy-98-speed",
                "content": "We just need a For-Loop to count the number of Parenthesis open. The \"append\" operator goes at the center of the expression to avoid including the Outermost Patentheses. Cheers,\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        popen, result = 0, []\\n        for x in S:\\n            if x==\\')\\':\\n                popen -= 1\\n            if popen>0:\\n                result.append(x)\\n            if x==\\'(\\':\\n                popen += 1\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        popen, result = 0, []\\n        for x in S:\\n            if x==\\')\\':\\n                popen -= 1\\n            if popen>0:\\n                result.append(x)\\n            if x==\\'(\\':\\n                popen += 1\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301174,
                "title": "javascript-beats-99-26-easy-to-understand",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\';\\n    let open = 0\\n    for (let i = 0; i < S.length; i++) {\\n        if (S[i] === \\'(\\') {\\n            if (open > 0) { \\n\\t\\t\\t\\tresult += \\'(\\';\\n\\t\\t\\t}\\n\\t\\t\\topen++;\\n        } else if (S[i] === \\')\\') {\\n            if (open > 1) { \\n\\t\\t\\t\\tresult += \\')\\'; \\n\\t\\t\\t}\\n\\t\\t\\topen--;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\';\\n    let open = 0\\n    for (let i = 0; i < S.length; i++) {\\n        if (S[i] === \\'(\\') {\\n            if (open > 0) { \\n\\t\\t\\t\\tresult += \\'(\\';\\n\\t\\t\\t}\\n\\t\\t\\topen++;\\n        } else if (S[i] === \\')\\') {\\n            if (open > 1) { \\n\\t\\t\\t\\tresult += \\')\\'; \\n\\t\\t\\t}\\n\\t\\t\\topen--;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680199,
                "title": "python-solution-using-stack-and-maintaining-counter",
                "content": "# Before I explain any further get this, let\\'s say for each \"(\" you get you put -1 and for each \")\" you get you put +1 to the counter varriable and because of that whenever we encounter a valid paranthese our sum will be zero for example for (()())(()) can be decomposed to (()()) + (()) note that for each valid decomposition our sum will be zero. Example (()) -1-1+1+1 ==0 also for (()()) -1-1+1-1+1+1==0 for each time our sum is zero we are looking at a valid decompostion and hence at that moment we take what we have in our stack and remove the outter brackets which is done easily using stack[1:-1] it will exlude the first and last from our stack and we add this value to our answer list and make our stack empty again for future decompistion, we repeat this and return the \" \".join(final_answer) here final answer is the list that has all the decompositions with there outter barckets removed. Upvote if you liked the approch. Thanks\\n\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = []\\n        final_answer = []\\n        counter=0\\n        for val in s:\\n            stack.append(val)\\n            if val==\\'(\\':\\n                counter+=1\\n            elif val==\\')\\':\\n                counter-=1\\n            if counter==0:\\n                final_answer+=stack[1:-1]\\n                stack=[]\\n        \\n        return \"\".join(final_answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = []\\n        final_answer = []\\n        counter=0\\n        for val in s:\\n            stack.append(val)\\n            if val==\\'(\\':\\n                counter+=1\\n            elif val==\\')\\':\\n                counter-=1\\n            if counter==0:\\n                final_answer+=stack[1:-1]\\n                stack=[]\\n        \\n        return \"\".join(final_answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379872,
                "title": "javascript-solution-98-faster",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let parenthesCount = 0;\\n    let result = \"\";\\n    \\n    for (const letter of S) {\\n        if (letter === \"(\") {\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n            parenthesCount++;\\n        } else {\\n            parenthesCount--;\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let parenthesCount = 0;\\n    let result = \"\";\\n    \\n    for (const letter of S) {\\n        if (letter === \"(\") {\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n            parenthesCount++;\\n        } else {\\n            parenthesCount--;\\n            if (parenthesCount) {\\n                result += letter;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358358,
                "title": "shortest-python-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        cnt, res = 0, \\'\\'\\n        for c in S:\\n            if c == \\')\\': cnt -= 1  \\n            if cnt != 0: res += c \\n            if c == \\'(\\': cnt+=1    \\n        return res\\n```            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        cnt, res = 0, \\'\\'\\n        for c in S:\\n            if c == \\')\\': cnt -= 1  \\n            if cnt != 0: res += c \\n            if c == \\'(\\': cnt+=1    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399066,
                "title": "python3-simple-solution-99-8",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        count = 0\\n        first = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                count +=1\\n            else:\\n                count -= 1\\n            \\n            if(count == 0):\\n                res +=(S[first+1:i])\\n                first = i+1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        count = 0\\n        first = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                count +=1\\n            else:\\n                count -= 1\\n            \\n            if(count == 0):\\n                res +=(S[first+1:i])\\n                first = i+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194215,
                "title": "best-c-2-solution-ever-string-stack-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using String + Stack.\\n2. Solved using String.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(N), Stack(store) space.\\n\\n    Solved using String + Stack.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> store;\\n        string ans = \"\";\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(store.size() > 0){\\n                    ans += c;\\n                }\\n                store.push(c);\\n            }\\n            else if(c == \\')\\'){\\n                if(store.size() > 1){\\n                    ans += c;\\n                }\\n                store.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the String(ans), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using String.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int openParentheses = 0;\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(openParentheses > 0){\\n                    ans += c;\\n                }\\n                openParentheses++;\\n            }\\n            else if(c == \\')\\'){\\n                if(openParentheses > 1){\\n                    ans += c;\\n                }\\n                openParentheses--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(N), Stack(store) space.\\n\\n    Solved using String + Stack.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> store;\\n        string ans = \"\";\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(store.size() > 0){\\n                    ans += c;\\n                }\\n                store.push(c);\\n            }\\n            else if(c == \\')\\'){\\n                if(store.size() > 1){\\n                    ans += c;\\n                }\\n                store.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the string(num). Here loop creates the time complexity.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the String(ans), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using String.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int openParentheses = 0;\\n        for(auto c : s){\\n            if(c == \\'(\\'){\\n                if(openParentheses > 0){\\n                    ans += c;\\n                }\\n                openParentheses++;\\n            }\\n            else if(c == \\')\\'){\\n                if(openParentheses > 1){\\n                    ans += c;\\n                }\\n                openParentheses--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308161,
                "title": "java-in-6-lines",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int count = 0;\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\n\\t\\t\\tif (c == \\'(\\' && count++ > 0) { sb.append(c); }\\n\\t\\t\\tif (c == \\')\\' && --count > 0) { sb.append(c); }\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int count = 0;\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\n\\t\\t\\tif (c == \\'(\\' && count++ > 0) { sb.append(c); }\\n\\t\\t\\tif (c == \\')\\' && --count > 0) { sb.append(c); }\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270153,
                "title": "simple-o-n-java-solution",
                "content": "Thanks to fengyunzhe90.\\n\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        \\n        String result = \"\";\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (stack.isEmpty() && c == \\'(\\') {\\n                stack.push(c);\\n                continue;\\n            }\\n            \\n            if (stack.size() == 1 && c == \\')\\') {\\n                stack.pop();\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            \\n            if (c == \\')\\') {\\n                stack.pop();\\n            }\\n            result += c + \"\";\\n        }\\n\\n        return result;\\n    }\\n} ;",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        \\n        String result = \"\";\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (stack.isEmpty() && c == \\'(\\') {\\n                stack.push(c);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1297744,
                "title": "java-o-n-easy-approach-with-comment",
                "content": "```\\nclass Solution\\n{\\n    public String removeOuterParentheses(String S) \\n    {\\n        Stack<Character> valid=new Stack<>();//checking the balance and when the stack is Empty\\n        List<Integer> index=new ArrayList<>();//for storing the index\\n        char ch;\\n        \\n        for(int i=0;i<S.length();i++)//traversering the indices \\n        {\\n            ch=S.charAt(i);//extracting charracter\\n            if(valid.isEmpty())//new valid parentheses \\n            {\\n                valid.push(ch);//pushing it into the stack the open parentheses \\n                index.add(i);//and pushing it corresponding index \\n            }\\n            else if(ch==\\')\\'&&valid.peek()==\\'(\\')\\n            {\\n                valid.pop();\\n                if(valid.isEmpty())//ending of new valid parentheses\\n                   index.add(i);//storing the closing index \\n            }\\n            else\\n            {\\n                valid.push(ch);//otherwise pushing he open parentheses \\n            }\\n        }\\n        StringBuilder res=new StringBuilder();//resultant \\n        for(int i=0;i<index.size();i+=2)//index is always in pair i.e;starting and ending \\n        {\\n            res.append(S.substring(index.get(i)+1,index.get(i+1)));//removing the outmost parenthesis for the given pair of indices \\n        }\\n        return res.toString();//returning the String \\n    }\\n}//Please do vote me, It helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public String removeOuterParentheses(String S) \\n    {\\n        Stack<Character> valid=new Stack<>();//checking the balance and when the stack is Empty\\n        List<Integer> index=new ArrayList<>();//for storing the index\\n        char ch;\\n        \\n        for(int i=0;i<S.length();i++)//traversering the indices \\n        {\\n            ch=S.charAt(i);//extracting charracter\\n            if(valid.isEmpty())//new valid parentheses \\n            {\\n                valid.push(ch);//pushing it into the stack the open parentheses \\n                index.add(i);//and pushing it corresponding index \\n            }\\n            else if(ch==\\')\\'&&valid.peek()==\\'(\\')\\n            {\\n                valid.pop();\\n                if(valid.isEmpty())//ending of new valid parentheses\\n                   index.add(i);//storing the closing index \\n            }\\n            else\\n            {\\n                valid.push(ch);//otherwise pushing he open parentheses \\n            }\\n        }\\n        StringBuilder res=new StringBuilder();//resultant \\n        for(int i=0;i<index.size();i+=2)//index is always in pair i.e;starting and ending \\n        {\\n            res.append(S.substring(index.get(i)+1,index.get(i+1)));//removing the outmost parenthesis for the given pair of indices \\n        }\\n        return res.toString();//returning the String \\n    }\\n}//Please do vote me, It helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978008,
                "title": "java-simple-solution-runtime-2ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                if (count != 0) {\\n                    result.append(c);\\n                }\\n                count++;\\n            } else {\\n                if (count != 1) {\\n                    result.append(c);\\n                }\\n                count--;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/81901a24-f5a0-4fb4-a020-a3cda419a018_1693337713.2181766.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                if (count != 0) {\\n                    result.append(c);\\n                }\\n                count++;\\n            } else {\\n                if (count != 1) {\\n                    result.append(c);\\n                }\\n                count--;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766133,
                "title": "stack-java",
                "content": "If you like it pls upvote\\n```\\n\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (st.size() >= 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.push(s.charAt(i));\\n            } else {\\n                if (st.size() > 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (st.size() >= 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.push(s.charAt(i));\\n            } else {\\n                if (st.size() > 1) {\\n                    sb.append(s.charAt(i));\\n                }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271188,
                "title": "c-solution-using-stack",
                "content": "```class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string result=\"\";\\n        stack<char> st;\\n        for(auto ch : S){\\n            if(ch==\\'(\\'){\\n                if(st.size()>0){\\n                    result+=ch;\\n                }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    result+=ch;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string result=\"\";\\n        stack<char> st;\\n        for(auto ch : S){\\n            if(ch==\\'(\\'){\\n                if(st.size()>0){\\n                    result+=ch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2607580,
                "title": "java-2-approaches-with-without-stack",
                "content": "**The main thing is --> (()()) --> If the stack(or counter) is greater than 1 then include \"(\" and \")\" in answer else don\\'t include as we need to remove outermost parenthesis... If you find the solution helpful please  upvote :)**\\n\\n**Without stack approach -->**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int level = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                level++;\\n            }\\n            if(level > 1){\\n                sb.append(s.charAt(i));\\n            }\\n            if(s.charAt(i) == \\')\\'){\\n                level--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n**With Stack Approach-->**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> st = new Stack<>();\\n        for(char c : s.toCharArray()){\\n            if(st.isEmpty() && c == \\'(\\'){\\n                st.push(\\'(\\');\\n            }\\n            else if(!st.isEmpty() && c == \\'(\\'){\\n                st.push(c);\\n                sb.append(c);\\n            }\\n            else if(st.size() >1 && c == \\')\\'){\\n                st.pop();\\n                sb.append(c);\\n            }\\n            else if(st.size() == 1 && c == \\')\\'){\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int level = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                level++;\\n            }\\n            if(level > 1){\\n                sb.append(s.charAt(i));\\n            }\\n            if(s.charAt(i) == \\')\\'){\\n                level--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> st = new Stack<>();\\n        for(char c : s.toCharArray()){\\n            if(st.isEmpty() && c == \\'(\\'){\\n                st.push(\\'(\\');\\n            }\\n            else if(!st.isEmpty() && c == \\'(\\'){\\n                st.push(c);\\n                sb.append(c);\\n            }\\n            else if(st.size() >1 && c == \\')\\'){\\n                st.pop();\\n                sb.append(c);\\n            }\\n            else if(st.size() == 1 && c == \\')\\'){\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977605,
                "title": "c-0ms-shortest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> st;\\n        string ans;\\n        for(char c: S)\\n        {\\n            if(c == \\')\\') st.pop();\\n            if(!st.empty()) ans += c;\\n            if(c == \\'(\\') st.push(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> st;\\n        string ans;\\n        for(char c: S)\\n        {\\n            if(c == \\')\\') st.pop();\\n            if(!st.empty()) ans += c;\\n            if(c == \\'(\\') st.push(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915577,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) space O(n)\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\'\\n    let level = 0\\n    \\n    for(const item of S) {\\n        if(item === \\')\\') {\\n            level--\\n        }\\n        if(level >= 1) {\\n            result += item                \\n        }\\n        if(item === \\'(\\') {\\n            level++\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) space O(n)\\nvar removeOuterParentheses = function(S) {\\n    let result = \\'\\'\\n    let level = 0\\n    \\n    for(const item of S) {\\n        if(item === \\')\\') {\\n            level--\\n        }\\n        if(level >= 1) {\\n            result += item                \\n        }\\n        if(item === \\'(\\') {\\n            level++\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526367,
                "title": "c-2-solutions-stack-counter",
                "content": "# Solution 1 : Use std::stack\\n\\n## Intuition\\nTo solve this problem, we can keep track of the outer parentheses using a stack. Whenever we encounter an open parenthesis, we push it onto the stack. When we encounter a close parenthesis, we pop an open parenthesis from the stack. We only add the current character to our result string when the stack is not empty.\\n\\n## Approach\\n1 Initialize an empty stack and an empty result string.\\n2. Iterate through the input string:\\na. If the stack is not empty, add the current character to the result string.\\nb. If the current character is an open parenthesis, push it onto the stack.\\nc. If the current character is a close parenthesis, pop an open parenthesis from the stack. If the stack is now empty, remove the last character from the result string.\\n3. Return the result string.\\n\\n## Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string. We iterate through the entire string once.\\n- Space complexity: $$O(n)$$, as in the worst case (e.g., all open parentheses), the stack could store all characters in the input string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::stack<char> stack;\\n        std::string r;\\n\\n        for(auto c: s){\\n            if(!stack.empty()) {\\n                r += c;\\n            }\\n            if(c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            else {\\n                stack.pop();\\n                if(stack.empty()) { \\n                    r.pop_back();\\n                }\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```\\n\\n\\n# Solution 2 : Use a counter\\n\\n## Intuition\\nAn alternative to using a stack is to simply maintain a count of the open parentheses encountered. We can increment the count when we encounter an open parenthesis and decrement it when we encounter a close parenthesis.\\n\\n## Approach\\n1. Initialize an empty result string and a count variable set to 0.\\n2. Iterate through the input string:\\na. If the current character is an open parenthesis and the count is greater than 0, add the current character to the result string and increment the count.\\nb. If the current character is a close parenthesis and the count is greater than 1, add the current character to the result string and decrement the count.\\n3. Return the result string.\\n\\n## Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string. We iterate through the entire string once.\\n- Space complexity: $$O(n)$$, since the result string could store up to n-2 characters (e.g., if the input string has only one pair of outer parentheses).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::string r;\\n        int count = 0;\\n        for(char c : s){\\n            if(c == \\'(\\' && count++ > 0) r += c;\\n            if(c == \\')\\' && count-- > 1) r += c;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::stack<char> stack;\\n        std::string r;\\n\\n        for(auto c: s){\\n            if(!stack.empty()) {\\n                r += c;\\n            }\\n            if(c == \\'(\\') {\\n                stack.push(c);\\n            }\\n            else {\\n                stack.pop();\\n                if(stack.empty()) { \\n                    r.pop_back();\\n                }\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        std::string r;\\n        int count = 0;\\n        for(char c : s){\\n            if(c == \\'(\\' && count++ > 0) r += c;\\n            if(c == \\')\\' && count-- > 1) r += c;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720986,
                "title": "c-stack-and-without-stack-easy-solution",
                "content": "**Approach 1: (Stack) \\u2705**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    stack<char>st;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st.size()>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st.push(\\'(\\');\\n        }\\n        else\\n        {\\n            if(st.size()>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st.pop();\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n               st.pop();\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Approach 2: (Without Stack ) \\u2705**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    int st=0;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st++;\\n        }\\n        else\\n        {\\n            if(st>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    stack<char>st;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st.size()>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st.push(\\'(\\');\\n        }\\n        else\\n        {\\n            if(st.size()>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st.pop();\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n               st.pop();\\n                if(st.size() > 0){\\n                    sb.append(ch);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\nstring removeOuterParentheses(string S) {\\n    int st=0;\\n    string ans;\\n    for(auto a:S)\\n    {\\n        if(a==\\'(\\')\\n        {\\n            if(st>0)\\n            {\\n                ans+=\\'(\\';\\n            }\\n            st++;\\n        }\\n        else\\n        {\\n            if(st>1)\\n            {\\n                ans+=\\')\\';\\n            }\\n            st--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        for(char c : S.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250239,
                "title": "java-two-solution-1-using-stack-2-simple-for-loop",
                "content": "using Stack\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nusing Array\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int top=-1;\\n        String str=\"\";\\n        for(int i=0;i<S.length()-1;i++){\\n           \\n            if(S.charAt(i)==\\'(\\'&&++top!=0)\\n           {\\n               str+=S.charAt(i);\\n           }\\n            else if(S.charAt(i)==\\')\\'&&--top!=-1)\\n            {\\n                str+=S.charAt(i);\\n            }\\n          \\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1)\\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int top=-1;\\n        String str=\"\";\\n        for(int i=0;i<S.length()-1;i++){\\n           \\n            if(S.charAt(i)==\\'(\\'&&++top!=0)\\n           {\\n               str+=S.charAt(i);\\n           }\\n            else if(S.charAt(i)==\\')\\'&&--top!=-1)\\n            {\\n                str+=S.charAt(i);\\n            }\\n          \\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162269,
                "title": "python-simplest-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        stack=[]\\n        counter=0\\n        for i in S:\\n            if i==\\'(\\':\\n                counter=counter+1\\n                if counter==1:\\n                    pass\\n                else:\\n                    stack.append(i)\\n            else:\\n                counter=counter-1\\n                if counter == 0:\\n                    pass\\n                else:\\n                    stack.append(i)\\n        return (\\'\\'.join(stack))\\n```\\n\\nDo upvote \\uD83D\\uDC4D if you like and understand my approach!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        stack=[]\\n        counter=0\\n        for i in S:\\n            if i==\\'(\\':\\n                counter=counter+1\\n                if counter==1:\\n                    pass\\n                else:\\n                    stack.append(i)\\n            else:\\n                counter=counter-1\\n                if counter == 0:\\n                    pass\\n                else:\\n                    stack.append(i)\\n        return (\\'\\'.join(stack))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270450,
                "title": "javascript-counter-solution",
                "content": "```\\n/**\\n * @param {string} S\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(S) {\\n    let counter = 0;\\n    let result = \\'\\';\\n    \\n    for (let i = 0; i < S.length; i++) {\\n        if ((S[i] === \\'(\\' && ++counter !== 1) || (S[i] === \\')\\' && --counter !== 0)) {\\n            result += S[i];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(S) {\\n    let counter = 0;\\n    let result = \\'\\';\\n    \\n    for (let i = 0; i < S.length; i++) {\\n        if ((S[i] === \\'(\\' && ++counter !== 1) || (S[i] === \\')\\' && --counter !== 0)) {\\n            result += S[i];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890939,
                "title": "easy-c-solution-beginner-friendly",
                "content": "\\n# Approach\\nThis question is all about the counter. As the very first bracket would start from 0 and thus that will not be included and the last outermost bracket with value 0 will also be not included.\\n\\nIn this way we will check whether the char should be added into the string or not. \\nAdd 1 if there is \\'(\\' open parenthesis. and sub 1 if  \\')\\' clsed paranthesis.\\n\\nFor eg.\\n    \\n![01.png](https://assets.leetcode.com/users/images/0aec98a5-dfdc-452d-9417-ad1e1bacf6eb_1691679008.493465.png)\\n\\n\\nIn above explanation, wherever the count is zero. We are not adding that in string.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int c=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\' && c==0){\\n                //skip, as this would be the first bracket so it will be considered as outermost bracket\\n                c++;\\n            }\\n            else if(ch==\\'(\\' && c>=1){\\n                ans+=ch;\\n                c++;\\n                //add ch in the string\\n            }\\n            else if(ch==\\')\\' && c>1){\\n                //sub ch in the string, as it\\'s pair is alrrady added\\n                ans+=ch;\\n                c--;\\n            }\\n            else if(ch==\\')\\' && c==1){\\n                //skip it, outermost bracket\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int c=0;\\n        for(char ch:s){\\n            if(ch==\\'(\\' && c==0){\\n                //skip, as this would be the first bracket so it will be considered as outermost bracket\\n                c++;\\n            }\\n            else if(ch==\\'(\\' && c>=1){\\n                ans+=ch;\\n                c++;\\n                //add ch in the string\\n            }\\n            else if(ch==\\')\\' && c>1){\\n                //sub ch in the string, as it\\'s pair is alrrady added\\n                ans+=ch;\\n                c--;\\n            }\\n            else if(ch==\\')\\' && c==1){\\n                //skip it, outermost bracket\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876395,
                "title": "c-beats-100-self-explained-beginner-friendly-approach-clean-code-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        stack <char> st;\\n        for(int i:s)\\n        {\\n            if(i==\\'(\\')\\n            {\\n                if(!st.empty())\\n                {\\n                result.push_back(i);\\n                }\\n                st.push(i);\\n            }\\n            else{\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        stack <char> st;\\n        for(int i:s)\\n        {\\n            if(i==\\'(\\')\\n            {\\n                if(!st.empty())\\n                {\\n                result.push_back(i);\\n                }\\n                st.push(i);\\n            }\\n            else{\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    result.push_back(i);\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627545,
                "title": "remove-outermost-parentheses-cpp-easy-way",
                "content": "```\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if( s[i]==\\'(\\' && count == 0){\\n                count++;\\n            }\\n            else\\n                if(s[i]==\\'(\\' && count>0){\\n                    count++;\\n                    ans+=s[i];\\n                }\\n            else if(s[i]==\\')\\'){\\n                count--;\\n                if(count>0)ans+=s[i];\\n            } \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1949936,
                "title": "simple-short-and-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        string ans = \"\";\\n        stack<char> s;\\n        \\n        for(char c : str){\\n            if(c == \\'(\\') s.push(c);\\n            if(s.size() > 1) ans += c;\\n            if(c == \\')\\') s.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        string ans = \"\";\\n        stack<char> s;\\n        \\n        for(char c : str){\\n            if(c == \\'(\\') s.push(c);\\n            if(s.size() > 1) ans += c;\\n            if(c == \\')\\') s.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338577,
                "title": "python-solution-beats-99",
                "content": "Traverse the string `S` from left to right. Time: O(N).\\n\\nUse the variable `net` to record the current net number of parenthese -- \\'(\\' contributes +1 and \\')\\' contributes -1. \\n\\nThe variable \\'start\\' is to store the starting index of the next primitive part in \\'S\\'.\\n\\nWhenever \\'net\\' becomes 0, one concludes that from the start position to the current position we have a primitive part. Update `res` by adding this primitive part without the starting \\'(\\' and the ending \\')\\'. Also, reset `start`.\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        net, res, start = 0 , \\'\\', 0\\n        for i in range(len(S)):\\n            \\n            if S[i] == \\'(\\':\\n                net += 1\\n            else:\\n                net -= 1\\n            \\n            if net == 0:\\n                res += S[start+1:i]\\n                start = i + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        net, res, start = 0 , \\'\\', 0\\n        for i in range(len(S)):\\n            \\n            if S[i] == \\'(\\':\\n                net += 1\\n            else:\\n                net -= 1\\n            \\n            if net == 0:\\n                res += S[start+1:i]\\n                start = i + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398832,
                "title": "c-and-c-very-easy-solution",
                "content": "# Intuition:First of all,we have to find outer parentheses and after that we have to add other parentheses to a new string.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:Each pair has a couple of parenthese.So we use stack to declare which parenthese is either opener or cleser.\\n<!-- Describe your approach to solving the problem. -->\\n![photo_2023-04-10_05-40-10.jpg](https://assets.leetcode.com/users/images/399e55fc-74f8-4ba0-809c-086907be6e71_1681087371.7124531.jpeg)\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        int index = 0;\\n        for (char x : s) {\\n           switch(x){\\n               case \\'(\\':\\n               if(index++>0)result+=x;\\n               break;\\n               case \\')\\':\\n               if(index-->1)result+=x;\\n               break;\\n           }\\n        }\\n        return result;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        StringBuilder result=new();\\n        int index = 0;\\n        foreach (char x in s) {\\n            if (x == \\'(\\' && index++ > 0) \\n            result.Append(x);\\n            else if (x == \\')\\' && index-- > 1) \\n            result.Append(x);\\n        }\\n        return result.ToString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string result;\\n        int index = 0;\\n        for (char x : s) {\\n           switch(x){\\n               case \\'(\\':\\n               if(index++>0)result+=x;\\n               break;\\n               case \\')\\':\\n               if(index-->1)result+=x;\\n               break;\\n           }\\n        }\\n        return result;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        StringBuilder result=new();\\n        int index = 0;\\n        foreach (char x in s) {\\n            if (x == \\'(\\' && index++ > 0) \\n            result.Append(x);\\n            else if (x == \\')\\' && index-- > 1) \\n            result.Append(x);\\n        }\\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109592,
                "title": "best-o-n-solution",
                "content": "\\n\\n# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                if (count > 0)\\n                    ans += s[i]; \\n                count++;\\n            }\\n            if (s[i] == \\')\\') {\\n                if (count > 1)\\n                    ans += s[i];\\n                count--;\\n            }       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') {\\n                if (count > 0)\\n                    ans += s[i]; \\n                count++;\\n            }\\n            if (s[i] == \\')\\') {\\n                if (count > 1)\\n                    ans += s[i];\\n                count--;\\n            }       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062859,
                "title": "java-without-using-stack-simple-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       String res=\"\";\\n       int k=0;\\n       int op=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==\\'(\\')op++;\\n           else op--;\\n           if(op==0){\\n               res+=help(s.substring(k,i+1));\\n               k=i+1;\\n           }\\n       }\\n       return res;\\n    }\\n\\n    public static String help(String str)\\n    {\\n        return str.substring(1,str.length()-1);\\n    }\\n}\\n\\n/*\\n s = \"(  ()()   )    (  ()   )\"\\n int k=0;\\n open=0;close=0;\\n ( op=1  ( op=1\\n (op=2   ( op=2\\n )op=1   ) op=1\\n (op=2   ) op=0\\n )op=1\\n)op=0\\nwhen op becomes 0 (op=0) , we gonna found one decompose string and removing it\\'s outer most parenthese\\n*/\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       String res=\"\";\\n       int k=0;\\n       int op=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==\\'(\\')op++;\\n           else op--;\\n           if(op==0){\\n               res+=help(s.substring(k,i+1));\\n               k=i+1;\\n           }\\n       }\\n       return res;\\n    }\\n\\n    public static String help(String str)\\n    {\\n        return str.substring(1,str.length()-1);\\n    }\\n}\\n\\n/*\\n s = \"(  ()()   )    (  ()   )\"\\n int k=0;\\n open=0;close=0;\\n ( op=1  ( op=1\\n (op=2   ( op=2\\n )op=1   ) op=1\\n (op=2   ) op=0\\n )op=1\\n)op=0\\nwhen op becomes 0 (op=0) , we gonna found one decompose string and removing it\\'s outer most parenthese\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009037,
                "title": "without-stack-beats-100-6-lines-solution-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n    int cnt = 0;\\n    string res;\\n    for(char x : s)\\n    { \\n        if(x == \\'(\\'&& cnt++ > 0) res += x;\\n        if (x == \\')\\' && cnt-- > 1) res += x;\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n    int cnt = 0;\\n    string res;\\n    for(char x : s)\\n    { \\n        if(x == \\'(\\'&& cnt++ > 0) res += x;\\n        if (x == \\')\\' && cnt-- > 1) res += x;\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834889,
                "title": "java-faster-solution-99-85-big-o-n-without-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if( s.charAt(i) == \\'(\\'){\\n                count++;\\n                if(count>=2) str.append(\\'(\\');\\n            }else {\\n                if(count>=2) str.append(\\')\\');\\n                count--;\\n            }\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if( s.charAt(i) == \\'(\\'){\\n                count++;\\n                if(count>=2) str.append(\\'(\\');\\n            }else {\\n                if(count>=2) str.append(\\')\\');\\n                count--;\\n            }\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859843,
                "title": "c-easy-understandable-solution-using-stack",
                "content": "```\\nstring removeOuterParentheses(string s) {\\n        stack<char>s1;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(s1.size()>0)\\n                    ans+=\\'(\\';\\n                s1.push(\\'(\\');\\n            }else\\n            {\\n                if(s1.size()>1)\\n                    ans+=\\')\\';\\n                s1.pop();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        stack<char>s1;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(s1.size()>0)\\n                    ans+=\\'(\\';\\n                s1.push(\\'(\\');\\n            }else\\n            {\\n                if(s1.size()>1)\\n                    ans+=\\')\\';\\n                s1.pop();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487636,
                "title": "100-fastest-solution-explained-every-line-efficient-easy-to-understand-cpp-o-n",
                "content": "100% fastest solution | Explained every line | Efficient | Easy to understand | cpp | O(n)\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans;\\n        stack<char> st;\\n\\n        for(auto x: s)\\n        {\\n            if(x==\\'(\\')   // 1. ->add to stack    2. -> add to ans if not outermost\\n            {\\n                if(st.size()>0)\\n                    ans.push_back(x);\\n                st.push(x);\\n            }\\n            else  // 1. -> pop    2. -> add to ans if not empty\\n            {\\n                st.pop();\\n                if(!st.empty())\\n                    ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans;\\n        stack<char> st;\\n\\n        for(auto x: s)\\n        {\\n            if(x==\\'(\\')   // 1. ->add to stack    2. -> add to ans if not outermost\\n            {\\n                if(st.size()>0)\\n                    ans.push_back(x);\\n                st.push(x);\\n            }\\n            else  // 1. -> pop    2. -> add to ans if not empty\\n            {\\n                st.pop();\\n                if(!st.empty())\\n                    ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1209415,
                "title": "python-simple-solution-speed-98-46-and-memory-99-39",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        ans = []\\n        l = []\\n        count = 0\\n        for i in S:\\n            l.append(i)\\n            if i == \\'(\\':\\n                count+= 1\\n            else:\\n                count -= 1\\n            if count == 0:\\n                ans.extend(l[1:-1])\\n                l = []\\n        return \"\".join(ans)\\n\\t\\t\\n\\t# Kindly upvote if you find it useful !!\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        ans = []\\n        l = []\\n        count = 0\\n        for i in S:\\n            l.append(i)\\n            if i == \\'(\\':\\n                count+= 1\\n            else:\\n                count -= 1\\n            if count == 0:\\n                ans.extend(l[1:-1])\\n                l = []\\n        return \"\".join(ans)\\n\\t\\t\\n\\t# Kindly upvote if you find it useful !!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020703,
                "title": "python-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result =  \\'\\'\\n        depth = 0\\n        for index in range(0, len(S) - 1):\\n            char = S[index]\\n            if depth != 0:\\n                result += char\\n            if char == \"(\" and S[index + 1] == \"(\":\\n                depth += 1\\n            elif char == \")\" and S[index + 1] == \")\":\\n                depth -= 1\\n        return result\\n```\\n\\nThe **depth** variable represents how many levels into the primitive parentheses the current parenthesis is in. A depth value of zero represents a paraenteses belonging to a set primitive parentheses.\\n\\n## Logic\\n- Subsequent opening parentheses will result in depth increasing by one\\n- Subsequent closing parentheses will result in depth decreasing by one\\n-  A switch from closing to opening parenthesis \\'(\\' -> \\')\\' will not change the depth value\\n-  If the depth value is not 0 (i.e. not an outer parenthesis) add the current parenthesis to the result\\n-  The last parenthesis in the string S will always be a closing parenthesis [i.e. \")\" ]\\n\\n\\n### Example 1\\n| Depth Value | 0 | 1 | 2 | 2 | 1 | 0 |\\n|:-----------:|:-:|---|---|---|---|---|\\n| char in S      | ( | ( | ( | ) | ) | ) |\\n\\n\\n### Example 2\\n| Depth Value | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |\\n|:-----------:|:-:|---|---|---|---|---|---|---|\\n| char in S  | ( | ( | ) | ) | ( | ( | ) | ) |\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result =  \\'\\'\\n        depth = 0\\n        for index in range(0, len(S) - 1):\\n            char = S[index]\\n            if depth != 0:\\n                result += char\\n            if char == \"(\" and S[index + 1] == \"(\":\\n                depth += 1\\n            elif char == \")\" and S[index + 1] == \")\":\\n                depth -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955525,
                "title": "c-faster-than-100-easy",
                "content": "A simple iterative program that iterates on the string.\\nWe use a variable flag to cound the number of left parenthesis. Since we just have to remove one parenthesis only, we check if the flag value is greater than 1, and then add characters to the resultant string.\\n\\n```\\nConsider the following test case\\n\\n\\tS = \"(()())(())\"\\n\\t\\t\\n\\t\\t\\t1. S[i] = \"(\"  , flag = 1, result = \"\";\\n\\t\\t\\t2. S[i] = \"(\"  , flag = 2, result = \"(\";\\n\\t\\t\\t3. S[i] = \")\"  , flag = 1, result = \"()\";\\n\\t\\t\\t4. S[i] = \"(\"  , flag = 2, result = \"()(\";\\n\\t\\t\\t5. S[i] = \")\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t6. S[i] = \")\"  , flag = 0, result = \"()()\";\\n\\t\\t\\t7. S[i] = \"(\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t8. S[i] = \"(\"  , flag = 2, result = \"()()(\";\\n\\t\\t\\t9. S[i] = \")\"  , flag = 1, result = \"()()()\";\\n\\t\\t\\t10. S[i] = \")\"  , flag = 0, result = \"()()()\";\\n\\t\\t\\t\\n\\t\\t\\tresult = \"()()()\";\\n\\t\\t\\treturn result;\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int flag = 0,l = int(S.length());\\n        string result;\\n        for(int i = 0;i < l;i++){\\n            if(S[i] == \\'(\\'){\\n                flag += 1;\\n                result += flag > 1 ? \"(\" : \"\";\\n            } else {\\n                flag -= 1;\\n                result += flag > 0 ? \")\" : \"\";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/66145b21-665b-4402-ae74-2c6565dceefe_1606804144.1577873.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nConsider the following test case\\n\\n\\tS = \"(()())(())\"\\n\\t\\t\\n\\t\\t\\t1. S[i] = \"(\"  , flag = 1, result = \"\";\\n\\t\\t\\t2. S[i] = \"(\"  , flag = 2, result = \"(\";\\n\\t\\t\\t3. S[i] = \")\"  , flag = 1, result = \"()\";\\n\\t\\t\\t4. S[i] = \"(\"  , flag = 2, result = \"()(\";\\n\\t\\t\\t5. S[i] = \")\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t6. S[i] = \")\"  , flag = 0, result = \"()()\";\\n\\t\\t\\t7. S[i] = \"(\"  , flag = 1, result = \"()()\";\\n\\t\\t\\t8. S[i] = \"(\"  , flag = 2, result = \"()()(\";\\n\\t\\t\\t9. S[i] = \")\"  , flag = 1, result = \"()()()\";\\n\\t\\t\\t10. S[i] = \")\"  , flag = 0, result = \"()()()\";\\n\\t\\t\\t\\n\\t\\t\\tresult = \"()()()\";\\n\\t\\t\\treturn result;\\n```\n```\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int flag = 0,l = int(S.length());\\n        string result;\\n        for(int i = 0;i < l;i++){\\n            if(S[i] == \\'(\\'){\\n                flag += 1;\\n                result += flag > 1 ? \"(\" : \"\";\\n            } else {\\n                flag -= 1;\\n                result += flag > 0 ? \")\" : \"\";\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783755,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n    \\tchar [] chars=S.toCharArray();\\n    \\tStringBuilder sb=new  StringBuilder();\\n    \\tStack<Character> st= new Stack<>();\\n    \\tint startindex=0;\\n    \\tfor ( int i=0;i<chars.length;i++ ) {\\n    \\t\\tchar c= chars[i];\\n    \\t\\tif(c==\\'(\\') {\\n    \\t\\t\\tst.push(\\'(\\');\\n    \\t\\t}else if(c==\\')\\') {\\n    \\t\\t\\tst.pop();\\n    \\t\\t}\\n    \\t\\tif(st.isEmpty()) {\\n    \\t\\t\\tsb.append(S.substring((startindex+1),i));\\n    \\t\\t\\tstartindex=i+1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t}\\n    \\t\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        \\n    \\tchar [] chars=S.toCharArray();\\n    \\tStringBuilder sb=new  StringBuilder();\\n    \\tStack<Character> st= new Stack<>();\\n    \\tint startindex=0;\\n    \\tfor ( int i=0;i<chars.length;i++ ) {\\n    \\t\\tchar c= chars[i];\\n    \\t\\tif(c==\\'(\\') {\\n    \\t\\t\\tst.push(\\'(\\');\\n    \\t\\t}else if(c==\\')\\') {\\n    \\t\\t\\tst.pop();\\n    \\t\\t}\\n    \\t\\tif(st.isEmpty()) {\\n    \\t\\t\\tsb.append(S.substring((startindex+1),i));\\n    \\t\\t\\tstartindex=i+1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t}\\n    \\t\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651147,
                "title": "simple-string-operation-no-stacks-used-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        String k=\"\",s=\"\";int c=0,d=0;// c-> to count no. of \\'(\\' and d->no. of \\')\\' \\n        for(int i=0;i<S.length();i++)\\n        {\\n            if(S.charAt(i)==\\'(\\'){\\n            s=s+\\'(\\';\\n                c++;\\n            }\\n            else if(S.charAt(i)==\\')\\')\\n            {\\n                s=s+\\')\\';\\n                d++;\\n            }\\n            if(c==d)// when c==d means one complete bracket series ended....eg: (()()) c==d for this.... \\n            {\\n                k=k+s.substring(1,s.length()-1);// select the string execpt first and last portion 1 -> s.length()-1,which gives ()()\\n                s=\"\";//this for next bracket series\\n                c=d=0;//for next bracket series....\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        String k=\"\",s=\"\";int c=0,d=0;// c-> to count no. of \\'(\\' and d->no. of \\')\\' \\n        for(int i=0;i<S.length();i++)\\n        {\\n            if(S.charAt(i)==\\'(\\'){\\n            s=s+\\'(\\';\\n                c++;\\n            }\\n            else if(S.charAt(i)==\\')\\')\\n            {\\n                s=s+\\')\\';\\n                d++;\\n            }\\n            if(c==d)// when c==d means one complete bracket series ended....eg: (()()) c==d for this.... \\n            {\\n                k=k+s.substring(1,s.length()-1);// select the string execpt first and last portion 1 -> s.length()-1,which gives ()()\\n                s=\"\";//this for next bracket series\\n                c=d=0;//for next bracket series....\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485690,
                "title": "c-solution",
                "content": "```\\nchar * removeOuterParentheses(char * S){\\n    char *str = malloc(sizeof(char) * strlen(S));\\n    int flag = 0,p = 0;\\n    for (int i = 0;i < strlen(S); i++) {\\n        if (S[i]==\\'(\\') {\\n            flag++;\\n            if (flag != 1) {\\n                str[p++] = S[i];\\n            }\\n        }else{\\n            flag--;\\n            if(flag!=0){\\n                str[p++] = S[i];\\n            }\\n        }\\n    }\\n    str[p] = 0;\\n    return str;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * removeOuterParentheses(char * S){\\n    char *str = malloc(sizeof(char) * strlen(S));\\n    int flag = 0,p = 0;\\n    for (int i = 0;i < strlen(S); i++) {\\n        if (S[i]==\\'(\\') {\\n            flag++;\\n            if (flag != 1) {\\n                str[p++] = S[i];\\n            }\\n        }else{\\n            flag--;\\n            if(flag!=0){\\n                str[p++] = S[i];\\n            }\\n        }\\n    }\\n    str[p] = 0;\\n    return str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270763,
                "title": "javascript",
                "content": "```\\nvar removeOuterParentheses = function(S) {\\n    let res = \\'\\',\\n        leftNum = 0;\\n    for(let i = 0; i < S.length; ++i) {\\n        if(S.charAt(i) == \\'(\\') {\\n            leftNum ++;\\n            if(leftNum == 2) {\\n                while(leftNum > 0) {\\n                    res += S.charAt(i);\\n                    S.charAt(++i) == \\'(\\' ? leftNum ++ : leftNum --;\\n                    \\n                }\\n            }\\n        } else\\n            leftNum --;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeOuterParentheses = function(S) {\\n    let res = \\'\\',\\n        leftNum = 0;\\n    for(let i = 0; i < S.length; ++i) {\\n        if(S.charAt(i) == \\'(\\') {\\n            leftNum ++;\\n            if(leftNum == 2) {\\n                while(leftNum > 0) {\\n                    res += S.charAt(i);\\n                    S.charAt(++i) == \\'(\\' ? leftNum ++ : leftNum --;\\n                    \\n                }\\n            }\\n        } else\\n            leftNum --;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269958,
                "title": "python-c-haskell-solutions",
                "content": "**Video Explanation:** https://www.youtube.com/watch?v=ekdNNn3vOqQ\\n\\n1. Group by parentheses substring when LEFT = RIGHT\\n2. Then just shave off the first and last parentheses of each group and rejoin\\n\\n**Python Solution 1:**\\n```\\ndef group(S):\\n\\tt, a, l = 0, 0, []\\n    for i in range(len(S)):\\n        t = t + 1 if S[i] == \\'(\\' else t - 1\\n        if t == 0:\\n            l.append(S[a:i+1])\\n            a = i + 1\\n    return l\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\\n**Python Solution 2 (Functional Programming):**\\n```\\ndef group(S: str) -> str:\\n    a = [1 if i == \\'(\\' else -1 for i in S]    \\n    b = [0] + [i+1 for i, j in enumerate(itertools.accumulate(a)) if j == 0]\\n    return [S[i:j] for i, j in zip(b[:-1], b[1:])]\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\\n**Haskell:**\\n```\\nremoveOuterParentheses s = concat $ map (tail . init) primitives\\n    where primitives = map (map fst) $ init $ segmentAfter ((==0) . snd) (zip s (parenCount s))\\n          parenCount = scanl1 (+) . map (\\\\e -> if e == \\'(\\' then 1 else -1)\\n```\\n**C++:**\\n```\\nstring removeOuterParentheses(string S) {\\n   vector<int> a(S.size()), b(S.size());\\n   transform(S.begin(), S.end(), a.begin(), [](auto c) { return c == \\'(\\' ? 1 : -1; });\\n   partial_sum(a.begin(), a.end(), b.begin());\\n   return accumulate(b.begin(), b.end(), string(),\\n      [&S, t = string(), i = 0](auto s, auto e) mutable {\\n      e == 0 ? s += t.substr(1, t.size() - 1), t = \"\" : t += S[i]; ++i;\\n      return s;\\n   });\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\ndef group(S):\\n\\tt, a, l = 0, 0, []\\n    for i in range(len(S)):\\n        t = t + 1 if S[i] == \\'(\\' else t - 1\\n        if t == 0:\\n            l.append(S[a:i+1])\\n            a = i + 1\\n    return l\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\n```\\ndef group(S: str) -> str:\\n    a = [1 if i == \\'(\\' else -1 for i in S]    \\n    b = [0] + [i+1 for i, j in enumerate(itertools.accumulate(a)) if j == 0]\\n    return [S[i:j] for i, j in zip(b[:-1], b[1:])]\\n\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        return \\'\\'.join(sub[1:-1] for sub in group(S))\\n```\n```\\nremoveOuterParentheses s = concat $ map (tail . init) primitives\\n    where primitives = map (map fst) $ init $ segmentAfter ((==0) . snd) (zip s (parenCount s))\\n          parenCount = scanl1 (+) . map (\\\\e -> if e == \\'(\\' then 1 else -1)\\n```\n```\\nstring removeOuterParentheses(string S) {\\n   vector<int> a(S.size()), b(S.size());\\n   transform(S.begin(), S.end(), a.begin(), [](auto c) { return c == \\'(\\' ? 1 : -1; });\\n   partial_sum(a.begin(), a.end(), b.begin());\\n   return accumulate(b.begin(), b.end(), string(),\\n      [&S, t = string(), i = 0](auto s, auto e) mutable {\\n      e == 0 ? s += t.substr(1, t.size() - 1), t = \"\" : t += S[i]; ++i;\\n      return s;\\n   });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886659,
                "title": "c-beats-100-with-explaination-o-n-time-o-1-space",
                "content": "# Intuition\\nOpening parenthesis decreases the counter and closing parenthesis increases the counter\\n```\\n   (  (  )  (  ) )  (  (  ) )\\n0 -1 -2 -1 -2 -1 0 -1 -2 -1 0\\n```\\n\\nThere is always a primitive string after a zero till next zero.\\nWe just need to remove first and last character of primitive string.\\n\\nSo the intution is...\\nIf you get c=0 do not take that character and the character next to it.\\n\\n# Approach\\nIf you encounter c=0, it means previous substring was primitive. So the position at which you are currently, must be opening parenthesis. Make c= -1 and continue.\\n```\\n if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n```\\n\\nIf you got Opening parenthesis decreases the counter else for closing parenthesis increases the counter.\\n```\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n```\\n\\nIf you got c=0, this is last character of primitive parenthesis. Therefore do not push it into ans str.\\n```\\n      if (c == 0) continue;\\n```\\n\\nElse push it into ans string.\\n```\\n      str.push_back(s[i]);\\n```\\n\\n# Code\\n```\\nclass Solution {\\n  public: string removeOuterParentheses(string s) {\\n    string str;\\n    int c = 0;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n      if (c == 0) continue;\\n      str.push_back(s[i]);\\n    }\\n    return str;\\n  }\\n};\\n```\\n\\n# Complexity\\n```\\n- Time complexity: O(n)\\n```\\n\\n```\\n- Space complexity: O(1)\\n```\\n\\n    if(helpful) Upvote++ ;\\n    \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n ![image.png](https://assets.leetcode.com/users/images/56a4f661-44cb-4e7b-98be-49a7b8604658_1691592068.1438534.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   (  (  )  (  ) )  (  (  ) )\\n0 -1 -2 -1 -2 -1 0 -1 -2 -1 0\\n```\n```\\n if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n```\n```\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n```\n```\\n      if (c == 0) continue;\\n```\n```\\n      str.push_back(s[i]);\\n```\n```\\nclass Solution {\\n  public: string removeOuterParentheses(string s) {\\n    string str;\\n    int c = 0;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (c == 0) {\\n        c--;\\n        continue;\\n      }\\n      if (s[i] == \\'(\\') c--;\\n      else c++;\\n      if (c == 0) continue;\\n      str.push_back(s[i]);\\n    }\\n    return str;\\n  }\\n};\\n```\n```\\n- Time complexity: O(n)\\n```\n```\\n- Space complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823992,
                "title": "c-solution-explained",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        // to store the ans\\n        string ans = \"\";\\n        // to keep the track of valid parenthesis we have initialized count variable\\n        // valid parenthesis contains equal number of \\n        int count = 0;\\n        for(char ch: s){\\n            if(ch == \\'(\\' && count == 0){\\n                // this bracket is a part of outermost parenthesis\\n                // dont add it to the ans, skip it\\n                count++;\\n            }else if(ch == \\'(\\' && count >= 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans\\n                ans += ch;\\n                count++;\\n                \\n            }else if(ch == \\')\\' && count > 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans, and decrease the count\\n                ans += ch;\\n                count--;\\n            }else if(ch == \\')\\' && count == 1){\\n                // this bracket is a part of outer parenthesis\\n                // avoid it\\n                count--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        // to store the ans\\n        string ans = \"\";\\n        // to keep the track of valid parenthesis we have initialized count variable\\n        // valid parenthesis contains equal number of \\n        int count = 0;\\n        for(char ch: s){\\n            if(ch == \\'(\\' && count == 0){\\n                // this bracket is a part of outermost parenthesis\\n                // dont add it to the ans, skip it\\n                count++;\\n            }else if(ch == \\'(\\' && count >= 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans\\n                ans += ch;\\n                count++;\\n                \\n            }else if(ch == \\')\\' && count > 1){\\n                // this bracket is a part of inner parenthesis\\n                // add it to the ans, and decrease the count\\n                ans += ch;\\n                count--;\\n            }else if(ch == \\')\\' && count == 1){\\n                // this bracket is a part of outer parenthesis\\n                // avoid it\\n                count--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778885,
                "title": "explained-optimized-interview-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nitna to samjh aa jaata hai saab, 350 ques karne k baad\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust use the stack \\n\\n# Complexity\\n- Time complexity:\\nO(n), n is size of given string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//see- https://www.youtube.com/watch?v=MLfAFCkzChU\\n/* algo:\\n   1. check stack empty ? if true then put the 1st char and this will be not ans as it\\'s    outermost.\\n\\n   2. add another cha, check stack is empty or not, if not then it means this char should be in our ans string add it their and then place it inside stack.\\n\\n   3. add another char if it\\'s a closing bracket then remove it\\'s opening bracket from stack and check if stack gets empty after this or not, if yes then it was outermost don\\'t add in ans, if not empty the this can be added to ans string.\\n*/\\n\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        if(s==\"\" || s==\"()\") return \"\";\\n        string ans=\"\";\\n        int n=s.size();\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    ans+=s[i];\\n                    st.push(s[i]);\\n                    \\n                }\\n                else\\n                {\\n                    st.pop();\\n                    if(!st.empty()) ans+=s[i];\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n// PLEASE UPVOTE THANK YOU\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//see- https://www.youtube.com/watch?v=MLfAFCkzChU\\n/* algo:\\n   1. check stack empty ? if true then put the 1st char and this will be not ans as it\\'s    outermost.\\n\\n   2. add another cha, check stack is empty or not, if not then it means this char should be in our ans string add it their and then place it inside stack.\\n\\n   3. add another char if it\\'s a closing bracket then remove it\\'s opening bracket from stack and check if stack gets empty after this or not, if yes then it was outermost don\\'t add in ans, if not empty the this can be added to ans string.\\n*/\\n\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        if(s==\"\" || s==\"()\") return \"\";\\n        string ans=\"\";\\n        int n=s.size();\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else\\n            {\\n                if(s[i]==\\'(\\')\\n                {\\n                    ans+=s[i];\\n                    st.push(s[i]);\\n                    \\n                }\\n                else\\n                {\\n                    st.pop();\\n                    if(!st.empty()) ans+=s[i];\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n// PLEASE UPVOTE THANK YOU\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752187,
                "title": "easy-way-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (cnt == 0 && c == \\'(\\') cnt--;\\n            else if (cnt == -1 && c == \\')\\') cnt++;\\n            else {\\n                res.push_back(c);\\n                if (c == \\'(\\') cnt--;\\n                else cnt++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**compact code**\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (c == \\'(\\' && cnt++ > 0 ) res.push_back(c);\\n            if (c == \\')\\' && cnt-- > 1 ) res.push_back(c);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (cnt == 0 && c == \\'(\\') cnt--;\\n            else if (cnt == -1 && c == \\')\\') cnt++;\\n            else {\\n                res.push_back(c);\\n                if (c == \\'(\\') cnt--;\\n                else cnt++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int cnt = 0;\\n        string res;\\n\\n        for (auto c: s) {\\n            if (c == \\'(\\' && cnt++ > 0 ) res.push_back(c);\\n            if (c == \\')\\' && cnt-- > 1 ) res.push_back(c);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691237,
                "title": "c-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272641,
                "title": "o-n-solution-using-stack-beats-100-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n\\n        stack<char> st;\\n        string ans=\"\";\\n\\n        for(auto c: s){\\n\\n            if(!st.empty()) ans+=c;\\n            if(c==\\'(\\') st.push(c);\\n            else {\\n                st.pop();\\n                 if(st.empty()) ans.pop_back();\\n            }\\n           \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n\\n        stack<char> st;\\n        string ans=\"\";\\n\\n        for(auto c: s){\\n\\n            if(!st.empty()) ans+=c;\\n            if(c==\\'(\\') st.push(c);\\n            else {\\n                st.pop();\\n                 if(st.empty()) ans.pop_back();\\n            }\\n           \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169732,
                "title": "clean-readable-code-c",
                "content": "# Intuition\\nEasy one-liner in C++\\n\\n# Approach\\nYou don\\'t need Python, when you know C++ like me\\n\\n# Complexity\\n- Time complexity: O(-1)\\n\\n- Space complexity: O(inf)\\n\\n# Code\\n```\\nclass Solution {public:string removeOuterParentheses(string s) {string output;int count = 0;for (auto c : s) {if (c == \\')\\') count--;if (count != 0) output += c;if (c == \\'(\\') count++;}return output;}};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {public:string removeOuterParentheses(string s) {string output;int count = 0;for (auto c : s) {if (c == \\')\\') count--;if (count != 0) output += c;if (c == \\'(\\') count++;}return output;}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094732,
                "title": "simple-cpp-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.empty()&&s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>0 &&s[i]==\\'(\\')\\n                {\\n                    st.push(\\'(\\');\\n                    ans+=\\'(\\';\\n                }\\n                else if(st.size()>1 && s[i]==\\')\\')\\n                {\\n                    st.pop();\\n                    ans+=\\')\\';\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n    {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.empty()&&s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(st.size()>0 &&s[i]==\\'(\\')\\n                {\\n                    st.push(\\'(\\');\\n                    ans+=\\'(\\';\\n                }\\n                else if(st.size()>1 && s[i]==\\')\\')\\n                {\\n                    st.pop();\\n                    ans+=\\')\\';\\n                }\\n                else\\n                {\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819789,
                "title": "python-96-77-faster-explained-without-stack-o-n-solution",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c,j,n=0,0,len(s)\\n        ans=[]\\n        for i in range(n):\\n            if s[i]==\\'(\\':\\n                c+=1 #If there is opening paranthesis we increment the counter variable\\n            else:\\n                c-=1 #If there is closing paranthesis we decrement the counter variable\\n#If counter variable is 0 it means that No. of opening paranthesis = No. of closing paranthesis and we get a set of valid parethesis \\n\\t\\t\\t\\tif c==0:\\n#Once we get a valid set of parenthesis we store it in the list where j is the starting index of the valid parenthesis set and i is the last index.\\n#j+1 will remove the opening parenthesis and slicing the string till i(i.e., i-1) will store the valid set of parethesis in list after removing the outermost parenthis\\n                    ans.append(s[j+1:i])\\n                    j=i+1 #Changing the value of starting index for next valid set of parenthesis\\n        return \\'\\'.join(ans) #It will change the list into string\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c,j,n=0,0,len(s)\\n        ans=[]\\n        for i in range(n):\\n            if s[i]==\\'(\\':\\n                c+=1 #If there is opening paranthesis we increment the counter variable\\n            else:\\n                c-=1 #If there is closing paranthesis we decrement the counter variable\\n#If counter variable is 0 it means that No. of opening paranthesis = No. of closing paranthesis and we get a set of valid parethesis \\n\\t\\t\\t\\tif c==0:\\n#Once we get a valid set of parenthesis we store it in the list where j is the starting index of the valid parenthesis set and i is the last index.\\n#j+1 will remove the opening parenthesis and slicing the string till i(i.e., i-1) will store the valid set of parethesis in list after removing the outermost parenthis\\n                    ans.append(s[j+1:i])\\n                    j=i+1 #Changing the value of starting index for next valid set of parenthesis\\n        return \\'\\'.join(ans) #It will change the list into string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518109,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0, start=0;\\n        StringBuilder res= new StringBuilder();\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\')\\n                count++;\\n            else\\n                count--;\\n\\t\\t\\t\\t\\n            if(count==0){\\n                res.append(s.substring(start+1,i));\\n                start=i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0, start=0;\\n        StringBuilder res= new StringBuilder();\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==\\'(\\')\\n                count++;\\n            else\\n                count--;\\n\\t\\t\\t\\t\\n            if(count==0){\\n                res.append(s.substring(start+1,i));\\n                start=i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361682,
                "title": "java-solution-5-lines-faster-and-less-memory-than-99-example-also-in-c-python",
                "content": "Although this problem is labeled as \\'easy\\' it can seem quite difficult at first, especially due to the way the writeup was written.\\n\\nHere is an advice, which has always helped me break down parenthesis problems. There is something called Catalan structures or Catalan numbers. Now, bear with me! This might seem awfully complicated since Catalan numbers is something abstract and mathematical. But take a look at table 2 on page 2 in this paper:\\n http://www.geometer.org/mathcircles/catalan.pdf\\n\\nSee these \\'Mountain Ranges\\'? These can be thought of as matches. Where you would add an upwards leaning match for an open parenthesis and a downwards leaning match for a closing parenthesis. Here is the important part: A Mountain range like this, where we start at the bottom and end at the bottom is a valid parenthesis.\\n\\nNow, if you draw on a piece of paper the three examples given in the write-up. You can see that the problem is only asking you to remove the lowest level of each \\'mountain\\'. Since that is the case, the only thing we need is a counter while we iterate through the characters forming the parenthesis string. For each level we go up (open parenthesis) we increment the counter while we decrement it while we go down. So you can think of the counter as keeping track of the elevation in the mountain range.\\n\\nNow, what I did in my solution was to initialize a counter and a string builder. Whenever there was an open parenthesis at levels other than zero I added the char to the string builder. Whenever there was a closing parenthesis at a level other than 1, I added the parenthesis to the string builder. This effectively removes the bottom level for each mountain in the mountain range\\n\\nWhy does this work? Try drawing it out!\\n\\n**Java**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        for(char c : s.toCharArray())\\n            if      (c == \\'(\\' && count++ != 0) sb.append(c);\\n            else if (c == \\')\\' && count-- != 1) sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n        \\n        int count = 0;            // count elevation\\n        char output[s.length()];  // the output string\\n        int head = 0;             // write head of buffer\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            char c = s[i];\\n            if      (c == \\'(\\' && count++ > 0) output[head++] = c;\\n            else if (c == \\')\\' && count-- > 1) output[head++] = c;\\n        }\\n        \\n        // null terminate the string and return\\n        output[head] = 0;\\n        return output;\\n    }\\n};\\n```\\n\\n**Python 3**\\nNote that using an array, keeps the running time linear (amortized) appending strings would result in O(N^2)\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        output = []\\n        count = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if count > 0: output.append(c)\\n                count += 1\\n            if c == \\')\\':\\n                if count > 1: output.append(c)\\n                count -= 1\\n        return \"\".join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        for(char c : s.toCharArray())\\n            if      (c == \\'(\\' && count++ != 0) sb.append(c);\\n            else if (c == \\')\\' && count-- != 1) sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) \\n        \\n        int count = 0;            // count elevation\\n        char output[s.length()];  // the output string\\n        int head = 0;             // write head of buffer\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            char c = s[i];\\n            if      (c == \\'(\\' && count++ > 0) output[head++] = c;\\n            else if (c == \\')\\' && count-- > 1) output[head++] = c;\\n        }\\n        \\n        // null terminate the string and return\\n        output[head] = 0;\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        output = []\\n        count = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if count > 0: output.append(c)\\n                count += 1\\n            if c == \\')\\':\\n                if count > 1: output.append(c)\\n                count -= 1\\n        return \"\".join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307181,
                "title": "javascript-stack-oriented-solution",
                "content": "var removeOuterParentheses = function(S) {\\n\\n    let stack = [];\\n    let result = \\'\\';\\n    for (const s of S) {\\n       if( s === \\'(\\') {\\n           if (stack.length) {\\n               result+=s;\\n           }\\n           stack.push(s);\\n       } else {\\n           stack.pop();\\n           if (stack.length) {\\n               result+=s;\\n           }\\n       }\\n    }\\n\\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var removeOuterParentheses = function(S) {\\n\\n    let stack = [];\\n    let result = \\'\\';\\n    for (const s of S) {\\n       if( s === \\'(\\') {\\n           if (stack.length) {\\n               result+=s;\\n           }\\n           stack.push(s);\\n       } else {\\n           stack.pop();\\n           if (stack.length) {\\n               result+=s;\\n           }\\n       }\\n    }\\n\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1045167,
                "title": "simple-go-and-java-solutions",
                "content": "Java:\\n\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```\\n\\nGolang:\\n\\n```\\nfunc removeOuterParentheses(S string) string {\\n\\ts := \"\"\\n\\th := []string{}\\n\\n\\tfor _, i2 := range S {\\n\\t\\tif string(i2) == \"(\" {\\n\\t\\t\\tif len(h) != 0 {\\n\\t\\t\\t\\ts += \"(\"\\n\\t\\t\\t}\\n\\t\\t\\th = append(h, \"(\")\\n\\t\\t} else {\\n\\t\\t\\tif len(h) != 1 {\\n\\t\\t\\t\\ts += \")\"\\n\\t\\t\\t}\\n\\t\\t\\th = h[:len(h)-1]\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Go"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```\n```\\nfunc removeOuterParentheses(S string) string {\\n\\ts := \"\"\\n\\th := []string{}\\n\\n\\tfor _, i2 := range S {\\n\\t\\tif string(i2) == \"(\" {\\n\\t\\t\\tif len(h) != 0 {\\n\\t\\t\\t\\ts += \"(\"\\n\\t\\t\\t}\\n\\t\\t\\th = append(h, \"(\")\\n\\t\\t} else {\\n\\t\\t\\tif len(h) != 1 {\\n\\t\\t\\t\\ts += \")\"\\n\\t\\t\\t}\\n\\t\\t\\th = h[:len(h)-1]\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967051,
                "title": "java-solution-with-stack-and-explanation",
                "content": "This works because if the parentheses is outer most and it is a closing parenthese then the size of the stack has to be equal to one. If the parenthese is opening then the size should be 0. Other wise they are inear parentheses.\\n```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder s = new StringBuilder();\\n\\tStack<Character> h = new Stack<>();\\n\\n\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\tif (h.size() == 1 && S.charAt(i) == \\')\\'){\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (h.size() == 0 && S.charAt(i) == \\'(\\'){\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\')\\'){\\n\\t\\t\\ts.append(\")\");\\n\\t\\t\\th.pop();\\n\\t\\t}\\n\\t\\telse if (S.charAt(i) == \\'(\\'){\\n\\t\\t\\ts.append(\"(\");\\n\\t\\t\\th.push(\\'(\\');\\n\\t\\t}\\n\\t}\\n\\treturn s.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935016,
                "title": "easy-way-explanation-every-step",
                "content": "# if your current char is \\'(\\' then two things happen one is stack is empty then don\\'t add char in result means it indicates no outer parentheses is present.if your stack is not empty then definitely have a outer parentheses this time add char into results\\n```\\nif c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n\\n```\\n# when current char is \")\" and popfrom a stack \"(\" .two things happen if your stack is empty it means no outer parentheses.if not empty then outer parentheses is present.so add into result .\\n```\\nelse:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n```\\n# Easy example\\n```\\nYour input\\n\"()()()()\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 2  current char= (  stack=  []\\nresult= \\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 4  current char= (  stack=  []\\nresult= \\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 6  current char= (  stack=  []\\nresult= \\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= \\n\\n\\nOutput\\n\"\"\\n\\n\\n```\\n# simple Example\\n```\\nYour input\\n\"(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= ()\\n\\n\\nOutput\\n\"()\"\\nExpected\\n\"()\"\\n```\\n# hard example\\n```\\n\"(((())))\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= (  stack=  [\\'(\\', \\'(\\']\\nresult= ((\\n\\nposition= 3  current char= (  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= (((\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\', \\'(\\']\\nresult= ((()\\n\\nposition= 5  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= ((())\\n\\nposition= 6  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ((()))\\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= ((()))\\n\\n\\nOutput\\n\"((()))\"\\nExpected\\n\"((()))\"\\n```\\n# complex example\\n```\\nYour input\\n\"(()())(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= (  stack=  [\\'(\\']\\nresult= ()(\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()\\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= ()()\\nposition= 6  current char= (  stack=  []\\nresult= ()()\\n\\nposition= 7  current char= (  stack=  [\\'(\\']\\nresult= ()()(\\n\\nposition= 8  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()()\\n\\nposition= 9  current char= )  stack=  [\\'(\\']\\nresult= ()()()\\n\\nOutput\\n\"()()()\"\\nExpected\\n\"()()()\"\\n\\n```\\n\\n```\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,stack = [],[]\\n        for i,c in enumerate (S):\\n            \\n            if c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n            else:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n           \\n        return \\'\\'.join(res)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nif c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n\\n```\n```\\nelse:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n```\n```\\nYour input\\n\"()()()()\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 2  current char= (  stack=  []\\nresult= \\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 4  current char= (  stack=  []\\nresult= \\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= \\n\\nposition= 6  current char= (  stack=  []\\nresult= \\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= \\n\\n\\nOutput\\n\"\"\\n\\n\\n```\n```\\nYour input\\n\"(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= )  stack=  [\\'(\\']\\nresult= ()\\n\\n\\nOutput\\n\"()\"\\nExpected\\n\"()\"\\n```\n```\\n\"(((())))\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= (  stack=  [\\'(\\', \\'(\\']\\nresult= ((\\n\\nposition= 3  current char= (  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= (((\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\', \\'(\\']\\nresult= ((()\\n\\nposition= 5  current char= )  stack=  [\\'(\\', \\'(\\', \\'(\\']\\nresult= ((())\\n\\nposition= 6  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ((()))\\n\\nposition= 7  current char= )  stack=  [\\'(\\']\\nresult= ((()))\\n\\n\\nOutput\\n\"((()))\"\\nExpected\\n\"((()))\"\\n```\n```\\nYour input\\n\"(()())(())\"\\nstdout\\nposition= 0  current char= (  stack=  []\\nresult= \\n\\nposition= 1  current char= (  stack=  [\\'(\\']\\nresult= (\\n\\nposition= 2  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()\\n\\nposition= 3  current char= (  stack=  [\\'(\\']\\nresult= ()(\\n\\nposition= 4  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()\\n\\nposition= 5  current char= )  stack=  [\\'(\\']\\nresult= ()()\\nposition= 6  current char= (  stack=  []\\nresult= ()()\\n\\nposition= 7  current char= (  stack=  [\\'(\\']\\nresult= ()()(\\n\\nposition= 8  current char= )  stack=  [\\'(\\', \\'(\\']\\nresult= ()()()\\n\\nposition= 9  current char= )  stack=  [\\'(\\']\\nresult= ()()()\\n\\nOutput\\n\"()()()\"\\nExpected\\n\"()()()\"\\n\\n```\n```\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,stack = [],[]\\n        for i,c in enumerate (S):\\n            \\n            if c == \\'(\\':\\n                if stack:\\n                    res.append(c)\\n                stack.append(c)\\n            else:\\n                stack.pop()\\n                if stack:\\n                    res.append(c)\\n           \\n        return \\'\\'.join(res)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 570594,
                "title": "concept-of-these-kind-of-problems-simple",
                "content": "problem similar to Google Hashcode 2020 Qualification round\\nThe key in these types of problems is to have a variable named depth, and increment and decrement it accordingly [ \\'(\\' depth increases ] \\nHere whenver the depth is currently zero we ignore it, and when it is again going to be zero after a series of open and closing parenthesis we ignore it again. \\n\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int depth=0;\\n        string p;\\n        for(int i=0;i<S.length();i++){\\n            if (S[i]==\\'(\\') {\\n\\t\\t\\t\\tif (depth!=0){\\n                    p+=\\'(\\';\\n\\t\\t\\t\\t}\\n                depth+=1;\\n\\t\\t\\t}\\n            if (S[i]==\\')\\'){\\n\\t\\t\\t\\tif (depth-1!=0){\\n                    p+=\\')\\';\\n\\t\\t\\t\\t}\\n                depth-=1;\\n\\t\\t\\t}    \\n        }\\n        return p;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        int depth=0;\\n        string p;\\n        for(int i=0;i<S.length();i++){\\n            if (S[i]==\\'(\\') {\\n\\t\\t\\t\\tif (depth!=0){\\n                    p+=\\'(\\';\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 483874,
                "title": "c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> ss;\\n        string ans = \"\";\\n        \\n        for(char c: S) {\\n            if(ss.empty() && c==\\'(\\') {\\n                ss.push(c);\\n            } else if(ss.size() == 1 && c==\\')\\') {\\n                ss.pop();\\n            } else if(c==\\'(\\') {\\n                ss.push(c);\\n                ans+=c;\\n            } else if(c==\\')\\') {\\n                ss.pop();\\n                ans+=c;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> ss;\\n        string ans = \"\";\\n        \\n        for(char c: S) {\\n            if(ss.empty() && c==\\'(\\') {\\n                ss.push(c);\\n            } else if(ss.size() == 1 && c==\\')\\') {\\n                ss.pop();\\n            } else if(c==\\'(\\') {\\n                ss.push(c);\\n                ans+=c;\\n            } else if(c==\\')\\') {\\n                ss.pop();\\n                ans+=c;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467915,
                "title": "c",
                "content": "```\\npublic string RemoveOuterParentheses(string S) {\\n\\tvar str = new StringBuilder();\\n\\tvar i = 0;\\n\\n\\tforeach (var c in S.ToCharArray()) {\\n\\t\\ti += c == \\'(\\' ? 1 : -1;\\n\\n\\t\\tif (c == \\'(\\' && i > 1 || c == \\')\\' && i > 0)\\n\\t\\t\\tstr.Append(c);\\n\\t}\\n\\n\\treturn str.ToString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic string RemoveOuterParentheses(string S) {\\n\\tvar str = new StringBuilder();\\n\\tvar i = 0;\\n\\n\\tforeach (var c in S.ToCharArray()) {\\n\\t\\ti += c == \\'(\\' ? 1 : -1;\\n\\n\\t\\tif (c == \\'(\\' && i > 1 || c == \\')\\' && i > 0)\\n\\t\\t\\tstr.Append(c);\\n\\t}\\n\\n\\treturn str.ToString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358034,
                "title": "haskell-wins-1-liner",
                "content": "This is why Haskell is so beautiful:\\n```\\nsolve :: String -> String\\nsolve = concat \\n      . map (tail . init) \\n      . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```\\nThe one-liner would be:\\n```\\nsolve = concat . map (tail . init) . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```",
                "solutionTags": [],
                "code": "```\\nsolve :: String -> String\\nsolve = concat \\n      . map (tail . init) \\n      . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```\n```\\nsolve = concat . map (tail . init) . groupBy (\\\\a b -> [a,b] /= \")(\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324746,
                "title": "python3-40ms-beas-93",
                "content": "time complexity : O(n)\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        if len(S) <= 2:\\n            return \"\"\\n        \\n        ans = \"\"\\n        count = 0\\n        for c in S:\\n            if c == \"(\":\\n                count += 1\\n                if count > 1:\\n                    ans += c\\n            else:\\n                count -= 1\\n                if count > 0:\\n                    ans += c\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        if len(S) <= 2:\\n            return \"\"\\n        \\n        ans = \"\"\\n        count = 0\\n        for c in S:\\n            if c == \"(\":\\n                count += 1\\n                if count > 1:\\n                    ans += c\\n            else:\\n                count -= 1\\n                if count > 0:\\n                    ans += c\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316971,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        if(S == null) return \"\";\\n        char[] chars = S.toCharArray();\\n        int stack = 0;\\n\\n        StringBuilder builder = new StringBuilder();\\n        for(int i=0; i<chars.length; i++){\\n            if (chars[i] == 40) {\\n                stack ++;\\n                if(stack != 1) builder.append(chars[i]);\\n            } else if (chars[i] == 41) {\\n                stack --;\\n                if(stack != 0) builder.append(chars[i]);\\n            }\\n        }\\n\\n        return builder.toString();\\n    }\\n}\\n```\\n\\n\\nI use an \\u201Cint stack\\u201D to simulate the use of the stack.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        if(S == null) return \"\";\\n        char[] chars = S.toCharArray();\\n        int stack = 0;\\n\\n        StringBuilder builder = new StringBuilder();\\n        for(int i=0; i<chars.length; i++){\\n            if (chars[i] == 40) {\\n                stack ++;\\n                if(stack != 1) builder.append(chars[i]);\\n            } else if (chars[i] == 41) {\\n                stack --;\\n                if(stack != 0) builder.append(chars[i]);\\n            }\\n        }\\n\\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658776,
                "title": "c-2-solutions-using-stack-i-without-stack",
                "content": "\\n# Code\\n```\\n# WITHOUTSTACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int open=0;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(open>0)\\n            ans+=\\'(\\';\\n             open++;\\n        }\\n\\n        if(s[i] == \\')\\'){\\n            if(open>1){\\n                ans+=\\')\\';\\n            }\\n        open--;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\n# STACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(st.size()>0)\\n            ans+=\\'(\\';\\n             st.push(\\'(\\');\\n        }\\n\\n        if(s[i] == \\')\\'){\\n                if(st.size() > 1){\\n                    ans+=\\')\\';\\n                }\\n            st.pop();\\n\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n# WITHOUTSTACK\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int open=0;\\n        for(int i=0;i<s.size();i++){\\n        if(s[i] == \\'(\\'){\\n            if(open>0)\\n            ans+=\\'(\\';\\n             open++;\\n        }\\n\\n        if(s[i] == \\')\\'){\\n            if(open>1){\\n                ans+=\\')\\';\\n            }\\n        open--;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478488,
                "title": "python-simple-clean-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans, cnt = [], 0\\n        for ch in s:\\n            if ch == \\'(\\' and cnt > 0: ans.append(ch)\\n            if ch == \\')\\' and cnt > 1: ans.append(ch)\\n            cnt += 1 if ch == \\'(\\' else -1\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans, cnt = [], 0\\n        for ch in s:\\n            if ch == \\'(\\' and cnt > 0: ans.append(ch)\\n            if ch == \\')\\' and cnt > 1: ans.append(ch)\\n            cnt += 1 if ch == \\'(\\' else -1\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444614,
                "title": "easily-understandable-java-stack-without-stack-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n         StringBuilder sb = new StringBuilder();\\n\\n//               STACK SOLUTION\\n\\n        //  Stack<Character> st = new Stack<>();\\n        //  for(int i=0;i<s.length();i++){\\n        //      char ch = s.charAt(i);\\n        //      if(ch == \\'(\\'){\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //          st.push(ch);                  \\n        //      }else{\\n        //          st.pop();\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //      }\\n        //  }\\n        // return sb.toString();\\n             \\n         int con=0;\\n         for(char c:s.toCharArray()){\\n             if(c==\\'(\\' && con++>0 )sb.append(c);\\n             if(c==\\')\\' && con-->1 )sb.append(c);\\n         }\\n         return sb.toString();\\n    }\\n}\\n/*  \\n-->Solve without using stack:\\nKeep a counter c = 0\\nIncrement when ( found and decrement when ) found\\nif c = 1 means ( is outer most, don\\'t add it to answer\\nif c = 0 means ) is outer most, don\\'t add it to answer\\nelse keep adding parenthesis to answer\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n         StringBuilder sb = new StringBuilder();\\n\\n//               STACK SOLUTION\\n\\n        //  Stack<Character> st = new Stack<>();\\n        //  for(int i=0;i<s.length();i++){\\n        //      char ch = s.charAt(i);\\n        //      if(ch == \\'(\\'){\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //          st.push(ch);                  \\n        //      }else{\\n        //          st.pop();\\n        //          if(!st.isEmpty()){\\n        //              sb.append(ch);\\n        //          }\\n        //      }\\n        //  }\\n        // return sb.toString();\\n             \\n         int con=0;\\n         for(char c:s.toCharArray()){\\n             if(c==\\'(\\' && con++>0 )sb.append(c);\\n             if(c==\\')\\' && con-->1 )sb.append(c);\\n         }\\n         return sb.toString();\\n    }\\n}\\n/*  \\n-->Solve without using stack:\\nKeep a counter c = 0\\nIncrement when ( found and decrement when ) found\\nif c = 1 means ( is outer most, don\\'t add it to answer\\nif c = 0 means ) is outer most, don\\'t add it to answer\\nelse keep adding parenthesis to answer\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401631,
                "title": "go-golang-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc removeOuterParentheses(s string) string {\\n    var result string\\n    var index int\\n\\n    for _, x := range s {\\n        switch x {\\n        case \\'(\\':\\n            if index > 0 {\\n                result += string(x)\\n            }\\n            index++\\n        case \\')\\':\\n            index--\\n            if index > 0 {\\n                result += string(x)\\n            }\\n        }\\n    }\\n\\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\nfunc removeOuterParentheses(s string) string {\\n    var result string\\n    var index int\\n\\n    for _, x := range s {\\n        switch x {\\n        case \\'(\\':\\n            if index > 0 {\\n                result += string(x)\\n            }\\n            index++\\n        case \\')\\':\\n            index--\\n            if index > 0 {\\n                result += string(x)\\n            }\\n        }\\n    }\\n\\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3352798,
                "title": "c-0ms-solution",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int sum = 1;\\n        string ans = \"\";\\n        // \"we will count the opening and closing bracket\"\\n        int open = 1;\\n        int end = 0;\\n        for(int i = 1; i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                open++;\\n            }else{\\n                end++;\\n            }\\n            if(s[i] == \\')\\' && open == end ){\\n                open = 0;\\n                end = 0;\\n            }else if(open > 1){\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int sum = 1;\\n        string ans = \"\";\\n        // \"we will count the opening and closing bracket\"\\n        int open = 1;\\n        int end = 0;\\n        for(int i = 1; i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                open++;\\n            }else{\\n                end++;\\n            }\\n            if(s[i] == \\')\\' && open == end ){\\n                open = 0;\\n                end = 0;\\n            }else if(open > 1){\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109543,
                "title": "easy-c-without-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n   int n=s.size();\\n   string p;\\n   int c=0;\\n   for(int i=0;i<n;i++)\\n   {\\n       if(s[i]==\\'(\\')\\n       {c++;}\\n       else if(s[i]==\\')\\')\\n       {c--;}\\n        if( c!=1 && s[i]==\\'(\\')\\n        {p+=s[i];}\\n        else if(c!=0 && s[i]==\\')\\')\\n        {\\n            p+=s[i];\\n        }\\n   }\\n   return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n   int n=s.size();\\n   string p;\\n   int c=0;\\n   for(int i=0;i<n;i++)\\n   {\\n       if(s[i]==\\'(\\')\\n       {c++;}\\n       else if(s[i]==\\')\\')\\n       {c--;}\\n        if( c!=1 && s[i]==\\'(\\')\\n        {p+=s[i];}\\n        else if(c!=0 && s[i]==\\')\\')\\n        {\\n            p+=s[i];\\n        }\\n   }\\n   return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953073,
                "title": "without-stack-c-simple-100-fastest",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n![Capture.PNG](https://assets.leetcode.com/users/images/65e175ad-14eb-4977-863f-c412c1d53620_1672049199.2318532.png)\\n\\n# Approach \\n    Keep a counter c = 0\\n    Increment when ( found \\n    decrement when ) found\\n    if c = 1 &&  ( is outer most, don\\'t add it to answer\\n    if c = 0 && ) is outer most, don\\'t add it to answer\\n    else keep adding parenthesis to answer\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        if(s.length()==0) return \"\";\\n        if(s.length()==2) return \"\";\\n        string ans=\"\";\\n        stack<char>st;\\n        int counter=0;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s[i]==\\'(\\') counter++;\\n            else if(s[i]==\\')\\') counter--;\\n            if(s[i]==\\'(\\' && counter!=1) ans+=s[i];\\n            else if(s[i]==\\')\\' && counter!=0) ans+=s[i];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        if(s.length()==0) return \"\";\\n        if(s.length()==2) return \"\";\\n        string ans=\"\";\\n        stack<char>st;\\n        int counter=0;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s[i]==\\'(\\') counter++;\\n            else if(s[i]==\\')\\') counter--;\\n            if(s[i]==\\'(\\' && counter!=1) ans+=s[i];\\n            else if(s[i]==\\')\\' && counter!=0) ans+=s[i];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837110,
                "title": "c-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\";\\n        stack<char> st;\\n        int i=0;\\n        while(i<s.size()){\\n            char ch = s[i];\\n            if(ch ==\\'(\\'){\\n                if(st.size()>0)\\n                res += ch;\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    res +=\\')\\';\\n                }\\n                st.pop();\\n            }\\n          \\n\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\";\\n        stack<char> st;\\n        int i=0;\\n        while(i<s.size()){\\n            char ch = s[i];\\n            if(ch ==\\'(\\'){\\n                if(st.size()>0)\\n                res += ch;\\n                st.push(ch);\\n            }\\n            else{\\n                if(st.size()>1){\\n                    res +=\\')\\';\\n                }\\n                st.pop();\\n            }\\n          \\n\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846566,
                "title": "javascript-easy-stepwise",
                "content": "\\n    let count = 0, outer = \"\"\\n    \\n    for(let i = 0 ; i < s.length; i++) {\\n        if(s[i] === \"(\") {\\n            count++\\n        }\\n         if(count > 1) {\\n            outer += s[i]\\n        }\\n        if(s[i] === \")\") {\\n            count--\\n        }\\n    }\\n    return outer\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n    let count = 0, outer = \"\"\\n    \\n    for(let i = 0 ; i < s.length; i++) {\\n        if(s[i] === \"(\") {\\n            count++\\n        }\\n         if(count > 1) {\\n            outer += s[i]\\n        }\\n        if(s[i] === \")\") {\\n            count--\\n        }\\n    }\\n    return outer\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1804384,
                "title": "without-stack-simple-solution-c",
                "content": "**My Approach**\\n\\nMaintain  a counter that counts the incoming open parenthesis \\'(\\'  \\nif count is 0 then we ignore it o/w add it to o/p string \\nsimilar case is for closing parenthesis :\\nif count is 0 we ignore o/w add it to the o/p string.\\n\\n**Time Complexity : O(N)**\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\' && count++)\\n                ans+=\"(\";\\n            else if(s[i]==\\')\\'&& (--count))\\n                ans+=\")\";\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote \\uD83D\\uDC4D\\uD83C\\uDFFB and Spread Motivation !!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans=\"\";\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\' && count++)\\n                ans+=\"(\";\\n            else if(s[i]==\\')\\'&& (--count))\\n                ans+=\")\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637392,
                "title": "python-idea-of-stack",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = 0\\n        start = 0\\n        answer = \\'\\'\\n\\n        for i,j in enumerate(s):\\n            if j == \"(\":\\n                stack+= 1\\n            elif j == \")\":\\n                stack -= 1\\n            if stack == 0:\\n                answer += s[start+1:i:]\\n                start = i+1\\n\\n        return answer\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        stack = 0\\n        start = 0\\n        answer = \\'\\'\\n\\n        for i,j in enumerate(s):\\n            if j == \"(\":\\n                stack+= 1\\n            elif j == \")\":\\n                stack -= 1\\n            if stack == 0:\\n                answer += s[start+1:i:]\\n                start = i+1\\n\\n        return answer\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1425905,
                "title": "clean-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans = \"\"\\n        stack = []\\n        \\n        for br in s:\\n            if br == \\'(\\':\\n                if stack:\\n                    ans+=br\\n                stack.append(br)\\n            else:\\n                ch = stack.pop()\\n                if stack:\\n                    ans+=br\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        ans = \"\"\\n        stack = []\\n        \\n        for br in s:\\n            if br == \\'(\\':\\n                if stack:\\n                    ans+=br\\n                stack.append(br)\\n            else:\\n                ch = stack.pop()\\n                if stack:\\n                    ans+=br\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1381567,
                "title": "c-tc-o-n-sc-o-n",
                "content": "**Feel free to post your doubts in comment**\\n```\\nstring removeOuterParentheses(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n        int co=0, cc=0;\\n        int start=0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'(\\') co++;\\n            else cc++;\\n            if(co==cc){\\n                for(int j=start+1; j<i; j++)\\n                    ans+=s[j];\\n                start=i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        int n=s.size();\\n        string ans=\"\";\\n        int co=0, cc=0;\\n        int start=0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'(\\') co++;\\n            else cc++;\\n            if(co==cc){\\n                for(int j=start+1; j<i; j++)\\n                    ans+=s[j];\\n                start=i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374386,
                "title": "be-water-my-friend-time-o-n-no-substring-function-c",
                "content": "*Runtime: 0 ms, faster than 100.00% of C++ online submissions for Remove Outermost Parentheses.*\\n\\nJust keep incrementing and decrementing number of open bracket and take decisions.\\n\\n1st Decision: The current character will be part of the result if you have seen at least 1 opening bracket.\\n2nd Decision: As we are first decrementing we have to handle the last valid closing bracket explicitely.\\n\\nThat\\'s it.\\nStraightforward.\\n\\n```\\nstring removeOuterParentheses(string str) {\\n    int open = 0;\\n    string result = \"\";\\n    for (auto bracket : str) {\\n        bracket == \\'(\\' ? ++open : --open;\\n        if (open > 1 || (open == 1 && bracket == \\')\\')) {\\n            result += bracket;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nIf you are having problem understanding do one dry run on your own\\n\\n**My Dry Run**\\n**str = ( ( ) ) ( )**\\n\\nstrSeen = ( \\nresult = \"\"\\nopen = 1\\n\\nstrSeen = ( (\\nresult = \"(\"\\nopen = 2\\n\\nstrSeen = ( ( ) \\nresult = \"()\"\\nopen = 1\\n\\nstrSeen = ( ( ) )\\nresult = \"()\"\\nopen = 0\\n\\nstrSeen = ( ( ) ) (\\nresult = \"()\"\\nopen = 1\\n\\nstrSeen = ( ( ) ) ( )\\nresult = \"()\"\\nopen = 0",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring removeOuterParentheses(string str) {\\n    int open = 0;\\n    string result = \"\";\\n    for (auto bracket : str) {\\n        bracket == \\'(\\' ? ++open : --open;\\n        if (open > 1 || (open == 1 && bracket == \\')\\')) {\\n            result += bracket;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059557,
                "title": "cpp-use-counter-to-record-the-unmatched-pairs",
                "content": "## Analysis\\n\\nIn order to identify which parenthesis to be included inside our return string, we need to check two cases:\\n\\n1. If current **open parenthesis** is the first parenthesis in the block of the decomposition, we should not add it. This means the current **unmatched pairs** in block is 1.\\n2. If current **close parenthesis** is the last parenthesis in the block of the decomposition, we should not add it. This means the current **unmatched pairs** in block is 0.\\n\\nLet\\'s walk through an example:\\n\\nThe left most column represents the current processing parthesis\\n\\n```\\nFor \"(()(()))\":\\n(    (|()(())): we have 1 unmatched pair -> \"\" don\\'t do anything here\\n(    ((|)(())): we have 2 unmatched pair -> \"(\"\\n)    (()|(())): we have 1 unmatched pair -> \"()\"\\n(    (()(|())): we have 2 unmatched pair -> \"()(\"\\n(    (()((|))): we have 3 unmatched pair -> \"()((\"\\n)    (()(()|)): we have 2 unmatched pair -> \"()(()\"\\n)    (()(())|): we have 1 unmatched pair -> \"()(())\"\\n)    (()(()))|: we have 0 unmatched pair -> \"()(())\" don\\'t do anything here\\n```\\n\\nFrom this example, we can see that all we need is to count the number of unmatched pairs as well as the current processing parenthesis.\\n\\nTime: $O(n)$\\n\\nSpace: $O(1)$\\n\\n## Code\\n\\n```c++\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int cnt = 0;\\n        for (char& c : S) {\\n            if (c == \\'(\\' && ++cnt != 1)\\n                res += c;\\n            if (c == \\')\\' && --cnt != 0)\\n                res += c;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNote that since the input is always valid (no mismatch), we can just use != instead of >= to check the unmatched pairs.\\n\\nThis analysis is included in: https://peterchen.xyz/Leetcode/1021.-Remove-Outermost-Parentheses/\\nIf you want to check my other analysis, please visit https://peterchen.xyz/\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nFor \"(()(()))\":\\n(    (|()(())): we have 1 unmatched pair -> \"\" don\\'t do anything here\\n(    ((|)(())): we have 2 unmatched pair -> \"(\"\\n)    (()|(())): we have 1 unmatched pair -> \"()\"\\n(    (()(|())): we have 2 unmatched pair -> \"()(\"\\n(    (()((|))): we have 3 unmatched pair -> \"()((\"\\n)    (()(()|)): we have 2 unmatched pair -> \"()(()\"\\n)    (()(())|): we have 1 unmatched pair -> \"()(())\"\\n)    (()(()))|: we have 0 unmatched pair -> \"()(())\" don\\'t do anything here\\n```\n```c++\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res;\\n        int cnt = 0;\\n        for (char& c : S) {\\n            if (c == \\'(\\' && ++cnt != 1)\\n                res += c;\\n            if (c == \\')\\' && --cnt != 0)\\n                res += c;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053939,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int leftBracket = 0;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char currChar:S.toCharArray())\\n        {\\n            if(currChar==\\'(\\')\\n            {\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n                leftBracket++;\\n            }\\n            else\\n            {\\n                leftBracket--;\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        int leftBracket = 0;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char currChar:S.toCharArray())\\n        {\\n            if(currChar==\\'(\\')\\n            {\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n                leftBracket++;\\n            }\\n            else\\n            {\\n                leftBracket--;\\n                if(leftBracket!=0)\\n                {\\n                    sb.append(currChar);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615583,
                "title": "python-3-easy-solution-with-explanation-20ms-99-95-speed",
                "content": "maintain a pointer variable to point which index you encountered, if the value of the variable is 0, you\\'re pointing to the opening of the outer braces, then you don\\'t append it to the result. \\nEach time we encounter a left brace we increment the value of ptr by 1, for a right brace we decrement it by 1. I\\'ll just explain this segment: \"(()())\" \\nnow look:\\n( => ptr = 0, don\\'t append to res; increment it and you get ptr = 1\\n( => ptr = 1, append to res; increment it and you get ptr = 2, \\n) => ptr = 2, decrement it and you get ptr = 1, append to res\\n( => ptr = 1, append to res; increment it and you get ptr = 2, \\n) => ptr = 2,  decrement it and you get ptr = 1, append to res\\n) => ptr = 1,  decrement it and you get ptr = 0, don\\'t append to res\\nthus you proceed\\n\\n```\\ndef removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        ptr = 0\\n        for c in S:\\n            if c==\\')\\':\\n                ptr-=1\\n            if ptr:\\n                res+=c\\n            if c==\\'(\\': \\n                ptr+=1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef removeOuterParentheses(self, S: str) -> str:\\n        res = \"\"\\n        ptr = 0\\n        for c in S:\\n            if c==\\')\\':\\n                ptr-=1\\n            if ptr:\\n                res+=c\\n            if c==\\'(\\': \\n                ptr+=1\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 584245,
                "title": "stack-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char>s;\\n        vector<int>partitions;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'(\\') s.push(S[i]);\\n            else {\\n                s.pop();\\n                if(s.empty()) partitions.push_back(i);\\n            }\\n        }\\n        int start = 1;\\n        string ans = \"\";\\n        for(int i=0;i<partitions.size();i++){\\n            string yo = S.substr(start,partitions[i]-start);\\n            ans += yo;\\n            start = partitions[i]+2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char>s;\\n        vector<int>partitions;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'(\\') s.push(S[i]);\\n            else {\\n                s.pop();\\n                if(s.empty()) partitions.push_back(i);\\n            }\\n        }\\n        int start = 1;\\n        string ans = \"\";\\n        for(int i=0;i<partitions.size();i++){\\n            string yo = S.substr(start,partitions[i]-start);\\n            ans += yo;\\n            start = partitions[i]+2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513253,
                "title": "python-o-n-time-o-1-space",
                "content": "Somewhat counter intuitive, but hey it works\\n```python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        parentheses = 0 \\n        result = \"\"\\n        for c in S:\\n            if(c == \"(\"):\\n                parentheses += 1\\n            \\n            if(parentheses > 1):\\n                result += c\\n            \\n            if(c == \")\"):\\n                parentheses -= 1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        \\n        parentheses = 0 \\n        result = \"\"\\n        for c in S:\\n            if(c == \"(\"):\\n                parentheses += 1\\n            \\n            if(parentheses > 1):\\n                result += c\\n            \\n            if(c == \")\"):\\n                parentheses -= 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504575,
                "title": "python-simple-solution",
                "content": "```\\n\\n```#40 ms, faster than 42.94% of Python3 online submissions for Remove Outermost Parentheses.\\n#12.9 MB, less than 100.00% of Python3 online submissions for Remove Outermost Parentheses.\\n\\nclass Solution:\\n\\tdef removeOuterParentheses(self, S: str) -> str:\\n        stacks = []\\n        result = \\'\\'\\n        for ch in S:\\n            stacks.append(ch)\\n            if (stacks.count(\\'(\\') == stacks.count(\\')\\')):\\n                result += (\\'\\'.join(stacks[1:-1]))\\n                stacks.clear()\\n        return (result)\\n",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459604,
                "title": "java-very-easy-solution",
                "content": "Use the depth of parentheses.\\n\\n```java\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder result = new StringBuilder();\\n        int depth = 0;\\n\\n        for (Character character : S.toCharArray()) {\\n            if (character == \\'(\\') {\\n                depth += 1;\\n            }\\n\\n            if (depth > 1) {\\n                result.append(character);\\n            }\\n\\n            if (character == \\')\\') {\\n                depth -= 1;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        StringBuilder result = new StringBuilder();\\n        int depth = 0;\\n\\n        for (Character character : S.toCharArray()) {\\n            if (character == \\'(\\') {\\n                depth += 1;\\n            }\\n\\n            if (depth > 1) {\\n                result.append(character);\\n            }\\n\\n            if (character == \\')\\') {\\n                depth -= 1;\\n            }\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416446,
                "title": "java-stack-solution",
                "content": "\\t\\t public String removeOuterParentheses(String S) {\\n\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t        stack.push(S.charAt(0));\\n\\t\\t\\t\\t   String ans = \"\";\\n\\t\\t\\t\\t   for(int i=1;i<S.length();i++) {\\n\\t\\t\\t\\tif(S.charAt(i) == \\'(\\' && stack.isEmpty()) {\\n\\t\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\t} else if(S.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tif(!stack.isEmpty())\\n\\t\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "solutionTags": [],
                "code": "\\t\\t public String removeOuterParentheses(String S) {\\n\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t        stack.push(S.charAt(0));\\n\\t\\t\\t\\t   String ans = \"\";\\n\\t\\t\\t\\t   for(int i=1;i<S.length();i++) {\\n\\t\\t\\t\\tif(S.charAt(i) == \\'(\\' && stack.isEmpty()) {\\n\\t\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\t} else if(S.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(S.charAt(i));\\n\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tif(!stack.isEmpty())\\n\\t\\t\\t\\t\\tans+=S.charAt(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 371270,
                "title": "java-100-runtime-and-memory-9-lines",
                "content": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder SB = new StringBuilder();\\n\\tint currDepth = 0;\\n\\tfor(char curr : S.toCharArray()) {\\n\\t\\tif(curr == \\'(\\' && (currDepth += 1) > 1) SB.append(curr);\\n\\t\\telse if (curr == \\')\\' && (currDepth -= 1) >= 1) SB.append(curr);\\n\\t}\\n\\treturn SB.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String removeOuterParentheses(String S) {\\n\\tStringBuilder SB = new StringBuilder();\\n\\tint currDepth = 0;\\n\\tfor(char curr : S.toCharArray()) {\\n\\t\\tif(curr == \\'(\\' && (currDepth += 1) > 1) SB.append(curr);\\n\\t\\telse if (curr == \\')\\' && (currDepth -= 1) >= 1) SB.append(curr);\\n\\t}\\n\\treturn SB.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306738,
                "title": "easy-python-solution-using-stack",
                "content": "```\\n# Main idea is to use stack, we push the character to stack and pop when stack is not empty and character is \\')\\'\\n# If there is only one character \\'(\\' and the current character in string is \\')\\', then pop the stack and append the substring : S[j+1:i] to result and update\\n# j to i+1\\n# Return result string\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,j = \"\",0\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and S[i]==\\')\\':\\n                if len(my_stack)==1:\\n                    my_stack.pop() \\n                    res+=S[j+1:i] #To ignore first character which is \\'(\\' in order to remove-outermost-parentheses\\n                    j=i+1\\n                else:\\n                    my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n# Main idea is to use stack, we push the character to stack and pop when stack is not empty and character is \\')\\'\\n# If there is only one character \\'(\\' and the current character in string is \\')\\', then pop the stack and append the substring : S[j+1:i] to result and update\\n# j to i+1\\n# Return result string\\n\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        res,j = \"\",0\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and S[i]==\\')\\':\\n                if len(my_stack)==1:\\n                    my_stack.pop() \\n                    res+=S[j+1:i] #To ignore first character which is \\'(\\' in order to remove-outermost-parentheses\\n                    j=i+1\\n                else:\\n                    my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281068,
                "title": "python-beats-95-of-the-solutions",
                "content": "Python Solution \\n\\n```\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        count = 0 \\n        output_S = []\\n        for c in S:\\n            if c == \\')\\':\\n                count -= 1\\n            \\n            if count > 0:\\n                output_S.append(c)\\n            \\n            if c == \\'(\\':\\n                count += 1\\n        \\n        return \\'\\'.join(output_S)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeOuterParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        count = 0 \\n        output_S = []\\n        for c in S:\\n            if c == \\')\\':\\n                count -= 1\\n            \\n            if count > 0:\\n                output_S.append(c)\\n            \\n            if c == \\'(\\':\\n                count += 1\\n        \\n        return \\'\\'.join(output_S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270143,
                "title": "c-solution-using-one-stack-and-one-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> open;\\n        queue<char> primitive;\\n        string output;\\n        for(int i=0; i<S.length(); i++) {\\n            primitive.push(S[i]);\\n            if(S[i] == \\'(\\') {\\n                open.push(S[i]);\\n            }\\n            else {\\n                open.pop();\\n                if(open.empty()) {\\n                    primitive.pop();\\n                    while(!primitive.empty()) {\\n                        output.push_back(primitive.front());\\n                        primitive.pop();\\n                    }\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\nStack stores the opening brackets. Once the stack is empty, we found one primitive. Primitives are stored in queue. We remove the outer brackets and store in output.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        stack<char> open;\\n        queue<char> primitive;\\n        string output;\\n        for(int i=0; i<S.length(); i++) {\\n            primitive.push(S[i]);\\n            if(S[i] == \\'(\\') {\\n                open.push(S[i]);\\n            }\\n            else {\\n                open.pop();\\n                if(open.empty()) {\\n                    primitive.pop();\\n                    while(!primitive.empty()) {\\n                        output.push_back(primitive.front());\\n                        primitive.pop();\\n                    }\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269960,
                "title": "python-straightforward-concise-valid-paranthesis",
                "content": "* Check valid paranthesis as usual.\\n* When it is balanced, add to res.\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        l = r = 0\\n        res = cur = \\'\\'\\n        for s in S:\\n            cur += s\\n            l += s == \\'(\\'\\n            r += s == \\')\\'\\n            if l == r:\\n                res += cur[1:-1]\\n                cur = \\'\\'\\n        return res \\n```\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        l = r = 0\\n        res = cur = \\'\\'\\n        for s in S:\\n            cur += s\\n            l += s == \\'(\\'\\n            r += s == \\')\\'\\n            if l == r:\\n                res += cur[1:-1]\\n                cur = \\'\\'\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 269955,
                "title": "simple-python-counter",
                "content": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result = []\\n        counter = 1\\n        i = 1\\n        while i < len(S):\\n            counter += 1 if S[i] == \"(\" else -1\\n            if counter != 0:\\n                result.append(S[i])\\n            else:\\n                counter = 1\\n                i += 1\\n            i += 1\\n        return \"\".join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, S: str) -> str:\\n        result = []\\n        counter = 1\\n        i = 1\\n        while i < len(S):\\n            counter += 1 if S[i] == \"(\" else -1\\n            if counter != 0:\\n                result.append(S[i])\\n            else:\\n                counter = 1\\n                i += 1\\n            i += 1\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269954,
                "title": "my-8-lines-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res = \"\";\\n        int cnt = 0, start = 0, n = S.size();\\n        for (int i = 0; i < n; ++i) {\\n            (S[i] == \\'(\\') ? ++cnt : --cnt;\\n            if (cnt != 0) continue;\\n            res += S.substr(start + 1, i - start - 1);\\n            start = i + 1;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string S) {\\n        string res = \"\";\\n        int cnt = 0, start = 0, n = S.size();\\n        for (int i = 0; i < n; ++i) {\\n            (S[i] == \\'(\\') ? ++cnt : --cnt;\\n            if (cnt != 0) continue;\\n            res += S.substr(start + 1, i - start - 1);\\n            start = i + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4008513,
                "title": "js-simple-beats-95-easy-approach",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function (s) {\\n    let openCount = 0;\\n    let output = \"\";\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            if (openCount) output += s[i];\\n            openCount++;\\n        }\\n        else if (s[i] === \")\") {\\n            openCount--;\\n            if (openCount) output += s[i];\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function (s) {\\n    let openCount = 0;\\n    let output = \"\";\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            if (openCount) output += s[i];\\n            openCount++;\\n        }\\n        else if (s[i] === \")\") {\\n            openCount--;\\n            if (openCount) output += s[i];\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816879,
                "title": "single-pass-c-solution-without-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string a=\"\";\\n        int balanced=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n                balanced++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                balanced--;\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string a=\"\";\\n        int balanced=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n                balanced++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                balanced--;\\n                if(balanced>0)\\n                {\\n                    a+=s[i];\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804317,
                "title": "c-o-n-tc-o-1-sc",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        //keeping track of opened\\n        //opened --> represent no. of opened without closed \\n        //\"(()())(())\"\\n        // \"((\" --> opened=2; \\n        // \"(()\"  --> opened=1; \\n        string ans;\\n        int opened=0;\\n        for(auto i:s){\\n            if(i==\\'(\\' && opened++>0)    ans+=i;\\n            if(i==\\')\\' && opened-->1)    ans+=i;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        //keeping track of opened\\n        //opened --> represent no. of opened without closed \\n        //\"(()())(())\"\\n        // \"((\" --> opened=2; \\n        // \"(()\"  --> opened=1; \\n        string ans;\\n        int opened=0;\\n        for(auto i:s){\\n            if(i==\\'(\\' && opened++>0)    ans+=i;\\n            if(i==\\')\\' && opened-->1)    ans+=i;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711986,
                "title": "c-easy-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.length();\\n        string ans;\\n        int count=0;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(count==0)count++;\\n                else\\n                {\\n                    count++;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                if(count==1)\\n                {\\n                    count--;\\n                }\\n                else\\n                {\\n                    count--;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.length();\\n        string ans;\\n        int count=0;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                if(count==0)count++;\\n                else\\n                {\\n                    count++;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                if(count==1)\\n                {\\n                    count--;\\n                }\\n                else\\n                {\\n                    count--;\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585998,
                "title": "problem-1021-remove-outer-parentheses-solwed-with-stack-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        var stk = new Stack<char>();\\n        var qavslar = \"\";\\n        foreach (char c in s)\\n        {\\n            if(c == \\'(\\') stk.Push(c);\\n            if(stk.Count > 1) qavslar += c;\\n            if(c == \\')\\') stk.Pop();\\n        }\\n        return qavslar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveOuterParentheses(string s) {\\n        var stk = new Stack<char>();\\n        var qavslar = \"\";\\n        foreach (char c in s)\\n        {\\n            if(c == \\'(\\') stk.Push(c);\\n            if(stk.Count > 1) qavslar += c;\\n            if(c == \\')\\') stk.Pop();\\n        }\\n        return qavslar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487236,
                "title": "stack-c-beats-90",
                "content": "# Code\\n```\\nusing System.Text;\\n\\npublic class Solution \\n{\\n    public string RemoveOuterParentheses(string s) \\n    {\\n        Stack<char> stack = new Stack<char>();\\n        StringBuilder ans = new(\"\");\\n\\n        foreach (char c in s.ToCharArray())\\n        {\\n            if (c is \\'(\\')\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    ans.Append(\\'(\\');\\n                }\\n\\n                stack.Push(c);\\n            }\\n            else\\n            {\\n                if (stack.Count > 1)\\n                {\\n                    ans.Append(\\')\\');\\n\\n                }\\n\\n                stack.Pop();\\n            }\\n        }\\n\\n        return ans.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Text;\\n\\npublic class Solution \\n{\\n    public string RemoveOuterParentheses(string s) \\n    {\\n        Stack<char> stack = new Stack<char>();\\n        StringBuilder ans = new(\"\");\\n\\n        foreach (char c in s.ToCharArray())\\n        {\\n            if (c is \\'(\\')\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    ans.Append(\\'(\\');\\n                }\\n\\n                stack.Push(c);\\n            }\\n            else\\n            {\\n                if (stack.Count > 1)\\n                {\\n                    ans.Append(\\')\\');\\n\\n                }\\n\\n                stack.Pop();\\n            }\\n        }\\n\\n        return ans.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477847,
                "title": "simplest-method-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        int cnt = 0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                cnt--;\\n            }\\n            if((s[i]==\\'(\\' && cnt==1) || (s[i]==\\')\\'&& cnt==0))\\n            {\\n                continue;\\n            }\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        int cnt = 0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                cnt--;\\n            }\\n            if((s[i]==\\'(\\' && cnt==1) || (s[i]==\\')\\'&& cnt==0))\\n            {\\n                continue;\\n            }\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411357,
                "title": "c-without-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int st=0;\\n        string ans;\\n        for(auto a: s)\\n        {\\n            if(a == \\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int st=0;\\n        string ans;\\n        for(auto a: s)\\n        {\\n            if(a == \\'(\\')\\n            {\\n                if(st>0)\\n                {\\n                    ans+=\\'(\\';\\n                }\\n                st++;\\n            }\\n            else\\n            {\\n                if(st>1)\\n                {\\n                    ans+=\\')\\';\\n                }\\n                st--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392528,
                "title": "one-pass-o-1-space-simplest-just-count-parenthesis",
                "content": "If you find this solution helpful, **Upvote**. \\uD83D\\uDC4D \\n\\n```\\n  string removeOuterParentheses(string s) {\\n     int count=0;\\n     int j=0;\\n     for(int i=0;i<s.size();i++){   \\n        \\n         if(s[i]==\\'(\\')count++;\\n         if(s[i]==\\')\\')count--;\\n         if(s[i]==\\')\\' and count==0){\\n\\t\\t \\n             s.erase(i,1);         //rightmost parenthesis.\\n             s.erase(j,1);        //leftmost parenthesis.\\n             i=i-2;                //adjusting i after deletion\\n             j=i+1;                //intializing starting parenthesis\\n\\t\\t\\t \\n         }      \\n     }\\n        return s;\\n    }",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "If you find this solution helpful, **Upvote**. \\uD83D\\uDC4D \\n\\n```\\n  string removeOuterParentheses(string s) {\\n     int count=0;\\n     int j=0;\\n     for(int i=0;i<s.size();i++){   \\n        \\n         if(s[i]==\\'(\\')count++;\\n         if(s[i]==\\')\\')count--;\\n         if(s[i]==\\')\\' and count==0){\\n\\t\\t \\n             s.erase(i,1);         //rightmost parenthesis.\\n             s.erase(j,1);        //leftmost parenthesis.\\n             i=i-2;                //adjusting i after deletion\\n             j=i+1;                //intializing starting parenthesis\\n\\t\\t\\t \\n         }      \\n     }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3181745,
                "title": "c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n     stack<char> a;\\n     string q;\\n     for(int i=0;i<s.length();i++){\\n         if(s[i]==\\'(\\'){\\n             if(a.size()>0){\\n             q.push_back(s[i]);\\n             }\\n             a.push(s[i]);\\n         }\\n         else{\\n             a.pop();\\n             if(!a.empty())\\n             q.push_back(s[i]);\\n         }\\n     \\n     } \\n     return q;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n     stack<char> a;\\n     string q;\\n     for(int i=0;i<s.length();i++){\\n         if(s[i]==\\'(\\'){\\n             if(a.size()>0){\\n             q.push_back(s[i]);\\n             }\\n             a.push(s[i]);\\n         }\\n         else{\\n             a.pop();\\n             if(!a.empty())\\n             q.push_back(s[i]);\\n         }\\n     \\n     } \\n     return q;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181729,
                "title": "easiest-c-code-using-for-loop-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.size();\\n        int c=0;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n                if(s[i]==\\'(\\'){\\n                    if(c>0){ str+=s[i];}\\n                    c++;\\n                    }\\n                else{\\n                    if(c>1){ str+=s[i];}\\n                    c--;\\n                    }\\n            }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int n=s.size();\\n        int c=0;\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n                if(s[i]==\\'(\\'){\\n                    if(c>0){ str+=s[i];}\\n                    c++;\\n                    }\\n                else{\\n                    if(c>1){ str+=s[i];}\\n                    c--;\\n                    }\\n            }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181672,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> tem;\\n        string re;\\n        for(int i=0; i<s.length(); i++){\\n           if(s[i]==\\'(\\'){\\n               if(tem.size()>0) re.push_back(s[i]);\\n               tem.push(s[i]);\\n           }\\n           else{\\n               tem.pop();\\n               if(!tem.empty()) re.push_back(s[i]);\\n           }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> tem;\\n        string re;\\n        for(int i=0; i<s.length(); i++){\\n           if(s[i]==\\'(\\'){\\n               if(tem.size()>0) re.push_back(s[i]);\\n               tem.push(s[i]);\\n           }\\n           else{\\n               tem.pop();\\n               if(!tem.empty()) re.push_back(s[i]);\\n           }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140108,
                "title": "java-optimal-approach-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                if(counter != 0) sb.append(c);\\n                counter++;\\n            }\\n            else{\\n                counter--;\\n                if(counter != 0) sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059333,
                "title": "c-no-extra-space",
                "content": "\\n\\n### Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int last = s.size() - 1, balanced = 0;\\n        for(int i = last; i >= 0; i--) {            \\n            if(s[i] == \\')\\') balanced++;\\n            else {\\n                balanced--;\\n                if(balanced == 0) {\\n                    s.erase(last,1);\\n                    s.erase(i, 1);\\n                    last = i - 1;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int last = s.size() - 1, balanced = 0;\\n        for(int i = last; i >= 0; i--) {            \\n            if(s[i] == \\')\\') balanced++;\\n            else {\\n                balanced--;\\n                if(balanced == 0) {\\n                    s.erase(last,1);\\n                    s.erase(i, 1);\\n                    last = i - 1;\\n                }\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862199,
                "title": "golang-efficient-two-pointers-solution-using-strings-builder-o-n-time-o-n-memory",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we only have one type of parentheses and the input sequence is guaranteed to be valid, let\\'s use a counter (called \"balance\" in my code) instead of a stack. As we iterate through the input string and get \\'(\\', then we increment by balance 1 and decrement it by 1 in case we get \\')\\'.\\nWhen the balance becomes equal to zero, we are sure that we got a perfectly valid parentheses string.\\n\\nLet\\'s use two pointers to know where the valid \"atomic\" parentheses sequence starts and ends. Lets call these pointers \"slow\" and \"fast\".\\n\\nFirst we suppose that the input string contains at least two parentheses, so we could place the pointers separately. Then we move the fast pointer and update the balance variable based on the value where the fast pointer is at.\\n\\nWhen the balance becomes equal to 0, we just need to remove the outer brackets. We go through the non-inclusive interval (slow, fast) with a new pointer and add all the parentheses to the answer variable.\\n\\nBecause of immutability of strings, it\\'s inefficient to use the sum operation to concatenate strings in a loop. Instead we use the [strings.Builder](https://pkg.go.dev/strings#Builder) type, which is used to efficiently build strings using several Write methods, as it minimizes memory copying.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe loop through the input string and then loop through the every valid segment we encounter. Basically, it\\'s $O(2n)$ in the worst case.\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe linear memory is used only to construct the answer storing it inside strings.Builder.\\n\\n# Code\\n```\\nimport (\\n    \"strings\"\\n)\\n\\nfunc removeOuterParentheses(s string) string {\\n    if s == \"\" {\\n        return \"\"\\n    }\\n\\n    var sb strings.Builder\\n\\n    slow := 0\\n    balance := 1 // assuming that the first character of the string is always (\\n    for fast := 1; fast < len(s); fast++ {\\n        if s[fast] == \\'(\\' {\\n            balance++\\n        } else if s[fast] == \\')\\' {\\n            balance--\\n        }\\n\\n        if balance == 0 {\\n            for c := slow + 1; c < fast; c++ {\\n                sb.WriteByte(s[c])\\n            }\\n\\n            slow = fast + 1\\n            fast++\\n            balance = 1\\n        }\\n    }\\n\\n    return sb.String()\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nimport (\\n    \"strings\"\\n)\\n\\nfunc removeOuterParentheses(s string) string {\\n    if s == \"\" {\\n        return \"\"\\n    }\\n\\n    var sb strings.Builder\\n\\n    slow := 0\\n    balance := 1 // assuming that the first character of the string is always (\\n    for fast := 1; fast < len(s); fast++ {\\n        if s[fast] == \\'(\\' {\\n            balance++\\n        } else if s[fast] == \\')\\' {\\n            balance--\\n        }\\n\\n        if balance == 0 {\\n            for c := slow + 1; c < fast; c++ {\\n                sb.WriteByte(s[c])\\n            }\\n\\n            slow = fast + 1\\n            fast++\\n            balance = 1\\n        }\\n    }\\n\\n    return sb.String()\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2800575,
                "title": "easy-python3-solution-using-two-pointer-concept",
                "content": "Approach:\\nUsing Two pointers concept we can remove the outer most parentheses by keep tracking the count of opening and closing parentheses.\\n```\\ndef removeOuterParentheses(self, s: str) -> str:\\n\\ti=j=1\\n\\tn = len(s)\\n\\topening_count = 1\\n\\tclosing_count = 0\\n\\tresult = \"\"\\n\\twhile j<n: \\n\\t\\tif  opening_count != closing_count:\\n\\t\\t\\tif s[j] == \"(\":\\n\\t\\t\\t\\topening_count +=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tclosing_count +=1\\n\\t\\t\\tj +=1\\n\\t\\t\\tif j ==n and  opening_count == closing_count :\\n\\t\\t\\t\\tresult += s[i:j-1]\\n\\t\\telse:\\n\\t\\t\\tresult += s[i:j-1]\\n\\t\\t\\tj += 1\\n\\t\\t\\ti = j\\n\\t\\t\\topening_count = 1\\n\\t\\t\\tclosing_count = 0\\n\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "Approach:\\nUsing Two pointers concept we can remove the outer most parentheses by keep tracking the count of opening and closing parentheses.\\n```\\ndef removeOuterParentheses(self, s: str) -> str:\\n\\ti=j=1\\n\\tn = len(s)\\n\\topening_count = 1\\n\\tclosing_count = 0\\n\\tresult = \"\"\\n\\twhile j<n: \\n\\t\\tif  opening_count != closing_count:\\n\\t\\t\\tif s[j] == \"(\":\\n\\t\\t\\t\\topening_count +=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tclosing_count +=1\\n\\t\\t\\tj +=1\\n\\t\\t\\tif j ==n and  opening_count == closing_count :\\n\\t\\t\\t\\tresult += s[i:j-1]\\n\\t\\telse:\\n\\t\\t\\tresult += s[i:j-1]\\n\\t\\t\\tj += 1\\n\\t\\t\\ti = j\\n\\t\\t\\topening_count = 1\\n\\t\\t\\tclosing_count = 0\\n\\treturn result",
                "codeTag": "Python3"
            },
            {
                "id": 2667158,
                "title": "java-without-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int n=s.length();\\n        int a=0;\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                if(a!=0){\\n                    str=str+ch;\\n                }\\n                a++;\\n            }\\n            else{\\n                if(a!=1){\\n                    str=str+ch;\\n                }\\n                a--;\\n            }\\n        }\\n        \\n       return str;\\n      \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        int n=s.length();\\n        int a=0;\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                if(a!=0){\\n                    str=str+ch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2654107,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n       stack<int> st;\\n       string ans = \"\";\\n        int start = 0 ;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s[i] == \\'(\\') st.push(s[i]) , ans.push_back(s[i]);\\n           else if(s[i] == \\')\\') st.pop() , ans.push_back(s[i]);\\n           \\n           if(st.empty())\\n           {\\n               ans.pop_back();\\n               ans.erase(start,1);\\n               start = ans.length();\\n           }\\n       }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n       stack<int> st;\\n       string ans = \"\";\\n        int start = 0 ;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s[i] == \\'(\\') st.push(s[i]) , ans.push_back(s[i]);\\n           else if(s[i] == \\')\\') st.pop() , ans.push_back(s[i]);\\n           \\n           if(st.empty())\\n           {\\n               ans.pop_back();\\n               ans.erase(start,1);\\n               start = ans.length();\\n           }\\n       }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557192,
                "title": "js-with-explanation-easy-to-understand-63ms",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/1021-remove-outermost-parentheses-stack.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(s) {\\n    let result = [];\\n    let stack = new Stack()\\n    for(let i=0;i<s.length;i++){\\n        let char  = s[i];\\n         if (stack.isEmpty()){\\n             if (char==\\'(\\'){\\n                 stack.push(\\'(\\');\\n             }\\n         }else {\\n            if(char == \\')\\' && stack.size() == 1){\\n                stack.pop();\\n            }else{\\n                result.push(char);\\n                if(char == \\'(\\'){\\n                   stack.push(char);\\n                }else{\\n                    stack.pop()\\n                }\\n            }\\n         }\\n    }\\n    return result.join(\"\");\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    toString(){\\n      return this.stack.join(\"\");  \\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```\\n\\n```\\nRuntime: 63 ms, faster than 97.88% of JavaScript online submissions for Remove Outermost Parentheses.\\nMemory Usage: 43.7 MB, less than 68.18% of JavaScript online submissions for Remove Outermost Parentheses.\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeOuterParentheses = function(s) {\\n    let result = [];\\n    let stack = new Stack()\\n    for(let i=0;i<s.length;i++){\\n        let char  = s[i];\\n         if (stack.isEmpty()){\\n             if (char==\\'(\\'){\\n                 stack.push(\\'(\\');\\n             }\\n         }else {\\n            if(char == \\')\\' && stack.size() == 1){\\n                stack.pop();\\n            }else{\\n                result.push(char);\\n                if(char == \\'(\\'){\\n                   stack.push(char);\\n                }else{\\n                    stack.pop()\\n                }\\n            }\\n         }\\n    }\\n    return result.join(\"\");\\n};\\n\\nclass Stack {\\n    constructor() {\\n        this.stack = []\\n    }\\n    push(a) {\\n        this.stack.push(a)\\n    }\\n    pop() {\\n        return this.stack.pop()\\n    }\\n    peek() {\\n        return this.stack[this.stack.length - 1]\\n    }\\n    size() {\\n        return this.stack.length\\n    }\\n    toString(){\\n      return this.stack.join(\"\");  \\n    }\\n    isEmpty() {\\n        return this.stack.length == 0\\n    }\\n}\\n```\n```\\nRuntime: 63 ms, faster than 97.88% of JavaScript online submissions for Remove Outermost Parentheses.\\nMemory Usage: 43.7 MB, less than 68.18% of JavaScript online submissions for Remove Outermost Parentheses.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554567,
                "title": "java-o-n-tc",
                "content": "```\\n\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       \\n\\t    StringBuilder sb = new StringBuilder(); \\n        int sum = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {\\n                sum += 1;\\n                if(sum > 1) {\\n                    sb.append(\"(\");\\n                }\\n            } else {\\n                sum -= 1;\\n                if(sum > 0) {\\n                    sb.append(\")\");\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n       \\n\\t    StringBuilder sb = new StringBuilder(); \\n        int sum = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'(\\') {\\n                sum += 1;\\n                if(sum > 1) {\\n                    sb.append(\"(\");\\n                }\\n            } else {\\n                sum -= 1;\\n                if(sum > 0) {\\n                    sb.append(\")\");\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543307,
                "title": "java-stringbuilder-counting-easy-approach",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0;\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                count++;\\n                if(count!=1)\\n                    str.append(s.charAt(i));\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                count--;\\n                if(count!=0)\\n                    str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int count=0;\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                count++;\\n                if(count!=1)\\n                    str.append(s.charAt(i));\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                count--;\\n                if(count!=0)\\n                    str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524647,
                "title": "c-easy-fast",
                "content": "```\\nstring removeOuterParentheses(string s) {\\n        string ans;\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++){\\n            char sb = s[i];\\n            if(sb==\\'(\\'){\\n              if(st.size()>0){\\n                ans.push_back(sb);  \\n              }\\n              st.push(sb);  \\n            }\\n            else{\\n                st.pop();\\n                if(st.size()>0){\\n                   ans.push_back(sb); \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        string ans;\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++){\\n            char sb = s[i];\\n            if(sb==\\'(\\'){\\n              if(st.size()>0){\\n                ans.push_back(sb);  \\n              }\\n              st.push(sb);  \\n            }\\n            else{\\n                st.pop();\\n                if(st.size()>0){\\n                   ans.push_back(sb); \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524511,
                "title": "easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    \\n    def removeOuterParentheses(self, s: str) -> str:\\n    \\n        val = 0 \\n        ans = []\\n        idx = 0 \\n        for i in range(0,len(s)):\\n\\n            if(i == 0):\\n\\n                val += 1 \\n\\n                continue \\n\\n\\n            elif(s[i] == \"(\"):\\n\\n                val += 1 \\n\\n            else: \\n\\n                val -= 1 \\n\\n\\n\\n            if(val == 0 ):\\n\\n                ans.append(s[idx:i+1])\\n\\n\\n                idx = i + 1 \\n\\n        t = \"\"\\n\\n\\n      \\n        for par in ans:\\n\\n            n = len(par)\\n\\n            t += par[1:n-1]\\n\\n\\n        return t \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def removeOuterParentheses(self, s: str) -> str:\\n    \\n        val = 0 \\n        ans = []\\n        idx = 0 \\n        for i in range(0,len(s)):\\n\\n            if(i == 0):\\n\\n                val += 1 \\n\\n                continue \\n\\n\\n            elif(s[i] == \"(\"):\\n\\n                val += 1 \\n\\n            else: \\n\\n                val -= 1 \\n\\n\\n\\n            if(val == 0 ):\\n\\n                ans.append(s[idx:i+1])\\n\\n\\n                idx = i + 1 \\n\\n        t = \"\"\\n\\n\\n      \\n        for par in ans:\\n\\n            n = len(par)\\n\\n            t += par[1:n-1]\\n\\n\\n        return t \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516105,
                "title": "easiest-python-solution-o-n-solution",
                "content": "```\\ndef removeOuterParentheses(self, s: str) -> str:\\n        countOpen = 0\\n        res = \"\"\\n        \\n        for ch in s:\\n            if ch == \\'(\\' :\\n                countOpen += 1\\n                if countOpen > 1 :\\n                    res += ch                \\n            \\n            if ch == \\')\\' :\\n                countOpen -= 1\\n                if countOpen > 0 :\\n                    res += ch\\n                  \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeOuterParentheses(self, s: str) -> str:\\n        countOpen = 0\\n        res = \"\"\\n        \\n        for ch in s:\\n            if ch == \\'(\\' :\\n                countOpen += 1\\n                if countOpen > 1 :\\n                    res += ch                \\n            \\n            if ch == \\')\\' :\\n                countOpen -= 1\\n                if countOpen > 0 :\\n                    res += ch\\n                  \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2514370,
                "title": "self-made-simple-logic-cpp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring removeOuterParentheses(string s) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tstring ns=\"\";\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch=s.at(i);\\n\\t\\t\\t\\tif(ch==\\')\\')\\n\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tif(c>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tns+=ch;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ch==\\'(\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring removeOuterParentheses(string s) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tstring ns=\"\";\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch=s.at(i);\\n\\t\\t\\t\\tif(ch==\\')\\')\\n\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\tif(c>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tns+=ch;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2375032,
                "title": "c-simple-o-n-solution-beats-100",
                "content": "The question seems to be difficult but its rather easy to understand.\\nThe main idea here is to understand that the given string is already a valid parenthesis and the main requirement is to just remove the outermost bracket of the simplest valid parenthesis that can be done using the **counting method** what it means is that the number of opening brackets is same as closing bracket for a given sub valid parenthesis string.\\nTake two pointer i and j both at zero and start counting the opening brackets and reducing the count on closing bracket once the count reaches zero that means we have a valid parenthesis and we can now remove the given set of brackets and then update i to j+1 to the next opening bracket if it exits and then also incrementing j so that the above initial step can be repeated.\\n\\nC++ \\n```\\nstring removeOuterParentheses(string s) {\\n        int i=0,j=0,countOfBrackets=0;\\n        while(j<s.length())\\n        {\\n            if(s[j]==\\'(\\')\\n            {\\n                countOfBrackets++;\\n                j++;\\n            }else{\\n                countOfBrackets--;\\n                if(countOfBrackets==0)\\n                {\\n                    s[i]=\\'0\\';\\n                    s[j]=\\'0\\';\\n                    i=j+1;\\n                }\\n                j++;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.at(i)!=\\'0\\')\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring removeOuterParentheses(string s) {\\n        int i=0,j=0,countOfBrackets=0;\\n        while(j<s.length())\\n        {\\n            if(s[j]==\\'(\\')\\n            {\\n                countOfBrackets++;\\n                j++;\\n            }else{\\n                countOfBrackets--;\\n                if(countOfBrackets==0)\\n                {\\n                    s[i]=\\'0\\';\\n                    s[j]=\\'0\\';\\n                    i=j+1;\\n                }\\n                j++;\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.at(i)!=\\'0\\')\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366578,
                "title": "python-o-1-space-easy-explanation",
                "content": "Success\\nDetails \\nRuntime: 55 ms, faster than **61.98%** of Python3 online submissions.\\nMemory Usage: 13.9 MB, less than **92.46%** of Python3 online submissions.\\n\\n1. Create an empty result string. res=\\'\\'\\n\\n2. I have take temp variable C which is intially zero.\\n3. Itterate over the string.\\n4. When we find \\'(\\' increament C and when we find \\')\\' decrement C.\\n5. So whenever C becmoes 0, we will be outside the paranthessis.\\n6. So, while iterating the string, when the current element is \\'(\\' append \\'(\\' to out result except when c==0 and while current element is \\')\\' append \\')\\' to our result except when c==1. (because after this we will decrement C to zero )\\n\\n***If this helps, Please leave an upvote!!!***\\n\\n```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c=0\\n        res=\\'\\'\\n        for i in s:\\n            if i==\\')\\' and c==1:\\n                c=c-1\\n            elif i==\\'(\\' and c==0:\\n                c=c+1\\n            elif i==\\'(\\':\\n                res=res+\\'(\\'\\n                c=c+1\\n            elif i==\\')\\':\\n                res=res+\\')\\'\\n                c=c-1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeOuterParentheses(self, s: str) -> str:\\n        c=0\\n        res=\\'\\'\\n        for i in s:\\n            if i==\\')\\' and c==1:\\n                c=c-1\\n            elif i==\\'(\\' and c==0:\\n                c=c+1\\n            elif i==\\'(\\':\\n                res=res+\\'(\\'\\n                c=c+1\\n            elif i==\\')\\':\\n                res=res+\\')\\'\\n                c=c-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334680,
                "title": "solution-in-c-using-stack-and-without-stack",
                "content": "```\\n// using stack :- Time: O(n) ,  space: O(n)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        stack<char> st;\\n        for(char c: s){\\n            if(c == \\'(\\'){\\n                if(!st.empty()){\\n                    str += \\'(\\';\\n                }\\n                st.push(c);\\n            }\\n            else {\\n                st.pop();\\n                if(!st.empty()){\\n                    str += \")\";\\n                }\\n            }\\n            \\n        }\\n        return str;\\n    }\\n};\\n\\n//without stack Time: O(n),  space: O(1)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string str;\\n        for(char c : s){\\n            if (c == \\'(\\' && count++) str += \\'(\\';\\n            else if ( c == \\')\\' && --count) str+= \\')\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n// using stack :- Time: O(n) ,  space: O(n)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string str;\\n        stack<char> st;\\n        for(char c: s){\\n            if(c == \\'(\\'){\\n                if(!st.empty()){\\n                    str += \\'(\\';\\n                }\\n                st.push(c);\\n            }\\n            else {\\n                st.pop();\\n                if(!st.empty()){\\n                    str += \")\";\\n                }\\n            }\\n            \\n        }\\n        return str;\\n    }\\n};\\n\\n//without stack Time: O(n),  space: O(1)\\n\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int count = 0;\\n        string str;\\n        for(char c : s){\\n            if (c == \\'(\\' && count++) str += \\'(\\';\\n            else if ( c == \\')\\' && --count) str+= \\')\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269720,
                "title": "simple-java-solution-o-n",
                "content": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        int count=0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            \\n            char c=s.charAt(i);\\n            int prev=count;\\n            if(c==\\'(\\') count++;\\n            else count--;\\n            \\n            if(prev==0 && count==1) continue; // if it is a starting \\'(\\' of outer most parentheses then continue\\n            else if(prev==1 && count==0) continue; // if it is a ending \\')\\' of the outer most parentheses then continue\\n            \\n            res.append(c); // else append it to result\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        int count=0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            \\n            char c=s.charAt(i);\\n            int prev=count;\\n            if(c==\\'(\\') count++;\\n            else count--;\\n            \\n            if(prev==0 && count==1) continue; // if it is a starting \\'(\\' of outer most parentheses then continue\\n            else if(prev==1 && count==0) continue; // if it is a ending \\')\\' of the outer most parentheses then continue\\n            \\n            res.append(c); // else append it to result\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2040897,
                "title": "java-solution-using-stack",
                "content": "# java Solution\\n```\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder stb=new StringBuilder();\\n        Stack<Character> stack= new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(stack.size()>=1){\\n                    stb.append(\\'(\\');\\n                }\\n                stack.push(\\'(\\');\\n            }else{\\n                if(stack.size()>1){\\n                    stb.append(\\')\\');\\n                }\\n                stack.pop();\\n            }\\n           \\n        }\\n        return stb.toString();\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "String",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder stb=new StringBuilder();\\n        Stack<Character> stack= new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                if(stack.size()>=1){\\n                    stb.append(\\'(\\');\\n                }\\n                stack.push(\\'(\\');\\n            }else{\\n                if(stack.size()>1){\\n                    stb.append(\\')\\');\\n                }\\n                stack.pop();\\n            }\\n           \\n        }\\n        return stb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008555,
                "title": "simple-and-small-c-stack",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char> st;\\n        string ans = \"\", cur = \"\";\\n        for (auto it : s)\\n        {\\n            if (st.empty())\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\' && st.size() == 1)\\n            {\\n                st.pop();\\n                ans += cur.substr(1);\\n                cur = \"\";\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\')\\n            {\\n                st.pop();\\n                cur += it;\\n            }\\n            else\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string removeOuterParentheses(string s)\\n    {\\n        stack<char> st;\\n        string ans = \"\", cur = \"\";\\n        for (auto it : s)\\n        {\\n            if (st.empty())\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\' && st.size() == 1)\\n            {\\n                st.pop();\\n                ans += cur.substr(1);\\n                cur = \"\";\\n            }\\n            else if (st.top() == \\'(\\' && it == \\')\\')\\n            {\\n                st.pop();\\n                cur += it;\\n            }\\n            else\\n            {\\n                st.push(it);\\n                cur += it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981458,
                "title": "c-without-stack-and-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int sum = 0, lastIndex=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'(\\') {\\n                sum++;\\n            } else if(s[i] == \\')\\') {\\n                sum--;\\n            }\\n            if(sum == 0) {\\n                ans +=  s.substr(lastIndex+1, i-lastIndex-1);\\n                lastIndex = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \"\";\\n        int sum = 0, lastIndex=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'(\\') {\\n                sum++;\\n            } else if(s[i] == \\')\\') {\\n                sum--;\\n            }\\n            if(sum == 0) {\\n                ans +=  s.substr(lastIndex+1, i-lastIndex-1);\\n                lastIndex = i+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935363,
                "title": "java-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int f=0,l=0;\\n        StringBuilder res = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n            if(stack.empty()){\\n                res.append(s.substring(f+1,i));\\n                f = i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int f=0,l=0;\\n        StringBuilder res = new StringBuilder(\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n            if(stack.empty()){\\n                res.append(s.substring(f+1,i));\\n                f = i+1;\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794873,
                "title": "easy-java-solution-without-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int counter = 0;   \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\'){\\n                if (counter++ > 0)\\n                    sb.append(c);\\n            } else {\\n                if (--counter > 0) \\n                    sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        int counter = 0;   \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\'){\\n                if (counter++ > 0)\\n                    sb.append(c);\\n            } else {\\n                if (--counter > 0) \\n                    sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749419,
                "title": "c-0ms-100-0",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\", temp=\"\";\\n        int n=s.size();\\n        int open=0, clos=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            temp+=s[i];\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                clos++;\\n            if(open==clos)\\n            {\\n                res+=temp.substr(1, temp.size()-2);\\n                temp=\"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string res=\"\", temp=\"\";\\n        int n=s.size();\\n        int open=0, clos=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            temp+=s[i];\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                clos++;\\n            if(open==clos)\\n            {\\n                res+=temp.substr(1, temp.size()-2);\\n                temp=\"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734763,
                "title": "java-both-with-without-extra-space-fast-100",
                "content": "**Approach 1 : With using extra space** \\nWith using Stack, we are appending in resultant string if at any point our stack becomes empty :\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Integer> stk = new Stack<>() ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                stk.push(i);\\n            }\\n            else{\\n                int j = stk.pop() ;\\n                if(stk.isEmpty()){\\n                    res.append(s.substring(j+1,i));\\n                }\\n            }    \\n        }\\n        return res.toString() ;\\n    }\\n}\\n```\\n\\n**Approach 2 : Without using extra space**\\nIf we encounter an open bracket we will just increase the open count similarly for closeing bracket we are dereasing the count.\\nIf at any point `open` becomes 0 that means we need  substring from start of` open` = 0 to end `open` = 0 .\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int open = 0 ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                open++;\\n                if(open > 1) res.append(ch);\\n            }\\n            else{\\n                 open-- ;\\n                if(open > 0) res.append(ch);\\n            }\\n        }\\n        return res.toString() ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Integer> stk = new Stack<>() ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                stk.push(i);\\n            }\\n            else{\\n                int j = stk.pop() ;\\n                if(stk.isEmpty()){\\n                    res.append(s.substring(j+1,i));\\n                }\\n            }    \\n        }\\n        return res.toString() ;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        \\n        int open = 0 ;\\n        StringBuilder res = new StringBuilder() ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                open++;\\n                if(open > 1) res.append(ch);\\n            }\\n            else{\\n                 open-- ;\\n                if(open > 0) res.append(ch);\\n            }\\n        }\\n        return res.toString() ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732284,
                "title": "100-faster-java-solution-without-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int op=0;\\n        int cl=0;\\n        int si=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                op++;\\n            }else{\\n                cl++;\\n            }\\n            if(op==cl){\\n                for(int j=si+1;j<i;j++){\\n                    sb.append(s.charAt(j));\\n                }\\n                op=0;\\n                cl=0;\\n                si=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int op=0;\\n        int cl=0;\\n        int si=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                op++;\\n            }else{\\n                cl++;\\n            }\\n            if(op==cl){\\n                for(int j=si+1;j<i;j++){\\n                    sb.append(s.charAt(j));\\n                }\\n                op=0;\\n                cl=0;\\n                si=i+1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730020,
                "title": "c-solution",
                "content": "string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                str.pop();\\n            if(str.size()!=0)\\n                ans=ans+s[i];\\n            if(s[i]==\\'(\\')\\n                str.push(s[i]);\\n        }\\n        return ans;\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                str.pop();\\n            if(str.size()!=0)\\n                ans=ans+s[i];\\n            if(s[i]==\\'(\\')\\n                str.push(s[i]);\\n        }\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1691784,
                "title": "the-best-possible-solution-without-using-stack-that-run-in-0ms",
                "content": "class Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        \\n        string str = \"\";\\n        int i = 0;\\n        \\n        for(int j=1; j<s.size(); j++)\\n        {\\n            char ch = s[j];\\n            if(ch == \\'(\\')\\n                i++;\\n            if(i>0)\\n                str += ch;\\n            if(ch == \\')\\')\\n                i--;\\n        }\\n        \\n        \\n        \\n        return str;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        \\n        string str = \"\";\\n        int i = 0;\\n        \\n        for(int j=1; j<s.size(); j++)\\n        {\\n            char ch = s[j];\\n            if(ch == \\'(\\')\\n                i++;\\n            if(i>0)\\n                str += ch;\\n            if(ch == \\')\\')\\n                i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1686263,
                "title": "java-using-stack-and-without-using-stack",
                "content": "**USING STACK O(N)** \\n```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())  //convert string into character array\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)  //check if stack is empty or not i.e its first opening bracket or not\\n                 {\\n                     sb.append(ch);  // adds to sb if opening bracket but not first\\n                 }\\n                st.push(ch);  //push element into stack\\n            }\\n            else{\\n                if(st.size()>1)  // if stack is empty doesn\\'t append \\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop(); //pop out of stack\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**WITHOUT USING STACK O(N)**\\n```\\nclass Solution {\\n    public String removeOuterParentheses(String str) {\\n          StringBuilder sb= new StringBuilder();\\n        \\n        int opened= 0;\\n        for( char c:str.toCharArray()){\\n            \\n            if(c==\\'(\\'){\\n                if(opened>0) sb.append(c);\\n                opened++;\\n            }else{\\n                if(opened>1)sb.append(c);\\n                opened--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n**Hope you  like it**\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeOuterParentheses(String S) {\\n        Stack<Character> st=new Stack();\\n        StringBuilder sb=new StringBuilder();\\n        for(char ch:S.toCharArray())  //convert string into character array\\n        {\\n            if(ch==\\'(\\')\\n            {\\n                 if(st.size()>=1)  //check if stack is empty or not i.e its first opening bracket or not\\n                 {\\n                     sb.append(ch);  // adds to sb if opening bracket but not first\\n                 }\\n                st.push(ch);  //push element into stack\\n            }\\n            else{\\n                if(st.size()>1)  // if stack is empty doesn\\'t append \\n                 {\\n                     sb.append(ch);\\n                 }\\n                st.pop(); //pop out of stack\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeOuterParentheses(String str) {\\n          StringBuilder sb= new StringBuilder();\\n        \\n        int opened= 0;\\n        for( char c:str.toCharArray()){\\n            \\n            if(c==\\'(\\'){\\n                if(opened>0) sb.append(c);\\n                opened++;\\n            }else{\\n                if(opened>1)sb.append(c);\\n                opened--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677664,
                "title": "easiest-solution-using-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<int> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                st.pop();\\n            if(st.size()!=0)\\n                ans+=s[i];\\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<int> st;\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n                st.pop();\\n            if(st.size()!=0)\\n                ans+=s[i];\\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611056,
                "title": "without-stack-solution-o-n-single-pass",
                "content": "````    public String removeOuterParentheses(String s) {\\n        int sb = 0;\\n        int eb = 0;int sp = 0;\\n        StringBuilder str1 = new StringBuilder(\"\");\\n        for(int i = 0;i < s.length() ;i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                sb++;\\n            }else{\\n                eb++;\\n            }\\n            if(sb == eb ){\\n                str1.append(s.substring(sp+1,i));\\n                sb = 0;eb = 0;sp = i+1;\\n            }\\n        }\\n\\n        return str1.toString();\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "````    public String removeOuterParentheses(String s) {\\n        int sb = 0;\\n        int eb = 0;int sp = 0;\\n        StringBuilder str1 = new StringBuilder(\"\");\\n        for(int i = 0;i < s.length() ;i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                sb++;\\n            }else{\\n                eb++;\\n            }\\n            if(sb == eb ){\\n                str1.append(s.substring(sp+1,i));\\n                sb = 0;eb = 0;sp = i+1;\\n            }\\n        }\\n\\n        return str1.toString();\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1506586,
                "title": "clean-solution-using-stack-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int countLeft = 0, countRight = 0;\\n        string ans = \"\";\\n        stack<char> st;\\n        \\n        for(int i =0;i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                countLeft++;\\n                if(countLeft > 1){\\n                    st.push(s[i]);\\n                }\\n            }else if(countLeft == countRight+1){\\n                countLeft = 0;\\n                countRight = 0;\\n                continue;\\n            }else if(s[i] == \\')\\'){\\n                st.push(s[i]);\\n                countRight++;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        int countLeft = 0, countRight = 0;\\n        string ans = \"\";\\n        stack<char> st;\\n        \\n        for(int i =0;i<s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                countLeft++;\\n                if(countLeft > 1){\\n                    st.push(s[i]);\\n                }\\n            }else if(countLeft == countRight+1){\\n                countLeft = 0;\\n                countRight = 0;\\n                continue;\\n            }else if(s[i] == \\')\\'){\\n                st.push(s[i]);\\n                countRight++;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469321,
                "title": "java-easy-solution-using-stack-o-n",
                "content": "Simply use a stack follow if-else laddar conditions:-\\n\\n```class Solution {``\\n    public String removeOuterParentheses(String s) {\\n        String str=\"\";\\n    Stack<Character> st=new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        char ch=s.charAt(i);\\n        if(ch==\\'(\\'){\\n            st.push(ch);\\n            if(st.size()>1){\\n                str+=ch;\\n            }\\n        }\\n        else if(ch==\\')\\'){\\n            if( st.size()>1 && st.peek()==\\'(\\'){\\n                str+=ch;\\n                st.pop();\\n            }\\n            else if(st.size()==1 && st.peek()==\\'(\\' ){\\n                st.pop();\\n            }\\n        }\\n        \\n    }\\n    return str;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {``\\n    public String removeOuterParentheses(String s) {\\n        String str=\"\";\\n    Stack<Character> st=new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        char ch=s.charAt(i);\\n        if(ch==\\'(\\'){\\n            st.push(ch);\\n            if(st.size()>1){\\n                str+=ch;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433045,
                "title": "simple-solution-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        stack<char>s;\\n        string ans=\"\";\\n        \\n        for(auto x:str){\\n            \\n            if(x==\\'(\\'){\\n                \\n                if(!s.empty())  ans+=\\'(\\';\\n                 \\n                s.push(\\'(\\');\\n            \\n            } \\n            \\n            else{\\n                \\n                s.pop();\\n                \\n                if(!s.empty()) ans+=\\')\\';\\n                          \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string removeOuterParentheses(string str) {\\n        stack<char>s;\\n        string ans=\"\";\\n        \\n        for(auto x:str){\\n            \\n            if(x==\\'(\\'){\\n                \\n                if(!s.empty())  ans+=\\'(\\';\\n                 \\n                s.push(\\'(\\');\\n            \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1414500,
                "title": "java-using-stack-5ms",
                "content": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st=new Stack<>();\\n        StringBuilder sb= new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\')\\n            {\\n                if(st.size()>0)//to check if the stack is empty or not\\n                {\\n                    sb.append(ch);\\n                }\\n                st.push(ch);\\n            }\\n            else\\n            {\\n                st.pop();\\n                if(st.size()>0)\\n                {\\n                    sb.append(ch);\\n                }\\n                    \\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeOuterParentheses(String s) {\\n        Stack<Character> st=new Stack<>();\\n        StringBuilder sb= new StringBuilder();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\')\\n            {\\n                if(st.size()>0)//to check if the stack is empty or not\\n                {\\n                    sb.append(ch);\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1749987,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1944035,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1568298,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 2019757,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1752088,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1717947,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1935039,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1907179,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1846855,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1574537,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1749987,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1944035,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1568298,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 2019757,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1752088,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1717947,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1935039,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1907179,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1846855,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1574537,
                "content": [
                    {
                        "username": "mohammedmoin244",
                        "content": "i don\\'t understand this problem"
                    },
                    {
                        "username": "reassurance",
                        "content": "Solve this [First](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/). It will help"
                    },
                    {
                        "username": "enkil2003",
                        "content": "That is because the problem is the description.  Just read the title."
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "Rebv18",
                        "content": "These problems are written so poorly, I have to youtube it to even understand what it\\'s really asking me to do"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\\nWhat  \":**Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.**\"?\\n\\n\\n\\n\\nA valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\\n\\n_I don\\'t understand what that means._\\n\\n\\n\\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\\n\\n_What does this mean? What is nonempty? Does it mean left paren, followed by one or more chars, followed by right paren?_\\n\\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\\n\\n\\n_What is primitive decomposition?_\\n\\n\\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\\n\\n_What does this mean?_"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically primary decomposition means that decomposed string will itself be a valid string paranthesis for example \"(())\" or \"(()())\" .\\nNow \"(())\" is primitive because you can\\'t break it down and make it a valid string paranthesis.\\nbut for instance take \"()()()\" now this string can be broken into \"()\",\"()\",\"()\" which all are valid string paranthesis. \\nNow you have to break your string into primitive paranthesis(which can\\'t be broken further) and after that remove first and last parathesis and join all of them together and return."
                    },
                    {
                        "username": "BatMe",
                        "content": "Why is this easy??? \\n"
                    },
                    {
                        "username": "satyam1951711",
                        "content": "Its just that, whenever you find a valid parenthesis within the string, remove the outer parenthesis of the valid parenthesis.\\nHint : You can use stack for finding valid parenthesis.\\nLike we\\'re having a string ((())())(()) : We\\'re having two valid parenthesis inside this string that are, ((())()) and (()) --> \\'((())())\\' + \\'(())\\' (As stated in the question).\\nSo the answer would contain this valid parenthesis after removing their outermost parenthesis that is, \\'(())()()\\'."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA1One Pass | FAANG SDE-1 Interview\\uD83D\\uDE2F\\nhttps://leetcode.com/problems/remove-outermost-parentheses/solutions/2916928/one-pass-faang-sde-1-interview/?orderBy=most_votes"
                    },
                    {
                        "username": "kshitijgarg2609",
                        "content": "What would the test case for s.length is odd?"
                    },
                    {
                        "username": "theashggl",
                        "content": "[@Champak_Lal_Gada](/Champak_Lal_Gada) It is also given that the least length is 1."
                    },
                    {
                        "username": "Champak_Lal_Gada",
                        "content": "It is given that s is valid parenthesis string. so it will always be even length."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "explaining problem statement:-\\nremove outer parentheses means removing outer most parentheses (both opening and closing) of a balanced parantheses.. for ex:- ( ( ) ), representing outer by \\'[ ]\\', it will be like [ ( ) ] so ans will be ( ). a bigger ex:- ( ( ( ) ( ) ) ) ( ( ) ), represent it like [ ( ( ) ( ) ) ] [ ( ) ] so ans will be ( ( ) ) ( ).\\nhint:- it can be solved without stack\\nwhenever you encounter a first \\'(\\' remove it and when ct of \\'(\\' == ct of \\')\\' then remove \\')\\' again if you encounter \\'(\\' then you remove it. as it is given balanced parentheses already so after removing \\')\\' you will always find next element is \\'(\\' and it will be again first for next consecutive sequence.."
                    },
                    {
                        "username": "aishwarya_singh2095",
                        "content": "Thanks this helped me understand."
                    },
                    {
                        "username": "neel19",
                        "content": "Check the contiguous subarray which has valid parenthesis. Remove the opening and closing brace from this subarray, add this sub string to your answer. \n[My Solution](https://leetcode.com/problems/remove-outermost-parentheses/submissions/924004022/)"
                    },
                    {
                        "username": "SHELBY2798",
                        "content": "So,in this problem you are given a balanced parenthesis .So,a balanced parenthesis can be either made up of A1+A2+..An(where A is itself a valid parentheses) or it can\\'t.So,for each valid parenthesis(i.e A),you need to remove the outermost \\'(\\' and \\')\\'."
                    }
                ]
            },
            {
                "id": 1801906,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2074725,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2059542,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2037140,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2036139,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2034017,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2030162,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2029746,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 2004957,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            },
            {
                "id": 1963340,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-outermost-parentheses/solutions/3188368/javascript-linear-time-and-space-beat-80-in-space-and-time-stack-2-ways/\\n\\nUsing Stack, Linear Time and space"
                    },
                    {
                        "username": "reassurance",
                        "content": "Ok so I got this problem at my first try. Not to flex, but i decided to tell some points to keep in mind.\\n\\n1.  If you know what depth of parenthesis is, try connecting it to this problem. See how and when you have to add parenthesis to the answer when depth is at some value.\\n\\n2. If not, I highly recommend you checking out this [problem](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4097390/python-c-easiest-to-understand-beats-100/).\\n\\n3. Once you understand the above problem, try applying it in small steps to this problem. Essentially break the problem and generate parenthesis group by group. So if you go group by group and store it group by group, you can just pop the first and last element and the rest will be the answer.\\n\\nHappy Coding!"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "jesus christ, this hurt my eyes big time"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Explanation is super complicated. What do they want. I know how to work with stacks, but I do not understand what they ask for"
                    },
                    {
                        "username": "banerjeesunetra201001",
                        "content": "We can use stack to solve this. Use a counter and increase it while entering the outer \"(\" and decrease the counter while entering outer \")\" in the stack. Rest if the counter c>0, concatenate the characters the answer string."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was about falling asleep during reading the description. "
                    },
                    {
                        "username": "gokulsethi69",
                        "content": "it should be marked as medium.\\n"
                    },
                    {
                        "username": "Arjun_Chander",
                        "content": "does this question require stack? I did it without stack. "
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Reading Description is waste of time "
                    },
                    {
                        "username": "theashggl",
                        "content": "If you think about it, the problem doesn\\'t require any implementation of a stack data structure. It will only increase the space complexity."
                    }
                ]
            }
        ]
    },
    {
        "title": "Running Sum of 1d Array",
        "question_content": "<p>Given an array <code>nums</code>. We define a running sum of an array as&nbsp;<code>runningSum[i] = sum(nums[0]&hellip;nums[i])</code>.</p>\r\n\r\n<p>Return the running sum of <code>nums</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4]\r\n<strong>Output:</strong> [1,3,6,10]\r\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,1,1,1]\r\n<strong>Output:</strong> [1,2,3,4,5]\r\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3,1,2,10,1]\r\n<strong>Output:</strong> [3,4,6,16,17]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\r\n\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 3167663,
                "title": "simple-solution-java-cpp-python-c-language-runtime-1-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```java []\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i-1]+nums[i];\\n\\n        }\\n        return nums;\\n    }\\n}\\n```\\n```Cpp []\\nclass Solution {\\n\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++){\\n\\n            nums[i]+=nums[i-1];\\n\\n        }\\n\\n        return nums;\\n    }\\n};\\n```\\n```Python []\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\\n```C []\\n\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=1;i<numsSize;i++)\\n    {\\n        nums[i]+=nums[i-1];\\n    }\\n    return nums;\\n}\\n```\\n\\n\\n\\n![478xve.jpg](https://assets.leetcode.com/users/images/bec6803b-0214-4a33-be9e-f8c4b459d23e_1676026371.8625238.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i-1]+nums[i];\\n\\n        }\\n        return nums;\\n    }\\n}\\n```\n```Cpp []\\nclass Solution {\\n\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++){\\n\\n            nums[i]+=nums[i-1];\\n\\n        }\\n\\n        return nums;\\n    }\\n};\\n```\n```Python []\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n```\n```C []\\n\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=1;i<numsSize;i++)\\n    {\\n        nums[i]+=nums[i-1];\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635285,
                "title": "comprehensive-python-explanation-4-methods",
                "content": "**Intuition**\\nTo solve this problem we need to create an array that will store the running sum up to that index. There are many ways to do this, starting from the most basic brute force to a neat single pass.\\n\\n**Method 1: Pure Brute Force; Time: O(N^2), Space: O(N)**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tanswer = [] #array to keep track of our answer\\n\\tfor i in range(len(nums)): #iterate through all the elements in nums\\n\\t\\trunningSum = 0 #this will keep track of the running sum up to index i\\n\\t\\tfor j in range(i+1): \\n\\t\\t\\trunningSum += nums[j] #sum all the elements leading up to nums[i]\\n\\t\\tanswer.append(runningSum) #add the sum to our answer array\\n\\treturn answer\\n```\\nThe idea behind this method is that for every index i in nums, we will iterate from 0 to i and sum the elements in nums to get the running sum. The time complexity is O(N^2) since we need to iterate up to index i for every value of i between 0 and N. The space complexity is O(N) since our answer array has length N (where N is the length of nums).\\n\\n **Method 2: Brute Force with List Comprehension; Time: O(N^2), Space: O(N)**\\n ```\\n def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [sum(nums[:i+1]) for i in range(len(nums))]\\n```\\nThis method works the same as Method 1 but is a neat one liner. ```sum(nums[:i+1])``` performs the same function as our nested for loop in method 1, finding the running sum up to that point. \\n\\n**Improving from Brute Force**\\nBoth of these methods are accepted, but when we find a working solution, we should always ask if we can think of a better one. In this case, there is a way to complete the function in one pass, lowering the time complexity from O(N^2) to O(N).\\n\\n**Method 3: One Pass; Time: O(N), Space: O(N)**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\trunSum = [nums[0]] #our answer array starts with nums[0], which is the 0th running sum\\n\\tfor i in range(1,len(nums)):\\n\\t\\trunSum.append(runSum[i-1]+nums[i]) #the running sum up to index i is the sum of nums[i] and the running sum up to index i-1\\n\\treturn runSum\\n```\\nThe key insight here is that the running sum up to index i is the sum of nums[i] and the running sum up to index i-1. Here is a more detailled explanation:\\nWe know that ```runningSum[i] = nums[0] + nums[1] + ... + nums[i-1] + nums[i]```. \\nHowever, ```runningSum[i-1] = nums[0] + nums[1] + ... + nums[i-1]```, so we can rewrite the first expression to get that ```runningSum[i] = runningSum[i-1] + nums[i]```!\\n\\nThis code has a time complexity of O(N) since it only takes one pass, which will make the program run much faster when given a very large nums array. However, there is still a way to optimize the space we use.\\n\\n**Method 4: One Pass, In-Place Solution; Time: O(N), Space: O(1)**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tfor i in range(1,len(nums)):\\n\\t\\tnums[i] = nums[i-1] + nums[i]\\n\\treturn nums\\n```\\nThis method uses the same insight as Method 3 but does it without using an extra array to store the result!. If we are currently at index i, we can assume ```nums[i-1], nums[i-2]... nums[0]``` have all been visited before and therefore contain the running sum up to that point. This means that ```nums[i-1]``` is actually the same as ```runSum[i-1]``` in the last method! By modifying nums in-place and not using an extra array, we cut down on any unnecessary extra space.\\n\\n\\n**Thanks for Reading!**\\nIf this post has been helpful please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tanswer = [] #array to keep track of our answer\\n\\tfor i in range(len(nums)): #iterate through all the elements in nums\\n\\t\\trunningSum = 0 #this will keep track of the running sum up to index i\\n\\t\\tfor j in range(i+1): \\n\\t\\t\\trunningSum += nums[j] #sum all the elements leading up to nums[i]\\n\\t\\tanswer.append(runningSum) #add the sum to our answer array\\n\\treturn answer\\n```\n```\\n def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [sum(nums[:i+1]) for i in range(len(nums))]\\n```\n```sum(nums[:i+1])```\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\trunSum = [nums[0]] #our answer array starts with nums[0], which is the 0th running sum\\n\\tfor i in range(1,len(nums)):\\n\\t\\trunSum.append(runSum[i-1]+nums[i]) #the running sum up to index i is the sum of nums[i] and the running sum up to index i-1\\n\\treturn runSum\\n```\n```runningSum[i] = nums[0] + nums[1] + ... + nums[i-1] + nums[i]```\n```runningSum[i-1] = nums[0] + nums[1] + ... + nums[i-1]```\n```runningSum[i] = runningSum[i-1] + nums[i]```\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tfor i in range(1,len(nums)):\\n\\t\\tnums[i] = nums[i-1] + nums[i]\\n\\treturn nums\\n```\n```nums[i-1], nums[i-2]... nums[0]```\n```nums[i-1]```\n```runSum[i-1]```",
                "codeTag": "Python3"
            },
            {
                "id": 686276,
                "title": "c-python-partial-sum",
                "content": "**C++**\\n```cpp\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n}\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return accumulate(nums)   \\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n}\\n```\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return accumulate(nums)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468388,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-python3",
                "content": "# **Java Solution:**\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Running Sum of 1d Array.\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        // Create an output array of size equal to given nums size...\\n        int[] output = new int[nums.length];\\n        // Base case: if the array is empty...\\n        if(nums.length == 0)\\n            return output;\\n        // Set output[0] = nums[0]...\\n        output[0] = nums[0];\\n        // Traverse all elements through the for loop...\\n        for(int idx = 1; idx < nums.length; idx++) {\\n            // Storing the running sum...\\n            output[idx] = output[idx-1]+ nums[idx];\\n        }\\n        return output;      // Return the running sum of nums...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        // Create an output array of size equal to given nums size...\\n        vector<int> output(nums.size());\\n        // Base case: if the array is empty...\\n        if(nums.size() == 0)\\n            return output;\\n        // Set output[0] = nums[0]...\\n        output[0] = nums[0];\\n        // Traverse all elements through the for loop...\\n        for(int idx = 1; idx < nums.size(); idx++) {\\n            // Storing the running sum...\\n            output[idx] = output[idx-1] + nums[idx];\\n        } return output;     // Return the running sum of nums...\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\n# Time Complexity : O(n)\\n# Space Complexity : O(n)\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        # Create an output array of size equal to given nums size...\\n        output = [0] * len(nums)\\n        # Set output[0] = nums[0]...\\n        output[0] = nums[0]\\n        # Traverse all elements through the for loop...\\n        for idx in range(1, len(nums)):\\n            # Storing the running sum...\\n            output[idx] = output[idx - 1] + nums[idx]\\n        return output       # Return the running sum of nums...\\n```\\n                \\n# **JavaScript Solution:**\\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nvar runningSum = function(nums) {\\n    // Create an output array of size equal to given nums size...\\n    let output = new Array(nums.length)\\n    // Set output[0] = nums[0]...\\n    output[0] = nums[0];\\n    // Traverse all elements through the for loop...\\n    for(let idx = 1; idx < nums.length; idx++) {\\n        // Storing the running sum...\\n        output[idx] = output[idx-1] + nums[idx];\\n    }\\n    return output;      // Return the running sum of nums...\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Running Sum of 1d Array.\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        // Create an output array of size equal to given nums size...\\n        int[] output = new int[nums.length];\\n        // Base case: if the array is empty...\\n        if(nums.length == 0)\\n            return output;\\n        // Set output[0] = nums[0]...\\n        output[0] = nums[0];\\n        // Traverse all elements through the for loop...\\n        for(int idx = 1; idx < nums.length; idx++) {\\n            // Storing the running sum...\\n            output[idx] = output[idx-1]+ nums[idx];\\n        }\\n        return output;      // Return the running sum of nums...\\n    }\\n}\\n```\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        // Create an output array of size equal to given nums size...\\n        vector<int> output(nums.size());\\n        // Base case: if the array is empty...\\n        if(nums.size() == 0)\\n            return output;\\n        // Set output[0] = nums[0]...\\n        output[0] = nums[0];\\n        // Traverse all elements through the for loop...\\n        for(int idx = 1; idx < nums.size(); idx++) {\\n            // Storing the running sum...\\n            output[idx] = output[idx-1] + nums[idx];\\n        } return output;     // Return the running sum of nums...\\n    }\\n};\\n```\n```\\n# Time Complexity : O(n)\\n# Space Complexity : O(n)\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        # Create an output array of size equal to given nums size...\\n        output = [0] * len(nums)\\n        # Set output[0] = nums[0]...\\n        output[0] = nums[0]\\n        # Traverse all elements through the for loop...\\n        for idx in range(1, len(nums)):\\n            # Storing the running sum...\\n            output[idx] = output[idx - 1] + nums[idx]\\n        return output       # Return the running sum of nums...\\n```\n```\\n// Time Complexity : O(n)\\n// Space Complexity : O(n)\\nvar runningSum = function(nums) {\\n    // Create an output array of size equal to given nums size...\\n    let output = new Array(nums.length)\\n    // Set output[0] = nums[0]...\\n    output[0] = nums[0];\\n    // Traverse all elements through the for loop...\\n    for(let idx = 1; idx < nums.length; idx++) {\\n        // Storing the running sum...\\n        output[idx] = output[idx-1] + nums[idx];\\n    }\\n    return output;      // Return the running sum of nums...\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686261,
                "title": "java-c-python-array-time-o-n-space-o-1",
                "content": "**Explanation**\\nLoop once, we can get the sum of subarray starting from the initial point.\\n\\n**Complexity**\\n\\nTime ```O(N)```\\nSpace ```O(1)```\\n\\n**Java:**\\n```\\npublic int[] runningSum(int[] nums) {\\n        int i = 1;\\n        while (i<nums.length){\\n            nums[i]+=nums[i-1];\\n            i++;\\n        }\\n        return nums;\\n    }\\n```\\n**C++**\\n```\\nvector<int> runningSum(vector<int>& nums) {\\n        int i = 1;\\n        while (i<nums.size()){\\n            nums[i]+=nums[i-1];\\n            i++;\\n        }\\n        return nums;\\n    }\\n```\\n\\n@jain_kashish c++ code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& a) {\\n        for( int i=1 ; i<a.size() ; i++ )\\n            a[i] += a[i-1] ;\\n        return a ;\\n    }\\n};\\n```\\n**Python**\\n```\\n def runningSum(self, nums):\\n        i = 1\\n        while i<len(nums):\\n            nums[i]+=nums[i-1]\\n            i+=1\\n        return nums\\n```\\nWithout modifying the initial array\\n\\nTime ```O(N)```\\nSpace ```O(1)```\\n\\n```\\n def runningSum(self, nums):\\n        res = [nums[0]] + [0] * (len(nums) - 1)\\n        for i, num in enumerate(nums[1:]):\\n            res[i + 1] += res[i] + num\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```O(N)```\n```O(1)```\n```\\npublic int[] runningSum(int[] nums) {\\n        int i = 1;\\n        while (i<nums.length){\\n            nums[i]+=nums[i-1];\\n            i++;\\n        }\\n        return nums;\\n    }\\n```\n```\\nvector<int> runningSum(vector<int>& nums) {\\n        int i = 1;\\n        while (i<nums.size()){\\n            nums[i]+=nums[i-1];\\n            i++;\\n        }\\n        return nums;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& a) {\\n        for( int i=1 ; i<a.size() ; i++ )\\n            a[i] += a[i-1] ;\\n        return a ;\\n    }\\n};\\n```\n```\\n def runningSum(self, nums):\\n        i = 1\\n        while i<len(nums):\\n            nums[i]+=nums[i-1]\\n            i+=1\\n        return nums\\n```\n```O(N)```\n```O(1)```\n```\\n def runningSum(self, nums):\\n        res = [nums[0]] + [0] * (len(nums) - 1)\\n        for i, num in enumerate(nums[1:]):\\n            res[i + 1] += res[i] + num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694429,
                "title": "javascript-reduce",
                "content": "```\\nconst runningSum = nums => {\\n    nums.reduce((a,c,i,arr) => arr[i] += a)\\n    return nums\\n}\\n```\\n**Remember that assignment is an expression and therefore returns a value.\\nSpecifically, the new value of the variable being assigned something.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst runningSum = nums => {\\n    nums.reduce((a,c,i,arr) => arr[i] += a)\\n    return nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831397,
                "title": "python-3-2-simple-solutions-o-n-time",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nTime complexity for both the solutions: O(n).\\nSpace complexity in both the solutions: O(n) because we are creating a result list of size n.\\n\\n**Solution 1:**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tresult = []\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += nums[i]\\n\\t\\tresult.append(total)\\n\\treturn result\\n```\\n\\n**Solution 2: Without using \\'total\\' variable. Just use the last value in result to calculate new sum.**\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tresult = []\\n\\tresult.append(nums[0])\\n\\tfor i in range(1, len(nums)):\\n\\t\\tresult.append(result[-1]+nums[i])\\n\\treturn result\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tresult = []\\n\\ttotal = 0\\n\\tfor i in range(len(nums)):\\n\\t\\ttotal += nums[i]\\n\\t\\tresult.append(total)\\n\\treturn result\\n```\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tresult = []\\n\\tresult.append(nums[0])\\n\\tfor i in range(1, len(nums)):\\n\\t\\tresult.append(result[-1]+nums[i])\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2699842,
                "title": "python-c-java-faster-than-100-simple-short-solution-2-line-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q1480. Running Sum of 1d Array***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n    \\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++)  nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n         vector<int> runningSum(vector<int>& a) {\\n        for( int i=1 ; i<a.size() ; i++ )\\n            a[i] += a[i-1] ;\\n        return a ;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i]+=nums[i-1]\\n        return nums\\n    \\n```\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++)  nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n         vector<int> runningSum(vector<int>& a) {\\n        for( int i=1 ; i<a.size() ; i++ )\\n            a[i] += a[i-1] ;\\n        return a ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688613,
                "title": "java-clean-and-simple-solution",
                "content": "The simplest solution to this problem (without using streams or other oneliners) is to iterate the input array and perform n[i] += n[i-1], starting at index 1. This works well for arrays with size 1 too, since no iteration is attempted on the for loop (due to int i = 1):\\n\\n```\\n   public int[] runningSum(int[] nums) {       \\n\\t\\t// modify the input array, adding n[i] with n[i-1]\\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }      \\n\\t\\t\\n\\t\\t// return the modified array\\n        return nums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int[] runningSum(int[] nums) {       \\n\\t\\t// modify the input array, adding n[i] with n[i-1]\\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }      \\n\\t\\t\\n\\t\\t// return the modified array\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925781,
                "title": "c-2-lines-of-code-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> runningSum(vector<int>& nums) {\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++) nums[i] += nums[i-1];\\n\\t\\t\\treturn nums;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> runningSum(vector<int>& nums) {\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++) nums[i] += nums[i-1];\\n\\t\\t\\treturn nums;\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2096022,
                "title": "c-short-easy-w-prefix-sum-partial-sum-stl",
                "content": "**Please do upvote if you like the post :)**\\n\\n\\n**Most Intuitive Approach Ever (C++):**\\n```\\nclass Solution {\\npublic:\\n\\t// you can remove the \\'&\\' in case you don\\'t want to update the nums array\\n    vector<int> runningSum(vector<int>& nums) { \\n        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1]; //prefix sum calculation\\n        return nums;\\n    }\\n};\\n```\\n****\\n**Time Complexity : O(N)**, Where `N` is the size of the `nums`\\n**Space Complexity : O(1)**\\n****\\n****\\n![image](https://assets.leetcode.com/users/images/b2c1e604-038b-450f-ad18-becf9d03b26e_1654052909.841381.png)\\n****\\n\\n[https://en.wikipedia.org/wiki/Prefix_sum](http://) **If you want to know what prefix sum is actually.**\\n****\\n****\\n**STL - Partial_Sum Approach (C++) :**\\n```\\nclass Solution {\\npublic:\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n\\t}\\n};\\n```\\n****\\n****\\n**Time Complexity : O(N)**, Where `N` is the size of the `nums`\\n**Space Complexity : O(1)**\\n****\\n![image](https://assets.leetcode.com/users/images/87832640-c441-4cf4-b992-bc8f6eacf1cd_1654062822.817285.png)\\n****\\n****\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// you can remove the \\'&\\' in case you don\\'t want to update the nums array\\n    vector<int> runningSum(vector<int>& nums) { \\n        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1]; //prefix sum calculation\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841274,
                "title": "python-3-multiple-one-liners",
                "content": "Solution 1: \\nIterate through the list and append the sum of **```nums[:i+1]```** at every iteration.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return [sum(nums[:i+1]) for i in range(len(nums))]\\n```\\nSolution 2: \\nThe same logic as above, this time using **```enumerate()```**.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\treturn [sum(nums[:i]) for i, e in enumerate(nums, 1)]\\n```\\n\\nSolution 3: \\nUsing in-built function, **```itertools.accumulate()```**.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\treturn accumulate(nums)\\n```\\n\\nSolution 4: \\n**Simple, iterative approach**, cumulative sum by updating each element in the array with the sum of previous elements.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\tnums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```nums[:i+1]```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return [sum(nums[:i+1]) for i in range(len(nums))]\\n```\n```enumerate()```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\treturn [sum(nums[:i]) for i, e in enumerate(nums, 1)]\\n```\n```itertools.accumulate()```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\treturn accumulate(nums)\\n```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\tnums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686373,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    for(let i=1;i<nums.length;i++){\\n        nums[i]+=nums[i-1]\\n    }\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    for(let i=1;i<nums.length;i++){\\n        nums[i]+=nums[i-1]\\n    }\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096870,
                "title": "one-liner-javascript-solution",
                "content": "One Liner\\n``` js\\nvar runningSum = ((nums, val = 0) => nums.map(x => val = val + x))\\n```\\n\\nPlease upvote if helpful!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` js\\nvar runningSum = ((nums, val = 0) => nums.map(x => val = val + x))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417099,
                "title": "three-lines-of-code-for-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:99%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:88%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst runningSum = nums => {\\n  let sum = 0;\\n  return nums.map(num => sum += num);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst runningSum = nums => {\\n  let sum = 0;\\n  return nums.map(num => sum += num);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222530,
                "title": "simple-and-nice-approach-0-ms-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought of just keep on adding sum and return. That gave me error, because I didn\\'t read the question properly xD. I just added 2 extra lines of code to it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First initialize total sum and return vector. \\n- Then, iterate each element in nums vector. \\n- Keep on adding sum to the iterative value and keep on pushing new sum value to return array\\n- Return the array. WOW!!! Profit!!! Nice :)\\n\\n##### Pls upvote this multilingual solution\\n\\n# Code\\n### C++\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sums = 0;\\n        vector<int> retSums;\\n        for(auto i : nums) {\\n            sums += i;\\n            retSums.push_back(sums);\\n        }\\n        return retSums;\\n    }\\n};\\n```\\n### Python\\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sums=0\\n        retSum=[]\\n        for i in nums:\\n            sums+=i\\n            retSum.append(sums)\\n        return retSum\\n```\\n### Rust\\n```rust\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut sum = 0;\\n        let mut retValue:Vec<i32> = Vec::new();\\n        for num in nums {\\n            sum += num;\\n            retValue.push(sum);\\n        }\\n        retValue\\n    }\\n}\\n```\\n### Javascript\\n```js\\nvar runningSum = function(nums) {\\n    let sums = 0;\\n    let retSums = [];\\n    for(let i of nums) {\\n        sums += i;\\n        retSums.push(sums);\\n    }\\n    return retSums;\\n}\\n```\\n### Java\\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sums = 0;\\n        int[] retSums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            sums += nums[i];\\n            retSums[i] = sums;\\n        }\\n        return retSums;\\n    }\\n}\\n```\\n![Screenshot 2023-03-31 123451.png](https://assets.leetcode.com/users/images/2d8c6ac2-0d70-4e56-9c24-5d4aee04e91e_1680246415.857811.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Rust"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sums = 0;\\n        vector<int> retSums;\\n        for(auto i : nums) {\\n            sums += i;\\n            retSums.push_back(sums);\\n        }\\n        return retSums;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sums=0\\n        retSum=[]\\n        for i in nums:\\n            sums+=i\\n            retSum.append(sums)\\n        return retSum\\n```\n```rust\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut sum = 0;\\n        let mut retValue:Vec<i32> = Vec::new();\\n        for num in nums {\\n            sum += num;\\n            retValue.push(sum);\\n        }\\n        retValue\\n    }\\n}\\n```\n```js\\nvar runningSum = function(nums) {\\n    let sums = 0;\\n    let retSums = [];\\n    for(let i of nums) {\\n        sums += i;\\n        retSums.push(sums);\\n    }\\n    return retSums;\\n}\\n```\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sums = 0;\\n        int[] retSums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            sums += nums[i];\\n            retSums[i] = sums;\\n        }\\n        return retSums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526051,
                "title": "multiple-c-solution-brute-force-and-using-stl",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using *****Brute force approach*****\\n- We simply took a counter ***(count)*** to store the sum till the current index.\\n- Run a loop & in every iteration add the current value to count.\\n- Push the value to ans vector.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Using *****STL function*****\\n- It takes 3 parameters: `first`,\\xA0`last` &`sum`.\\n- **Time complexity:** O(*n\\xD7k*), where\\xA0*n*\\xA0is the distance from\\xA0`first`\\xA0to\\xA0`last`,\\xA0*O(k)*\\xA0is the complexity of\\xA0the function.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        int count =0;\\n        \\n        for(int i=0; i<n; i++){\\n            count += nums[i];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        for(int i=1; i<=nums.size(); i++)\\n            ans.push_back(accumulate(nums.begin(), (nums.begin()+i), 0));\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution** \\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        int count =0;\\n        \\n        for(int i=0; i<n; i++){\\n            count += nums[i];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        for(int i=1; i<=nums.size(); i++)\\n            ans.push_back(accumulate(nums.begin(), (nums.begin()+i), 0));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189005,
                "title": "js-python-java-c-easy-prefix-sum-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWhile this is not a terribly challenging problem, it\\'s a good introduction to the concept of a **prefix sum array**. Prefix sum arrays have many uses in more complex algorithms and can sometimes help reduce the time complexity of a advanced solution by an order of magnitude.\\n\\nIn a prefix sum array, we will create a duplicate array which contains the running sum of the elements **0** to **i** of our original array (**nums**) for each index **i** of our prefix sum array (**ans**). _(**Note**: We can lower the **space complexity** by using an **in-place** approach with **nums** directly and mutating it into its own prefix sum array, if there is no compelling reason to avoid modifying a function argument.)_\\n\\nSince we\\'ll need to build on a previous running total, we should start our iteration at **i = 1** and copy over the first element from **nums** to **ans**. Then we just iterate through **nums** and add each element (**nums[i]**) to the previous running total (**ans[i-1]**) to create the new running total (**ans[i]**).\\n\\nWhen we\\'re done, we can **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of nums_\\n - _**Space Complexity: O(N)** for our running sum array_\\n    - _or **O(1)** with an in-place approach_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar runningSum = function(nums) {\\n    let ans = new Array(nums.length)\\n    ans[0] = nums[0]\\n    for (let i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        ans[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            ans[i] = ans[i-1] + nums[i]\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    ans[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i];\\n    return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            ans[i] = ans[i-1] + nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar runningSum = function(nums) {\\n    let ans = new Array(nums.length)\\n    ans[0] = nums[0]\\n    for (let i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        ans[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            ans[i] = ans[i-1] + nums[i]\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    ans[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i];\\n    return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            ans[i] = ans[i-1] + nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535362,
                "title": "100-fast-c-lang",
                "content": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=0;i<numsSize;i++)\\n    {\\n       sum=sum+nums[i];\\n        nums[i]=sum;\\n    }\\n    return nums;\\n}\\n```\\ndo upvote if you understand the soluntion.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int sum=0;\\n    *returnSize = numsSize; //size for the new array to be returned\\n    \\nfor(int i=0;i<numsSize;i++)\\n    {\\n       sum=sum+nums[i];\\n        nums[i]=sum;\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744442,
                "title": "java-runtime-0ms-faster-than-100-memory-usage-less-than-97-1",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/18ee87a3-e5b1-4980-83ea-dddd559df842_1666751086.5643325.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691189,
                "title": "java-c-python-prefix-sum",
                "content": "# Explanation\\nLet `B[i] = A[0] + A[1] + .. + A[i]`\\n`B[i] = B[i-1] + A[i]`\\n<br>\\n\\n# Complexity\\nTime `O(N)`\\nSpace `O(N)`\\nSpace `O(1)` if changing the input, like in Java.\\n\\n**Java:**\\n```java\\n    public int[] runningSum(int[] A) {\\n        for (int i = 1; i < A.length; ++i)\\n            A[i] += A[i - 1];\\n        return A;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> runningSum(vector<int> A) {\\n        partial_sum(begin(A), end(A), begin(A));\\n        return A;\\n    }\\n```\\n\\n**Python3:**\\n1 line, return a list\\n```py\\n    def runningSum(self, A):\\n        return list(itertools.accumulate(A))\\n```\\n0 line, return an iterator\\n```py\\n    runningSum = accumulate\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] runningSum(int[] A) {\\n        for (int i = 1; i < A.length; ++i)\\n            A[i] += A[i - 1];\\n        return A;\\n    }\\n```\n```cpp\\n    vector<int> runningSum(vector<int> A) {\\n        partial_sum(begin(A), end(A), begin(A));\\n        return A;\\n    }\\n```\n```py\\n    def runningSum(self, A):\\n        return list(itertools.accumulate(A))\\n```\n```py\\n    runningSum = accumulate\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 687012,
                "title": "java-stream-solution-in-one-line",
                "content": "Runtime: **3 ms**, faster than 100.00% of Java online submissions for Running Sum of 1d Array.\\nMemory Usage: **39.9 MB**, less than 50.00% of Java online submissions for Running Sum of 1d Array.\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        return IntStream.range(0,nums.length).map(i->i==0?nums[i]:(nums[i]+=nums[i-1])).toArray();    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        return IntStream.range(0,nums.length).map(i->i==0?nums[i]:(nums[i]+=nums[i-1])).toArray();    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954633,
                "title": "typescript-solution-easy-map",
                "content": "# Code\\n```\\nfunction runningSum(nums: number[]): number[] {\\n     let result: number = 0;\\n     return nums.map(item => result += item);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction runningSum(nums: number[]): number[] {\\n     let result: number = 0;\\n     return nums.map(item => result += item);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2306599,
                "title": "easy-to-understand-python-solution",
                "content": "#### **Final Code:**\\nTime Complexity: **O(n)**\\n```\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        result = []\\n        current_sum = 0\\n        for i in range(0, len(nums)):\\n            result.append(current_sum + nums[i])\\n            current_sum = result[i]\\n        return result\\n```\\n\\n#### **Steps:**\\n* **Step1:**  \\nCreate a new array which can be returned as our result:\\n```result = [ ]  # empty array```\\n\\n* **Step2:**\\nNow let\\'s keep track of current sum:\\n```current_sum = 0  # It\\'s zero for now```\\n\\n* **Step3:**\\nFor every element we encounter in \\'nums\\', add it with current sum and append it to result, then change the value of current_sum to the current element in result\\n(Because we want to add it in the next iteration):\\n```\\n\\tfor i in range(0, len(nums)):\\n\\t\\tresult.append(current_sum + nums[i])\\n\\t\\tcurrent_sum = result[i]\\n```\\n\\n* **Step4:**\\nFinally return the result:\\n```return result```\\n\\n\\n**I hope that you\\'ve found this useful.**\\n**If so, consider leaving an upvote \\uD83D\\uDE01**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        result = []\\n        current_sum = 0\\n        for i in range(0, len(nums)):\\n            result.append(current_sum + nums[i])\\n            current_sum = result[i]\\n        return result\\n```\n```result = [ ]  # empty array```\n```current_sum = 0  # It\\'s zero for now```\n```\\n\\tfor i in range(0, len(nums)):\\n\\t\\tresult.append(current_sum + nums[i])\\n\\t\\tcurrent_sum = result[i]\\n```\n```return result```",
                "codeTag": "Java"
            },
            {
                "id": 2096129,
                "title": "python-almost-one-line-solution-faster-than-97-54",
                "content": "Any one need explanation please ask,\\nHere we also learning how can we use assignment inside comprehension \\uD83D\\uDE01 using `:`\\n\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        s = 0\\n        return [s:=s+v for _, v in enumerate(nums)]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/56798120-f222-4969-8fe1-4ae19e3ed185_1654046926.4836757.png)\\n\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        s = 0\\n        return [s:=s+v for _, v in enumerate(nums)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688524,
                "title": "ruby",
                "content": "```\\ndef running_sum(nums)\\n  total = 0\\n  nums.map { |number| total += number }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef running_sum(nums)\\n  total = 0\\n  nums.map { |number| total += number }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3063821,
                "title": "java-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907545,
                "title": "c-simple-solution",
                "content": "Fastest possible c# solution\\n```\\npublic int[] RunningSum(int[] nums) \\n{\\n\\tfor (int i = 1; i < nums.Length; ++i) \\n\\t{\\n\\t\\tnums[i] += nums[i - 1]; \\n\\t}\\n\\treturn nums;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] RunningSum(int[] nums) \\n{\\n\\tfor (int i = 1; i < nums.Length; ++i) \\n\\t{\\n\\t\\tnums[i] += nums[i - 1]; \\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330765,
                "title": "golang-faster-than-100-submissions-o-n",
                "content": "```\\nfunc runningSum(nums []int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t    nums[i] = nums[i] + nums[i-1]\\n\\t}\\n\\treturn nums\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc runningSum(nums []int) []int {\\n    for i := 1; i < len(nums); i++ {\\n\\t    nums[i] = nums[i] + nums[i-1]\\n\\t}\\n\\treturn nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265815,
                "title": "c-faster-than-86-46-using-system-linq",
                "content": "![image](https://assets.leetcode.com/users/images/1fe65e59-608a-493e-b603-b589ad8ac6e6_1623446237.0302718.png)\\n\\n```\\nusing System.Linq;\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n       int c = 0;\\n       return nums.Select(n => c += n).ToArray();\\n    }\\n}\\n````",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\nusing System.Linq;\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n       int c = 0;\\n       return nums.Select(n => c += n).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689727,
                "title": "rust-0ms-2-1mb",
                "content": "```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut pre_sum = 0;\\n        nums.into_iter().map(|num| {\\n            pre_sum += num;\\n            pre_sum\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut pre_sum = 0;\\n        nums.into_iter().map(|num| {\\n            pre_sum += num;\\n            pre_sum\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 842159,
                "title": "js-javascript-one-line-solution-with-explanation-and-trace",
                "content": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n/*\\n    The current array index is increamented by the accumlator which is the new value of arr[i]\\n    \\n    Example trace:\\n    \\n    input:\\n    [1,2,3,4]\\n    \\n        acc i  arr                return value\\n        0   0  1,2,3,4            0 + 1 = 1\\n        1   1  1,2,3,4            1 + 2 = 3\\n        3   2  1,3,3,4            3 + 3 = 6\\nend  => 6   3  1,3,6,4            6 + 4 = 10\\n        10  4  1,3,6,10\\n    \\n*/\\n    nums.reduce((acc, _, i, arr) => arr[i] += acc )\\n    return nums\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n/*\\n    The current array index is increamented by the accumlator which is the new value of arr[i]\\n    \\n    Example trace:\\n    \\n    input:\\n    [1,2,3,4]\\n    \\n        acc i  arr                return value\\n        0   0  1,2,3,4            0 + 1 = 1\\n        1   1  1,2,3,4            1 + 2 = 3\\n        3   2  1,3,3,4            3 + 3 = 6\\nend  => 6   3  1,3,6,4            6 + 4 = 10\\n        10  4  1,3,6,10\\n    \\n*/\\n    nums.reduce((acc, _, i, arr) => arr[i] += acc )\\n    return nums\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686302,
                "title": "simple-swift-solution",
                "content": "```\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\n    var arr : [Int] = []\\n    var sum = 0\\n    for n in nums{\\n        sum += n\\n        arr.append(sum)\\n    }\\n    return arr\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\n    var arr : [Int] = []\\n    var sum = 0\\n    for n in nums{\\n        sum += n\\n        arr.append(sum)\\n    }\\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680759,
                "title": "c-solution",
                "content": "Tip: never use ```nums[i] = nums[i] + nums[i-1];``` in place of ```nums[i] += nums[i-1];```\\n\\nThe time and space complexity increases in the former case.\\n\\nThis code beats 40% in time & 100% in space complexity\\n\\n*Please upvote to motivate me to write more solutions*\\n\\n# Code [C]\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    for (int i=1; i<numsSize; i++) {\\n        nums[i] += nums[i-1];\\n    }\\n    return nums;\\n}\\n```\\n\\n## Visit my GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C"
                ],
                "code": "```nums[i] = nums[i] + nums[i-1];```\n```nums[i] += nums[i-1];```\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    for (int i=1; i<numsSize; i++) {\\n        nums[i] += nums[i-1];\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195474,
                "title": "big-brain-solution",
                "content": "```\\nvar runningSum = function(nums) {\\n    let runningTotal = 0;\\nreturn nums.map(num => runningTotal += num);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar runningSum = function(nums) {\\n    let runningTotal = 0;\\nreturn nums.map(num => runningTotal += num);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189120,
                "title": "python-oneliner-using-accumulate-explained",
                "content": "In python we can use functionality of language and directly use `accumulate` function, which will give you iterator, which we need to transform to list. And this is all we need to do here. \\n\\n#### Complexity\\nTime and space complexity is `O(n)`, where `n` is the length of `nums`.\\n\\n#### Code\\n```\\nclass Solution:\\n    def runningSum(self, nums):\\n        return list(accumulate(nums))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums):\\n        return list(accumulate(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982633,
                "title": "coderaky-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++)\\n            nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n};\\n```\\nhttps://github.com/coderaky/leetcoder \\uD83D\\uDE4C",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++)\\n            nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755070,
                "title": "my-python-solution-runtime-93-07-memory-100",
                "content": "Hey!\\n\\nNothing special and not the most elegant approach for sure. I wanted to leave it here anyways. Sometimes I find it hard to understand one-line sophisticated solutions, so I think maybe someone can find this helpful:\\n\\n```\\nclass Solution(object):\\n    def runningSum(self, nums):     \\n        n = len(nums)\\n        result = list()\\n        \\n        if n == 0: return result\\n\\t\\t\\n        currentSum = 0\\n        for i in range(n):\\n            currentSum += nums[i]\\n            result.append(currentSum)\\n        \\n        return result\\n```\\n\\n*Runtime: 24 ms, faster than 93.07% of Python online submissions for Running Sum of 1d Array.\\nMemory Usage: 12.8 MB, less than 100.00% of Python online submissions for Running Sum of 1d Array.*",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def runningSum(self, nums):     \\n        n = len(nums)\\n        result = list()\\n        \\n        if n == 0: return result\\n\\t\\t\\n        currentSum = 0\\n        for i in range(n):\\n            currentSum += nums[i]\\n            result.append(currentSum)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686348,
                "title": "c-simple-o-n-time-o-1-space-solution",
                "content": "```csharp\\npublic int[] RunningSum(int[] nums) \\n{\\n\\tint sum = 0;\\n\\tint[] result= new int[nums.Length];\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tsum += nums[i];\\n\\t\\tresult[i] = sum;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] RunningSum(int[] nums) \\n{\\n\\tint sum = 0;\\n\\tint[] result= new int[nums.Length];\\n\\tfor(int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tsum += nums[i];\\n\\t\\tresult[i] = sum;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300739,
                "title": "go-o-n-memory-o-1-space",
                "content": "```\\nfunc runningSum(nums []int) []int {\\n    for i:= 1; i< len(nums); i++ {\\n        nums[i] += nums[i-1]\\n    }\\n    return nums\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc runningSum(nums []int) []int {\\n    for i:= 1; i< len(nums); i++ {\\n        nums[i] += nums[i-1]\\n    }\\n    return nums\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 712165,
                "title": "python-less-than-100-memory-usage",
                "content": "```\\n\\t\\tlst = []\\n        num = 1\\n        while len(lst) != len(nums):\\n            lst.append(sum((nums[0:num])))\\n            num += 1\\n        return lst\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tlst = []\\n        num = 1\\n        while len(lst) != len(nums):\\n            lst.append(sum((nums[0:num])))\\n            num += 1\\n        return lst\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2868456,
                "title": "rust-two-fast-solutions",
                "content": "# **Hey,Bro! This is my quick solutions**\\nFIRST\\n\\n\\n    impl Solution {\\n        pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n            let (mut result,mut array) = (0,Vec::with_capacity(nums.len()));\\n            for  i in 0..=nums.len()-1 {\\n                result = result + nums[i];\\n                array.push(result);\\n            }\\n            array\\n        }\\n    }\\n\\n\\n\\nSECOND\\n\\n        impl Solution {\\n\\n            pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n\\n            let mut sum = 0;\\n\\n            nums.into_iter().map(|x| {sum += x; sum}).collect::<Vec<i32>>()\\n\\n            }\\n        }\\n\\n# **If you like it ,please, push arrow to lift up solution to the top ,thanks!**",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "# **Hey,Bro! This is my quick solutions**\\nFIRST\\n\\n\\n    impl Solution {\\n        pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n            let (mut result,mut array) = (0,Vec::with_capacity(nums.len()));\\n            for  i in 0..=nums.len()-1 {\\n                result = result + nums[i];\\n                array.push(result);\\n            }\\n            array\\n        }\\n    }\\n\\n\\n\\nSECOND\\n\\n        impl Solution {\\n\\n            pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n\\n            let mut sum = 0;\\n\\n            nums.into_iter().map(|x| {sum += x; sum}).collect::<Vec<i32>>()\\n\\n            }\\n        }\\n\\n# **If you like it ,please, push arrow to lift up solution to the top ,thanks!**",
                "codeTag": "Unknown"
            },
            {
                "id": 2709615,
                "title": "easy-to-understand-c-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1];\\n        return nums;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1];\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2399466,
                "title": "2-lines-of-code-100-fast-simple-and-easy",
                "content": "**Running Sum of 1d Array Solution :**\\n\\n**In C++ :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++) nums[i] += nums[i-1];\\n\\t    return nums;\\n    }\\n};\\n```\\n\\n**In Java :**\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1; i<nums.length; i++) nums[i] += nums[i-1];\\n\\t    return nums;\\n    }\\n}\\n```\\n\\n**Runtime: 0 ms**, faster than **100.00%** of Java online submissions for Running Sum of 1d Array.\\nMemory Usage: 43.3 MB, less than 48.96% of Java online submissions for Running Sum of 1d Array.\\n\\n\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++) nums[i] += nums[i-1];\\n\\t    return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1; i<nums.length; i++) nums[i] += nums[i-1];\\n\\t    return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096323,
                "title": "python-one-liner-with-walrus-operator",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return [tot := nums[0]] + [tot := i+tot for i in nums[1:]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return [tot := nums[0]] + [tot := i+tot for i in nums[1:]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132235,
                "title": "php-solution",
                "content": "```\\n// Runtime: 4 ms, faster than 97.05% of PHP online submissions for Running Sum of 1d Array.\\n// Memory Usage: 15.8 MB, less than 87.76% of PHP online submissions for Running Sum of 1d Array.\\nfunction runningSum($nums) {\\n    $current[0] = $nums[0];\\n    for($i = 1; $i < sizeof($nums); $i++) {\\n        $current[$i] = $nums[$i] + $current[$i-1];\\n    }\\n\\n    return $current;\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 97.05% of PHP online submissions for Running Sum of 1d Array.\\n// Memory Usage: 15.8 MB, less than 87.76% of PHP online submissions for Running Sum of 1d Array.\\nfunction runningSum($nums) {\\n    $current[0] = $nums[0];\\n    for($i = 1; $i < sizeof($nums); $i++) {\\n        $current[$i] = $nums[$i] + $current[$i-1];\\n    }\\n\\n    return $current;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681627,
                "title": "java-easy-solution-using-for-loop",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n     int sum = 0;\\n     for(int i = 0; i < nums.length; i ++) {\\n         sum += nums[i];\\n         nums[i] = sum; \\n     } \\n     return nums;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n     int sum = 0;\\n     for(int i = 0; i < nums.length; i ++) {\\n         sum += nums[i];\\n         nums[i] = sum; \\n     } \\n     return nums;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187158,
                "title": "c-java-c-c-js-ts-scala-kotlin-php-rust-go-swift-ruby-python3-python-easy-solutions",
                "content": "The running sum of numbers upto ith index is the algebric sum of all elements from index 0 to index i inclusive. Insetead of recalculating the sum, we can use the stored value calculated previously.\\n1.\\n```C++  []\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n      for(int i =1; i< nums.size(); i++)\\n          nums[i] += nums[i-1];\\n      return nums;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n      for(int i=1;i<nums.length;i++) \\n          nums[i]+=nums[i-1];\\n      return nums;\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n      for(int i=1;i<nums.Length;i++) \\n          nums[i]+=nums[i-1];\\n      return nums;\\n    }\\n}\\n```\\n```C []\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for(int i=1;i<numsSize;i++) \\n        nums[i]+=nums[i-1];\\n\\t*returnSize = numsSize;\\n    return nums;\\n}\\n```\\n2.\\n```javascript []\\nvar runningSum = function(nums) {\\n  for(var i =1; i< nums.length; i++)\\n      nums[i] += nums[i-1];\\n  return nums;\\n};\\n```\\n```TypeScript []\\nfunction runningSum(nums: number[]): number[] {\\n  for(var i =1; i< nums.length; i++)\\n      nums[i] += nums[i-1];\\n  return nums;\\n};\\n```\\n```Scala []\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = {\\n        for(i <- 1 until nums.length)\\n            nums(i)+=nums(i-1);\\n        return nums;\\n    }\\n}\\n```\\n```Kotlin []\\nclass Solution {\\n    fun runningSum(nums: IntArray): IntArray {\\n        for (i in 1 until nums.size)\\n            nums[i] +=nums[i-1]\\n        return nums\\n    }\\n}\\n```\\n3.\\n```PHP []\\nclass Solution {\\n    function runningSum($nums) {\\n        for($i = 1; $i < sizeof($nums); $i++)\\n            $nums[$i] += $nums[$i-1];\\n        return $nums;\\n    }\\n}\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        for i in 1..nums.len() {\\n            nums[i] += nums[i-1];\\n        }\\n        nums\\n    }\\n}\\n```\\n```Go []\\nfunc runningSum(nums []int) []int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[i] += nums[i-1]\\n\\t}\\n\\treturn nums\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        curr=0\\n        for i in range(len(nums)):\\n            nums[i]+=curr\\n            curr=nums[i]\\n        return nums\\n```\\n4.\\n```python []\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        curr=0\\n        for i in range(len(nums)):\\n            nums[i]+=curr\\n            curr=nums[i]\\n        return nums\\n```\\n```Swift []\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        var res = nums\\n        for i in 1..<nums.count {\\n            res[i] += res[i-1]\\n        }\\n        return res\\n    }\\n}\\n```\\n```Ruby []\\ndef running_sum(nums)\\n    return_array=[]\\n    counter=0\\n    for i in 0...nums.length\\n        return_array<<counter+=nums[i] \\n    end\\n    return return_array\\nend\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```C++  []\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n      for(int i =1; i< nums.size(); i++)\\n          nums[i] += nums[i-1];\\n      return nums;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n      for(int i=1;i<nums.length;i++) \\n          nums[i]+=nums[i-1];\\n      return nums;\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n      for(int i=1;i<nums.Length;i++) \\n          nums[i]+=nums[i-1];\\n      return nums;\\n    }\\n}\\n```\n```C []\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for(int i=1;i<numsSize;i++) \\n        nums[i]+=nums[i-1];\\n\\t*returnSize = numsSize;\\n    return nums;\\n}\\n```\n```javascript []\\nvar runningSum = function(nums) {\\n  for(var i =1; i< nums.length; i++)\\n      nums[i] += nums[i-1];\\n  return nums;\\n};\\n```\n```TypeScript []\\nfunction runningSum(nums: number[]): number[] {\\n  for(var i =1; i< nums.length; i++)\\n      nums[i] += nums[i-1];\\n  return nums;\\n};\\n```\n```Scala []\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = {\\n        for(i <- 1 until nums.length)\\n            nums(i)+=nums(i-1);\\n        return nums;\\n    }\\n}\\n```\n```Kotlin []\\nclass Solution {\\n    fun runningSum(nums: IntArray): IntArray {\\n        for (i in 1 until nums.size)\\n            nums[i] +=nums[i-1]\\n        return nums\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\n    function runningSum($nums) {\\n        for($i = 1; $i < sizeof($nums); $i++)\\n            $nums[$i] += $nums[$i-1];\\n        return $nums;\\n    }\\n}\\n```\n```Rust []\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        for i in 1..nums.len() {\\n            nums[i] += nums[i-1];\\n        }\\n        nums\\n    }\\n}\\n```\n```Go []\\nfunc runningSum(nums []int) []int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[i] += nums[i-1]\\n\\t}\\n\\treturn nums\\n}\\n```\n```python3 []\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        curr=0\\n        for i in range(len(nums)):\\n            nums[i]+=curr\\n            curr=nums[i]\\n        return nums\\n```\n```python []\\nclass Solution(object):\\n    def runningSum(self, nums):\\n        curr=0\\n        for i in range(len(nums)):\\n            nums[i]+=curr\\n            curr=nums[i]\\n        return nums\\n```\n```Swift []\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        var res = nums\\n        for i in 1..<nums.count {\\n            res[i] += res[i-1]\\n        }\\n        return res\\n    }\\n}\\n```\n```Ruby []\\ndef running_sum(nums)\\n    return_array=[]\\n    counter=0\\n    for i in 0...nums.length\\n        return_array<<counter+=nums[i] \\n    end\\n    return return_array\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805438,
                "title": "in-c",
                "content": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int i;\\n    int* result = (int*)malloc(numsSize*sizeof(int)); \\n    result[i]=0;\\n    result[i] = result[i]+nums[i];\\n    for(i=1;i<numsSize;i++){\\n        result[i] = result[i-1]+nums[i];\\n    }\\n\\t*returnSize = numsSize;\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int i;\\n    int* result = (int*)malloc(numsSize*sizeof(int)); \\n    result[i]=0;\\n    result[i] = result[i]+nums[i];\\n    for(i=1;i<numsSize;i++){\\n        result[i] = result[i-1]+nums[i];\\n    }\\n\\t*returnSize = numsSize;\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3261883,
                "title": "array-in-place-solution-o-1-extra-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    for(let i=1; i<nums.length; i++){\\n        nums[i] = nums[i-1] + nums[i];\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    for(let i=1; i<nums.length; i++){\\n        nums[i] = nums[i-1] + nums[i];\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2796847,
                "title": "java-3-lines-100-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734958,
                "title": "solution-in-java-simple-w-explanation-1-ms",
                "content": "Start from the second element, keep adding the previous element in the array while going forward.\\n\\n* Why do we start from second element (`nums[1]`) and not first element (`nums[0]`)?\\n-> This is because the first element will always be the same because it doesn\\'t have any previous element to add it to.\\n* Why do we keep adding the previous element?\\n-> We can have a sum count before we start the loop and keep adding the last element and put it in the sum, then add it to the current element and put it there. But instead we can just count the sum of previous element and current element and put it, then move ahead and we will have the solution.\\n\\t* Example: [1,2,3,4]\\n\\t\\t* Sum method:\\n\\t\\t\\t* sum = 0\\n\\t\\t\\t* At each iteration, sum = 1, 3, 6, 10 and we keep putting these elements in the list\\n\\t\\t* Running sum method\\n\\t\\t\\t* given = [1,2,3,4]\\n\\t\\t\\t* just keep adding the last element and keep putting it, [1,3,6,10] but we do not need an extra sum count here.\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098250,
                "title": "kotlin-one-liner",
                "content": "```\\n    fun runningSum(nums: IntArray): IntArray =\\n       nums.also { (1..nums.lastIndex).forEach { nums[it] += nums[it-1] } } \\n```\\nP.S. There is a built-in function `runningReduce` but leetcode doesn\\'t support it sadly.",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun runningSum(nums: IntArray): IntArray =\\n       nums.also { (1..nums.lastIndex).forEach { nums[it] += nums[it-1] } } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096299,
                "title": "c-2-approach-using-prefix-sum",
                "content": "**Solution 1 :**  Using extra memory for storing result\\nThis approach can be used when input array is read-only.\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int length = nums.size();\\n        vector<int> res(length);\\n        res[0] = nums[0];\\n        for(int i = 1; i < length; i++)\\n            res[i] = nums[i] + res[i - 1];\\n        return res;\\n    }\\n};\\n```\\nTC : O(n)\\nSC : O(n)\\n\\n**Solution 2** : Using input array to store result\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n            nums[i] = nums[i] + nums[i - 1];\\n        return nums;\\n    }\\n};\\n```\\nTC : O(n)\\nSC : O(1)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int length = nums.size();\\n        vector<int> res(length);\\n        res[0] = nums[0];\\n        for(int i = 1; i < length; i++)\\n            res[i] = nums[i] + res[i - 1];\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n            nums[i] = nums[i] + nums[i - 1];\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686317,
                "title": "java-python-3-3-1-liner-accumulate",
                "content": "\\n```java\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++)\\n            nums[i] += nums[i - 1];\\n        return nums;\\n    }\\n```\\n```python\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return list(itertools.accumulate(nums))\\n```\\nBTW, not only \\n```\\n        return [*itertools.accumulate(nums)]\\n```\\nbut also\\n```\\n        return itertools.accumulate(nums) # credit to @todor91\\n```\\nand \\n```\\n        return accumulate(nums) # credit to @todor91\\n```\\naccepted.",
                "solutionTags": [],
                "code": "```java\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++)\\n            nums[i] += nums[i - 1];\\n        return nums;\\n    }\\n```\n```python\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        return list(itertools.accumulate(nums))\\n```\n```\\n        return [*itertools.accumulate(nums)]\\n```\n```\\n        return itertools.accumulate(nums) # credit to @todor91\\n```\n```\\n        return accumulate(nums) # credit to @todor91\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3396738,
                "title": "simple-solution-by-java-in-runtime-3-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int [] sol = new int[nums.length];\\n\\n        for (int i = nums.length-1 ; i >= 0 ; i--) {\\n            for (int j = i; j >= 0 ; j--) {\\n                sol[i] +=nums[j];\\n            }\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int [] sol = new int[nums.length];\\n\\n        for (int i = nums.length-1 ; i >= 0 ; i--) {\\n            for (int j = i; j >= 0 ; j--) {\\n                sol[i] +=nums[j];\\n            }\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389843,
                "title": "java-solution-with-super-logic",
                "content": "\\n# Java Solution with Super Logic\\n```\\nclass Solution {\\n    public int[] runningSum(int nums[]){\\n        for(int i=0;i<nums.length-1;i++){\\n            nums[i+1]=nums[i]+nums[i+1];\\n        }\\n        return nums;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int nums[]){\\n        for(int i=0;i<nums.length-1;i++){\\n            nums[i+1]=nums[i]+nums[i+1];\\n        }\\n        return nums;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117107,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        nums[i]+=nums[i-1];\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086350,
                "title": "c-easy-3-line",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) \\n    {\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) \\n    {\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023839,
                "title": "simple-python-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        # The variable that will have the running sum\\n        tot = 0\\n        # The array that will hold the running su,\\n        ans = []\\n        # For loop\\n        for ele in nums:\\n            # Adding the element\\n            tot += ele\\n            # Appending this running sum to ans\\n            ans.append(tot)\\n        # Return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        # The variable that will have the running sum\\n        tot = 0\\n        # The array that will hold the running su,\\n        ans = []\\n        # For loop\\n        for ele in nums:\\n            # Adding the element\\n            tot += ele\\n            # Appending this running sum to ans\\n            ans.append(tot)\\n        # Return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618412,
                "title": "brute-force-optimize-c-stl-solution",
                "content": "**Approach: 1** \\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Condition:**  *If we not allowed to change the given array.*\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n**Solution : 01**\\n\\n\\n* Using **Brute force approach**\\n* We simply took a counter (sum) to store the sum till the current index.\\n* Run a loop & in every iteration add the current value to sum.\\n* Push the value(sum) to ans vector.\\n* Return the ans vector.\\n\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Solution:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int>ans;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size();i++)\\n        {\\n            sum = sum + nums[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n**Analysis:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Time Complexity** : `O(n) ` -----> As we are iterating through all the elements of the array.\\n**Space Complexity** : `O(n)`  ----> Where n is the size of the Vector we created.\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Approach: 2**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\nIf we are allowed to change the given array we can solve this problem in place(i.e without using extra space.)\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\nSolution: \\n\\n------------------------------------------------------------------------------------------------------------------------------\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 1; i < n;i++)\\n        {\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n**Analysis:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Time Complexity** : `O(n) ` -----> As we are iterating through all the elements of the array.\\n**Space Complexity** : `O(1)`  ----> In place solution (i.e Without using the extra space).\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Approach: 3**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\nBy using the **C++ STL partial_sum**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n**solution:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        partial_sum(begin(nums),end(nums),begin(nums));\\n        return nums;\\n    }\\n};\\n```\\n\\n\\n**Analysis:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Time Complexity** : `O(n) ` -----> As we are iterating through all the elements of the array.\\n**Space Complexity** : `O(1)`  ----> In place solution (i.e Without using the extra space).\\n\\n------------------------------------------------------------------------------------------------------------------------------\\nIf this solution helps you then please` Upvote.`\\n\\n*Thank You!!!*\\n\\nIf any doubt/ mistake feel free to comment.\\n\\n**Keep learning, Keep Growing !!!**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int>ans;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size();i++)\\n        {\\n            sum = sum + nums[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 1; i < n;i++)\\n        {\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        partial_sum(begin(nums),end(nums),begin(nums));\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329597,
                "title": "python-o-n-simple-solution-easy-and-fast",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n        return nums\\n```\\nUPVOTE if you like ^_^",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189009,
                "title": "running-sum-of-1d-array-js-python-java-c-easy-prefix-sum-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWhile this is not a terribly challenging problem, it\\'s a good introduction to the concept of a **prefix sum array**. Prefix sum arrays have many uses in more complex algorithms and can sometimes help reduce the time complexity of a advanced solution by an order of magnitude.\\n\\nIn a prefix sum array, we will create a duplicate array which contains the running sum of the elements **0** to **i** of our original array (**nums**) for each index **i** of our prefix sum array (**ans**). _(**Note**: We can lower the **space complexity** by using an **in-place** approach with **nums** directly and mutating it into its own prefix sum array, if there is no compelling reason to avoid modifying a function argument.)_\\n\\nSince we\\'ll need to build on a previous running total, we should start our iteration at **i = 1** and copy over the first element from **nums** to **ans**. Then we just iterate through **nums** and add each element (**nums[i]**) to the previous running total (**ans[i-1]**) to create the new running total (**ans[i]**).\\n\\nWhen we\\'re done, we can **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of nums_\\n - _**Space Complexity: O(N)** for our running sum array_\\n    - _or **O(1)** with an in-place approach_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar runningSum = function(nums) {\\n    let ans = new Array(nums.length)\\n    ans[0] = nums[0]\\n    for (let i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        ans[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            ans[i] = ans[i-1] + nums[i]\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    ans[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i];\\n    return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            ans[i] = ans[i-1] + nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar runningSum = function(nums) {\\n    let ans = new Array(nums.length)\\n    ans[0] = nums[0]\\n    for (let i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        ans[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            ans[i] = ans[i-1] + nums[i]\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    ans[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++)\\n        ans[i] = ans[i-1] + nums[i];\\n    return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            ans[i] = ans[i-1] + nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999294,
                "title": "javascript-o-n-time-o-1-space",
                "content": "```\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for (let i in nums) {\\n        sum += nums[i]        \\n        nums[i] = sum\\n    }\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for (let i in nums) {\\n        sum += nums[i]        \\n        nums[i] = sum\\n    }\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927456,
                "title": "kotlin-map",
                "content": "\\nhttps://discuss.kotlinlang.org/t/is-there-a-way-to-accumulate-and-map-in-the-same-operation/1492\\n```\\nfun runningSum(nums: IntArray): IntArray {\\n    var sum = 0\\n    return nums.map(){sum += it; sum}.toIntArray()\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun runningSum(nums: IntArray): IntArray {\\n    var sum = 0\\n    return nums.map(){sum += it; sum}.toIntArray()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783332,
                "title": "easy-c-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            nums[i] += nums[i - 1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 687833,
                "title": "one-line-swift-solution",
                "content": "One-line Swift solution\\n```\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        return nums.reduce(into: (Int(0), [Int]()), { $0.0 += $1; $0.1.append($0.0) }).1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        return nums.reduce(into: (Int(0), [Int]()), { $0.0 += $1; $0.1.append($0.0) }).1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925525,
                "title": "java-c-c-rust-solutions-with-easy-explanation-0-ms-runtime",
                "content": "# Approach\\nTo calculate the running sum of the given array nums, we can iterate through the array and update each element with the sum of all elements up to that point. This way, each element of the modified array will represent the running sum from the beginning of the original array.\\n\\nIn this solution we start iterating with 1st index, because running sum of 0th is equal to nothing else but itself. So, it doesn\\'t need change.\\n\\n# Complexity\\n\\n## Java solution complexity\\nGot 0 ms runtime in Java\\n![image.png](https://assets.leetcode.com/users/images/01599a48-d492-4472-9c75-db7754dcd351_1692341026.9505627.png)\\n\\n\\n## C# solution complexity\\n![image.png](https://assets.leetcode.com/users/images/fe32dbfd-ffcc-4bfc-9891-e64b8316aac9_1692339570.3382912.png)\\n\\n## Rust solution complexity\\n![image.png](https://assets.leetcode.com/users/images/45555df4-691d-43ed-9c35-023fa30352a5_1692340401.1896594.png)\\n\\n\\n# Code\\n```C# []\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n\\n        return nums;\\n    }\\n}\\n```\\n```Java []\\npublic class Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for (int i = 1; i < nums.size(); i++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        // Create a mutable copy of the input vector\\n        let mut nums = nums;\\n        \\n        for i in 1..nums.len() {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        nums\\n    }\\n}\\n```\\n\\n## If you found my solution helpful, please consider giving it an upvote. Happy coding!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "Rust"
                ],
                "code": "```C# []\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n\\n        return nums;\\n    }\\n}\\n```\n```Java []\\npublic class Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for (int i = 1; i < nums.size(); i++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\n```Rust []\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        // Create a mutable copy of the input vector\\n        let mut nums = nums;\\n        \\n        for i in 1..nums.len() {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        \\n        nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676873,
                "title": "c-easy-and-100-fast-solution-0ms-beginner-friendly",
                "content": "```\\n            int sum = 0;\\n            for(int i = 0;i<nums.size();i++){\\n                    sum = sum + nums[i];\\n                    nums[i] = sum;\\n            }\\n            return nums;\\n        \\n```",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n            int sum = 0;\\n            for(int i = 0;i<nums.size();i++){\\n                    sum = sum + nums[i];\\n                    nums[i] = sum;\\n            }\\n            return nums;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096062,
                "title": "swift-2-lines-of-code",
                "content": "```\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        return nums.reduce(into: []) { newArr, num in\\n            newArr.append(num + (newArr.last ?? 0))\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        return nums.reduce(into: []) { newArr, num in\\n            newArr.append(num + (newArr.last ?? 0))\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002353,
                "title": "kotlin-solution-faster-than-94-92",
                "content": "```\\nclass Solution {\\n    \\n    fun runningSum(nums: IntArray): IntArray {\\n        \\n        // if array has only one element\\n        if(nums.size == 1) {\\n            return nums\\n        }\\n        \\n        \\n        for (i in 1..nums.size-1) {\\n            nums[i] += nums[i-1]\\n        }\\n        \\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun runningSum(nums: IntArray): IntArray {\\n        \\n        // if array has only one element\\n        if(nums.size == 1) {\\n            return nums\\n        }\\n        \\n        \\n        for (i in 1..nums.size-1) {\\n            nums[i] += nums[i-1]\\n        }\\n        \\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959773,
                "title": "3-java-solutions",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        /*Solution 1*/\\n     // int n=nums.length;\\n     // int[] runningSum=new int[n];\\n     // for(int i=0;i<n;i++) {\\n     // for(int j=0;j<=i;j++) {\\n     // runningSum[i]+=nums[j];\\n     // }\\n     // }\\n     // return runningSum;   \\n        \\n     /*Solution 2*/\\n        // for(int i=1;i<nums.length;i++){\\n        //     nums[i]+=nums[i-1];\\n        // }\\n        // return nums;\\n        \\n        /*Solution 3*/\\n        int[] b=new int[nums.length];\\n        int prev=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            b[i]=prev+nums[i];\\n            prev=b[i];\\n        }\\n        b[0]=nums[0];\\n         return b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        /*Solution 1*/\\n     // int n=nums.length;\\n     // int[] runningSum=new int[n];\\n     // for(int i=0;i<n;i++) {\\n     // for(int j=0;j<=i;j++) {\\n     // runningSum[i]+=nums[j];\\n     // }\\n     // }\\n     // return runningSum;   \\n        \\n     /*Solution 2*/\\n        // for(int i=1;i<nums.length;i++){\\n        //     nums[i]+=nums[i-1];\\n        // }\\n        // return nums;\\n        \\n        /*Solution 3*/\\n        int[] b=new int[nums.length];\\n        int prev=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            b[i]=prev+nums[i];\\n            prev=b[i];\\n        }\\n        b[0]=nums[0];\\n         return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797688,
                "title": "simple-python-approach",
                "content": "Simple python approach \\n\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum = 0\\n        for i in range(len(nums)):\\n            sum = sum + nums[i]\\n            nums[i] = sum\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum = 0\\n        for i in range(len(nums)):\\n            sum = sum + nums[i]\\n            nums[i] = sum\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708655,
                "title": "scala-scanleft",
                "content": "```\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = {\\n        nums.scanLeft(0)(_ + _).drop(1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = {\\n        nums.scanLeft(0)(_ + _).drop(1)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 691891,
                "title": "javascript-easy-to-understand-inplace-or-not",
                "content": "The strategy is pretty straight forward. We could maintain a variable as the prefix sum and update the final array with it.\\n\\nHere\\'s a strategy to return a new array:\\n\\n```js\\nconst runningSum = nums => {\\n  const LEN = nums.length;\\n  const ret = new Int32Array(LEN);\\n  ret[0] = nums[0];\\n  for (let i = 1; i < LEN; ++i) {\\n    ret[i] = ret[i - 1] + nums[i];\\n  }\\n  return ret;\\n};\\n```\\n\\nAnd here\\'s an inplace strategy:\\n\\n```js\\nconst runningSum = nums => {\\n  for (let i = 1; i < nums.length; ++i) {\\n    nums[i] += nums[i - 1];\\n  }\\n  return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst runningSum = nums => {\\n  const LEN = nums.length;\\n  const ret = new Int32Array(LEN);\\n  ret[0] = nums[0];\\n  for (let i = 1; i < LEN; ++i) {\\n    ret[i] = ret[i - 1] + nums[i];\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst runningSum = nums => {\\n  for (let i = 1; i < nums.length; ++i) {\\n    nums[i] += nums[i - 1];\\n  }\\n  return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686246,
                "title": "easy-c-solution-one-pass",
                "content": "```\\n vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417112,
                "title": "the-fastest-solution-of-all",
                "content": "\\n# Complexity\\n- Time complexity:100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:88%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc runningSum(nums []int) []int {\\n  sum := 0\\n  sums := make([]int, len(nums))\\n  for i, num := range nums {\\n    sum += num\\n    sums[i] = sum\\n  }\\n  return sums\\n}\\n```\\n\\n# Apply my work for all to see",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc runningSum(nums []int) []int {\\n  sum := 0\\n  sums := make([]int, len(nums))\\n  for i, num := range nums {\\n    sum += num\\n    sums[i] = sum\\n  }\\n  return sums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3338100,
                "title": "simple-javascript-explanation-100-easy",
                "content": "# Intuition\\nAs you know, we should give back nums array with same length so I decided to overrite array elements with updated one.\\n\\n# Approach\\nThe algorithm iterates through the input array using a single loop, and uses a variable \\'sum\\' to keep track of the running sum. At each iteration, the current element of the array is assigned the current value of the running sum, and the \\'sum\\' variable is updated to include the next element in the array.\\n\\nFinally, the modified input array containing the running sums is returned.\\n\\nOverall, this is a simple and efficient approach to calculate running sums, and it does not require any additional data structures or complex computations.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    //TIME-COMPLEXITY: O(n);\\n    //MEMORY: O(1);\\n    let sum = nums[0];\\n    for(let i = 0; i < nums.length; i++){\\n        nums[i] = sum;\\n        if(i+1 < nums.length){\\n            sum += nums[i+1]\\n        }\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar runningSum = function(nums) {\\n    //TIME-COMPLEXITY: O(n);\\n    //MEMORY: O(1);\\n    let sum = nums[0];\\n    for(let i = 0; i < nums.length; i++){\\n        nums[i] = sum;\\n        if(i+1 < nums.length){\\n            sum += nums[i+1]\\n        }\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297246,
                "title": "c-easy-solution-with-for-loop",
                "content": "\\n# Complexity\\n- Time complexity:141 ms.Beats 64.54% of other solutions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 42.9 Mb.Beats 63.99% of other solution.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n       int sum=0;\\n       for(int i=0;i<nums.Length;i++){\\n           sum+=nums[i];\\n           nums[i]=sum;\\n       } \\n       return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] RunningSum(int[] nums) {\\n       int sum=0;\\n       for(int i=0;i<nums.Length;i++){\\n           sum+=nums[i];\\n           nums[i]=sum;\\n       } \\n       return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136461,
                "title": "simple-c-code-easy-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRuns a loop and iterates through each element while increasing the \\'c\\' counter by the value of new \\'i\\' and entering the value of \\'c\\' to the vector. \\n\\nRuntime : Beats 100% \\u270C\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> res;\\n        int c=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            c=c+nums[i];\\n            res.push_back(c);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> res;\\n        int c=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            c=c+nums[i];\\n            res.push_back(c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959094,
                "title": "100-0-ms-42-mb-java-with-explanation",
                "content": "\\t1. class Solution {\\n\\t\\t\\tpublic int[] runningSum(int[] nums) { //[1,2,3,4]\\n\\t\\t\\t\\tint a=1;\\n\\t\\t\\t\\twhile (nums.length>a){\\n\\t\\t\\t\\t\\t// [1]+[1]...[6]+[4]\\n\\t\\t\\t\\t\\tnums[a]=nums[a]+nums[a-1];\\n\\t\\t\\t\\t\\ta++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn nums;\\n\\t\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic int[] runningSum(int[] nums) { //[1,2,3,4]\\n\\t\\t\\t\\tint a=1;\\n\\t\\t\\t\\twhile (nums.length>a){\\n\\t\\t\\t\\t\\t// [1]+[1]...[6]+[4]\\n\\t\\t\\t\\t\\tnums[a]=nums[a]+nums[a-1];\\n\\t\\t\\t\\t\\ta++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2903772,
                "title": "sss-swift-simple-solutions-2-approaches",
                "content": "**1.a. Straight Approach**\\r\\n\\r\\n- Time complexity: $$O(N)$$\\r\\n- Space complexity: $$O(N)$$\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var result = [Int](), sum = 0\\r\\n    for n in nums {\\r\\n        sum += n\\r\\n        result.append(sum)\\r\\n    }\\r\\n    return result\\r\\n}\\r\\n```\\r\\n\\r\\n**1.b. In-place Way**\\r\\n\\r\\n- Time complexity: $$O(N)$$\\r\\n- Space complexity: $$O(1)$$\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var nums = nums, sum = 0\\r\\n    for (i, _) in nums.enumerated() {\\r\\n        sum += nums[i]\\r\\n        nums[i] = sum\\r\\n    }\\r\\n    return nums\\r\\n} \\r\\n```\\r\\n\\r\\n**1.c. Optimal In-place Way**\\r\\n\\r\\n- Time complexity: $$O(N)$$\\r\\n- Space complexity: $$O(1)$$\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var nums = nums\\r\\n    for i in 1..<nums.count {\\r\\n        nums[i] = nums[i - 1] + nums[i]\\r\\n    }\\r\\n    return nums\\r\\n}\\r\\n```\\r\\n**2. Functional Approach (One-liner)**\\r\\n\\r\\n- Time complexity: $$O(N)$$\\r\\n- Space complexity: $$O(N)$$\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    nums.reduce(into: [Int]()) { result, n in result.append(n + (result.last ?? 0)) }\\r\\n}\\r\\n```\\r\\n\\r\\nor\\r\\n\\r\\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    nums.reduce(into: [], { $0.append(($0.last ?? 0) + $1) })\\r\\n}\\r\\n```\\r\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var result = [Int](), sum = 0\\r\\n    for n in nums {\\r\\n        sum += n\\r\\n        result.append(sum)\\r\\n    }\\r\\n    return result\\r\\n}\\r\\n```\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var nums = nums, sum = 0\\r\\n    for (i, _) in nums.enumerated() {\\r\\n        sum += nums[i]\\r\\n        nums[i] = sum\\r\\n    }\\r\\n    return nums\\r\\n} \\r\\n```\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    var nums = nums\\r\\n    for i in 1..<nums.count {\\r\\n        nums[i] = nums[i - 1] + nums[i]\\r\\n    }\\r\\n    return nums\\r\\n}\\r\\n```\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    nums.reduce(into: [Int]()) { result, n in result.append(n + (result.last ?? 0)) }\\r\\n}\\r\\n```\n```\\r\\nfunc runningSum(_ nums: [Int]) -> [Int] {\\r\\n    nums.reduce(into: [], { $0.append(($0.last ?? 0) + $1) })\\r\\n}\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2763508,
                "title": "running-sum-of-1d-array-in-c",
                "content": "\\'\\'\\'\\nvector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        \\n        for(int i=1; i<nums.size(); i++)\\n            ans.push_back(nums[i] + ans[i-1]);\\n        \\n        return ans;\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "\\'\\'\\'\\nvector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        \\n        for(int i=1; i<nums.size(); i++)\\n            ans.push_back(nums[i] + ans[i-1]);\\n        \\n        return ans;\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2607693,
                "title": "java-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447969,
                "title": "0ms-java-solution-100-faster-than-all-submission",
                "content": "**Upvote in if you like tha approach**\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i = 0 ; i < n ; i ++){\\n            sum += nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i = 0 ; i < n ; i ++){\\n            sum += nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398478,
                "title": "scala-solution-with-scan-function",
                "content": "This solution uses the scan function in Scala, which applies a binary operator to create a running total for each element in the collection.\\n\\nThe first argument list is the initial value, which is usually set to zero, but since this element would be the first of the output collection, it seemed pointless to add it and later drop it. For this reason, I use the array\\'s tail (all elements but the first) and then use the first value nums(0) or nums.head as the initial value of the function.\\n\\n```scala\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = nums.tail.scan(nums(0))(_+_)\\n}\\n```\\n\\nOpen to feedback and possible optimizations.",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nobject Solution {\\n    def runningSum(nums: Array[Int]): Array[Int] = nums.tail.scan(nums(0))(_+_)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2097249,
                "title": "super-easy-python-solution-running-sum-of-1d-array",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum=0\\n        for i in range(len(nums)):\\n            sum+=nums[i]\\n            nums[i]=sum  \\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum=0\\n        for i in range(len(nums)):\\n            sum+=nums[i]\\n            nums[i]=sum  \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096695,
                "title": "c-prefix-sum",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(i > 0) nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(i > 0) nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919382,
                "title": "0ms-java-simple",
                "content": "**Very simple 0ms java solution**\\n```\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832685,
                "title": "easy-js-solution",
                "content": "```\\nvar runningSum = function(nums) {\\n    for (let i = 1; i < nums.length; i++) nums[i] += nums[i-1];\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar runningSum = function(nums) {\\n    for (let i = 1; i < nums.length; i++) nums[i] += nums[i-1];\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 694698,
                "title": "c-easy",
                "content": "```\\nRuntime: 4 ms, faster than 93.14% of C++ online submissions for Running Sum of 1d Array.\\nMemory Usage: 8.6 MB, less than 80.00% of C++ online submissions for Running Sum of 1d Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 1; i < (int)nums.size(); ++i) \\n            nums[i] += nums[i - 1];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nRuntime: 4 ms, faster than 93.14% of C++ online submissions for Running Sum of 1d Array.\\nMemory Usage: 8.6 MB, less than 80.00% of C++ online submissions for Running Sum of 1d Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i = 1; i < (int)nums.size(); ++i) \\n            nums[i] += nums[i - 1];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979191,
                "title": "c-100-fast-solution-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the array and store its ith sum to the new array runningSum at its ith position\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the sum of all the values of nums array one by one and assign it to the ith index of runningSum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>runningsum(n);\\n        int sum = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += nums[i];\\n            runningsum[i] = sum;\\n        }\\n        return runningsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>runningsum(n);\\n        int sum = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            sum += nums[i];\\n            runningsum[i] = sum;\\n        }\\n        return runningsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958439,
                "title": "mathematical-one-line-for-loop-solution",
                "content": "# Intuition\\nAs we know that since every element in the the array is the of sum of all the previous elements in the array , therefore my first thought was to use the sum upto n numbers formula n(n+1)/2 where n is varing ,\\n\\nfor first iteration n = 1, second n = 2 and so on...\\n\\nBut then looking at the example testcases and applying somewhat similar concept we can see that if we sum the (i-1)th elements holds the sum upto (i-1)th term then the sum upto ith element is \\n`sum upto (i-1)th element + nums[i]`\\n\\n# Approach\\nThe first element of the array will remain unchnaged \\nstarting from the next index if we keep on adding the previous index in the current index then we\\'ll have our desired output\\n\\n`nums[i] = nums[i-1] + nums[i];`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        //vector <long long> ans;\\n        for(auto i=1; i<nums.size(); i++) {\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        //vector <long long> ans;\\n        for(auto i=1; i<nums.size(); i++) {\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830020,
                "title": "c-std-partial-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo what the problem asks as to do.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing ```std::partial_sum```.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ because we are rewriting the input.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        partial_sum(nums.begin(), nums.end(), nums.begin());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```std::partial_sum```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        partial_sum(nums.begin(), nums.end(), nums.begin());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793276,
                "title": "simple-approach-upvote-if-you-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nvector \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\n        vector<int> sums;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n            sums.push_back(sum);\\n        }\\n        return sums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\n        vector<int> sums;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n            sums.push_back(sum);\\n        }\\n        return sums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698023,
                "title": "js-very-easy-solution",
                "content": "```\\nvar runningSum = function(nums) {\\n    const output = [nums[0]];\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        output.push(output[output.length - 1] + nums[i]);\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar runningSum = function(nums) {\\n    const output = [nums[0]];\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        output.push(output[output.length - 1] + nums[i]);\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679612,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] = nums[i-1]+nums[i]\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] = nums[i-1]+nums[i]\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2591195,
                "title": "easy-c-solution-runtime-0-ms-faster-than-100-00-of-c",
                "content": "Please upvote the solution\\uD83D\\uDE4F\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575989,
                "title": "running-sum-1d-array-python3-easy-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367467,
                "title": "python-should-be-the-most-efficient-solution",
                "content": "We notice the ith sum is actually the (i-1)th sum plus the ith element. And we can apply the small trick of using the input list to store our result to further save some space.\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098759,
                "title": "java-easiest-solution-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sumTillNow = 0;\\n        for(int i=0; i<nums.length; i++){\\n            nums[i] = nums[i] + sumTillNow;\\n            sumTillNow = nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sumTillNow = 0;\\n        for(int i=0; i<nums.length; i++){\\n            nums[i] = nums[i] + sumTillNow;\\n            sumTillNow = nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096122,
                "title": "fastest-approach-c-solution-and-approach",
                "content": "See let us see the test cases, they demand to have sum of their previous elements. So in this question, many of us will make the mistake to create a new vector(array) and then thinking of storing values in that array. I\\'ll say that you don\\'t need to create a new array ie. space complexity became O(1) and just rather update the values. for eg if our array has element 1,2,3,4 then run a loop from the 1st index(index after the 0th index) and then add the current and the previous element. \\n1st   index -> 1st index    + 0th index = 2 + 1 = 3 -->  array = 1,3,3,4\\n2nd index ->  2nd index  + 1st index = 3 + 3 = 6 -->   array = 1,3,6,4\\n3rd index  ->  3rd index   + 2nd index = 4 + 6 = 10 -> array = 1,3,6,10\\n\\nHence this was the simplest algorithm in O(n).\\n**And btw why do we start from 1st index only?\\nDrop down in the comments below. And do upvote the solution\\u2764\\uFE0F.**\\n\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> runningSum(vector<int> &nums)\\n        {\\n            /*lets take a example ->[1,2,3,4]\\n              rather than creating a new array, we should make changes in the  same array itself.\\n            */\\n\\n            for (int i = 1; i < nums.size(); i++)\\n            {\\n                nums[i] = nums[i] + nums[i - 1];\\n            }\\n\\n            return nums;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> runningSum(vector<int> &nums)\\n        {\\n            /*lets take a example ->[1,2,3,4]\\n              rather than creating a new array, we should make changes in the  same array itself.\\n            */\\n\\n            for (int i = 1; i < nums.size(); i++)\\n            {\\n                nums[i] = nums[i] + nums[i - 1];\\n            }\\n\\n            return nums;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003656,
                "title": "python-recursive-memoization-dp-with-explanations",
                "content": "I think that running sum is a very good starting point to understand dynamic programming. To come up with DP solution you always start with brute force recursion (or backtracking):\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        ans = []\\n        \\n        def cumsum(ind):\\n            if ind == 0:\\n                return nums[ind]\\n            \\n            return nums[ind] + cumsum(ind-1)\\n        \\n        for i in range(len(nums)):\\n            ans.append(cumsum(i))\\n        \\n        return ans\\n```\\n\\nAnd here you can clearly see that you are doing a ton of unnecessary work: for each number in the array you repeat all steps down to the end (bottom) of the array. So, this approach is called top-to-bottom. You can improve it with memoization.\\n\\n```\\n def runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        ans = []\\n        \\n        memo = [None] * len(nums)\\n        memo[0] = nums[0]\\n        \\n        def cumsum(ind):\\n            if memo[ind] is None:\\n            \\n                memo[ind] = nums[ind] + cumsum(ind-1)\\n            \\n            return memo[ind]\\n        \\n        for i in range(len(nums)):\\n            ans.append(cumsum(i))\\n        \\n        return ans\\n```\\nNow you avoid doing work that you\\'ve already done: you store your previous useful results in a memo array. And now it could be converted to a bottom-to-top DP solution.\\n\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        dp = [None] * len(nums)\\n        dp[0] = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            dp[i] = nums[i] + dp[i-1]\\n        \\n        return dp\\n```\\n\\nNow you gradually build your answer and for running sum it is the most intuitive approach that most people would use. So, I think that all DP problems are like building some kind of a bit more complicated running sum.\\n\\nNotice that all above solutions share the same idea: current element plus previous one. In DP they call it a recurrence relation. Here in running sum it is simple and intuitive, but in real DP problems your job is to figure out this recurrence relation.\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        ans = []\\n        \\n        def cumsum(ind):\\n            if ind == 0:\\n                return nums[ind]\\n            \\n            return nums[ind] + cumsum(ind-1)\\n        \\n        for i in range(len(nums)):\\n            ans.append(cumsum(i))\\n        \\n        return ans\\n```\n```\\n def runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        ans = []\\n        \\n        memo = [None] * len(nums)\\n        memo[0] = nums[0]\\n        \\n        def cumsum(ind):\\n            if memo[ind] is None:\\n            \\n                memo[ind] = nums[ind] + cumsum(ind-1)\\n            \\n            return memo[ind]\\n        \\n        for i in range(len(nums)):\\n            ans.append(cumsum(i))\\n        \\n        return ans\\n```\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        \\n        dp = [None] * len(nums)\\n        dp[0] = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            dp[i] = nums[i] + dp[i-1]\\n        \\n        return dp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1924101,
                "title": "simple-easy-beginner-friendly-60-ms",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum1 = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            sum1.append(sum(nums[:i])+nums[i])\\n          \\n        return sum1 \\n\\t\\t\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        sum1 = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            sum1.append(sum(nums[:i])+nums[i])\\n          \\n        return sum1 \\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503177,
                "title": "100-java",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n       \\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]+=sum;\\n            sum=nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n       \\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]+=sum;\\n            sum=nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334814,
                "title": "c-brute-force-efficient-solutions-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n    vector<int> result;\\n    int len=nums.size(),sum=0;\\n    for(int i=0;i<len;i++){\\n          sum=0;\\n        for(int j=0;j<=i;j++){\\n              sum+=nums[j];\\n        }\\n        result.push_back(sum);\\n    }\\n        return result;\\n    }\\n};\\n```\\n\\n**Efficient Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n    int len=nums.size();\\n    for(int i=1;i<len;i++){\\n        nums[i]+=nums[i-1];\\n    }\\n        return nums;  \\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n    vector<int> result;\\n    int len=nums.size(),sum=0;\\n    for(int i=0;i<len;i++){\\n          sum=0;\\n        for(int j=0;j<=i;j++){\\n              sum+=nums[j];\\n        }\\n        result.push_back(sum);\\n    }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n    int len=nums.size();\\n    for(int i=1;i<len;i++){\\n        nums[i]+=nums[i-1];\\n    }\\n        return nums;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188952,
                "title": "java-c-python-prefix-sum-logic-explained-o-1-space-o-n-time",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\nBrute force logic will be to take every number 1 by 1 and calculate the sum of numbers before it and add the current number to the sum.  This will take **O (N^2)** time.\\n\\nWe can optimize this to **O (N)** time by precalculating the sum of numbers before the current number using the prefix sum logic.\\n\\n**Prefix sum of an array element is the sum of all the numbers including itself from the start of the array.**\\n\\nSo basically: `prefixSum [i] = prefixSum [i-1] + nums [i]`.  Since there is no number before the first number, `prefixSum [0] = nums [0]` itself.\\n\\nSince, we don\\'t need to do any processing after calculating the prefix sum, we can use the given array itself as the prefix sum array.\\n\\nDo: `nums [i] = nums [i] + nums [i-1]` and simply return `nums` array.\\n\\n**Java** 0 ms:\\n\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++)\\n            nums [i] += nums [i-1];\\n        return nums;\\n    }\\n}\\n```\\n\\n**C++** 4 ms:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for (int i = 1; i < nums.size (); i++)\\n            nums [i] += nums [i-1];\\n        return nums;\\n    }\\n};\\n```\\n\\n**Python** 40 ms:\\n\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range (1, len(nums)):\\n            nums [i] = nums [i] + nums [i-1]\\n        return nums\\n```\\n\\nIf you like the solution and explanation, please **upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for (int i = 1; i < nums.length; i++)\\n            nums [i] += nums [i-1];\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for (int i = 1; i < nums.size (); i++)\\n            nums [i] += nums [i-1];\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range (1, len(nums)):\\n            nums [i] = nums [i] + nums [i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153939,
                "title": "swift-running-sum-of-1d-array",
                "content": "#### Solution\\n\\n```swift\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        var res = [Int]()\\n        for i in 0..<nums.count where !nums.isEmpty {\\n            i == 0 ? res.append(nums[i]) : res.append(res[i-1] + nums[i])\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n#### Tests:\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.runningSum([1,2,3,4]), [1,3,6,10]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.runningSum([1,1,1,1,1]), [1,2,3,4,5]) // success\\n    }\\n    func testExample3() {\\n        XCTAssertEqual(s.runningSum([3,1,2,10,1]), [3,4,6,16,17]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func runningSum(_ nums: [Int]) -> [Int] {\\n        var res = [Int]()\\n        for i in 0..<nums.count where !nums.isEmpty {\\n            i == 0 ? res.append(nums[i]) : res.append(res[i-1] + nums[i])\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.runningSum([1,2,3,4]), [1,3,6,10]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.runningSum([1,1,1,1,1]), [1,2,3,4,5]) // success\\n    }\\n    func testExample3() {\\n        XCTAssertEqual(s.runningSum([3,1,2,10,1]), [3,4,6,16,17]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027797,
                "title": "python-3-3-liner-o-n-time-o-1-memory",
                "content": "**Uses initial memory and writes over it.**\\n\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] += nums[i-1]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] += nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717785,
                "title": "c-solution",
                "content": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int i, prev=0;\\n    *returnSize = numsSize;\\n    int* returnSum;\\n    returnSum = (int*)malloc(sizeof(int)*numsSize);\\n    returnSum[0] = nums[0];\\n    for(i=1;i<numsSize;i++)\\n        returnSum[i]=returnSum[i-1] + nums[i];\\n    return returnSum;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    int i, prev=0;\\n    *returnSize = numsSize;\\n    int* returnSum;\\n    returnSum = (int*)malloc(sizeof(int)*numsSize);\\n    returnSum[0] = nums[0];\\n    for(i=1;i<numsSize;i++)\\n        returnSum[i]=returnSum[i-1] + nums[i];\\n    return returnSum;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688159,
                "title": "swift-2-line-simple-solution",
                "content": "```\\nvar sum = 0\\nreturn nums.map{(sum+=$0, sum).1}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nvar sum = 0\\nreturn nums.map{(sum+=$0, sum).1}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686902,
                "title": "python-solution-easy-to-undersatnd",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        cum_sum = 0 #cummulative sum\\n        for i in range(len(nums)):\\n            cum_sum += nums[i]\\n            nums[i] = cum_sum\\n        return nums",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        cum_sum = 0 #cummulative sum\\n        for i in range(len(nums)):\\n            cum_sum += nums[i]\\n            nums[i] = cum_sum\\n        return nums",
                "codeTag": "Java"
            },
            {
                "id": 686495,
                "title": "functional-programming-one-line-with-rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .scan(0, |sum, &v| {\\n                *sum += v;\\n                Some(*sum)\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .scan(0, |sum, &v| {\\n                *sum += v;\\n                Some(*sum)\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686327,
                "title": "java-simple-solution-100-time-in-place",
                "content": "```\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1;i<nums.length;i++){\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1;i<nums.length;i++){\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686233,
                "title": "a-few-solutions",
                "content": "Return the ongoing accumulated `total` of each value `x` of the input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun runningSum(A: IntArray): IntArray {\\n        var total = 0\\n        return A.map{ total += it; total }!!.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet runningSum = (A, sum = 0) => A.map(x => sum += x);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def runningSum(self, A: List[int], sum = 0) -> List[int]:\\n        N = len(A)\\n        for i in range (1, N):\\n            A[i] += A[i - 1]\\n        return A\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI runningSum(VI& A, int sum = 0, VI ans = {}) {\\n        transform(A.begin(), A.end(), back_inserter(ans), [&](auto x) { return sum += x; });\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun runningSum(A: IntArray): IntArray {\\n        var total = 0\\n        return A.map{ total += it; total }!!.toIntArray()\\n    }\\n}\\n```\n```\\nlet runningSum = (A, sum = 0) => A.map(x => sum += x);\\n```\n```\\nclass Solution:\\n    def runningSum(self, A: List[int], sum = 0) -> List[int]:\\n        N = len(A)\\n        for i in range (1, N):\\n            A[i] += A[i - 1]\\n        return A\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI runningSum(VI& A, int sum = 0, VI ans = {}) {\\n        transform(A.begin(), A.end(), back_inserter(ans), [&](auto x) { return sum += x; });\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632450,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe problem asks for a running sum of an array, which means for each element at index `i` in the resultant array, its value is the sum of all elements from index 0 to `i` in the original array. A straightforward approach is to iterate over the array and at each step, add the current element to the sum of all previous elements.\\n\\n# Approach\\nWe create a prefix sum array `prefix` which has length 1 more than the input `nums` array. This is because the prefix sum includes the sum of elements up to and including the current element, and we want the first element to be zero for an easier calculation. We then iterate over the `nums` array and for each element, we add it to the previous prefix sum and store it in the current position of the prefix sum array.\\n\\nFinally, we return all elements from index 1 to the end of the prefix array. This is because the running sum of `nums` starts from the first element, not the zeroth element.\\n\\n# Complexity\\n- Time complexity: The time complexity for this algorithm is O(n), where `n` is the length of the `nums` array. This is because we perform a single pass over the `nums` array.\\n\\n- Space complexity: The space complexity is O(n), as we create a prefix sum array of the same size as the `nums` array. \\n\\n# Code\\n```go\\nfunc runningSum(nums []int) []int {\\n    prefix:=make([]int,len(nums)+1)\\n    for i:=1;i<len(prefix);i++{\\n        prefix[i]=prefix[i-1]+nums[i-1]\\n    }\\n    return prefix[1:]\\n}\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "# Intuition\\nThe problem asks for a running sum of an array, which means for each element at index `i` in the resultant array, its value is the sum of all elements from index 0 to `i` in the original array. A straightforward approach is to iterate over the array and at each step, add the current element to the sum of all previous elements.\\n\\n# Approach\\nWe create a prefix sum array `prefix` which has length 1 more than the input `nums` array. This is because the prefix sum includes the sum of elements up to and including the current element, and we want the first element to be zero for an easier calculation. We then iterate over the `nums` array and for each element, we add it to the previous prefix sum and store it in the current position of the prefix sum array.\\n\\nFinally, we return all elements from index 1 to the end of the prefix array. This is because the running sum of `nums` starts from the first element, not the zeroth element.\\n\\n# Complexity\\n- Time complexity: The time complexity for this algorithm is O(n), where `n` is the length of the `nums` array. This is because we perform a single pass over the `nums` array.\\n\\n- Space complexity: The space complexity is O(n), as we create a prefix sum array of the same size as the `nums` array. \\n\\n# Code\\n```go\\nfunc runningSum(nums []int) []int {\\n    prefix:=make([]int,len(nums)+1)\\n    for i:=1;i<len(prefix);i++{\\n        prefix[i]=prefix[i-1]+nums[i-1]\\n    }\\n    return prefix[1:]\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3500006,
                "title": "easy-java-program-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465270,
                "title": "0ms-100-faster-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum[]=new int[nums.length];\\n        sum[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum[i]=sum[i-1]+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum[]=new int[nums.length];\\n        sum[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            sum[i]=sum[i-1]+nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416816,
                "title": "c-code-0-ms-and-beats-100-of-the-c-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will iterate from the **index 1** to **`nums.size() - 1`** of the array **`nums`** and add the previous element **`nums[i - 1]`** to the current element **`nums[i]`** and store it at the same index **`nums[i]`** and return the **`nums`**.\\n\\n![temp1.png](https://assets.leetcode.com/users/images/59324d05-edfd-40c9-9aa4-f4bceb7993f1_1681485544.2118454.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        // vector<int> ans = {nums[0]};\\n\\n        for(int i = 1; i < nums.size(); i++) {\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n\\n\\n\\n```\\n\\n\\n\\n# **Please Upvote.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        // vector<int> ans = {nums[0]};\\n\\n        for(int i = 1; i < nums.size(); i++) {\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303462,
                "title": "simple-approach-i-was-able-to-get-0ms-runtime-with-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCreate a new vector `ans`.\\n\\nNow, we can simply do :\\n\\n`ans[0] = nums[0]`\\n\\nand now, \\n\\nwe run a loop till end of vector, and use the following formula for populating vactor `ans` :\\n\\n> ans[i] = ans[i - 1] + nums[i]\\n\\njust note to start the loop from `i = 1`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            ans.push_back(ans[i - 1] + nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            ans.push_back(ans[i - 1] + nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190932,
                "title": "c-solution-standard-code-must-know",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++) nums[i]+= nums[i-1];\\n        return nums;\\n    }\\n};\\n```\\n\\n```\\n//if initial array is not allowed to modify\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\tvector<int> arr={nums[0]};\\n        for(int i=1;i<nums.size();i++) arr.push_back(nums[i]+arr.back()) ;\\n        return arr;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++) nums[i]+= nums[i-1];\\n        return nums;\\n    }\\n};\\n```\n```\\n//if initial array is not allowed to modify\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\tvector<int> arr={nums[0]};\\n        for(int i=1;i<nums.size();i++) arr.push_back(nums[i]+arr.back()) ;\\n        return arr;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160888,
                "title": "simple-java-prefix-sum-clear-understanding",
                "content": "```\\nExplanation : (Prefix Sum) \\n\\t\\n\\t Here I\\'m taking first example TestCase of leetcode\\n\\t\\n\\t nums = [1, 2, 3, 4]\\n\\t\\n\\t Inner Working of Prefix Sum Approach\\n\\t\\n\\t steps :\\n\\t 1. create prefixSum array with nums array length --> {0, 0, 0,0};\\n\\t 2. add 0th index element of nums array to prefixSum array, prefixSum[0] = nums[0];\\n\\t\\n\\t for (int i = 1; i < nums.length; i++) {\\n\\t\\t prefixSum[i] = prefixSum[i - 1] + nums[i];\\n\\t }\\n\\n\\t how this loop is working ?\\n\\n\\t intial prefixSum array = {1, 0, 0, 0}\\n\\n\\t consider,\\n\\t i = 1;\\n\\t prefixSum[i] = prefixSum[i - 1] + nums[i], it means,\\n\\t prefixSum[1] = prefixSum[1 - 1] + nums[1],\\n\\t prefixSum[1] = prefixSum[0] + nums[1] // calculate answers;\\n\\t prefixSum[1] = 1 + 2;\\n\\t prefixSum[1] = 3;\\n\\t prefixSum array = {1, 3, 0, 0}\\n\\n\\t similarly, for i = 2;\\n\\t prefixSum[i] = prefixSum[i - 1] + nums[i], it means,\\n\\t prefixSum[2] = prefixSum[2 - 1] + nums[2],\\n\\t prefixSum[2] = prefixSum[1] + nums[2] // calculate answers;\\n\\t prefixSum[2] = 3 + 3;\\n\\t prefixSum[2] = 6;\\n\\t prefixSum array = {1, 3, 6, 0}\\n\\n\\t same as for i = 3;\\n\\t prefixSum[i] = prefixSum[i - 1] + nums[i], it means,\\n\\t prefixSum[3] = prefixSum[3 - 1] + nums[3],\\n\\t prefixSum[3] = prefixSum[2] + nums[3] // calculate answers;\\n\\t prefixSum[3] = 6 + 4;\\n\\t prefixSum[3] = 10;\\n\\t prefixSum array = {1, 3, 6, 10}\\n\\n\\t Hope you get the idea behind Prefix Sum. \\uD83D\\uDC95\\n\\t \\nJAVA CODE : \\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        int[] prefixSum = new int[nums.length];\\n        prefixSum[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        \\n        return prefixSum;\\n    }\\n}\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(N)\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        int[] prefixSum = new int[nums.length];\\n        prefixSum[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3085608,
                "title": "summing-up-a-1d-array-php-solution-4-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst i thought that we can go with a straight forward approach that using to for loops for interating through the array summing up to on new array and returning it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe best approach is as per explanation & constrain alway first element is same element as in input array , so i started from index 1 & to reduce the memory useage i am using the same array so storing a summing up value & returning it \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nits o(n-1) solution\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nits o(1) solution\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[]\\n     */\\n    function runningSum($nums) {\\n        \\n        for ($i=1;$count=count($nums),$i<$count;$i++){\\n\\n           $nums[$i]=$nums[$i-1]+$nums[$i];\\n\\n        }\\n       \\n       return $nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[]\\n     */\\n    function runningSum($nums) {\\n        \\n        for ($i=1;$count=count($nums),$i<$count;$i++){\\n\\n           $nums[$i]=$nums[$i-1]+$nums[$i];\\n\\n        }\\n       \\n       return $nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056570,
                "title": "c-proper-solution-explained",
                "content": "# Intuition\\nThe value of a number is equal to the sum of all the previous numbers and the current number.\\n\\n# Approach\\n- Sum keeps the track of the sum of all the previous numbers.\\n- Traverse through numbers, add the value of current number to the sum and then update the number of the array to sum.\\n  \\n- Example \\nConside nums= {1,2,3,4}\\nInitially sum=0;\\nsum=sum+nums[0]=0+1=1, nums[0]=1\\nsum=sum+nums[1]=1+2=3, nums[1]=3\\nsum=sum+nums[2]=3+3=6, nums[2]=6\\nsum=sum+nums[3]=6+4=10, nums[3]=10\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    int sum=0;\\n    for(int i=0;i<nums.size();i++){\\n        sum=sum+nums[i];\\n        nums[i]=sum;\\n    }    \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n    int sum=0;\\n    for(int i=0;i<nums.size();i++){\\n        sum=sum+nums[i];\\n        nums[i]=sum;\\n    }    \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052302,
                "title": "quick-and-short-solution",
                "content": "# Intuition\\nIterative Approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart from index 1 and assign the sum of current element and previous element to current position\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n# Code\\n```\\nclass Solution {\\n    fun runningSum(nums: IntArray): IntArray {\\n        for(i in 1 until nums.size){\\n            nums[i] = nums[i-1]+nums[i]\\n        }\\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun runningSum(nums: IntArray): IntArray {\\n        for(i in 1 until nums.size){\\n            nums[i] = nums[i-1]+nums[i]\\n        }\\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912299,
                "title": "sc-100-and-tc-98-java-and-python",
                "content": "# Java Solutions with SC----->O(1)\\n```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            nums[i+1]=nums[i]+nums[i+1];\\n        }\\n        return nums;\\n        \\n    }\\n}\\n```\\n# Python Solutions SC------>O(1)\\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i]=nums[i]+nums[i-1]\\n        return nums\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            nums[i+1]=nums[i]+nums[i+1];\\n        }\\n        return nums;\\n        \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i]=nums[i]+nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880685,
                "title": "c-o-n-easy-to-understand-with-in-depth-explanation-and-examples",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\nUse the original array to hold the running sum\\n\\n## Code\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        const int n = nums.size();\\n        for (int i = 1; i < n; i++)\\n            nums[i] += nums[i - 1];\\n\\n        return nums;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$\\n**Space Complexity:** $$O(1)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nRefer to the [TL;DR](#tldr)\\n\\n## Approach \\n\\nThe first index will just be itself, then from index 1 to n, it will be `nums[i] += nums[i - 1]` since you just want to add the previous value onto the current value continuously till the end. Then you just return the original array that was passed in.\\n\\n## Example\\n\\nLet\\'s use the third example, where `nums = [3,1,2,10,1]`\\n\\n* i = 1\\n`nums[i] += nums[i - 1]` $$\\\\rightarrow$$ `nums[1] = nums[1] + nums[0] = 1 + 3 = 4`\\n\\n* i = 2\\n`nums[i] += nums[i - 1]` $$\\\\rightarrow$$ `nums[2] = nums[2] + nums[1] = 2 + 4 = 6` (remember we just updated `nums[i]` in the last bullet)\\n\\n* i = 3\\n`nums[i] += nums[i - 1]` $$\\\\rightarrow$$ `nums[3] = nums[3] + nums[2] = 10 + 6 = 16`\\n\\n* i = 4\\n`nums[i] += nums[i - 1]` $$\\\\rightarrow$$ `nums[4] = nums[4] + nums[3] = 1 + 16 = 17`\\n\\n* Final Result = `[3,4,6,16,17]` which is the solution\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        const int n = nums.size();\\n        for (int i = 1; i < n; i++)\\n            nums[i] += nums[i - 1];\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782064,
                "title": "0ms-beats-100-easy-to-understand-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//...Please upvote if it helps...\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();++i){\\n            nums[i]+=nums[i-1];\\n        }return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n//...Please upvote if it helps...\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1;i<nums.size();++i){\\n            nums[i]+=nums[i-1];\\n        }return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709619,
                "title": "c-short-easy-solution-o-n-time-o-1-space",
                "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++) \\n\\t\\t    nums[i] += nums[i-1];\\n            \\n\\t\\treturn nums;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        for(int i=1; i<nums.size(); i++) \\n\\t\\t    nums[i] += nums[i-1];\\n            \\n\\t\\treturn nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2682544,
                "title": "javascript-map-o-n-faster-than-85",
                "content": "```\\nconst runningSum = (nums) => {\\n    nums.map((num,index)=>{    \\n        if(index!=0){\\n            return nums[index] = num + nums[index-1];\\n        }\\n    })\\n    return nums;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst runningSum = (nums) => {\\n    nums.map((num,index)=>{    \\n        if(index!=0){\\n            return nums[index] = num + nums[index-1];\\n        }\\n    })\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548476,
                "title": "very-easy-and-simple-java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        arr[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) { \\n            arr[i] = arr[i-1] + nums[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        arr[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) { \\n            arr[i] = arr[i-1] + nums[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544167,
                "title": "simple-java-solution-runtime-0-ms-faster-than-100-00-of-java",
                "content": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        for(int i=1; i<n; i++){    // notes you don\\'t put i=0, because we need nums[i-1]= nums[0-1] || So, ans is nums[-1] but we have no index of nums[-1] but have nums[0] is present so, we are put starting value of i=1.\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        for(int i=1; i<n; i++){    // notes you don\\'t put i=0, because we need nums[i-1]= nums[0-1] || So, ans is nums[-1] but we have no index of nums[-1] but have nums[0] is present so, we are put starting value of i=1.\\n            nums[i] = nums[i] + nums[i-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539371,
                "title": "leetcode-the-hard-way-three-solutions-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. I\\'ll explain my solution line by line daily. \\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n**Solution 1: Prefix Sum**\\n\\nExtracted from my tutorial [here](https://wingkwong.github.io/leetcode-the-hard-way/tutorials/basic-topics/prefix-sum).\\n\\n![image](https://assets.leetcode.com/users/images/8e660152-4785-4334-aa2d-b5b888b90085_1662458446.9801016.png)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // for full tutorial, please go to\\n    // https://wingkwong.github.io/leetcode-the-hard-way/tutorials/basic-topics/prefix-sum\\n    vector<int> generatePrefixSum(vector<int>& a) {\\n        int n = a.size();\\n\\t\\t// we need a vector of size n\\n        vector<int> pref(n);\\n\\t\\t// the first element is same as that in `a`\\n        pref[0] = a[0];\\n\\t\\t// starting the second one, we add the prefix sum `pref[i - 1]` and the current value `a[i]`\\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\\n        return pref;\\n    }\\n    \\n    vector<int> runningSum(vector<int>& nums) {\\n\\t    // use the pre-defined function directly\\n        return generatePrefixSum(nums);\\n    }\\n};\\n```\\n\\n**Solution 2: Partial Sum**\\n\\nThis STL basically does the same thing I mention above. See [here](https://cplusplus.com/reference/numeric/partial_sum/) for more details.\\n\\n```\\ny0 = x0\\ny1 = x0 + x1\\ny2 = x0 + x1 + x2\\ny3 = x0 + x1 + x2 + x3\\ny4 = x0 + x1 + x2 + x3 + x4\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\t// use STL directly\\n        partial_sum(nums.begin(), nums.end(), nums.begin());\\n        return nums;\\n    }\\n};\\n```\\n\\n**Solution 3: In-place Modification**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\t// we don\\'t actually need to generate a prefix sum vector\\n\\t\\t// instead we can modify the value in place.\\n        for(int i = 1; i < nums.size(); i++) {\\n            // add the previous result to the current element.\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // for full tutorial, please go to\\n    // https://wingkwong.github.io/leetcode-the-hard-way/tutorials/basic-topics/prefix-sum\\n    vector<int> generatePrefixSum(vector<int>& a) {\\n        int n = a.size();\\n\\t\\t// we need a vector of size n\\n        vector<int> pref(n);\\n\\t\\t// the first element is same as that in `a`\\n        pref[0] = a[0];\\n\\t\\t// starting the second one, we add the prefix sum `pref[i - 1]` and the current value `a[i]`\\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\\n        return pref;\\n    }\\n    \\n    vector<int> runningSum(vector<int>& nums) {\\n\\t    // use the pre-defined function directly\\n        return generatePrefixSum(nums);\\n    }\\n};\\n```\n```\\ny0 = x0\\ny1 = x0 + x1\\ny2 = x0 + x1 + x2\\ny3 = x0 + x1 + x2 + x3\\ny4 = x0 + x1 + x2 + x3 + x4\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\t// use STL directly\\n        partial_sum(nums.begin(), nums.end(), nums.begin());\\n        return nums;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n\\t\\t// we don\\'t actually need to generate a prefix sum vector\\n\\t\\t// instead we can modify the value in place.\\n        for(int i = 1; i < nums.size(); i++) {\\n            // add the previous result to the current element.\\n            nums[i] += nums[i - 1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498971,
                "title": "c-prefix-sum-beginner-friendly",
                "content": "**Approach 1: Prefix Sum \\u2705**\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1]; //prefix sum calculation\\n        return nums;\\n    }\\n};\\n```\\n\\n**Approach 2: Partial Sum (C++ STL)\\u2705**\\n```\\nclass Solution {\\npublic:\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n\\t}\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       for(int i=1;i<nums.size();i++) nums[i]+=nums[i-1]; //prefix sum calculation\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<int> runningSum(vector<int>& nums) {\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    return nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469092,
                "title": "python-easy-solution",
                "content": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        final_list = []\\n        for i in range(len(nums)):\\n            final_list.append(sum(nums[:i+1]))\\n        return final_list\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n        final_list = []\\n        for i in range(len(nums)):\\n            final_list.append(sum(nums[:i+1]))\\n        return final_list\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2321846,
                "title": "python-simple-faster-solution-prefix-sum",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        result = [nums[0]]\\n        for i in range(1,len(nums)):\\n            result.append(result[i-1] + nums[i])\\n        return result\\n```\\nPlease UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        result = [nums[0]]\\n        for i in range(1,len(nums)):\\n            result.append(result[i-1] + nums[i])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291984,
                "title": "ruby-96-faster-solution",
                "content": "```\\n@param {Integer[]} nums\\n@return {Integer[]}\\ndef running_sum(nums)\\n    (nums.length).times do |i|\\n        if i >= 1\\n            nums[i] += nums[i - 1] \\n        end\\n    end\\n    nums\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n@param {Integer[]} nums\\n@return {Integer[]}\\ndef running_sum(nums)\\n    (nums.length).times do |i|\\n        if i >= 1\\n            nums[i] += nums[i - 1] \\n        end\\n    end\\n    nums\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2219705,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099271,
                "title": "c-prefix-solution-o-n-dlc-1-june",
                "content": "**Please do upvote if u like the solution:)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        int sum = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        int sum = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099257,
                "title": "c-easy-and-short-solution-prefix-sum",
                "content": "This is quite simple and intitutive approach\\n\\nIn this solution we iterate through our vector and add previous index value to current index value and store it in current index\\n\\nTime complexity for given solution is O(N) and Space complexity is O(1)\\nN = size of nums \\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i=1;i<n;i++) {\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\nHowever there can be a variation of this question as vector nums is passed by reference \\nSo if question mentions that we do not have to update original vector we can move forward with another solution\\n\\nHere we create a another vector of same size of vector nums and intialize it with 0\\nwe iterate through nums vector and add previous index value of res and current index value of nums and store it in current index of res \\n\\nTime complexity for this solution is O(N) and space complexity for this is also O(N)\\nN = size of nums\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        res.assign(n,0);\\n        res[0] = nums[0];\\n        for (int i=1;i<n;i++) {\\n            res[i] = nums[i] + res[i-1];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThanks",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i=1;i<n;i++) {\\n            nums[i]+=nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        res.assign(n,0);\\n        res[0] = nums[0];\\n        for (int i=1;i<n;i++) {\\n            res[i] = nums[i] + res[i-1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097323,
                "title": "rust-four-styles",
                "content": "I took this as a drill in different coding styles:\\n\\n1. Destructive | Functional Style - Using `scan()` to have an accumulator state, and the idiom `for_each(drop)` to consume the iterator without using it ([https://github.com/rust-lang/rust/pull/48945](https://github.com/rust-lang/rust/pull/48945)).\\n\\n```\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter_mut()\\n            .scan(0, |prev, curr| {\\n                *curr += *prev;\\n                *prev = *curr;\\n                Some(())\\n            })\\n            .for_each(drop);\\n        nums\\n    }\\n}\\n```\\n\\n2. Non-destructive | Functional - OK, `nums` is owned by `running_sum()`, so it\\'s destroyed anyway when it goes out of scope, but say you wanted to continue using `nums` later on, this is the way to do it.\\n\\n```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        nums.into_iter()\\n            .scan(0, |prev, curr| {\\n                *prev += curr;\\n                Some(*prev)\\n            })\\n            .collect()\\n    }\\n}\\n```\\n\\n3. Destructive | Imperative - We are a person who likes manual indexing. We think we know better than the compiler how things should be done efficiently. :) Since we own `nums`, why not use it for the return value to avoid allocating another vector?\\n\\n```\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        for i in 1..nums.len() {\\n            nums[i] += nums[i-1];\\n        }\\n        nums\\n    }\\n}\\n```\\n\\n4. Non-destructive | Imperative - We want to contine using `nums` and we like loops. We preallocate `rez` to avoid reallocations, and we use iterators to avoid manual indexing.\\n\\n```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut rez = vec![0; nums.len()];\\n        let mut acc = 0;\\n        for (src, dst) in nums.iter().zip(rez.iter_mut()) {\\n            acc += *src;\\n            *dst = acc;\\n        }\\n        rez\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter_mut()\\n            .scan(0, |prev, curr| {\\n                *curr += *prev;\\n                *prev = *curr;\\n                Some(())\\n            })\\n            .for_each(drop);\\n        nums\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        nums.into_iter()\\n            .scan(0, |prev, curr| {\\n                *prev += curr;\\n                Some(*prev)\\n            })\\n            .collect()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn running_sum(mut nums: Vec<i32>) -> Vec<i32> {\\n        for i in 1..nums.len() {\\n            nums[i] += nums[i-1];\\n        }\\n        nums\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn running_sum(nums: Vec<i32>) -> Vec<i32> {\\n        let mut rez = vec![0; nums.len()];\\n        let mut acc = 0;\\n        for (src, dst) in nums.iter().zip(rez.iter_mut()) {\\n            acc += *src;\\n            *dst = acc;\\n        }\\n        rez\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012935,
                "title": "python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] += nums[i-1]\\n            \\n        return nums\\n            \\n    \\n```\\nIf it worked for you kindly upvote",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        for i in range(1,len(nums)):\\n            nums[i] += nums[i-1]\\n            \\n        return nums\\n            \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863520,
                "title": "c-easy-solution-o-n-time-1480-running-sum-of-1d-array",
                "content": "**Code**\\n\\t\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t   vector<int> runningSum(vector<int>& nums) {\\n\\t\\t   vector<int>ans;\\n\\t\\t   int sum=0;\\n\\t\\t   for(int i=0;i<nums.size();i++)\\n\\t\\t   {\\n\\t\\t\\t   sum+=nums[i];\\n\\t\\t\\t   ans.push_back(sum);\\n\\t\\t   }\\n\\t\\t   return ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t   vector<int> runningSum(vector<int>& nums) {\\n\\t\\t   vector<int>ans;\\n\\t\\t   int sum=0;\\n\\t\\t   for(int i=0;i<nums.size();i++)\\n\\t\\t   {\\n\\t\\t\\t   sum+=nums[i];\\n\\t\\t\\t   ans.push_back(sum);\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1551659,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tres = [0] * len(nums)\\n\\trun_sum = sum(nums)\\n\\n\\tfor i in range(len(nums) - 1, -1, -1):\\n\\t\\tres[i] = run_sum\\n\\t\\trun_sum -= nums[i]\\n\\n\\treturn res\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef runningSum(self, nums: List[int]) -> List[int]:\\n\\tres = [0] * len(nums)\\n\\trun_sum = sum(nums)\\n\\n\\tfor i in range(len(nums) - 1, -1, -1):\\n\\t\\tres[i] = run_sum\\n\\t\\trun_sum -= nums[i]\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1273236,
                "title": "weeb-does-python-in-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/baf3d537-de83-46b0-8d66-c7d6aafbfea0_1623725784.182452.png)\\n\\n\\tclass Solution:\\n\\t\\tdef runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tresult, count = [], 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tresult.append(count+nums[i])\\n\\t\\t\\t\\tcount+=nums[i]\\n\\t\\t\\treturn result\\n\\nAight coders, its time for some anime recommendations\\nCheck out **Dorohedoro**\\n\\n# Episodes: 12 + 1 OVA (might change in the future if Season 2 is confirmed)\\n# Genre: Action, Comedy, Fantasy, Horror, Seinen\\n\\nThis is a cool anime so grab ur popcorn and start binge watching this show",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/baf3d537-de83-46b0-8d66-c7d6aafbfea0_1623725784.182452.png)\\n\\n\\tclass Solution:\\n\\t\\tdef runningSum(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tresult, count = [], 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tresult.append(count+nums[i])\\n\\t\\t\\t\\tcount+=nums[i]\\n\\t\\t\\treturn result\\n\\nAight coders, its time for some anime recommendations\\nCheck out **Dorohedoro**\\n\\n# Episodes: 12 + 1 OVA (might change in the future if Season 2 is confirmed)\\n# Genre: Action, Comedy, Fantasy, Horror, Seinen\\n\\nThis is a cool anime so grab ur popcorn and start binge watching this show",
                "codeTag": "Java"
            },
            {
                "id": 1264327,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        if (nums.size() <= 1) return nums;\\n        for (int i = 1; i < nums.size(); i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        if (nums.size() <= 1) return nums;\\n        for (int i = 1; i < nums.size(); i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256180,
                "title": "python-2-pointer",
                "content": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        lp = 0\\n        rp = 1\\n        while(rp<len(nums)):\\n            sums = nums[lp] + nums[rp]\\n            nums[rp] = sums\\n            rp+=1\\n            lp = rp -1\\n        return nums\\n        \\n   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        lp = 0\\n        rp = 1\\n        while(rp<len(nums)):\\n            sums = nums[lp] + nums[rp]\\n            nums[rp] = sums\\n            rp+=1\\n            lp = rp -1\\n        return nums\\n        \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182604,
                "title": "javascript-with-map-doesn-t-modify-original-array-76-ms",
                "content": "Pretty straightforward solution, but since many of the solutions up involve modifying the input array, I wanted to put one up that returns a new array. \\n\\nRuntime: 76 ms, faster than 88.80% of JavaScript online submissions.\\nMemory Usage: 38.7 MB, less than 95.38% of JavaScript online submissions.\\n\\nTime: O(n)\\nSpace: O(n)\\n\\n```\\nconst runningSum = nums => {\\n    let total = 0;\\n    \\n    return nums.map(num => total += num);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst runningSum = nums => {\\n    let total = 0;\\n    \\n    return nums.map(num => total += num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135616,
                "title": "simple-java-solution-with-o-n-time-complexity-and-o-1-space-100-summited",
                "content": "class Solution {\\n    \\n    public int[] runningSum(int[] nums) {\\n       for (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tnums[i] = nums[i - 1] + nums[i];\\n\\t\\t}\\n\\t\\treturn nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int[] runningSum(int[] nums) {\\n       for (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tnums[i] = nums[i - 1] + nums[i];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1117894,
                "title": "faster-than-100-recursive-c",
                "content": "I notice most people did this iteratively, but you could also use recursion:\\n\\nAnother note, I\\'m seeing people use an accumulator outside their loops to track the sum. You don\\'t need that, just start on the second element, index 1, and sum the current element with the previous one. There\\'s never a need to iterate over the first element, because the running sum at that element is already equal to the element itself. For that reason we can simply check for inputs of size 1 (or 0) and return them as is.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        if(nums.size() <= 1) {\\n            return nums;\\n        }\\n        recur(nums, 1);\\n        return nums;\\n    }\\n    \\n    void recur(vector<int>& nums, int count) {\\n        if(count == nums.size()) {\\n            return;\\n        }\\n        nums.at(count) = nums.at(count) + nums.at(count - 1);\\n        recur(nums, count+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        if(nums.size() <= 1) {\\n            return nums;\\n        }\\n        recur(nums, 1);\\n        return nums;\\n    }\\n    \\n    void recur(vector<int>& nums, int count) {\\n        if(count == nums.size()) {\\n            return;\\n        }\\n        nums.at(count) = nums.at(count) + nums.at(count - 1);\\n        recur(nums, count+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1669397,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1706950,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1575473,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1655887,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1566060,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1701614,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1577000,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1673678,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1645448,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1714764,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1669397,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1706950,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1575473,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1655887,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1566060,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1701614,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1577000,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1673678,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1645448,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1714764,
                "content": [
                    {
                        "username": "mahann",
                        "content": "The solution times for submissions are all over the place.\\nMy first solution came in at 4ms, then 16ms, then 6ms, then when I submitted 22ms.\\nSo out of curiosity, I copied and submitted the fastest recorded submission... 3 times... 19ms. 13ms. 27ms.\\nThe memory usage was all over the place also.\\nWhat\\'s the point in having these metrics if they are not going to be accurate and won\\'t reflect the efficiency of people\\'s code??\\n"
                    },
                    {
                        "username": "aaltfeder12",
                        "content": "Due to to nature of how this website works you won\\'t get the most accurate run times. But you need some sort of way to limit inefficient run times for other problems where you have to run in log N versus N run times. The error in calculating the run time on on this site is low enough where this metric usually can be used to require a certain algorithm to be written. I hope what I wrote makes sense."
                    },
                    {
                        "username": "pnuema",
                        "content": "you could run \"time ./<name of executable>\" in your command line after writing this program outside of here to check your function. It is a bit more work but good practice."
                    },
                    {
                        "username": "The_White_Fox",
                        "content": "If I don't have the cells to come up with a solution for an \"easy\" task like this, should I consider quitting and be a nude yoga instructor instead? I am new to leetcode, after 8 months of coding courses. This is my second problem to solve and it gives me chills. "
                    },
                    {
                        "username": "wxgwxng",
                        "content": "i am in the same boat \\uD83E\\uDD72\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "suhan_hack_143",
                        "content": "Funniest man on Earth"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "There are no \"Easy\" questions on this site, besides the ones that are only meant to introduce people with no coding experience to the site. Easy just means it\\'s easy for someone who already knows the concepts involved with solving the question. If you have no clue what prefix sum is, then of course you won\\'t be able to solve this. If you don\\'t know how to generate a Fibonacci sequence in your language, and also don\\'t understand dynamic programming, then of course you won\\'t be able to do the Climbing Stairs problem, etc.\\n\\nThink of solving an algorithm like end of chapter tests in textbooks. You wouldn\\'t expect to be able to complete them without knowing the material that came before it, and algorithms are the same way. If you are totally stumped, it likely just means that there is some underlying concept that you are missing. Your goal should be to learn the concepts, and put your learning to the test with the algorithm. Not simply solving a problem.\\n\\nHere\\'s a hint: Go to the \"Related Topics\" section, and Google the topics they list. This doesn\\'t always work, but I have found it vital in gaining an understanding of the concepts within the problem."
                    },
                    {
                        "username": "puneetchhabra",
                        "content": "IG you haven\\'t practiced well while learning concepts. Don\\'t worry, understand solution and come back and try after 2 weeks without looking at solution. repeat until you can do it without looking at solution.  It happens to great coders as well. The solution just doesn\\'t click in mind. It happens, Just don\\'t stop."
                    },
                    {
                        "username": "joesus",
                        "content": "It gets easier. A high tolerance for feeling like a moron is an essential soft skill in programming. Give yourself credit for practicing algorithms in your free time."
                    },
                    {
                        "username": "velnon",
                        "content": "Don't quit. I was also stuck in terms of coding for a while, what helped me was to start using pen and paper to figure out the logic first and then trying to code it. I have ADHD and I kept forgetting what I was thinking about when I tried to do all of it in my head. Maybe you also think better that way, try it. "
                    },
                    {
                        "username": "DaHomie",
                        "content": "[@meltyblend](/meltyblend) Peak advice fr fr "
                    },
                    {
                        "username": "meltyblend",
                        "content": "If you cant solve it learn to understand the solution so you solve it in the future \\n"
                    },
                    {
                        "username": "Sparsh_kanak",
                        "content": "Can Someone please explain Can I code without oops in cpp ? Why doesn\\'t this leetcode accepts codes that way?\\n"
                    },
                    {
                        "username": "chembetikarunakar",
                        "content": "many tech companies online test code editor will be like this only actually this is so simple it may take a week that\\'s it even if u learn slowly.."
                    },
                    {
                        "username": "Naman_Chhabra",
                        "content": "C is for that\\n"
                    },
                    {
                        "username": "user2065yT",
                        "content": "it is beacuse most big tech uses oop as the model for software development, it can be a good way to orienting oneself toward oop  model"
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "While coding, this problem in c, i am unable to understand what this return size argument is?\\nIm new to coding."
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "[@j0rd4n](/j0rd4n) Bruh the comment beside it literally says to replace sizeof(result)."
                    },
                    {
                        "username": "j0rd4n",
                        "content": "Thanks for clearing this up. However, I don\\'t think you want to do *returnSize = sizeof(result); it seems to want the number of elements in the returned array. So instead use *returnSize = numsSize;"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "It\\u2019s for the caller function to determine the size of your returned result.\\n\\nRight before you return your result array, add this:\\n\\n    *returnSize = sizeof(result); // replace sizeof(result) with the size of your result array\\n    return result;\\n\\nSee also https://leetcode.com/problems/squares-of-a-sorted-array/solutions/1429040/solved-c-program-no-error-gives-output-on-array-ops-977/"
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "I coded this solution in Python, not C, and am not very familiar with C. But to comment concerning your question as to what the parameter is for, I am assuming the int* returnSize is used for an malloc(), as malloc() needs a size argument sent to it. If the returned array must be malloced, then it could be that the int* returnSize is for the purpose of an malloc() for the returned array."
                    },
                    {
                        "username": "31703it",
                        "content": "Even I had that same doubt;"
                    },
                    {
                        "username": "LeonMoreno",
                        "content": "Is there anyone who has done it in c? (......, int* returnSize) cannot be a return number, it is a pointer."
                    },
                    {
                        "username": "cc672012",
                        "content": "It\\'s the number of elements in the returned array"
                    },
                    {
                        "username": "Eman800",
                        "content": "me too\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/running-sum-of-1d-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Separate Space\n\n  \n**Approach 2:** Using Input Array for Output\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I am a bit confused of the third parameter of the function in C.\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n\\nWhy is there a returnSize out there? Is not it same as the nunSize?"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "Kota_lalala",
                        "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Running Sum of 1d Array.\\nMemory Usage: 2.7 MB, less than 89.64% of Go online submissions for Running Sum of 1d Array.\\n\\'\\'\\'\\n\\n\\tfunc runningSum(nums []int) []int {\\n\\n\\t\\tfor i:=1; i<len(nums); i++ {\\n\\t\\t\\tnums[i] += nums[i-1]\\n\\t\\t}\\n\\t\\treturn nums\\n\\n\\t}\\n\\'\\'\\'"
                    },
                    {
                        "username": "Loi17072001",
                        "content": "Nice"
                    },
                    {
                        "username": "johnidm",
                        "content": "My final solutions one-line code in Python using list comprehensions. \n\n```\nreturn [ sum(nums[:i+1]) for i in range(len(nums)) ]\n```\n"
                    },
                    {
                        "username": "coder_mverma",
                        "content": "The problem statement is quick easier and it might relevant to out daily programming activity. We can use a,ny approach as per the programming language. Sometimes, you might need to write a little long or small code to execute the operation. \n\nIn JavaScript, to get stick on the save side against the infinite loop, I prefer to create variables. As you can see the approach below.\n\n```\n// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n\nvar runningSum = function(nums) {\n  \n  let temp = 0, arrTemp = [];\n  \n  for (let i = 0; i < nums.length; i++){\n    temp += nums[i]\n    arrTemp.push(temp)\n  }    \n  return arrTemp\n};\n\nconst nums = [1,2,3,4];\nconsole.log(runningSum(nums))\n```\nI am 100% sure and confident that we have other more appropriate approaches/algorithms than mine, however, yes it depends on every individual use case.\n\nPlease add you comment with questions or feedback, I would welcome!"
                    },
                    {
                        "username": "nguyenhoanglapit",
                        "content": "[@CoderBoii](/CoderBoii)  \\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n        for(int i =1 ;i < nums.length; i++){\\n            nums[i] = nums[i-1] + nums[i];\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "CoderBoii",
                        "content": "Do you know how to do this in Java?"
                    },
                    {
                        "username": "Scorpio_Rising",
                        "content": "So I believe that this is now broken. My code works perfectly, but the return in C says that it gets \"]\" as an output. Now, my code could (it doesn\\'t) have a mistake....      BUT if I just `return 4` and it says that I returned \"[]\" then something is weird"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    }
                ]
            },
            {
                "id": 1984312,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1809740,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1681772,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1803170,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1773245,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1752181,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 1576953,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 2062008,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 2020940,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 2018805,
                "content": [
                    {
                        "username": "dariolabrador",
                        "content": "** REMINDER**\\nFor all absolute beginners like me,\\nLearn to identify whether it\\'s a logical error or a syntax error. This may sound obvious for most, but if your solution throws an error, it could be due to a symbol in the wrong place. And therefore, it could be the reason why you think you are a bad programmer. \\nJust do some research on the methods you want for your solution, and you will be much closer to your goal. \\nTake care yall :)"
                    },
                    {
                        "username": "AlaSaiHarsha",
                        "content": "Hey Guys here is the java code \\nif u are struck\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "cc672012",
                        "content": "For C, you can do it in place without having to `malloc` the new array.\\n\\n```\\nint* runningSum(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize; // This is the size of the runningSum array. It does not matter for our solution\\n                                            // but our code will fail if we do not set this.\\n    for (int i = 0; i < numsSize; ++i) {\\n        nums[i] = i ? nums[i] + nums[i - 1] : nums[i];\\n    }\\n    return nums;\\n}\\n```"
                    },
                    {
                        "username": "John-Wayne",
                        "content": "I got same problem without assigning *returnSize."
                    },
                    {
                        "username": "Drako_Rexon",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        vector<int> ans;\\n        for (int i=0; i<nums.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<=i; j++) {\\n                sum += nums[j];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "Hey, your code is logically correct, but for it automatically starts from 0 but we have to start it from first element. Thats why sum = nums[i];"
                    },
                    {
                        "username": "kmfahey",
                        "content": "So, the wrap-up bar graph display. Am I right that my python solution is being compared to submissions in languages other than python?"
                    },
                    {
                        "username": "akashnagar10",
                        "content": "EASY C++ SOLUTION\\n\\nvector<int> runningSum(vector<int>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "Tom_PB",
                        "content": "def runningSum(self, nums: List[int]) -> List[int]:\\n\\treturn [num+sum(nums[:i]) for i, num in enumerate(nums)]"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "damn i feel like a chad i solved it fast lol, for my solution i just use an variable that gonna hold the sum, something like this sum += nums[i], and I made a new array that is gonna hold the sum result and thats it "
                    },
                    {
                        "username": "machodave",
                        "content": "oh lord"
                    },
                    {
                        "username": "farfromweak413",
                        "content": "This is my second problem after adding two numbers and I have seen C tutorials and am familiar with most of the C concepts some times I need to take a look at my notes but still I can code most of the beginners program but here I am just unable to first of all understand what variable is for what use the code that I wrote is this  `your inline code...your inline code...`\\nand in line 7 it is saying insufficient space so are other problems on this site the same type cause if so then I find it very hard that I would be able to practice here it is kinda frustating as sometimes I think it is just because I\\'m not using Vsc that these problems are happening.\\nShould I practice here or are there some other easier sites.I\\'m also exploring some sites on my own "
                    },
                    {
                        "username": "SaadMohammed",
                        "content": "try solving basic qs from hackerrank or go with strivers a2z dsa course\\n"
                    }
                ]
            },
            {
                "id": 2014818,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1999939,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1979798,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1958614,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1952949,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1949707,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1939996,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1915618,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1906122,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1905304,
                "content": [
                    {
                        "username": "riteshpatil_01",
                        "content": "why it is giving memory limit exceeded error?"
                    },
                    {
                        "username": "erenyeager1",
                        "content": "i dont get it , what is the argument int* retrunsize? \\ni get that *num is the array ant numsize is the num size hahah\\nbut what is the retrunsize exactly? is a pointer but for what? \\nand what should i retrun ? a pointer to the running sum array or what?? its really unclear!!"
                    },
                    {
                        "username": "mrgarg01",
                        "content": "Time Complexity =O(n) , Space complexity = O(n)\\nThis question is super easy \\n\\nfollow these step :\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int temp = nums[0];\\n        int arr[]= new int [n];\\n        arr[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            arr[i]= temp+nums[i];\\n            temp = arr[i];\\n        }\\n        return arr;\\n    }\\n}[leetcode](https://leetcode.com) [@LeetCode](/LeetCode) `your inline code...your inline code...`\\n"
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "Is there better way to solve this problem without using a 2nd array ?\\nplz help me .."
                    },
                    {
                        "username": "syntaxtee",
                        "content": "public static int[] runningSum(int[] nums){\\nint sum = 0;\\nfor (int i = 0; i < nums.length; i++) {\\nsum = sum + nums[i];\\nnums[i] = sum;\\n}\\nreturn nums;\\n}\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "codefreak10",
                        "content": "Can anyone give me some hints and ideas in building my logic?\\nI stuck at the easiest problems, although i do get the knack of how to solve the problem but unable to approach it practically on my own."
                    },
                    {
                        "username": "syntaxtee",
                        "content": " public static int[] runningSum(int[] nums){\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            nums[i] = sum;\\n        }\\n        return nums;\\n    }\\n\\nThis is the solution.\\nThe logic lies in returning sum of previous index for each index.\\nSay i have 1 ,2 ,8.\\nFirst iteration should be 0+1;\\nSecond iteration should be sum of first iteration plus second index which is (0+1) + 2 in this instance\\nWhile making sure every item at each index is a sum of previous index say."
                    },
                    {
                        "username": "liuzheng1990",
                        "content": "I think the question should state whether it\\'s acceptable for user to mutate the `nums` parameter. It makes a huge difference for spatial complexity."
                    },
                    {
                        "username": "SumanKumarSP",
                        "content": "The problem statement has below constraints to check the value of nums[i];\\n\\nConstraints:\\n-10^6 <= nums[i] <= 10^6\\n\\nHow can we check if the value of nums[i] falls within this range in c programming?"
                    },
                    {
                        "username": "sarath480",
                        "content": "loop over the array and then add the elements from the first index to current index in another loop "
                    },
                    {
                        "username": "Scientifik",
                        "content": "I got the answer to this right away but I have a question about the big O space complexity. I chose the in place solution when solving it myself because I figured it would have better space complexity due to not creating an additional array. However when I watched the video answer to this after solving it I was surprised to find the space complexity to the answer when making an array to hold all the values and then returning it was also O(1). \\n\\nThings like this is where big O trips me up. When you make a new array to hold as many values as the input array why wouldn\\'t you need space complexity of O(n)? Is this because of garbage collection? \\n\\nFor example let\\'s say you ran that code on a total potato and that computer only had 1.5n total memory space where n was the size of the array you were trying to work with. You create a list of size n so now you are left with .5n memory. You now run that through the function which makes a new array to store the value. When we are in this function wouldn\\'t we run out of memory as we are filling the new array with values because the scope we are in would hold both the input array to the function which is called and now an array that is being filled by the logic of our loop?"
                    }
                ]
            },
            {
                "id": 1896444,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1890406,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1842630,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1842299,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1826099,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1820889,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1810967,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1807373,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1804374,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1795633,
                "content": [
                    {
                        "username": "Vertfromage",
                        "content": "Since Java is call by sharing wouldn\\'t that mean that the original nums array would be modified outside the method and therefore not the best practice unless you wanted to overwrite the original array? I thought it was bad practice to modify the imputed variables?"
                    },
                    {
                        "username": "taganrog85",
                        "content": "in Python I wrote my solution like this, but it writes that it is not correct\\nnums = [1, 2, 3, 4]\\nrunningSum = []\\ncount = 0\\ncount1 = 0\\nfor i in nums:\\n    count += i\\n    count1 = count\\n    runningSum.append(count1)\\nprint(runningSum)\\n"
                    },
                    {
                        "username": "ajay8766",
                        "content": "very easy"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`li = [sum(i) for i in accounts]\\n        return max(li)`"
                    },
                    {
                        "username": "syedsubhan0304",
                        "content": "i didn\\'t understand their question what it said!\\n"
                    },
                    {
                        "username": "Ursma",
                        "content": "Explain me, please, why in Intelliji IDEA this code works, but in this console: error: variable nums is already defined in method runningSum(int[])\n        int[] nums ={1, 3, 5, 7, 8};\nMy code:\n public class Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 3, 5, 7, 8};\n        int[] runningSum = new int[nums.length];\n        int sum = 0;\n        for (int i = 0; i < runningSum.length; i++) {\n            sum += nums[i];\n            runningSum[i] += sum;\n            System.out.println(runningSum[i]);\n        }\n    }\n}"
                    },
                    {
                        "username": "ygg-m",
                        "content": "My code works (solution is there, posting only to show that it works in other places): https://jsfiddle.net/nf1r5vg2/\\n\\nBut it\\'s throwing me this error: https://i.imgur.com/jfwRCOd.png\\n\\nAnyone know what\\'s happening?"
                    },
                    {
                        "username": "shuubhhaammm",
                        "content": "why i am not able to use return in this question"
                    },
                    {
                        "username": "RagulTK",
                        "content": "I got desired output  both these logic which is (nums[i]=nums[i]+nums[i-1]) and also (nums[i]+=nums[i-1])...But i got a undesired output even i wrote the code wrongly (i.e) (nums[i]=+nums[i-1]).....i also got a desired the output when i was using+=+ these combinaton of operator......what am i asking is? why i got output when i wrote code wrongly........Actaully\\nwhat happens on operators..Can you anyone please clear my doubt.  "
                    },
                    {
                        "username": "Nithish_kumar_S",
                        "content": "int* runningSum(int* nums, int numsSize, int* returnSize){\\nint i;\\nfor (i=1;i<numsSize;i++)\\n{\\n    nums[i]=+nums[i-1];\\n}\\nreturn nums;\\n}\\nwhats wrong with the above code the output is simply \"[ ]\""
                    }
                ]
            },
            {
                "id": 1791336,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1787393,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1786541,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1784928,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1783728,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1782379,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1777632,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1776455,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1775283,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1773303,
                "content": [
                    {
                        "username": "Arif1_2",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        \\n       int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        \\n        return nums;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            su=sum(nums[0:i+1])\\n            k.append(su)\\n        return k"
                    },
                    {
                        "username": "AzuSumiye",
                        "content": "Chat gpt said the answer to this question is \\n\\ndef runningSum(nums):\\n    running_sum = []\\n    current_sum = 0\\n    for num in nums:\\n        current_sum += num\\n        running_sum.append(current_sum)\\n    return running_sum\\n yet it turns up runtime error. rip chat gpt"
                    },
                    {
                        "username": "Sudharsan07",
                        "content": "JAVA 0 ms Solution\\n\\npublic int[] runningSum(int[] nums) {\\n        for(int i = 1 ; i < nums.length ; i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        return nums;\\n    }"
                    },
                    {
                        "username": "sureshHariharan",
                        "content": "A simple and efficient solution: (with 0 ms runtime)\n\n\nclass Solution {\n    public int[] runningSum(int[] nums) {\n    int temp=0;\n        for(int i=0;i<nums.length;i++){\n\n            nums[i]=temp+nums[i];\n            temp=nums[i]; \n    }\n    return nums;\n}\n}"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% fast in java || very easy\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sanithshetty41",
                        "content": "this solution ran in 0ms\\n\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n            arr[i]=nums[i]+sum;\\n            sum=arr[i];\\n\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "iamdhev",
                        "content": "Hi I am getting wrong answer due to below output, please help me\\n\\nExpected\\n[3,4,6,16,17]\\nStdout\\n[3, 4, 6, 16, 17]"
                    },
                    {
                        "username": "nikhilalugu",
                        "content": "I have a query ,In the solution for python how to take the list input "
                    },
                    {
                        "username": "Maharshi92",
                        "content": "Simple one loop solution\\n\\n ```public int[] runningSum(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        int sum =0;\\n        for (int i =0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }```"
                    }
                ]
            },
            {
                "id": 1771326,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1767854,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1764216,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1762095,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1760564,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1757942,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1749729,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1748704,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1744779,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1741988,
                "content": [
                    {
                        "username": "shrutisisodiya2021",
                        "content": "Here\\'s my solution to this problem! \\n\\n`class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n       int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums[i]=sum;\\n        }\\n        return nums;\\n    }\\n};`"
                    },
                    {
                        "username": "feed0",
                        "content": "Updating/overriding the input seems faster, but In which real cases that wouldn\\u2019t result in any further problems? That is, do you any real case where the input is somehow disposable?"
                    },
                    {
                        "username": "bansi_32",
                        "content": "My first solution took O(n2) as I came up with the following solution:\n`int arr[]=new int[nums.length];`\n        `arr[0]=nums[0];`\n       ` int ans=0;`\n        `for(int j=1;j<nums.length;j++)`\n        `{`\n          `  int i=0;`\n           ` ans=0`;\n            `while(i<=j)`\n            `{`\n                `ans+=nums[i++];`\n           ` }`\n           ` arr[j]=ans;`\n       ` }`"
                    },
                    {
                        "username": "bansi_32",
                        "content": "Following is my optimized solution:\\nint arr[]=new int[nums.length];\\n        arr[0]=nums[0];\\n        int ans=arr[0];\\n        for(int j=1;j<nums.length;j++)\\n        {\\n            ans+=nums[j];\\n            arr[j]=ans;\\n        }"
                    },
                    {
                        "username": "sajidalijhu",
                        "content": "hi i am a beginner so do not know whether it is an optimized code or not so my suggestion is that read the question properly you need sum(num[0]...num[i])\\nthat mean you have to add the previous elements so store it in a variable and add it to appropriate index."
                    },
                    {
                        "username": "saurabh_1975",
                        "content": " vector<int> runningSum(vector<int>& nums) {\\n        vector<int>res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n            res.push_back(nums[i] + res[res.size()-1]);\\n        return res;\\n    }"
                    },
                    {
                        "username": "SriyaKan",
                        "content": "Hi. When I read the problem description, I didn't think we would be allowed to modify nums and instead took the approach of creating a new array to store the running sums. But I get an IndexError: list assignment index out of range with this code: Can someone help me figure out why I get this error?\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [] \n        for i in range(len(nums)):\n            result[i] = nums[i]\n        for i in range(len(result) - 1):\n            result[i + 1] += result[i]\n        return result"
                    },
                    {
                        "username": "Squeky_squirrel",
                        "content": "why adding {} in for loop makes my code wrong. "
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def runningSum(self, nums: List[int]) -> List[int]:\\n        a = 0\\n        for i in range(len(nums)):\\n            nums[i] = nums[i] + a\\n            a = nums[i]\\n        return nums"
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": "def runningSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return [reduce(lambda x, y: x+y, nums[:x+1]) for x in range(len(nums))]"
                    },
                    {
                        "username": "mc1350",
                        "content": "For anyone using Kotlin trying to use runningFold or scan:\\n\\n LeetCode has not updated Kotlin for a long time and the version is pre runningFold and scan"
                    }
                ]
            },
            {
                "id": 1741464,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1741426,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1737364,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1736257,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1734300,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1732627,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1728780,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1726005,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1723628,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1719413,
                "content": [
                    {
                        "username": "PrateekDoliya",
                        "content": "OPTIMISED JAVA CODE\\nTime Complexity = O(n)\\nclass Solution {\\n    public int[] runningSum(int[] nums) {\\n        int n = nums.length;\\n        int sum[] = new int[n];\\n        sum[0] = nums[0];\\n        for(int i=1 ; i < n ; i++) {\\n            sum[i] = sum[i-1] + nums[i]; \\n        }\\n        return sum;\\n    }\\n}\\n "
                    },
                    {
                        "username": "abhishtt2110",
                        "content": "Easy Solution in Java\\n`class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum =0;\\n        int n= nums.length;\\n        int[] sums = new int[n];\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            sums[i]=sum;\\n        }\\n        return sums;\\n    }\\n}`"
                    },
                    {
                        "username": "LordOfDeadbush",
                        "content": "A fun challenge is to only use one variable in the solution: The solution vector. "
                    },
                    {
                        "username": "helloabhi004",
                        "content": "//I want to solve this problem using C language but can\\'t seem to find proper solution to it please help?\\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n    for (int i=0; i<numsSize; i++){\\n        returnSize= nums[i] + nums[i+1];\\n        printf(\"%d\", returnSize);\\n    }\\n}\\n\\nint main(){\\n    int nums, size, arr[];\\n    arrSize=(int returnSize*)malloc(sizeof(int returnSize));\\n    printf(\"\\\\nEnter the size of array\\\\n\");\\n    scanf(\"%d\",&size);\\n    for(int i=0; i<size; i++){\\n        printf(\"Enter the element\\\\n\")\\n        scanf(\"%d\", &arr[num]);\\n    }\\n    printf(\"Output:\", runningSum(arr[num], size, returnSize));\\n} "
                    },
                    {
                        "username": "durveshpal538",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n        int sum = nums[0];\\n        int n = nums.size();\\n        for(int i=1; i<n;i++)\\n        {\\n            nums[i] =nums[i]+sum ;\\n            sum  = nums[i];\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Krishnkant_singh",
                        "content": "The problem statement is pretty easy and understandable. I will tell you how you can do it through iterative approach. My solution came in at 4ms.\\nHere we will use for loop and will add element in a variable iteratively and store it an another vector and then we will return it.\\n\\nfor(int i =0; i<n; i++){\\n          sum = sum + nums[i];\\n          arrtemp.push_back(sum);\\n      } \\n      \\n"
                    },
                    {
                        "username": "BhushanBK",
                        "content": "//in JAVA\npublic int[] runningSum(int[] nums) {\n        int[] ans=new int[nums.length];\n        for(int i=0;i<nums.length;i++)\n            ans[i]=sum(nums,i);\n        return ans;\n    }\n    public int sum(int[] num,int end){\n        int sum=0;\n        for(int i=0;i<=end;i++)\n            sum+=num[i];\n        return sum;\n\n    }"
                    },
                    {
                        "username": "saarthakmadaan",
                        "content": "class Solution(object):\\n    def runningSum(self, nums):\\n        for i in range(len(nums)-1):\\n            nums[i+1]+= nums[i]\\n        return nums"
                    },
                    {
                        "username": "abdulbasitkhan2733",
                        "content": "how can i solve this problem please help me."
                    },
                    {
                        "username": "Eagle_eye",
                        "content": "class Solution {\\npublic:\\n    vector<int> runningSum(vector<int>& nums) {\\n     for(auto it=nums[i].begin;it!=nums[i].end();it++)\\n     {\\n         int i=0,z=0;\\n         vector<int> xrr[100];\\n         z=z+*it\\n         xrr[i].push_back(z);\\n         i=i+1;\\n     }   \\n    }\\n    return xrr;\\n};\\n\\nI dont know what is the problem in this code , the error is in return type but I tried all the method plz let me know :)"
                    }
                ]
            },
            {
                "id": 1718528,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1717424,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1716453,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1715558,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1715006,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1707902,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1707761,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1704405,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1693943,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            },
            {
                "id": 1693335,
                "content": [
                    {
                        "username": "savkul",
                        "content": "Compile Error\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> runningSum(vector<int> nums) {\\n\\n\\n        vector<int> runningSum;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i = i + 1)\\n        sum = sum + nums[i];\\n        runningSum.push_back(sum);\\n        cout << \"i = \" << i << \" nums[i] = \"; <<nums[i] << \"; sum = \" << sum << endl;\\n     }\\n     return runningSum;\\n};\\n"
                    },
                    {
                        "username": "ugiun1059",
                        "content": "Hello all, I am using C++, but how can we check the members of the class vector?"
                    },
                    {
                        "username": "Yani02",
                        "content": "Hy  i have a solution in c that works in replit but not in leet code ????? did you know why ?\\n\\n\\n \\n"
                    },
                    {
                        "username": "Yani02",
                        "content": "there is my solution : \\nint* runningSum(int* nums, int numsSize, int* returnSize){\\n     int *m = malloc(sizeof(int)*numsSize);\\n    m[0]=nums[0];\\nfor(int i = 1; numsSize; i++){\\n    m[i]=nums[i]+m[i-1];\\n}\\nreturn m;\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "***************************************************************\\nPython Working Code:\\n\\n[ sum ( nums [ : i+1 ] ) for i in range ( len ( nums ) ) ]\\n\\n**************************************************************"
                    },
                    {
                        "username": "tanishq16",
                        "content": "Is the best optimal solution has TC = O(n) and SC = O(n)?? or is there any more optimal soln.\\n"
                    },
                    {
                        "username": "pawankumar100",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=0;\\n        int[]ans= new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n}\\n \\n        \\n    \\n"
                    },
                    {
                        "username": "gentleman_ghost",
                        "content": "While coding the solution in C the judge seems not to read any value from the array. I declare the  `int* ret` array then allocate memory to it `malloc(numsSize * sizeof(int)` . Then after completing the task I get info that the array is empty, even though I check it while the program runs and I can print out every element of it. Output I get is:  `]`"
                    },
                    {
                        "username": "ce81245ff9f3",
                        "content": "Hello, please see https://leetcode.com/problems/running-sum-of-1d-array/discussion/comments/1779362"
                    },
                    {
                        "username": "umar630492866",
                        "content": "class Solution {\\n    public int[] runningSum(int[] nums) {\\n        int sum=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n            {\\n\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                nums[i]=sum;\\n            }\\n        }\\n        return nums;\\n    }\\n}"
                    },
                    {
                        "username": "Ajmal_ali",
                        "content": "This approach is in javaScript\\nvar runningSum = function(nums) {\\n    let sum = 0\\n    for(let i=0; i<nums.length; i++){\\n        sum += nums[i]\\n        nums[i] = sum\\n    }\\n    return nums\\n};\\nSpace complexity O(1)"
                    },
                    {
                        "username": "SunayanaT",
                        "content": "For a solution in Java, why is it taking 0ms when you use for loop and 1ms when you use while loop for the same code? Is while loop faster than for loop? I know that it depends on compiler and running background processes if any. Although, I wanted to know if there is any specific reason for the same."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Subarray Min-Product",
        "question_content": "<p>The <strong>min-product</strong> of an array is equal to the <strong>minimum value</strong> in the array <strong>multiplied by</strong> the array&#39;s <strong>sum</strong>.</p>\n\n<ul>\n\t<li>For example, the array <code>[3,2,5]</code> (minimum value is <code>2</code>) has a min-product of <code>2 * (3+2+5) = 2 * 10 = 20</code>.</li>\n</ul>\n\n<p>Given an array of integers <code>nums</code>, return <em>the <strong>maximum min-product</strong> of any <strong>non-empty subarray</strong> of </em><code>nums</code>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>Note that the min-product should be maximized <strong>before</strong> performing the modulo operation. Testcases are generated such that the maximum min-product <strong>without</strong> modulo will fit in a <strong>64-bit signed integer</strong>.</p>\n\n<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,<u>2,3,2</u>]\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).\n2 * (2+3+2) = 2 * 7 = 14.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,<u>3,3</u>,1,2]\n<strong>Output:</strong> 18\n<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).\n3 * (3+3) = 3 * 6 = 18.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,<u>5,6,4</u>,2]\n<strong>Output:</strong> 60\n<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).\n4 * (5+6+4) = 4 * 15 = 60.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1198718,
                "title": "java-python-stack-keeps-index-of-elements-less-than-nums-i-o-n",
                "content": "**Idea**\\n- `ans = 0`\\n- For each element `nums[i]` in array `nums`:\\n\\t- We treat `nums[i]` as minimum number in subarray which includes `nums[i]`\\n\\t- `ans = max(ans, nums[i] * getSum(left_bound_index, right_bound_index))`\\n\\t- `left_bound_index`: index of the farthest element greater or equal to `nums[i]` in the left side\\n\\t- `right_bound_index`: index of the farthest element greater or equal to `nums[i]` in the right side\\n- How to build `left_bound/right_bound` array which store index of the farthest element greater or equal to `nums[i]` in the left side or in the right side?\\n\\t- Use stack `st` which keeps index of elements less than `nums[i]` so far\\n\\t- For `i` in `[0..n-1]`:\\n\\t\\t- Pop all elements from `st` which are greater or equal to `nums[i]`\\n\\t\\t- If `st` is not empty: `left_bound[i]` = `st[-1] + 1` (because `st[-1]` is index of the nearest element smaller than `nums[i]`)\\n\\t\\t- else: `left_bound[i]` = `0` (because there is no element smaller than `nums[i]` so far)\\n\\t\\t- Add `i` to `st`\\n\\n<iframe src=\"https://leetcode.com/playground/L87Hqcpk/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**Idea**\\n- `ans = 0`\\n- For each element `nums[i]` in array `nums`:\\n\\t- We treat `nums[i]` as minimum number in subarray which includes `nums[i]`\\n\\t- `ans = max(ans, nums[i] * getSum(left_bound_index, right_bound_index))`\\n\\t- `left_bound_index`: index of the farthest element greater or equal to `nums[i]` in the left side\\n\\t- `right_bound_index`: index of the farthest element greater or equal to `nums[i]` in the right side\\n- How to build `left_bound/right_bound` array which store index of the farthest element greater or equal to `nums[i]` in the left side or in the right side?\\n\\t- Use stack `st` which keeps index of elements less than `nums[i]` so far\\n\\t- For `i` in `[0..n-1]`:\\n\\t\\t- Pop all elements from `st` which are greater or equal to `nums[i]`\\n\\t\\t- If `st` is not empty: `left_bound[i]` = `st[-1] + 1` (because `st[-1]` is index of the nearest element smaller than `nums[i]`)\\n\\t\\t- else: `left_bound[i]` = `0` (because there is no element smaller than `nums[i]` so far)\\n\\t\\t- Add `i` to `st`\\n\\n<iframe src=\"https://leetcode.com/playground/L87Hqcpk/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 1198896,
                "title": "o-n-monostack-with-picture",
                "content": "I came up with 3 different solutions for this problem, but they did not work (WA or TLE). I got the intuition that we need a monostack, but somehow it was hard for me to comprehend.\\n\\nWe store elements in a stack `st` in a non-decreasing order. When we need to remove an element `j` from the stack, it means:\\n- Elements from `j` to `i - 1` are all greater than `j`.\\n- Elements after the new top of the stack iare all greater than `j`.\\n\\nTherefore, we can multiply the current element `j` to the sum of all elements between the new top of the stack and `i`. In the example shown on the following picture, you can see that when we remove element `4` from the stack, we sum numbers between `1` (new top of the stack) and `2` (which is `i`).\\n\\n![image](https://assets.leetcode.com/users/images/b00b2dd4-b795-4ca1-a0c3-902cf3b7559c_1620686543.4356697.png)\\n\\nFinally, we use a partial sum array `dp` to efficiently compute sum between elements `j` and `i`.\\n\\n**C++**\\nTo make it simple, we will store indexes of elements, as we can get their values from the original array. Note that we remove all remaining elements from the stack when `i = n.size()` in the second loop.\\n\\n```cpp\\nint maxSumMinProduct(vector<int>& n) {\\n    long res = 0;\\n    vector<long> dp(n.size() + 1), st;\\n    for (int i = 0; i < n.size(); ++i)\\n       dp[i + 1] = dp[i] + n[i];\\n    for (int i = 0; i <= n.size(); ++i) {\\n        while (!st.empty() && (i == n.size() || n[st.back()] > n[i])) {\\n            int j = st.back();\\n            st.pop_back();\\n            res = max(res, n[j] * (dp[i] - dp[st.empty() ? 0 : st.back() + 1]));\\n        }\\n        st.push_back(i);\\n    }\\n    return res % 1000000007;\\n}\\n```\\n**Java**\\n```java\\npublic int maxSumMinProduct(int[] n) {\\n    Stack<Integer> st = new Stack<>();\\n    long dp[] = new long[n.length + 1], res = 0;\\n    for (int i = 0; i < n.length; ++i)\\n       dp[i + 1] = dp[i] + n[i];\\n    for (int i = 0; i <= n.length; ++i) {\\n        while (!st.empty() && (i == n.length || n[st.peek()] > n[i])) {\\n            int j = st.pop();\\n            res = Math.max(res, (dp[i] - dp[st.empty() ? 0 : st.peek() + 1]) * n[j]);\\n        }\\n        st.push(i);\\n    }\\n    return (int)(res % 1000000007);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint maxSumMinProduct(vector<int>& n) {\\n    long res = 0;\\n    vector<long> dp(n.size() + 1), st;\\n    for (int i = 0; i < n.size(); ++i)\\n       dp[i + 1] = dp[i] + n[i];\\n    for (int i = 0; i <= n.size(); ++i) {\\n        while (!st.empty() && (i == n.size() || n[st.back()] > n[i])) {\\n            int j = st.back();\\n            st.pop_back();\\n            res = max(res, n[j] * (dp[i] - dp[st.empty() ? 0 : st.back() + 1]));\\n        }\\n        st.push_back(i);\\n    }\\n    return res % 1000000007;\\n}\\n```\n```java\\npublic int maxSumMinProduct(int[] n) {\\n    Stack<Integer> st = new Stack<>();\\n    long dp[] = new long[n.length + 1], res = 0;\\n    for (int i = 0; i < n.length; ++i)\\n       dp[i + 1] = dp[i] + n[i];\\n    for (int i = 0; i <= n.length; ++i) {\\n        while (!st.empty() && (i == n.length || n[st.peek()] > n[i])) {\\n            int j = st.pop();\\n            res = Math.max(res, (dp[i] - dp[st.empty() ? 0 : st.peek() + 1]) * n[j]);\\n        }\\n        st.push(i);\\n    }\\n    return (int)(res % 1000000007);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198708,
                "title": "c-simple-solution-using-stacks-explained",
                "content": "The main idea is \\n*  As we want to find min-product, calculating minimum number from all sub arrays gives us **TLE**\\n*  So what we do is, we consider `nums[i]` where `0<=i< n`, as min element and find the min-products of subarrays with minimum as `nums[i]`.\\n* First we find the `prefix sum` of given array.\\n*  Then we find the **number of largest numbers** to the left in \"array left\" and number of largest numbers to the right in  \"array right\" with `nums[i]` as minimum.\\n*  After finding that, now its become simple, as we know the length of sub array with `nums[i]` as minimum.\\n* To get starting index a, `a = i-left[i]+1`, and ending index `b = i+right[i]-1`.\\n*  Then process the `res`, as we know the sum of subarray as we have `prefix sum` and minimum element is `nums[i]`.\\n*  Update the `res` by finding `maximum of min-product`.\\n\\n\\n**DO UPVOTE if you fnd it helpful!!**\\n```\\nint maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int left[n], right[n];\\n        long long int sum[n];\\n        sum[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            sum[i] = sum[i-1]+nums[i];\\n        }\\n        stack<pair<int, int> > s1, s2;\\n        for (int i = 0; i < n; ++i) {\\n            int cnt = 1;\\n            while (!s1.empty() && (s1.top().first) > nums[i]) {\\n                cnt += s1.top().second;\\n                s1.pop();\\n            }\\n            s1.push({ nums[i], cnt });\\n            left[i] = cnt;\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            int cnt = 1;\\n            while (!s2.empty() && (s2.top().first) >= nums[i]) {\\n                cnt += s2.top().second;\\n                s2.pop();\\n            }\\n\\n            s2.push({ nums[i], cnt });\\n            right[i] = cnt;\\n        }\\n        long long int res =0;\\n        for(int i=0;i<n;i++){\\n            int a = i-left[i]+1;\\n            int b = i+right[i]-1;\\n            long long int subArraySum;\\n            if(a>0)\\n                subArraySum = sum[b]-sum[a-1];\\n            else\\n                subArraySum = sum[b];\\n            res = max(res, subArraySum*nums[i]);\\n        }\\n        return res%1000000007;\\n    }\\n```\\n**Any improments in the code is highly encouraged!! Comment down below !!**",
                "solutionTags": [],
                "code": "```\\nint maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int left[n], right[n];\\n        long long int sum[n];\\n        sum[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            sum[i] = sum[i-1]+nums[i];\\n        }\\n        stack<pair<int, int> > s1, s2;\\n        for (int i = 0; i < n; ++i) {\\n            int cnt = 1;\\n            while (!s1.empty() && (s1.top().first) > nums[i]) {\\n                cnt += s1.top().second;\\n                s1.pop();\\n            }\\n            s1.push({ nums[i], cnt });\\n            left[i] = cnt;\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            int cnt = 1;\\n            while (!s2.empty() && (s2.top().first) >= nums[i]) {\\n                cnt += s2.top().second;\\n                s2.pop();\\n            }\\n\\n            s2.push({ nums[i], cnt });\\n            right[i] = cnt;\\n        }\\n        long long int res =0;\\n        for(int i=0;i<n;i++){\\n            int a = i-left[i]+1;\\n            int b = i+right[i]-1;\\n            long long int subArraySum;\\n            if(a>0)\\n                subArraySum = sum[b]-sum[a-1];\\n            else\\n                subArraySum = sum[b];\\n            res = max(res, subArraySum*nums[i]);\\n        }\\n        return res%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198670,
                "title": "max-rectangular-in-histogram-with-prefix-sum-python3-o-n",
                "content": "This problem is very similar to the max rectangular in histogram. 84  https://leetcode.com/problems/largest-rectangle-in-histogram/\\nJust replace the \"width\" with the subarray sum, which can be obtained by prefix sum in O(1) time.\\nAnd take care of the boundary conditions...\\n\\nNotice that leetcode 84 was \"hard\". Now this is hard + prefix sum twist, and is only \"medium\". \\nWow, the time has evolved... I am breathless trying to keep up.\\n\\nMonotonic stack solutions are very hard to grasp because there is a lot \"dynamic and delay in time\" going on for the stack. \\n**The following intuitions may be helpful to recognize when to use it.**\\nIt is very useful to get \"next bigger item\", \"next smaller item\", \"previous bigger item\", \"previous smaller item\" and therefore \"window max\" and \"window min\". \\nTo get the next **bigger** item, need to use monotonic **decreasing** stack, and the ans is obtained for each item when popping.\\nTo get the next **smaller** item, need to use monotonic **increasing** stack, and the ans is obtained for each item when popping.\\nTo get the prev **bigger** item, need to use monotonic **decreasing** stack, and the ans is obtained for the enqueueing item at the top of the stack.\\nTo get the prev **smaller** item, need to use monotonic **increasing** stack, and the ans is obtained for the enqueueing item at the top of the stack.\\n\\nTherefore, the left and right boundary for \"window max\" and \"window min\" are obtained. \\n\\nThe above relationship is assuming looping forwards. \\nIf looping backwards, the relationship will be \"reversed\". Sorry, it is quite interesting but easily confused. Correct me if I am wrong...\\n\\n```\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n\\t\\t#apply some tricks to simplify the boundary condition checking.\\n\\t\\t#the first -1 makes sure the mono_stack is never empty; the last -1 make sure every element will be popped and computed\\n        nums = [-1] + nums + [-1] \\n        mono_stack = [0] # mono increasing \\n        ans = 0\\n        prefix = [0]\\n        for n in nums:\\n            prefix.append(prefix[-1]+n)\\n            \\n        for i, n in enumerate(nums[1:],1):\\n            while n < nums[mono_stack[-1]]:\\n                left = mono_stack.pop()\\n                psum = prefix[i] - prefix[mono_stack[-1]+1] # important to +1 here... it is non inclusive boundary\\n                height = nums[left]\\n                ans = max(ans, psum*height )\\n            \\n            mono_stack.append(i)\\n        \\n        return ans%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n\\t\\t#apply some tricks to simplify the boundary condition checking.\\n\\t\\t#the first -1 makes sure the mono_stack is never empty; the last -1 make sure every element will be popped and computed\\n        nums = [-1] + nums + [-1] \\n        mono_stack = [0] # mono increasing \\n        ans = 0\\n        prefix = [0]\\n        for n in nums:\\n            prefix.append(prefix[-1]+n)\\n            \\n        for i, n in enumerate(nums[1:],1):\\n            while n < nums[mono_stack[-1]]:\\n                left = mono_stack.pop()\\n                psum = prefix[i] - prefix[mono_stack[-1]+1] # important to +1 here... it is non inclusive boundary\\n                height = nums[left]\\n                ans = max(ans, psum*height )\\n            \\n            mono_stack.append(i)\\n        \\n        return ans%(10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1198704,
                "title": "c-python-3-monostack-explanation-with-picture-o-n-time",
                "content": "For each number ```nums[i]``` in nums, we calculate how many **consecutive** numbers **no less** than ```nums[i]``` are on its left ```lft``` and on its right ```rgt```. \\n\\nThen, the Min-Product for **this number nums[i]** equals to the ```nums[i] * (lft + rgt + 1)```, since ```lft``` and ```rgt``` are calculated excluse ```nums[i]```, we have to add ```1``` to the total number standing for ```nums[i]``` itself.\\n\\nTake the picture below as an example.\\n![image](https://assets.leetcode.com/users/images/cf7317b7-e276-4151-9af4-0273585c588c_1620532928.1806393.png)\\nFor ```nums[3]```, we can find ```2``` numbers on its left (starting from ```nums[3]``` exclusively) which are no less than ```nums[3]```, and ```1``` number on its right exclusively, so the **segment with minimum number of nums[3] has length of 2 + 1 + 1 = 4**, this can be done by keeping a monotonic array.\\n\\n\\n![image](https://assets.leetcode.com/users/images/f6a14899-5dfb-446f-affe-7244d1004fa0_1620532938.484092.png)\\nThe sum of subarray can be done by getting the presum array of ```nums```, and the Min-product is ```nums[i] * presum[i + rgt + 1] - presum[i - lft]```\\n\\n#### Python 3\\n```\\ndef maxSumMinProduct(self, nums: List[int]) -> int:\\n        n, ans, mod = len(nums), 0, 10 ** 9 + 7\\n        \\n        lft, st = [0], [[nums[0], 0]]       #how many valid numbers on its left \\n        for i in range(1, n):\\n            cur = 0\\n            while st and nums[i] <= st[-1][0]:\\n                cur += st.pop()[1] + 1\\n            st.append([nums[i], cur])\\n            lft.append(cur)\\n\\n        rgt, st = [0], [[nums[-1], 0]]               #how many valid numbers on its right \\n        for i in range(n - 2, -1, -1):\\n            cur = 0\\n            while st and nums[i] <= st[-1][0]:\\n                cur += st.pop()[1] + 1\\n            st.append(([nums[i], cur]))\\n            rgt.append(cur)\\n        rgt.reverse()\\n\\n        sums, cur = [0], 0           # presum array\\n        for i in range(n):\\n            cur += nums[i]\\n            sums.append(cur)\\n\\n        for i in range(n):\\n            ans = max(ans, nums[i] * (sums[i + rgt[i] + 1] - sums[i - lft[i]]))\\n\\n        return ans % mod\\n```\\n\\n#### cpp\\n```\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int mod = 1000000007;\\n        int n = nums.size();\\n        int lft[n], rgt[n];\\n        long long int sum[n + 1];\\n        sum[0] = 0;\\n        for (int i = 1; i < n + 1; i++)\\n        {\\n            sum[i] = sum[i - 1] + nums[i - 1];\\n        }\\n\\n        stack<pair<int, int>> s1, s2;        \\n        lft[0] = 0;\\n        s1.push({nums[0], 0});\\n        for (int i = 1; i < n; i++)\\n        {\\n            int cur = 0;\\n            while(!s1.empty() && (s1.top().first) >= nums[i])\\n            {\\n                cur += s1.top().second + 1;\\n                s1.pop();\\n            }\\n            s1.push({nums[i], cur});\\n            lft[i] = cur;\\n        }\\n        \\n        rgt[n - 1] = 0;\\n        s2.push({nums[n - 1], 0});\\n        for (int i = n - 2; i > -1; i--)\\n        {\\n            int cur = 0;\\n            while(!s2.empty() && (s2.top().first) >= nums[i])\\n            {\\n                cur += s2.top().second + 1;\\n                s2.pop();\\n            }\\n            s2.push({nums[i], cur});\\n            rgt[i] = cur;\\n        }\\n\\n        long long int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans = max(ans, nums[i] * (sum[i + rgt[i] + 1] - sum[i - lft[i]]));\\n        }\\n        return ans % mod;           \\n    }\\n```",
                "solutionTags": [],
                "code": "```nums[i]```\n```nums[i]```\n```lft```\n```rgt```\n```nums[i] * (lft + rgt + 1)```\n```lft```\n```rgt```\n```nums[i]```\n```1```\n```nums[i]```\n```nums[3]```\n```2```\n```nums[3]```\n```nums[3]```\n```1```\n```nums```\n```nums[i] * presum[i + rgt + 1] - presum[i - lft]```\n```\\ndef maxSumMinProduct(self, nums: List[int]) -> int:\\n        n, ans, mod = len(nums), 0, 10 ** 9 + 7\\n        \\n        lft, st = [0], [[nums[0], 0]]       #how many valid numbers on its left \\n        for i in range(1, n):\\n            cur = 0\\n            while st and nums[i] <= st[-1][0]:\\n                cur += st.pop()[1] + 1\\n            st.append([nums[i], cur])\\n            lft.append(cur)\\n\\n        rgt, st = [0], [[nums[-1], 0]]               #how many valid numbers on its right \\n        for i in range(n - 2, -1, -1):\\n            cur = 0\\n            while st and nums[i] <= st[-1][0]:\\n                cur += st.pop()[1] + 1\\n            st.append(([nums[i], cur]))\\n            rgt.append(cur)\\n        rgt.reverse()\\n\\n        sums, cur = [0], 0           # presum array\\n        for i in range(n):\\n            cur += nums[i]\\n            sums.append(cur)\\n\\n        for i in range(n):\\n            ans = max(ans, nums[i] * (sums[i + rgt[i] + 1] - sums[i - lft[i]]))\\n\\n        return ans % mod\\n```\n```\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int mod = 1000000007;\\n        int n = nums.size();\\n        int lft[n], rgt[n];\\n        long long int sum[n + 1];\\n        sum[0] = 0;\\n        for (int i = 1; i < n + 1; i++)\\n        {\\n            sum[i] = sum[i - 1] + nums[i - 1];\\n        }\\n\\n        stack<pair<int, int>> s1, s2;        \\n        lft[0] = 0;\\n        s1.push({nums[0], 0});\\n        for (int i = 1; i < n; i++)\\n        {\\n            int cur = 0;\\n            while(!s1.empty() && (s1.top().first) >= nums[i])\\n            {\\n                cur += s1.top().second + 1;\\n                s1.pop();\\n            }\\n            s1.push({nums[i], cur});\\n            lft[i] = cur;\\n        }\\n        \\n        rgt[n - 1] = 0;\\n        s2.push({nums[n - 1], 0});\\n        for (int i = n - 2; i > -1; i--)\\n        {\\n            int cur = 0;\\n            while(!s2.empty() && (s2.top().first) >= nums[i])\\n            {\\n                cur += s2.top().second + 1;\\n                s2.pop();\\n            }\\n            s2.push({nums[i], cur});\\n            rgt[i] = cur;\\n        }\\n\\n        long long int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans = max(ans, nums[i] * (sum[i + rgt[i] + 1] - sum[i - lft[i]]));\\n        }\\n        return ans % mod;           \\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1198782,
                "title": "c-o-n-time-next-smaller-element",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Next Smaller Element\\n\\n**Intuition**: For a given number `A[i]`, we only care about the subarray `[p + 1, q - 1]` where `p` and `q` are the index to the previous and next smaller element.\\n\\n\\n**Why do we use the next/previous smaller element as the boundary?**:\\nFor example:\\n\\n```\\n 0 1 2 3 4 5 // index\\n[3,1,5,6,4,2] // value\\n```\\n\\nFor `A[1] = 1`, it\\'s the smallest value of the entire array. So we should use the sum of the entire array.\\n\\nFor `A[5] = 2`, it\\'s the second smallest value. We won\\'t want to extend the subarray to index `1` because then the minimum value will become `1` and fall back to the previous case. So we only use subarray `[5,6,4,2]`.\\n\\nSimilarly, for other numbers. In essense, we don\\'t want to go over the previous/next smaller element.\\n\\n**Algorithm**:\\n\\n1. Store prefix sum in `sum` array.\\n2. Store the indexes to the previous/next smaller element into `prev`/`next` array. \\n3. For `A[i]`, the max product including it is `A[i] * SUM(prev[i] + 1, next[i] - 1)` where `SUM(i, j)` is the sum of subarray `A[i..j]`.\\n\\nFor \"how to get the next smaller element\", check out the mono-stack solutions to [496. Next Greater Element I (Easy)](https://leetcode.com/problems/next-greater-element-i/)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-subarray-min-product/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& A) {\\n        long long mod = 1e9+7, N = A.size(), ans = 0;\\n        vector<long long> sum(N + 1); // prefix sum\\n        for (int i = 0; i < N; ++i) sum[i + 1] = sum[i] + A[i];\\n        vector<int> prev(N, -1), next(N, -1); // prev[i]/next[i] is the index to the previous/next smaller element\\n        vector<int> s; // a stack.\\n        for (int i = 0; i < N; ++i) { // compute the index to the previous smaller elements\\n            while (s.size() && A[s.back()] >= A[i]) s.pop_back();\\n            if (s.size()) prev[i] = s.back();\\n            s.push_back(i);\\n        }\\n        s.clear();\\n        for (int i = N - 1; i >= 0; --i) { // compute the index to the next smaller elements\\n            while (s.size() && A[s.back()] >= A[i]) s.pop_back();\\n            if (s.size()) next[i] = s.back();\\n            s.push_back(i);\\n        }\\n        for (int i = 0; i < N; ++i) {\\n            long long s = next[i] == -1 ? sum.back() : sum[next[i]];\\n            if (prev[i] != -1) {\\n                s -= sum[prev[i] + 1];\\n            }\\n            ans = max(ans, (long long) A[i] * s);\\n        }\\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n 0 1 2 3 4 5 // index\\n[3,1,5,6,4,2] // value\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-subarray-min-product/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& A) {\\n        long long mod = 1e9+7, N = A.size(), ans = 0;\\n        vector<long long> sum(N + 1); // prefix sum\\n        for (int i = 0; i < N; ++i) sum[i + 1] = sum[i] + A[i];\\n        vector<int> prev(N, -1), next(N, -1); // prev[i]/next[i] is the index to the previous/next smaller element\\n        vector<int> s; // a stack.\\n        for (int i = 0; i < N; ++i) { // compute the index to the previous smaller elements\\n            while (s.size() && A[s.back()] >= A[i]) s.pop_back();\\n            if (s.size()) prev[i] = s.back();\\n            s.push_back(i);\\n        }\\n        s.clear();\\n        for (int i = N - 1; i >= 0; --i) { // compute the index to the next smaller elements\\n            while (s.size() && A[s.back()] >= A[i]) s.pop_back();\\n            if (s.size()) next[i] = s.back();\\n            s.push_back(i);\\n        }\\n        for (int i = 0; i < N; ++i) {\\n            long long s = next[i] == -1 ? sum.back() : sum[next[i]];\\n            if (prev[i] != -1) {\\n                s -= sum[prev[i] + 1];\\n            }\\n            ans = max(ans, (long long) A[i] * s);\\n        }\\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198678,
                "title": "java-stack-time-o-n",
                "content": "For this problem, we want to use each number in `nums` as `min` value. And expand to both left and right. On the right we want to find the first index that is smaller than `nums[i]`. And similar for left, we want to find the first index on the left whose corresponding value  is smaller than `nums[i]`. \\n\\nWe use stack to get both the first left index and first right index.\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        //for this problem, we can quickly know the sum of an subarray with prefix sum array\\n        //so the difficult point is how to get the min value for each array very quickly\\n        //we can use segment tree\\n        //but this still O(N^2), since you will find for each pair of [i, j]\\n        //we can focus on each number in nums, let it be the min and we expand from this number to right and to left\\n        //we want to ask what is the first number on the right that is smaller than this number\\n        //and what is the first number on the left that is smaller than this number\\n        int n = nums.length;\\n        int mod = (int)(1e9 + 7);\\n        if (n == 1) return (int)(((long)nums[0] * (long)nums[0]) % mod);\\n        int[] left = new int[n];\\n        Stack<Integer> st = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            while (!st.isEmpty() && nums[st.peek()] >= nums[i]) {\\n                st.pop();\\n            }\\n            if (st.isEmpty()) left[i] = -1;\\n            else left[i] = st.peek();\\n            st.add(i);\\n        }\\n        int[] right = new int[n];\\n        st = new Stack<>();\\n        for (int i = n-1; i >= 0; i--) {\\n            while (!st.isEmpty() && nums[st.peek()] >= nums[i]) {\\n                st.pop();\\n            }\\n            if (st.isEmpty()) right[i] = n;\\n            else right[i] = st.peek();\\n            st.add(i);\\n        }\\n\\n        long res = 0L;\\n        long[] preSum = new long[n];\\n        preSum[0] = (long)nums[0];\\n        for (int i = 1; i < n; i++) {\\n            preSum[i] = preSum[i-1] + (long)nums[i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            long sum = left[i] == -1 ? preSum[right[i]-1] : preSum[right[i]-1] - preSum[left[i]];\\n            long cur = (long)nums[i] * sum;\\n            res = Math.max(cur, res);\\n        }\\n        return (int)(res % mod);\\n    }\\n}\\n```\\n\\nSimilar Stack problems:\\n\\n1. https://leetcode.com/problems/largest-rectangle-in-histogram/\\n2. https://leetcode.com/problems/sum-of-subarray-minimums/\\n3. https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/\\n4. https://leetcode.com/problems/sliding-window-maximum/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        //for this problem, we can quickly know the sum of an subarray with prefix sum array\\n        //so the difficult point is how to get the min value for each array very quickly\\n        //we can use segment tree\\n        //but this still O(N^2), since you will find for each pair of [i, j]\\n        //we can focus on each number in nums, let it be the min and we expand from this number to right and to left\\n        //we want to ask what is the first number on the right that is smaller than this number\\n        //and what is the first number on the left that is smaller than this number\\n        int n = nums.length;\\n        int mod = (int)(1e9 + 7);\\n        if (n == 1) return (int)(((long)nums[0] * (long)nums[0]) % mod);\\n        int[] left = new int[n];\\n        Stack<Integer> st = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            while (!st.isEmpty() && nums[st.peek()] >= nums[i]) {\\n                st.pop();\\n            }\\n            if (st.isEmpty()) left[i] = -1;\\n            else left[i] = st.peek();\\n            st.add(i);\\n        }\\n        int[] right = new int[n];\\n        st = new Stack<>();\\n        for (int i = n-1; i >= 0; i--) {\\n            while (!st.isEmpty() && nums[st.peek()] >= nums[i]) {\\n                st.pop();\\n            }\\n            if (st.isEmpty()) right[i] = n;\\n            else right[i] = st.peek();\\n            st.add(i);\\n        }\\n\\n        long res = 0L;\\n        long[] preSum = new long[n];\\n        preSum[0] = (long)nums[0];\\n        for (int i = 1; i < n; i++) {\\n            preSum[i] = preSum[i-1] + (long)nums[i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            long sum = left[i] == -1 ? preSum[right[i]-1] : preSum[right[i]-1] - preSum[left[i]];\\n            long cur = (long)nums[i] * sum;\\n            res = Math.max(cur, res);\\n        }\\n        return (int)(res % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198695,
                "title": "c-a-follow-up-of-standard-histogram-area-problem",
                "content": "This is the followup of standard largest area rectangle in histogram problem (https://leetcode.com/problems/largest-rectangle-in-histogram/)\\nOnly change to be done is in last \\'for loop\\' where we have to take the sum of the rectangular bars to be included instead of just taking width of the rectangle.\\n\\nLets say you have array 2 1 3 4 7 2 5. You need to calculate to each nums[i] the size of its window such that it is the smallest element. So the window sizes are as follows: 1 7 3 2 1 4 1. This can be calculated using the method shown in histogram problem or use two arrays Left and Right (which I prefer) to find smallest element on the right and left of a number at index I. Then use prefix sums to find max over all elements.\\n(Thanks @amk1214 for the explanation)\\n\\n*DO UPVOTE if you fnd it helpful!!*\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& heights) {\\n        const unsigned int M = 1000000007;\\n        vector<int> left,right;\\n        stack<pair<int,int>> s;\\n        int n=heights.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(s.size()==0) right.push_back(n);\\n            else if(s.size()>0 && s.top().first<heights[i]) right.push_back(s.top().second);\\n            else if(s.size()>0 && s.top().first>=heights[i]){\\n                while(s.size()>0 && s.top().first>=heights[i]) s.pop();\\n                if(s.size()==0) right.push_back(n);\\n                else right.push_back(s.top().second);\\n            }\\n            s.push({heights[i],i});\\n        }\\n        reverse(right.begin(), right.end());\\n        \\n        stack<pair<int,int>> s1;\\n        for(int i=0;i<n;i++){\\n            if(s1.size()==0) left.push_back(-1);\\n            else if(s1.size()>0 && s1.top().first<heights[i]) left.push_back(s1.top().second);\\n            else if(s1.size()>0 && s1.top().first>=heights[i]){\\n                while(s1.size()>0 && s1.top().first>=heights[i]) s1.pop();\\n                if(s1.size()==0) left.push_back(-1);\\n                else left.push_back(s1.top().second);\\n            }\\n            s1.push({heights[i],i});\\n        }\\n        long long int area=0;\\n        vector<long long int> sum(n,0);\\n        sum[0]=heights[0]%M;\\n        for(int i=1;i<n;i++){\\n            sum[i]= (sum[i-1] +heights[i]);\\n            // sum[i]%=M;\\n            // cout<<sum[i]<<\" \";\\n        }\\n        // cout<<endl;\\n        for(int i=0;i<n;i++){\\n            // cout<<right[i]<<\" \"<<left[i]<<\"   \";\\n            long long int s;\\n            if(left[i]==-1) s=0;\\n            else s=sum[left[i]];\\n            long long int curr= (heights[i] *(sum[right[i]-1]-s));\\n            // int curr=0;\\n            area = max(area,curr);\\n            // area=area%M;\\n        }\\n        // cout<<endl;\\n        return area%M;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& heights) {\\n        const unsigned int M = 1000000007;\\n        vector<int> left,right;\\n        stack<pair<int,int>> s;\\n        int n=heights.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(s.size()==0) right.push_back(n);\\n            else if(s.size()>0 && s.top().first<heights[i]) right.push_back(s.top().second);\\n            else if(s.size()>0 && s.top().first>=heights[i]){\\n                while(s.size()>0 && s.top().first>=heights[i]) s.pop();\\n                if(s.size()==0) right.push_back(n);\\n                else right.push_back(s.top().second);\\n            }\\n            s.push({heights[i],i});\\n        }\\n        reverse(right.begin(), right.end());\\n        \\n        stack<pair<int,int>> s1;\\n        for(int i=0;i<n;i++){\\n            if(s1.size()==0) left.push_back(-1);\\n            else if(s1.size()>0 && s1.top().first<heights[i]) left.push_back(s1.top().second);\\n            else if(s1.size()>0 && s1.top().first>=heights[i]){\\n                while(s1.size()>0 && s1.top().first>=heights[i]) s1.pop();\\n                if(s1.size()==0) left.push_back(-1);\\n                else left.push_back(s1.top().second);\\n            }\\n            s1.push({heights[i],i});\\n        }\\n        long long int area=0;\\n        vector<long long int> sum(n,0);\\n        sum[0]=heights[0]%M;\\n        for(int i=1;i<n;i++){\\n            sum[i]= (sum[i-1] +heights[i]);\\n            // sum[i]%=M;\\n            // cout<<sum[i]<<\" \";\\n        }\\n        // cout<<endl;\\n        for(int i=0;i<n;i++){\\n            // cout<<right[i]<<\" \"<<left[i]<<\"   \";\\n            long long int s;\\n            if(left[i]==-1) s=0;\\n            else s=sum[left[i]];\\n            long long int curr= (heights[i] *(sum[right[i]-1]-s));\\n            // int curr=0;\\n            area = max(area,curr);\\n            // area=area%M;\\n        }\\n        // cout<<endl;\\n        return area%M;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2363116,
                "title": "javao-n-one-pass-only-13ms-99-55-49-9mb-memo-100",
                "content": "Please upvote if you find this Solution helpful, thank you!\\nWe only need 1 monotonic decreasing stack to get both the left and right boundary of each min value. (i.e. each value in array)\\n\\nThis is very similar to:\\n[2104. Sum of Subarray Ranges](https://leetcode.com/problems/sum-of-subarray-ranges/)\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)\\n```java\\nclass Solution {\\n    public int maxSumMinProduct(int[] a) {\\n        int n = a.length, M = 1_000_000_007;\\n        long res = 0L;\\n\\n        //step 1; get prefixs um\\n        long [] psum = new long[n + 1];\\n        for(int i = 0; i < n; i++) psum[i+1] = psum[i] + a[i];\\n\\n        //step 2: get the left and right bound of each sub-array using mono deceasing & increasing stack\\n        int[] s = new int[n];\\n        int top = -1; // mono-decreasing for right bound\\n        for (int i = 0; i <= n; s[++top] = i++)\\n            while (top >= 0 && (i == n || a[i] < a[s[top]])) {\\n                int min = a[s[top--]]; // get curMin value and poll current index out of stack, it\\'s left and right bouldary is not determined\\n                int l = top == -1 ? 0 : s[top] + 1; // use the prev idx to get left bound, inclusive\\n                int r = i - 1; // right bound, inclusive\\n                res = Math.max(res, min * (psum[r+1] - psum[l]));\\n            }\\n\\n        return (int) (res % M);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumMinProduct(int[] a) {\\n        int n = a.length, M = 1_000_000_007;\\n        long res = 0L;\\n\\n        //step 1; get prefixs um\\n        long [] psum = new long[n + 1];\\n        for(int i = 0; i < n; i++) psum[i+1] = psum[i] + a[i];\\n\\n        //step 2: get the left and right bound of each sub-array using mono deceasing & increasing stack\\n        int[] s = new int[n];\\n        int top = -1; // mono-decreasing for right bound\\n        for (int i = 0; i <= n; s[++top] = i++)\\n            while (top >= 0 && (i == n || a[i] < a[s[top]])) {\\n                int min = a[s[top--]]; // get curMin value and poll current index out of stack, it\\'s left and right bouldary is not determined\\n                int l = top == -1 ? 0 : s[top] + 1; // use the prev idx to get left bound, inclusive\\n                int r = i - 1; // right bound, inclusive\\n                res = Math.max(res, min * (psum[r+1] - psum[l]));\\n            }\\n\\n        return (int) (res % M);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208707,
                "title": "interview-friendly-solution-and-java-impl",
                "content": "It took me a few looks to identify this is the same problem as max rect in histrogram.\\n\\nI know there is a famous stack-based solution for that and each time that took me a while to re-understand, and I\\'m not 100% comfortable with that yet, thus I cannot say I can re-come up with the stack solution in interview and explain it clearly.\\n\\nHowever I came up below solution since years ago and applied it a few times. It\\'s like parent finding for Union Find, but this is not Union Find. By the look it should have time complexity O(NlogN) but in reality it is always very fast and out-perform O(N) solutions. I got no mathematical proof why, but probably like fast sort, it\\'s just fast in real life with simple data structures and linear operatons.\\n\\nThe idea is,\\n**Consider every position as the min value of a subarray, what is the longest subarray we can form?**\\n\\n1. Find the nearest position to the left that is smaller than current position\\n2. Find the nearest position to the right that is smaller than current position\\n3. Get the subarray (inbetween above 2 positions) sum with presums\\n4. Got a candidate, keep the max candidate\\n\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int N = nums.length;\\n        \\n        // First smaller value to the left\\n        int[] left = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            int prev = i - 1;\\n            while (prev >= 0 && nums[prev] >= nums[i]) prev = left[prev];\\n            left[i] = prev;\\n        }\\n        \\n        // First smaller value to the right\\n        int[] right = new int[N];\\n        for (int i = N - 1; i >= 0; i--) {\\n            int next = i + 1;\\n            while (next < N && nums[next] >= nums[i]) next = right[next];\\n            right[i] = next;\\n        }\\n        \\n        // PreSums\\n        long[] sums = new long[N + 1];\\n        for (int i = 0; i < N; i++) sums[i + 1] = sums[i] + nums[i];\\n        \\n        // Find min-prod\\n        long ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            int l = left[i];\\n            int r = right[i];\\n            long sum = sums[r] - sums[l + 1];\\n            ans = Math.max(ans, sum * nums[i]);\\n        }\\n        return (int)(ans % 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int N = nums.length;\\n        \\n        // First smaller value to the left\\n        int[] left = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            int prev = i - 1;\\n            while (prev >= 0 && nums[prev] >= nums[i]) prev = left[prev];\\n            left[i] = prev;\\n        }\\n        \\n        // First smaller value to the right\\n        int[] right = new int[N];\\n        for (int i = N - 1; i >= 0; i--) {\\n            int next = i + 1;\\n            while (next < N && nums[next] >= nums[i]) next = right[next];\\n            right[i] = next;\\n        }\\n        \\n        // PreSums\\n        long[] sums = new long[N + 1];\\n        for (int i = 0; i < N; i++) sums[i + 1] = sums[i] + nums[i];\\n        \\n        // Find min-prod\\n        long ans = 0;\\n        for (int i = 0; i < N; i++) {\\n            int l = left[i];\\n            int r = right[i];\\n            long sum = sums[r] - sums[l + 1];\\n            ans = Math.max(ans, sum * nums[i]);\\n        }\\n        return (int)(ans % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242498,
                "title": "most-efficient-solution-c",
                "content": "```\\n int maxSumMinProduct(vector<int>& nums) {\\n      vector<long>preSum, left(nums.size(), -1), right(nums.size(), nums.size());\\n     int n = nums.size();\\n     preSum.push_back(0);\\n\\t \\n\\t //Getting perfix sum of given array to reduce complexity by avoiding recalculation \\n     for (int i = 0; i < nums.size(); i++)\\n        preSum.push_back(preSum.back() + nums[i]);\\n\\n    // Storing previous smaller element index in left array\\n\\t stack<int>st;\\n     for (int i = 0; i < nums.size(); i++) {\\n     while (!st.empty() && nums[i] <= nums[st.top()])\\n        st.pop();\\n     if (!st.empty())\\n        left[i] = st.top();\\n     st.push(i);\\n  }\\n   // Storing next smaller element index in right array\\n  st = stack<int>();\\n     for (int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t  while (!st.empty() && nums[i] <= nums[st.top()])\\n\\t\\t  st.pop();\\n    if (!st.empty())\\n\\t\\t  right[i] = st.top();\\n    st.push(i);\\n  }\\n\\n  long ans = 0, mod = 1e9 + 7;\\n\\n//finally calculating the contribution of each element\\n  for (int i = 0; i < nums.size(); i++) {\\n\\t\\tlong t = (preSum[right[i]] - preSum[left[i] + 1]) * nums[i];\\n\\t\\tans = max(ans, t);\\n  }\\n\\n  return ans % mod; \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\n int maxSumMinProduct(vector<int>& nums) {\\n      vector<long>preSum, left(nums.size(), -1), right(nums.size(), nums.size());\\n     int n = nums.size();\\n     preSum.push_back(0);\\n\\t \\n\\t //Getting perfix sum of given array to reduce complexity by avoiding recalculation \\n     for (int i = 0; i < nums.size(); i++)\\n        preSum.push_back(preSum.back() + nums[i]);\\n\\n    // Storing previous smaller element index in left array\\n\\t stack<int>st;\\n     for (int i = 0; i < nums.size(); i++) {\\n     while (!st.empty() && nums[i] <= nums[st.top()])\\n        st.pop();\\n     if (!st.empty())\\n        left[i] = st.top();\\n     st.push(i);\\n  }\\n   // Storing next smaller element index in right array\\n  st = stack<int>();\\n     for (int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t  while (!st.empty() && nums[i] <= nums[st.top()])\\n\\t\\t  st.pop();\\n    if (!st.empty())\\n\\t\\t  right[i] = st.top();\\n    st.push(i);\\n  }\\n\\n  long ans = 0, mod = 1e9 + 7;\\n\\n//finally calculating the contribution of each element\\n  for (int i = 0; i < nums.size(); i++) {\\n\\t\\tlong t = (preSum[right[i]] - preSum[left[i] + 1]) * nums[i];\\n\\t\\tans = max(ans, t);\\n  }\\n\\n  return ans % mod; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198800,
                "title": "python3-mono-stack",
                "content": "\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = 0 \\n        stack = []\\n        for i, x in enumerate(nums + [-inf]): # append \"-inf\" to force flush all elements\\n            while stack and stack[-1][1] >= x: \\n                _, xx = stack.pop()\\n                ii = stack[-1][0] if stack else -1 \\n                ans = max(ans, xx*(prefix[i] - prefix[ii+1]))\\n            stack.append((i, x))\\n        return ans % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = 0 \\n        stack = []\\n        for i, x in enumerate(nums + [-inf]): # append \"-inf\" to force flush all elements\\n            while stack and stack[-1][1] >= x: \\n                _, xx = stack.pop()\\n                ii = stack[-1][0] if stack else -1 \\n                ans = max(ans, xx*(prefix[i] - prefix[ii+1]))\\n            stack.append((i, x))\\n        return ans % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386041,
                "title": "c-tc-o-n-sc-o-n",
                "content": "# Feel free to post your doubts in comment section\\n# Stacks | Prefix Sum | Next Min on Left & Right\\n* For every element we will try to find the best ans, i.e. considering every ith element as minimum, how much we can extend the subarray to left and right ?\\n*This made me to find left and right minimum*\\n\\n* Now we can find the subarray sum between left min and right min index, how to optimise this ? \\n*This made me to go for prefix sum.*\\n\\nGive it a like if it helped you !\\n```\\nclass Solution {\\npublic:\\n    void nextMinOnLeft( vector<int>& A, vector<int> &leftMin){ \\n        stack<int> s;\\n        int n=A.size();\\n        for( int i=n-1; i>=0; i-- ){\\n            while( !s.empty() && A[s.top()] > A[i] ){\\n                leftMin[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n    }\\n    void nextMinOnRight( vector<int>& A, vector<int> &rightMin ){\\n        stack<int> s;\\n        int n=A.size();\\n        for( int i=0; i<n; i++ ){\\n            while( !s.empty() && A[s.top()] > A[i] ){\\n                rightMin[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n    }\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<long long> ps( n, 0 );\\n        vector<int> leftMin( n, -1 );\\n        vector<int> rightMin( n, n );\\n        nextMinOnLeft( nums, leftMin );\\n        nextMinOnRight( nums, rightMin );\\n        for(int i=0; i<n; i++){\\n            if(i==0){ps[i]=nums[0]; continue;}\\n            ps[i] = ps[i-1]+nums[i];\\n        }\\n        long long ans = 0;\\n        for(int i=0; i<n; i++){\\n            int lm = leftMin[i];\\n            int rm = rightMin[i];\\n            long long temp = 1ll*nums[i]*(1ll)*( ps[rm-1]-ps[lm+1]+nums[lm+1] );\\n            ans = max( ans, temp );\\n        }\\n        ans%=1000000007;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextMinOnLeft( vector<int>& A, vector<int> &leftMin){ \\n        stack<int> s;\\n        int n=A.size();\\n        for( int i=n-1; i>=0; i-- ){\\n            while( !s.empty() && A[s.top()] > A[i] ){\\n                leftMin[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n    }\\n    void nextMinOnRight( vector<int>& A, vector<int> &rightMin ){\\n        stack<int> s;\\n        int n=A.size();\\n        for( int i=0; i<n; i++ ){\\n            while( !s.empty() && A[s.top()] > A[i] ){\\n                rightMin[s.top()] = i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n    }\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<long long> ps( n, 0 );\\n        vector<int> leftMin( n, -1 );\\n        vector<int> rightMin( n, n );\\n        nextMinOnLeft( nums, leftMin );\\n        nextMinOnRight( nums, rightMin );\\n        for(int i=0; i<n; i++){\\n            if(i==0){ps[i]=nums[0]; continue;}\\n            ps[i] = ps[i-1]+nums[i];\\n        }\\n        long long ans = 0;\\n        for(int i=0; i<n; i++){\\n            int lm = leftMin[i];\\n            int rm = rightMin[i];\\n            long long temp = 1ll*nums[i]*(1ll)*( ps[rm-1]-ps[lm+1]+nums[lm+1] );\\n            ans = max( ans, temp );\\n        }\\n        ans%=1000000007;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213831,
                "title": "c-simple-solution-using-union-find-o-n-explained",
                "content": "So what we do is \\n\\n* Calculating all sub arrays and finding their min gives us TLE\\n* So what we do is,\\n* we consider nums[i] where 0<=i< n, as min element and find the min-products of subarrays with minimum as nums[i].\\n* First we compute and store the prefix sum of given array.\\n* Then for every nums[i] for 0<=i<n\\n* We find the index of the first element smaller than nums[i] in the left subarray and store it in **left** and the index of the first smaller element in the right subarray and store it in **right**.\\n\\n   for array [3,1,5,6,4,2] : pre_sum = [3, 4, 9, 15, 19, 21] , left = [-1, -1, 1, 2, 1, 1] , right = [6, 5, 4, 4, 6, 1]\\n   \\n* Now, we just traverse the array and for every nums[i] where 0<=i<n we calculate the min-product and store in res and maximum of them is stored in gmax.\\n* return gmax % 1000000007\\n\\n   PLEASE UPVOTE IF YOU FIND IT HELPFUL!\\n   \\n   C++ Code:\\n   \\n```\\nclass Solution {\\npublic:\\n#define lli long long int\\n    \\n    int findmin(int idx, int cur, vector<int>& minidx, vector<int>& n){  \\n        if(idx == -1 || idx == n.size())\\n            return idx;\\n        if(n[idx] < n[cur])\\n            return idx;\\n        \\n        return findmin(minidx[idx], cur, minidx, n);\\n            \\n    }\\n    int maxSumMinProduct(vector<int>& n){\\n        \\n        int sz = n.size();\\n        lli sum[sz];\\n        vector<int> left(sz), right(sz);\\n        \\n        sum[0] = n[0];\\n        \\n        for(int i=1;i<n.size();i++)\\n            sum[i] = sum[i-1]+n[i];\\n        \\n        for(int i=0;i<sz;i++)\\n            left[i] = findmin(i-1, i, left, n);\\n        \\n        for(int i=sz-1;i>=0;i--)\\n            right[i] = findmin(i+1, i, right, n);\\n        \\n        lli gmax = INT_MIN;\\n        lli res;\\n        for(int i=0;i<sz;i++){\\n            res = (sum[right[i]-1] - (left[i]>=0?sum[left[i]]:0)) * n[i];\\n            gmax = max(gmax,res);\\n        }\\n        \\n        return gmax%1000000007;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define lli long long int\\n    \\n    int findmin(int idx, int cur, vector<int>& minidx, vector<int>& n){  \\n        if(idx == -1 || idx == n.size())\\n            return idx;\\n        if(n[idx] < n[cur])\\n            return idx;\\n        \\n        return findmin(minidx[idx], cur, minidx, n);\\n            \\n    }\\n    int maxSumMinProduct(vector<int>& n){\\n        \\n        int sz = n.size();\\n        lli sum[sz];\\n        vector<int> left(sz), right(sz);\\n        \\n        sum[0] = n[0];\\n        \\n        for(int i=1;i<n.size();i++)\\n            sum[i] = sum[i-1]+n[i];\\n        \\n        for(int i=0;i<sz;i++)\\n            left[i] = findmin(i-1, i, left, n);\\n        \\n        for(int i=sz-1;i>=0;i--)\\n            right[i] = findmin(i+1, i, right, n);\\n        \\n        lli gmax = INT_MIN;\\n        lli res;\\n        for(int i=0;i<sz;i++){\\n            res = (sum[right[i]-1] - (left[i]>=0?sum[left[i]]:0)) * n[i];\\n            gmax = max(gmax,res);\\n        }\\n        \\n        return gmax%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198686,
                "title": "c-o-n-log-n-greedy-by-pre-sum-and-balanced-tree",
                "content": "Product = min * sum. We can get max product for each min by finding max sum.\\nGreedily iterate min ascendingly, use a balanced tree to maintain the visited mins. So the max sum for each min is the longest adjacent uninterrupted segment which can be find in O(log(n)) using the balanced tree.\\nAlso calculate pre sum in advance to get the sum of intervals.\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        constexpr int mod = 1e9 + 7;\\n        int n = nums.size();\\n        vector<long long int> preSum(nums.size() + 1);\\n        preSum[0] = 0;\\n        vector<pair<int, int>> list(nums.size());\\n        for (int i = 0; i < n; i++) {\\n            preSum[i + 1] = preSum[i] + nums[i];\\n            list[i].first = nums[i];\\n            list[i].second = i;\\n        }\\n        sort(list.begin(), list.end());\\n        set<int> tree;\\n        tree.insert(-1);\\n        tree.insert(n);\\n        long long int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            set<int>::iterator it = tree.upper_bound(list[i].second);\\n            long long int sum = preSum[*it] - preSum[*prev(it) + 1];\\n            result = max(result, list[i].first * sum);\\n            tree.insert(list[i].second);\\n        }\\n        return result % mod;\\n    }\\n};\\n```\\n\\nActually my first intuition is divide and conquer. But the input data can be unbalanced which degrades algorithm to O(n^2) in worst case.\\nWorth mention, though.\\n```\\n// TLE\\nclass Solution {\\n    long long int find(const vector<int> &nums, int start, int end) {\\n        if (start == end) {\\n            return 0;\\n        }\\n        long long int minVal = INT_MAX, sum = 0;\\n        int minIdx;\\n        for (int i = start; i < end; i++) {\\n            sum += nums[i];\\n            if (nums[i] < minVal) {\\n                minVal = nums[i];\\n                minIdx = i;\\n            }\\n        }\\n        long long int result = minVal * sum;\\n        result = max(result, find(nums, start, minIdx));\\n        result = max(result, find(nums, minIdx + 1, end));\\n        return result;\\n    }\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int mod = 1e9 + 7;\\n        return find(nums, 0, nums.size()) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        constexpr int mod = 1e9 + 7;\\n        int n = nums.size();\\n        vector<long long int> preSum(nums.size() + 1);\\n        preSum[0] = 0;\\n        vector<pair<int, int>> list(nums.size());\\n        for (int i = 0; i < n; i++) {\\n            preSum[i + 1] = preSum[i] + nums[i];\\n            list[i].first = nums[i];\\n            list[i].second = i;\\n        }\\n        sort(list.begin(), list.end());\\n        set<int> tree;\\n        tree.insert(-1);\\n        tree.insert(n);\\n        long long int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            set<int>::iterator it = tree.upper_bound(list[i].second);\\n            long long int sum = preSum[*it] - preSum[*prev(it) + 1];\\n            result = max(result, list[i].first * sum);\\n            tree.insert(list[i].second);\\n        }\\n        return result % mod;\\n    }\\n};\\n```\n```\\n// TLE\\nclass Solution {\\n    long long int find(const vector<int> &nums, int start, int end) {\\n        if (start == end) {\\n            return 0;\\n        }\\n        long long int minVal = INT_MAX, sum = 0;\\n        int minIdx;\\n        for (int i = start; i < end; i++) {\\n            sum += nums[i];\\n            if (nums[i] < minVal) {\\n                minVal = nums[i];\\n                minIdx = i;\\n            }\\n        }\\n        long long int result = minVal * sum;\\n        result = max(result, find(nums, start, minIdx));\\n        result = max(result, find(nums, minIdx + 1, end));\\n        return result;\\n    }\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int mod = 1e9 + 7;\\n        return find(nums, 0, nums.size()) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400680,
                "title": "java-standard-monostack-13ms-99-53",
                "content": "TC: O(n), SC: O(n)\\ntwo pass, 1 pass for presum, 2nd pass is the monostack and result calculation\\n```java\\nclass Solution {\\n    public int maxSumMinProduct(int[] a) {\\n        int n = a.length, M = 1_000_000_007;\\n        long res = 0L;\\n\\n        //step 1; get prefixs um\\n        long [] psum = new long[n + 1];\\n        for(int i = 0; i < n; i++) psum[i+1] = psum[i] + a[i];\\n\\n        //step 2: get the left and right bound of each sub-array using mono deceasing & increasing stack\\n        int[] s = new int[n];\\n        int top = -1; // mono-decreasing for right bound\\n        for (int i = 0; i <= n; s[++top] = i++)\\n            while (top >= 0 && (i == n || a[i] < a[s[top]])) {\\n                int min = a[s[top--]]; // get curMin value and poll current index out of stack, it\\'s left and right bouldary is not determined\\n                int l = top == -1 ? 0 : s[top] + 1; // use the prev idx to get left bound \\n                int r = i - 1; // right bound\\n                res = Math.max(res, min * (psum[r+1] - psum[l]));\\n            }\\n\\n        return (int) (res % M);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumMinProduct(int[] a) {\\n        int n = a.length, M = 1_000_000_007;\\n        long res = 0L;\\n\\n        //step 1; get prefixs um\\n        long [] psum = new long[n + 1];\\n        for(int i = 0; i < n; i++) psum[i+1] = psum[i] + a[i];\\n\\n        //step 2: get the left and right bound of each sub-array using mono deceasing & increasing stack\\n        int[] s = new int[n];\\n        int top = -1; // mono-decreasing for right bound\\n        for (int i = 0; i <= n; s[++top] = i++)\\n            while (top >= 0 && (i == n || a[i] < a[s[top]])) {\\n                int min = a[s[top--]]; // get curMin value and poll current index out of stack, it\\'s left and right bouldary is not determined\\n                int l = top == -1 ? 0 : s[top] + 1; // use the prev idx to get left bound \\n                int r = i - 1; // right bound\\n                res = Math.max(res, min * (psum[r+1] - psum[l]));\\n            }\\n\\n        return (int) (res % M);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198655,
                "title": "python-disjoint-set-union-iterate-from-largest-to-smallest",
                "content": "This is a intuition of the process\\n- We iterate from the largest number to the smallest number.\\n- At every iteration, if the adjacent number(s) is larger than the current number, merge it with the adjacent group(s).\\n- After every merge, we update the sum of the group and the minimum value of the group. We update the result if applicable.\\n\\nWe use a disjoint set union to track the group membership. You can get the disjoint set union template from elsewhere.\\n\\nWe use another dictionary to track the current sum of each group.\\n\\n```python\\nclass DisjointSet:\\n    # github.com/not522/ac-library-python/blob/master/atcoder/dsu.py\\n\\n    def __init__(self, n: int = 0) -> None:\\n        self._n = n\\n        self.parent_or_size = [-1]*n\\n\\n    def union(self, a: int, b: int) -> int:\\n        x = self.find(a)\\n        y = self.find(b)\\n\\n        if x == y:\\n            return x\\n\\n        if -self.parent_or_size[x] < -self.parent_or_size[y]:\\n            x, y = y, x\\n\\n        self.parent_or_size[x] += self.parent_or_size[y]\\n        self.parent_or_size[y] = x\\n\\n        return x\\n\\n    def find(self, a: int) -> int:\\n        parent = self.parent_or_size[a]\\n        while parent >= 0:\\n            if self.parent_or_size[parent] < 0:\\n                return parent\\n            self.parent_or_size[a], a, parent = (\\n                self.parent_or_size[parent],\\n                self.parent_or_size[parent],\\n                self.parent_or_size[self.parent_or_size[parent]]\\n            )\\n\\n        return a\\n\\n    def size(self, a: int) -> int:\\n        return -self.parent_or_size[self.leader(a)]\\n\\n\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        \\n        # we begin from the largest number to the smallest number\\n        nums = [0] + nums + [0]\\n        pos = [(x,i) for i,x in enumerate(nums)]\\n        pos.sort()\\n        pos.reverse()\\n        \\n        # we track the result with this variable\\n        maxres = 0\\n        \\n        # we track the membership of each element\\n        # d.find(x) == d.find(y) if x and y are in the same group\\n        d = DisjointSet(len(nums))\\n\\n        # we track the current sum of each group with a dictionary\\n        # map group_id (which may change over time) to the sum\\n        segsums = {}\\n        \\n        # iterate from the largest to the smallest number and index\\n        # excluding the two zeros padded at the ends\\n        for x,i in pos[:-2]:\\n            minval = x  # current value is minimum since we iterate from large to small\\n            segsum = x\\n            \\n            # if the left element is larger\\n            if nums[i-1] > nums[i]:     \\n                idx = d.find(i-1)       # get group index\\n                segsum += segsums[idx]  # include sum of adjacent group\\n                d.union(i, i-1)         # combine groups\\n            \\n            # equality because we iterate with decreasing index as well\\n            if nums[i+1] >= nums[i]:\\n                idx = d.find(i+1)\\n                segsum += segsums[idx]\\n                d.union(i, i+1)\\n            \\n            # update sum of group\\n            segsums[d.find(i)] = segsum  \\n            \\n            # update the result\\n            maxres = max(maxres, minval*segsum)\\n        \\n        # remember to take modulo\\n        return maxres%(10**9+7)\\n```\\n\\nThe algorithm runs in O(n log n) due to the sorting.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass DisjointSet:\\n    # github.com/not522/ac-library-python/blob/master/atcoder/dsu.py\\n\\n    def __init__(self, n: int = 0) -> None:\\n        self._n = n\\n        self.parent_or_size = [-1]*n\\n\\n    def union(self, a: int, b: int) -> int:\\n        x = self.find(a)\\n        y = self.find(b)\\n\\n        if x == y:\\n            return x\\n\\n        if -self.parent_or_size[x] < -self.parent_or_size[y]:\\n            x, y = y, x\\n\\n        self.parent_or_size[x] += self.parent_or_size[y]\\n        self.parent_or_size[y] = x\\n\\n        return x\\n\\n    def find(self, a: int) -> int:\\n        parent = self.parent_or_size[a]\\n        while parent >= 0:\\n            if self.parent_or_size[parent] < 0:\\n                return parent\\n            self.parent_or_size[a], a, parent = (\\n                self.parent_or_size[parent],\\n                self.parent_or_size[parent],\\n                self.parent_or_size[self.parent_or_size[parent]]\\n            )\\n\\n        return a\\n\\n    def size(self, a: int) -> int:\\n        return -self.parent_or_size[self.leader(a)]\\n\\n\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        \\n        # we begin from the largest number to the smallest number\\n        nums = [0] + nums + [0]\\n        pos = [(x,i) for i,x in enumerate(nums)]\\n        pos.sort()\\n        pos.reverse()\\n        \\n        # we track the result with this variable\\n        maxres = 0\\n        \\n        # we track the membership of each element\\n        # d.find(x) == d.find(y) if x and y are in the same group\\n        d = DisjointSet(len(nums))\\n\\n        # we track the current sum of each group with a dictionary\\n        # map group_id (which may change over time) to the sum\\n        segsums = {}\\n        \\n        # iterate from the largest to the smallest number and index\\n        # excluding the two zeros padded at the ends\\n        for x,i in pos[:-2]:\\n            minval = x  # current value is minimum since we iterate from large to small\\n            segsum = x\\n            \\n            # if the left element is larger\\n            if nums[i-1] > nums[i]:     \\n                idx = d.find(i-1)       # get group index\\n                segsum += segsums[idx]  # include sum of adjacent group\\n                d.union(i, i-1)         # combine groups\\n            \\n            # equality because we iterate with decreasing index as well\\n            if nums[i+1] >= nums[i]:\\n                idx = d.find(i+1)\\n                segsum += segsums[idx]\\n                d.union(i, i+1)\\n            \\n            # update sum of group\\n            segsums[d.find(i)] = segsum  \\n            \\n            # update the result\\n            maxres = max(maxres, minval*segsum)\\n        \\n        # remember to take modulo\\n        return maxres%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198805,
                "title": "monostack-very-similar-to-lc907",
                "content": "Key point: For each number in the array (index denoted as `i`), we want to find the the first smaller number on the left (index denoted as `l`) and on the right (index denoted as `r`), such that we know the answer of which `nums[i]` being the smallest number in the subarray is `nums[i] * sum(nums[l+1:r])`\\n\\nMono stack is the exactly data structure you want to learn (if you are not familiar with) for this special kind of problem.\\n\\nThe key idea is to maintain a stack where the elements in the stack is non-decreasing (a trick here is to push index into the stack instead of the real value, but the idea is as such). \\n\\nAt this point, before we want to push the current index `i` into the stack, we must pop all the index `j` such that `nums[j] > nums[i]` first. After you are popping index `j`, you know that **the smaller index of `j` on the right is `i`, and the smaller index of `j` on the left is stack.top()**. This is exactly what we want. So we know one of the candidate is `nums[j] * sum(nums[stack[-1]+1 : i])`. \\n\\nAdding an -1 into the stack is another trick for this monostack problem, where we can deal with cases easier when a number have no smaller number on the left.\\n\\n```python\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n\\t\\t\\n\\t\\t# preprocess for a prefix sum\\n        presum = [0]\\n        n = len(nums)\\n        for i in range(n):\\n            presum.append(presum[-1] + nums[i])\\n        \\n\\t\\tans = 0\\n\\t\\t\\n\\t\\t# monostack\\n        stack = [-1]\\n        for i in range(n):\\n            while len(stack) > 1 and nums[stack[-1]] > nums[i]:\\n                j = stack.pop()\\n                ans = max(ans, nums[j] * (presum[i] - presum[stack[-1] + 1]))\\n            \\n            stack.append(i)\\n        \\n\\t\\t# for those nums[j] that have no smaller element on the right\\n        while len(stack) > 1:\\n            j = stack.pop()\\n            ans = max(ans, nums[j] * (presum[n] - presum[stack[-1] + 1]))\\n        \\n        return ans % mod\\n```\\n\\nTime complexity: O(n), because each index is pushed into and popped out from the stack exactly once.\\n\\nMore monostack problem:\\n\\n[496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/)\\n[84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n\\t\\t\\n\\t\\t# preprocess for a prefix sum\\n        presum = [0]\\n        n = len(nums)\\n        for i in range(n):\\n            presum.append(presum[-1] + nums[i])\\n        \\n\\t\\tans = 0\\n\\t\\t\\n\\t\\t# monostack\\n        stack = [-1]\\n        for i in range(n):\\n            while len(stack) > 1 and nums[stack[-1]] > nums[i]:\\n                j = stack.pop()\\n                ans = max(ans, nums[j] * (presum[i] - presum[stack[-1] + 1]))\\n            \\n            stack.append(i)\\n        \\n\\t\\t# for those nums[j] that have no smaller element on the right\\n        while len(stack) > 1:\\n            j = stack.pop()\\n            ans = max(ans, nums[j] * (presum[n] - presum[stack[-1] + 1]))\\n        \\n        return ans % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127477,
                "title": "c-monostack-prefixsum-explained-with-comments",
                "content": "#### **Approach:**\\n* Find the \\'first next smallest\\' and \\'first prev smallest\\' element index of every element of the given array using stack. Why? \\n* Because to find the subarray in which a element is minimum is the subarray starts after its first previous minimum element and ends before its first next minimum element.\\n* Now for every element find the required \\'subarray left index\\' as -> \\'first prev smallest element\\'s\\' index of a element + 1.\\n* And \\'subarray right index\\' as ->\\'first next smallest element\\'s\\' index of a element - 1.\\n* Calculate required subarray sum as ->prefix[right] - prefix[left-1] ( and prefix[right] only if left==0) for each element.\\n* Finally Calculate Max min-product for each element and return the maximum ans%(1000000007).\\n\\n#### **CODE(with comments):**\\n```\\nclass Solution {\\npublic:\\n    #define M 1000000007\\n    #define ll long long\\n    \\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<int> prev_smallest(n); //prev. smallest ele idx for ith ele of nums\\n        vector<int> next_smallest(n); //next smallest ele idx for ith ele of nums\\n        vector<ll> prefix(n); // prefix sum to get the sum from any ith to jth idx\\n        prefix[0]=nums[0];\\n        \\n        //calculate prefixSum\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+ nums[i];\\n        }\\n        \\n        stack<pair<int,int>> st1, st2; // st1->next smallest | st2->prev_smallest\\n        st1.push({-1,n}); \\n        st2.push({-1,-1});\\n        \\n        //find next_smallest\\'s element index for every ele of nums\\n        for(int i=n-1;i>=0;i--){\\n            while(!st1.empty() && st1.top().first>=nums[i]){\\n                st1.pop();\\n            }\\n            \\n            next_smallest[i]=st1.top().second;\\n            st1.push({nums[i],i});\\n        }\\n        \\n        //find prev_smallest\\'s element index for every ele of nums\\n        for(int i=0;i<n;i++){\\n            while(!st2.empty() && st2.top().first>=nums[i]){\\n                st2.pop();\\n            }\\n            \\n            prev_smallest[i]=st2.top().second; //index\\n            st2.push({nums[i],i});\\n        }\\n        \\n        ll ans=INT_MIN; \\n        \\n        //calculate max min-product\\n        for(int i=0;i<n;i++){\\n        // as we have stored the index -1 ->if no prev smallest,\\n        // and index n ->if no next smallest.    \\n            \\n            int left=prev_smallest[i]+1; //left index of subarray \\n            int right=next_smallest[i]-1; //right index of subarray \\n            \\n            //find subarray sum using prefix sum\\n            ll subArraySum= left==0 ? prefix[right] : (prefix[right]-prefix[left-1]);\\n            \\n            //take the max min-product everytime\\n            ans=max(ans, nums[i]*subArraySum);\\n        }\\n        \\n        return ans%M;\\n    }\\n};\\n```\\n\\n#### Upvote, if you like it :)\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define M 1000000007\\n    #define ll long long\\n    \\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<int> prev_smallest(n); //prev. smallest ele idx for ith ele of nums\\n        vector<int> next_smallest(n); //next smallest ele idx for ith ele of nums\\n        vector<ll> prefix(n); // prefix sum to get the sum from any ith to jth idx\\n        prefix[0]=nums[0];\\n        \\n        //calculate prefixSum\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+ nums[i];\\n        }\\n        \\n        stack<pair<int,int>> st1, st2; // st1->next smallest | st2->prev_smallest\\n        st1.push({-1,n}); \\n        st2.push({-1,-1});\\n        \\n        //find next_smallest\\'s element index for every ele of nums\\n        for(int i=n-1;i>=0;i--){\\n            while(!st1.empty() && st1.top().first>=nums[i]){\\n                st1.pop();\\n            }\\n            \\n            next_smallest[i]=st1.top().second;\\n            st1.push({nums[i],i});\\n        }\\n        \\n        //find prev_smallest\\'s element index for every ele of nums\\n        for(int i=0;i<n;i++){\\n            while(!st2.empty() && st2.top().first>=nums[i]){\\n                st2.pop();\\n            }\\n            \\n            prev_smallest[i]=st2.top().second; //index\\n            st2.push({nums[i],i});\\n        }\\n        \\n        ll ans=INT_MIN; \\n        \\n        //calculate max min-product\\n        for(int i=0;i<n;i++){\\n        // as we have stored the index -1 ->if no prev smallest,\\n        // and index n ->if no next smallest.    \\n            \\n            int left=prev_smallest[i]+1; //left index of subarray \\n            int right=next_smallest[i]-1; //right index of subarray \\n            \\n            //find subarray sum using prefix sum\\n            ll subArraySum= left==0 ? prefix[right] : (prefix[right]-prefix[left-1]);\\n            \\n            //take the max min-product everytime\\n            ans=max(ans, nums[i]*subArraySum);\\n        }\\n        \\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253611,
                "title": "c-segment-tree-approach-with-explanation-o-n-log-n-time",
                "content": "Intuition: We want to maximize the sumOfElements*minElement. minElement is the bottleneck element which decreases the sum. Idea is to compute it first for the entire range of values. Then remove the min elment (which divides array in two parts - 0-> minIndex-1 and minIndex+1 -> n-1). We recur for both parts and keep updating the globalMax while doing this and return global max in the end.\\n\\nComplexity: O(n * log(n))\\n- An element is getting removed each time, so n. \\n- We find the min in the range each time which takes log(n) time if we\\'ve segment tree. \\n- Sum can easily be obtained in constant time by using prefix sum array.\\n```\\nclass Solution {\\n    int stSize, n, mod = 1e9 + 7;\\n    vector<int> st;\\n    vector<long> preSum;\\n    long globalMax=0;\\n\\n    int createSt(int idx, int low, int high, vector<int>& nums)\\n    {\\n        if (low == high)\\n        {\\n            return st[idx] = low; // store index and not value\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        int leftMinIdx = createSt(2 * idx + 1, low, mid, nums);\\n        int rightMinIdx = createSt(2 * idx + 2, mid + 1, high, nums);\\n\\n        return st[idx] = nums[leftMinIdx] < nums[rightMinIdx] ? leftMinIdx : rightMinIdx;\\n    }\\n\\n    int getMin(int idx, int low, int high, int qLow, int qHigh, vector<int>& nums)\\n    {\\n        if (qHigh < low || high < qLow)\\n        {\\n            return INT_MAX;\\n        }\\n\\n        if (qLow <= low && high <= qHigh)\\n        {\\n            return st[idx];\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        int leftMinIdx = getMin(2 * idx + 1, low, mid, qLow, qHigh, nums);\\n        int rightMinIdx = getMin(2 * idx + 2, mid + 1, high, qLow, qHigh, nums);\\n\\n        if (leftMinIdx == INT_MAX)\\n            return rightMinIdx;\\n        else if (rightMinIdx == INT_MAX)\\n            return leftMinIdx;\\n        else\\n            return nums[leftMinIdx] < nums[rightMinIdx] ? leftMinIdx : rightMinIdx;\\n    }\\n\\n    void helper(int low, int high, vector<int>& nums)\\n    {\\n        if (low > high)\\n        {\\n            return;\\n        }\\n\\n        int minIdx = getMin(0, 0, nums.size() - 1, low, high, nums);\\n        globalMax = max(globalMax, nums[minIdx] * (preSum[high + 1] - preSum[low]));\\n\\n        helper(low, minIdx - 1, nums);\\n        helper(minIdx + 1, high, nums);\\n    }\\n\\npublic:\\n    int maxSumMinProduct(vector<int>& nums)\\n    {\\n        n = nums.size();\\n        int power = ceil(log2(n));\\n        stSize = 2 * pow(2, power)-1;\\n        st.resize(stSize, INT_MAX);\\n\\n        createSt(0, 0, n - 1, nums);\\n\\n        preSum.resize(n + 1, 0);\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            preSum[i + 1] = preSum[i] + nums[i];\\n        }\\n\\n        helper(0, n - 1, nums);\\n        return globalMax%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int stSize, n, mod = 1e9 + 7;\\n    vector<int> st;\\n    vector<long> preSum;\\n    long globalMax=0;\\n\\n    int createSt(int idx, int low, int high, vector<int>& nums)\\n    {\\n        if (low == high)\\n        {\\n            return st[idx] = low; // store index and not value\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        int leftMinIdx = createSt(2 * idx + 1, low, mid, nums);\\n        int rightMinIdx = createSt(2 * idx + 2, mid + 1, high, nums);\\n\\n        return st[idx] = nums[leftMinIdx] < nums[rightMinIdx] ? leftMinIdx : rightMinIdx;\\n    }\\n\\n    int getMin(int idx, int low, int high, int qLow, int qHigh, vector<int>& nums)\\n    {\\n        if (qHigh < low || high < qLow)\\n        {\\n            return INT_MAX;\\n        }\\n\\n        if (qLow <= low && high <= qHigh)\\n        {\\n            return st[idx];\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        int leftMinIdx = getMin(2 * idx + 1, low, mid, qLow, qHigh, nums);\\n        int rightMinIdx = getMin(2 * idx + 2, mid + 1, high, qLow, qHigh, nums);\\n\\n        if (leftMinIdx == INT_MAX)\\n            return rightMinIdx;\\n        else if (rightMinIdx == INT_MAX)\\n            return leftMinIdx;\\n        else\\n            return nums[leftMinIdx] < nums[rightMinIdx] ? leftMinIdx : rightMinIdx;\\n    }\\n\\n    void helper(int low, int high, vector<int>& nums)\\n    {\\n        if (low > high)\\n        {\\n            return;\\n        }\\n\\n        int minIdx = getMin(0, 0, nums.size() - 1, low, high, nums);\\n        globalMax = max(globalMax, nums[minIdx] * (preSum[high + 1] - preSum[low]));\\n\\n        helper(low, minIdx - 1, nums);\\n        helper(minIdx + 1, high, nums);\\n    }\\n\\npublic:\\n    int maxSumMinProduct(vector<int>& nums)\\n    {\\n        n = nums.size();\\n        int power = ceil(log2(n));\\n        stSize = 2 * pow(2, power)-1;\\n        st.resize(stSize, INT_MAX);\\n\\n        createSt(0, 0, n - 1, nums);\\n\\n        preSum.resize(n + 1, 0);\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            preSum[i + 1] = preSum[i] + nums[i];\\n        }\\n\\n        helper(0, n - 1, nums);\\n        return globalMax%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200240,
                "title": "python-monotonic-stack-beats-100",
                "content": "a monotonic stack with index and prefix sum\\n\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        mod=int(1e9+7)\\n        stack=[] # (index, prefix sum at index)\\n        rsum=0\\n        res=0\\n        \\n        nums.append(0)\\n        \\n        for i, v in enumerate(nums):\\n            while stack and nums[stack[-1][0]] >= v:\\n                index, _ = stack.pop()\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if the stack is empty, the subarray sum is the current prefixsum\\n                arrSum=rsum\\n                \\n                if stack:\\n                    arrSum=rsum-stack[-1][1]\\n                \\n\\t\\t\\t\\t# update res with subarray sum\\n                res=max(res, nums[index]*arrSum)\\n                \\n            rsum+=v\\n            stack.append((i, rsum))\\n        \\n        return res%mod",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "a monotonic stack with index and prefix sum\\n\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        mod=int(1e9+7)\\n        stack=[] # (index, prefix sum at index)\\n        rsum=0\\n        res=0\\n        \\n        nums.append(0)\\n        \\n        for i, v in enumerate(nums):\\n            while stack and nums[stack[-1][0]] >= v:\\n                index, _ = stack.pop()\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if the stack is empty, the subarray sum is the current prefixsum\\n                arrSum=rsum\\n                \\n                if stack:\\n                    arrSum=rsum-stack[-1][1]\\n                \\n\\t\\t\\t\\t# update res with subarray sum\\n                res=max(res, nums[index]*arrSum)\\n                \\n            rsum+=v\\n            stack.append((i, rsum))\\n        \\n        return res%mod",
                "codeTag": "Java"
            },
            {
                "id": 1199303,
                "title": "java-simple-and-easy-to-understand-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n### Approach 1\\n\\nTime Complexity : O (N ^ 2)\\nSpace Complexity : O(N)\\n\\nNote : 41 / 41 test cases passed, but took too long.\\n\\n```\\nclass Solution {\\n    \\n    static int MOD = (int)(1e9 + 7);\\n    public int maxSumMinProduct(int[] nums) {\\n\\n        \\n        int n = nums.length;\\n        int[][] arr = new int[n][2];\\n        \\n        for(int i = 0; i < n; i++){\\n            arr[i] = new int[]{i, nums[i]};\\n        }\\n        \\n        Arrays.sort(arr, (a, b) ->  b[1] - a[1]);\\n        \\n        boolean[] processed = new boolean[n];\\n        long maxSum = 0;\\n        for(int[] num :  arr){\\n            \\n            if(processed[num[0]]) continue;\\n            \\n            long minProduct = getMinProduct(nums, num[0], processed);\\n            \\n            maxSum = Math.max(maxSum, minProduct);\\n        }\\n        \\n        return (int) (maxSum % MOD);\\n    }\\n    \\n    private long getMinProduct(int[] nums, int index, boolean[] processed){\\n        \\n        long sum = (long)nums[index];\\n        processed[index] = true;\\n        \\n        //sum %= MOD;\\n        \\n        int i = index - 1;\\n        while(i >= 0 && nums[i] >= nums[index]){\\n            sum +=  (long)nums[i];\\n            //sum %= MOD;\\n            \\n            processed[i] = true;\\n            \\n            i--;\\n        }\\n        \\n        \\n         i = index + 1;\\n        while(i < nums.length && nums[i] >= nums[index]){\\n            sum += (long)nums[i];\\n            //sum %= MOD;\\n            processed[i] = true;\\n            i++;\\n        }\\n        \\n        \\n        long product = sum * (long)nums[index];\\n        \\n        return product;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n### Approach 2\\n\\nTime Complexity : O (N)\\nSpace Complexity : O(N)\\n\\n```\\nclass Solution {\\n    static int MOD = (int)(1e9 + 7);\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        //leftMin[i] = give the index(left direction) which value is less than nums[i] \\n        int[] leftMin  = getLeftMinIndex(nums);\\n        \\n        //rightMin[i] = give the index(right direction) which value is less than nums[i]\\n        int[] rightMin = getRightMinIndex(nums);\\n        \\n        long[] prefixSum = getPrefixSum(nums);\\n        \\n\\n        long maxProduct = 0l;\\n        \\n        for(int i = 0; i < n; i++){\\n            long sum = leftMin[i] == -1 ? prefixSum[rightMin[i] - 1] :  prefixSum[rightMin[i] - 1] -  prefixSum[leftMin[i]];\\n            long product = sum * nums[i];\\n            \\n            //update max product\\n            maxProduct = Math.max(product, maxProduct);\\n        }\\n        \\n        return (int) (maxProduct % MOD);\\n    }\\n    \\n    private int[] getLeftMinIndex(int[] nums){\\n        int n = nums.length;\\n        \\n        int[] arr = new int[n];\\n        Arrays.fill(arr, -1);\\n        \\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            //remove all the index which value is greater or equal to current number\\n            while(!stack.isEmpty() && nums[i] <= nums[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n\\n            //check is any index which is less than current number\\n            if(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                arr[i] = stack.peek();\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        \\n        return arr;\\n    }\\n    \\n    private int[] getRightMinIndex(int[] nums){\\n        int n = nums.length;\\n        \\n        int[] arr = new int[n];\\n        Arrays.fill(arr, n);\\n        \\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            \\n            //remove all the index which value is greater or equal to current number\\n            while(!stack.isEmpty() && nums[i] <= nums[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            //check is any index which is less than current number\\n            if(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                arr[i] = stack.peek();\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        \\n        return arr;\\n    }\\n    \\n    private long[] getPrefixSum(int[] nums){\\n        int n = nums.length;\\n        \\n        long[] arr = new long[n];\\n        arr[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++){\\n            arr[i] = nums[i] + arr[i - 1];\\n        }\\n        \\n        return  arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int MOD = (int)(1e9 + 7);\\n    public int maxSumMinProduct(int[] nums) {\\n\\n        \\n        int n = nums.length;\\n        int[][] arr = new int[n][2];\\n        \\n        for(int i = 0; i < n; i++){\\n            arr[i] = new int[]{i, nums[i]};\\n        }\\n        \\n        Arrays.sort(arr, (a, b) ->  b[1] - a[1]);\\n        \\n        boolean[] processed = new boolean[n];\\n        long maxSum = 0;\\n        for(int[] num :  arr){\\n            \\n            if(processed[num[0]]) continue;\\n            \\n            long minProduct = getMinProduct(nums, num[0], processed);\\n            \\n            maxSum = Math.max(maxSum, minProduct);\\n        }\\n        \\n        return (int) (maxSum % MOD);\\n    }\\n    \\n    private long getMinProduct(int[] nums, int index, boolean[] processed){\\n        \\n        long sum = (long)nums[index];\\n        processed[index] = true;\\n        \\n        //sum %= MOD;\\n        \\n        int i = index - 1;\\n        while(i >= 0 && nums[i] >= nums[index]){\\n            sum +=  (long)nums[i];\\n            //sum %= MOD;\\n            \\n            processed[i] = true;\\n            \\n            i--;\\n        }\\n        \\n        \\n         i = index + 1;\\n        while(i < nums.length && nums[i] >= nums[index]){\\n            sum += (long)nums[i];\\n            //sum %= MOD;\\n            processed[i] = true;\\n            i++;\\n        }\\n        \\n        \\n        long product = sum * (long)nums[index];\\n        \\n        return product;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static int MOD = (int)(1e9 + 7);\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        //leftMin[i] = give the index(left direction) which value is less than nums[i] \\n        int[] leftMin  = getLeftMinIndex(nums);\\n        \\n        //rightMin[i] = give the index(right direction) which value is less than nums[i]\\n        int[] rightMin = getRightMinIndex(nums);\\n        \\n        long[] prefixSum = getPrefixSum(nums);\\n        \\n\\n        long maxProduct = 0l;\\n        \\n        for(int i = 0; i < n; i++){\\n            long sum = leftMin[i] == -1 ? prefixSum[rightMin[i] - 1] :  prefixSum[rightMin[i] - 1] -  prefixSum[leftMin[i]];\\n            long product = sum * nums[i];\\n            \\n            //update max product\\n            maxProduct = Math.max(product, maxProduct);\\n        }\\n        \\n        return (int) (maxProduct % MOD);\\n    }\\n    \\n    private int[] getLeftMinIndex(int[] nums){\\n        int n = nums.length;\\n        \\n        int[] arr = new int[n];\\n        Arrays.fill(arr, -1);\\n        \\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            //remove all the index which value is greater or equal to current number\\n            while(!stack.isEmpty() && nums[i] <= nums[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n\\n            //check is any index which is less than current number\\n            if(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                arr[i] = stack.peek();\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        \\n        return arr;\\n    }\\n    \\n    private int[] getRightMinIndex(int[] nums){\\n        int n = nums.length;\\n        \\n        int[] arr = new int[n];\\n        Arrays.fill(arr, n);\\n        \\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            \\n            //remove all the index which value is greater or equal to current number\\n            while(!stack.isEmpty() && nums[i] <= nums[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            //check is any index which is less than current number\\n            if(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                arr[i] = stack.peek();\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        \\n        return arr;\\n    }\\n    \\n    private long[] getPrefixSum(int[] nums){\\n        int n = nums.length;\\n        \\n        long[] arr = new long[n];\\n        arr[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++){\\n            arr[i] = nums[i] + arr[i - 1];\\n        }\\n        \\n        return  arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198650,
                "title": "java-easy-stack",
                "content": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 1; i <= n; i++) { // prefix Sum\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n        Stack<Integer> stk1 = new Stack<>();\\n        Stack<Integer> stk2 = new Stack<>();\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        for (int i = 0; i < n; i++) { // find the first element\\' value < nums[i] in the left\\n            while (!stk1.isEmpty() && nums[i] <= nums[stk1.peek()]) {\\n                stk1.pop();\\n            }\\n            if (stk1.isEmpty()) {\\n                left[i] = -1;\\n            } else {\\n                left[i] = stk1.peek();\\n            }\\n            stk1.push(i);\\n        }\\n        for (int i = n - 1; i >= 0; i--) { //  find the first element\\' value < nums[i] in the right\\n            while (!stk2.isEmpty() && nums[i] <= nums[stk2.peek()]) {\\n                stk2.pop();\\n            }\\n            if (stk2.isEmpty()) {\\n                right[i] = n;\\n            } else {\\n                right[i] = stk2.peek();\\n            }\\n            stk2.push(i);\\n        }\\n        long max = 0;\\n        for (int i = 0; i < n; i++) { // make current element as Min value\\n            int l = left[i];\\n            int r = right[i];\\n            long sum = prefixSum[r] - prefixSum[l + 1];\\n            long prod = sum * nums[i];\\n            max = Math.max(prod, max);\\n        }\\n        return (int)(max % 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 1; i <= n; i++) { // prefix Sum\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n        Stack<Integer> stk1 = new Stack<>();\\n        Stack<Integer> stk2 = new Stack<>();\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        for (int i = 0; i < n; i++) { // find the first element\\' value < nums[i] in the left\\n            while (!stk1.isEmpty() && nums[i] <= nums[stk1.peek()]) {\\n                stk1.pop();\\n            }\\n            if (stk1.isEmpty()) {\\n                left[i] = -1;\\n            } else {\\n                left[i] = stk1.peek();\\n            }\\n            stk1.push(i);\\n        }\\n        for (int i = n - 1; i >= 0; i--) { //  find the first element\\' value < nums[i] in the right\\n            while (!stk2.isEmpty() && nums[i] <= nums[stk2.peek()]) {\\n                stk2.pop();\\n            }\\n            if (stk2.isEmpty()) {\\n                right[i] = n;\\n            } else {\\n                right[i] = stk2.peek();\\n            }\\n            stk2.push(i);\\n        }\\n        long max = 0;\\n        for (int i = 0; i < n; i++) { // make current element as Min value\\n            int l = left[i];\\n            int r = right[i];\\n            long sum = prefixSum[r] - prefixSum[l + 1];\\n            long prod = sum * nums[i];\\n            max = Math.max(prod, max);\\n        }\\n        return (int)(max % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811287,
                "title": "python-3-monotomic-stack-prefix-sum-simple",
                "content": "# Intuition\\nsimilar to this problem: https://leetcode.com/problems/largest-rectangle-in-histogram/\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        ps = [0]\\n        stack = [-1]\\n        nums.append(0)\\n        res = 0\\n        \\n        for i in range(len(nums)):\\n            while nums[stack[-1]] > nums[i]:\\n                min_val = nums[stack.pop()]\\n                range_sum = ps[i] - ps[stack[-1] + 1]\\n                res = max(res, range_sum * min_val)\\n            stack.append(i)\\n            ps.append(ps[-1] + nums[i])\\n        return res % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        ps = [0]\\n        stack = [-1]\\n        nums.append(0)\\n        res = 0\\n        \\n        for i in range(len(nums)):\\n            while nums[stack[-1]] > nums[i]:\\n                min_val = nums[stack.pop()]\\n                range_sum = ps[i] - ps[stack[-1] + 1]\\n                res = max(res, range_sum * min_val)\\n            stack.append(i)\\n            ps.append(ps[-1] + nums[i])\\n        return res % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796476,
                "title": "c-solution-using-stack-prefix-sum-and-suffix-sum",
                "content": "**for every number in nums just search for the smallest element in its left and  in right.\\n#than just using prefix sum and suffix sum calculate your value for your answer**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)1e9 + 7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int>left(n  , 0);\\n        vector<int>right(n , 0);\\n        \\n        stack<int>st;\\n        \\n        for(int i=0 ; i < n ; i++){\\n            int index = i;\\n            while(!st.empty() and nums[st.top()] >= nums[i]){\\n                index = left[st.top()];\\n                st.pop();\\n            }\\n            \\n            if(st.empty()){\\n                left[i] = -1;\\n            }else{\\n                left[i] = index;\\n            }\\n            st.push(i);\\n        }\\n        \\n        while(!st.empty())st.pop();        \\n        \\n        for(int i=n-1 ; i >= 0 ; i--){\\n            int index = i;\\n            while(!st.empty() and nums[st.top()] >= nums[i]){\\n                index = right[st.top()];\\n                st.pop();\\n            }\\n            \\n            if(st.empty()){\\n                right[i] = -1;\\n            }else{\\n                right[i] = index;\\n            }\\n            st.push(i);\\n        }\\n        \\n        long long ans = INT_MIN;\\n        \\n        vector<long long>prefix(n);\\n        \\n        long long sum = 0;\\n        \\n        for(int i=0 ;  i < n ; i++){\\n            sum = sum + nums[i];\\n            prefix[i] = sum;\\n        }\\n        \\n        for(int i=0 ; i < n ; i++){\\n            long long sum = 0;\\n            if(left[i] == -1 and right[i] == -1){\\n                sum = prefix[n - 1] * nums[i]; \\n            }else if(left[i] == -1){\\n                sum = prefix[right[i]] * nums[i];\\n            }else if(right[i] == -1){\\n                sum = (prefix[n - 1] - prefix[left[i] - 1]) * nums[i];\\n            }else{\\n                sum = (prefix[right[i]] - prefix[left[i] - 1]) * nums[i];\\n            }\\n            \\n            \\n            ans = max(ans , sum);\\n        }\\n        \\n        return ans % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = (int)1e9 + 7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int>left(n  , 0);\\n        vector<int>right(n , 0);\\n        \\n        stack<int>st;\\n        \\n        for(int i=0 ; i < n ; i++){\\n            int index = i;\\n            while(!st.empty() and nums[st.top()] >= nums[i]){\\n                index = left[st.top()];\\n                st.pop();\\n            }\\n            \\n            if(st.empty()){\\n                left[i] = -1;\\n            }else{\\n                left[i] = index;\\n            }\\n            st.push(i);\\n        }\\n        \\n        while(!st.empty())st.pop();        \\n        \\n        for(int i=n-1 ; i >= 0 ; i--){\\n            int index = i;\\n            while(!st.empty() and nums[st.top()] >= nums[i]){\\n                index = right[st.top()];\\n                st.pop();\\n            }\\n            \\n            if(st.empty()){\\n                right[i] = -1;\\n            }else{\\n                right[i] = index;\\n            }\\n            st.push(i);\\n        }\\n        \\n        long long ans = INT_MIN;\\n        \\n        vector<long long>prefix(n);\\n        \\n        long long sum = 0;\\n        \\n        for(int i=0 ;  i < n ; i++){\\n            sum = sum + nums[i];\\n            prefix[i] = sum;\\n        }\\n        \\n        for(int i=0 ; i < n ; i++){\\n            long long sum = 0;\\n            if(left[i] == -1 and right[i] == -1){\\n                sum = prefix[n - 1] * nums[i]; \\n            }else if(left[i] == -1){\\n                sum = prefix[right[i]] * nums[i];\\n            }else if(right[i] == -1){\\n                sum = (prefix[n - 1] - prefix[left[i] - 1]) * nums[i];\\n            }else{\\n                sum = (prefix[right[i]] - prefix[left[i] - 1]) * nums[i];\\n            }\\n            \\n            \\n            ans = max(ans , sum);\\n        }\\n        \\n        return ans % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204859,
                "title": "java-simple-solution-using-stacks-application-of-next-smaller-element",
                "content": "**Explanation:**\\n ```\\neg: nums= [2,3,3,1,2]\\n\\n step1: psum =[2,5,8,9,11]\\n step2 :Numbers are always positive. So no need to check small subarray check the largest possible subarray for every element where it is minimum. (similar idea as of max area of histogram)\\n  \\n      leftmin=[-1,0,0,-1,3];\\n      rightmin=[3,3,3,5,5];\\n      \\n      -> every element is minimum in subarray (left[i]+1 to right[i]-1) So calculate sum from from (left to right)*nums[i]\\n        \\n        max=Math.max(max,(prefix[right-1]-prefix[left])*nums[i]);\\n        if(left==-1) we have to handle that to.\\n```\\n**CODE:**\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int mod=(int)Math.pow(10,9)+7;\\n        int n=nums.length;\\n        \\n        //next smaller on left\\n        int[] left=new int[n];\\n        Stack<Integer> st=new Stack<>();\\n        left[0]=-1;\\n        st.push(0);\\n        for(int i=1;i<n;i++){\\n            while(st.size()>0 && nums[st.peek()]>=nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(st.size()==0) left[i]=-1;\\n            else left[i]=st.peek();\\n            \\n            st.push(i);\\n        }\\n        \\n        //next smaller on right\\n        int[] right=new int[n];\\n        st=new Stack<>();\\n        right[n-1]=n;\\n        st.push(n-1);\\n        for(int i=n-2;i>=0;i--){\\n        while(st.size()>0 && nums[st.peek()]>=nums[i]) st.pop();\\n            \\n            if(st.size()>0) right[i]=st.peek();\\n            else right[i]=n;\\n            \\n            st.push(i);\\n        }\\n        \\n        long[] prefixSum=new long[n];\\n        prefixSum[0]=nums[0];\\n        for(int i=1;i<n;i++) prefixSum[i]=prefixSum[i-1]+nums[i];\\n        \\n      \\n        long max=0;\\n        for(int i=0;i<nums.length;i++){\\n            int l=left[i];\\n            int r=right[i]-1;\\n            \\n            max=Math.max(max,(prefixSum[r]-(l==-1?0:prefixSum[l]))*nums[i]);\\n        }\\n        return (int)(max%mod);\\n    }\\n}\\n```\\n\\n**Complexity:**\\n`Time:O(n) and Space:O(n)`\\n\\n**Similar Questions:**\\n[largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n[maximal rectangle](https://leetcode.com/problems/maximal-rectangle/)\\n\\nPlease upvote if found it helpful :)",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\neg: nums= [2,3,3,1,2]\\n\\n step1: psum =[2,5,8,9,11]\\n step2 :Numbers are always positive. So no need to check small subarray check the largest possible subarray for every element where it is minimum. (similar idea as of max area of histogram)\\n  \\n      leftmin=[-1,0,0,-1,3];\\n      rightmin=[3,3,3,5,5];\\n      \\n      -> every element is minimum in subarray (left[i]+1 to right[i]-1) So calculate sum from from (left to right)*nums[i]\\n        \\n        max=Math.max(max,(prefix[right-1]-prefix[left])*nums[i]);\\n        if(left==-1) we have to handle that to.\\n```\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int mod=(int)Math.pow(10,9)+7;\\n        int n=nums.length;\\n        \\n        //next smaller on left\\n        int[] left=new int[n];\\n        Stack<Integer> st=new Stack<>();\\n        left[0]=-1;\\n        st.push(0);\\n        for(int i=1;i<n;i++){\\n            while(st.size()>0 && nums[st.peek()]>=nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(st.size()==0) left[i]=-1;\\n            else left[i]=st.peek();\\n            \\n            st.push(i);\\n        }\\n        \\n        //next smaller on right\\n        int[] right=new int[n];\\n        st=new Stack<>();\\n        right[n-1]=n;\\n        st.push(n-1);\\n        for(int i=n-2;i>=0;i--){\\n        while(st.size()>0 && nums[st.peek()]>=nums[i]) st.pop();\\n            \\n            if(st.size()>0) right[i]=st.peek();\\n            else right[i]=n;\\n            \\n            st.push(i);\\n        }\\n        \\n        long[] prefixSum=new long[n];\\n        prefixSum[0]=nums[0];\\n        for(int i=1;i<n;i++) prefixSum[i]=prefixSum[i-1]+nums[i];\\n        \\n      \\n        long max=0;\\n        for(int i=0;i<nums.length;i++){\\n            int l=left[i];\\n            int r=right[i]-1;\\n            \\n            max=Math.max(max,(prefixSum[r]-(l==-1?0:prefixSum[l]))*nums[i]);\\n        }\\n        return (int)(max%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198849,
                "title": "c-time-o-n-space-o-n",
                "content": "The basic idea to solve this question is to calculate product for every element present in array.\\nNow our task should be to get sum of valid subarray for current element\\nfor exam [3,1,5,6,4,2] in this array, the valid subarray for ele 4 is 5,6,4.\\nIf you don\\'t want to get TLE then to calculate this sum time complexity should be O(1)\\nor O(log(N)).\\n\\nNow our only task is to calculate sum of valid subarray for every element and store is somewhere so that we can get it in O(1).\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int maxSumMinProduct(vector<int>& nums) {\\n        unordered_map<int,long long int>total_left,total_right; \\n\\t\\t\\t\\t//to store sum of every element\\n\\t\\t\\t\\t//total_left contain sum of left side of ele\\n\\t\\t\\t\\t//total_right contain sum of right side of ele\\n\\t\\t\\t\\t\\n        stack<int>st;//to get sum of left elements\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(st.size() == 0){\\n                st.push(i);\\n                total_left[i]=0;\\n            }\\n            else if(nums[i] > nums[st.top()]){\\n                st.push(i);\\n                total_left[i]=0;\\n            }\\n            else{\\n                long long int sum=0;\\n                while(st.size() && nums[i] <= nums[st.top()]){\\n                    sum+=total_left[st.top()]+nums[st.top()];\\n                    st.pop();\\n                }\\n                total_left[i]=sum;\\n                st.push(i);\\n            }\\n        }\\n        \\n        stack<int>st1; //to get sum of right elements\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(st1.size() == 0){\\n                total_right[i]=0;\\n                st1.push(i);\\n            }\\n            else if(nums[i] > nums[st1.top()]){\\n                total_right[i]=0;\\n                st1.push(i);\\n            }\\n            else{\\n                long long int sum=0;\\n                while(st1.size() && nums[i] <= nums[st1.top()]){\\n                    sum+=total_right[st1.top()]+nums[st1.top()];\\n                    st1.pop();\\n                }\\n                total_right[i]=sum;\\n                st1.push(i);\\n            }\\n        }\\n        \\n        long long int res=0,tmp;\\n        for(int i=0;i<nums.size();i++){\\n            long long int sum=nums[i] + total_left[i] + total_right[i];\\n            //total sum of valid subarray\\n            tmp=sum * (long long int)nums[i];\\n            res=max(tmp,res);\\n        }\\n        \\n        return res % mod;\\n    }\\n};\\n```\\n\\nIf you want to get good understand of the code ,i\\'ll recommend, dry run with any example.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int maxSumMinProduct(vector<int>& nums) {\\n        unordered_map<int,long long int>total_left,total_right; \\n\\t\\t\\t\\t//to store sum of every element\\n\\t\\t\\t\\t//total_left contain sum of left side of ele\\n\\t\\t\\t\\t//total_right contain sum of right side of ele\\n\\t\\t\\t\\t\\n        stack<int>st;//to get sum of left elements\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(st.size() == 0){\\n                st.push(i);\\n                total_left[i]=0;\\n            }\\n            else if(nums[i] > nums[st.top()]){\\n                st.push(i);\\n                total_left[i]=0;\\n            }\\n            else{\\n                long long int sum=0;\\n                while(st.size() && nums[i] <= nums[st.top()]){\\n                    sum+=total_left[st.top()]+nums[st.top()];\\n                    st.pop();\\n                }\\n                total_left[i]=sum;\\n                st.push(i);\\n            }\\n        }\\n        \\n        stack<int>st1; //to get sum of right elements\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(st1.size() == 0){\\n                total_right[i]=0;\\n                st1.push(i);\\n            }\\n            else if(nums[i] > nums[st1.top()]){\\n                total_right[i]=0;\\n                st1.push(i);\\n            }\\n            else{\\n                long long int sum=0;\\n                while(st1.size() && nums[i] <= nums[st1.top()]){\\n                    sum+=total_right[st1.top()]+nums[st1.top()];\\n                    st1.pop();\\n                }\\n                total_right[i]=sum;\\n                st1.push(i);\\n            }\\n        }\\n        \\n        long long int res=0,tmp;\\n        for(int i=0;i<nums.size();i++){\\n            long long int sum=nums[i] + total_left[i] + total_right[i];\\n            //total sum of valid subarray\\n            tmp=sum * (long long int)nums[i];\\n            res=max(tmp,res);\\n        }\\n        \\n        return res % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198823,
                "title": "python-divide-and-conquer-o-nlogn",
                "content": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        def maxSumMinProductRange(i, j):\\n            if i == j:\\n                return nums[i]*nums[i]\\n            mid = i + (j - i)//2\\n            p1 = mid\\n            p2 = mid + 1\\n            cur_min = min(nums[p1], nums[p2])\\n            cur_sum = nums[p1] + nums[p2]\\n            max_so_far = cur_min*cur_sum\\n            while p1 > i or p2 < j:\\n                if p1 == i or (p2 < j and nums[p2 + 1] >= nums[p1 - 1]):\\n                    p2 += 1\\n                    cur_min = min(cur_min, nums[p2])\\n                    cur_sum += nums[p2]\\n                else:\\n                    p1 -= 1\\n                    cur_min = min(cur_min, nums[p1])\\n                    cur_sum += nums[p1]\\n                max_so_far = max(max_so_far, cur_min*cur_sum)\\n            left = maxSumMinProductRange(i, mid)\\n            right = maxSumMinProductRange(mid + 1, j)\\n            return max(left, right, max_so_far)\\n        return maxSumMinProductRange(0, len(nums) - 1) % int(1e9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        def maxSumMinProductRange(i, j):\\n            if i == j:\\n                return nums[i]*nums[i]\\n            mid = i + (j - i)//2\\n            p1 = mid\\n            p2 = mid + 1\\n            cur_min = min(nums[p1], nums[p2])\\n            cur_sum = nums[p1] + nums[p2]\\n            max_so_far = cur_min*cur_sum\\n            while p1 > i or p2 < j:\\n                if p1 == i or (p2 < j and nums[p2 + 1] >= nums[p1 - 1]):\\n                    p2 += 1\\n                    cur_min = min(cur_min, nums[p2])\\n                    cur_sum += nums[p2]\\n                else:\\n                    p1 -= 1\\n                    cur_min = min(cur_min, nums[p1])\\n                    cur_sum += nums[p1]\\n                max_so_far = max(max_so_far, cur_min*cur_sum)\\n            left = maxSumMinProductRange(i, mid)\\n            right = maxSumMinProductRange(mid + 1, j)\\n            return max(left, right, max_so_far)\\n        return maxSumMinProductRange(0, len(nums) - 1) % int(1e9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198640,
                "title": "c-solution-start-from-the-smallest-number-greedy",
                "content": "\\n### Idea\\n- We start from the smallest number and find the left and right bound by the current index, then the answer is current_number * (prefix[r] - prefix[l]).\\n\\n\\n### Time Complexity\\n- Time O(nLogn)\\n- Space O(n)\\n\\n### Solution\\n- C++\\n```\\nclass Solution {\\npublic:\\n    long long M = 1e9 + 7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        map<long long, long long> stick;\\n        vector<pair<int, int> > sortedArray(nums.size());\\n        vector<long long> prefix = {nums[0]};\\n        for(int i = 0; i < nums.size(); i++) {\\n            sortedArray[i] = {nums[i], i};\\n        }\\n        for(int i = 1; i < nums.size(); i++) {\\n            prefix.push_back(prefix.back() + (long long)nums[i]);\\n        }\\n        sort(sortedArray.begin(), sortedArray.end());\\n        long long ans = 0;\\n        for(auto [num, i] : sortedArray) {\\n            auto it = stick.lower_bound(i);\\n            int r = nums.size(); //right bound\\n            if(it != stick.end()) r = it->first;\\n            int l = -1;\\n            if(it != stick.begin()) {//left bound\\n                --it;\\n                l = it->first;\\n            }\\n            long long cur = (long long)num * (long long)(prefix[r - 1] - (l >= 0 ? prefix[l] : 0));\\n            ans = max(ans, cur);\\n            stick[i] = 1;\\n        }\\n        return ans % M;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long M = 1e9 + 7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        map<long long, long long> stick;\\n        vector<pair<int, int> > sortedArray(nums.size());\\n        vector<long long> prefix = {nums[0]};\\n        for(int i = 0; i < nums.size(); i++) {\\n            sortedArray[i] = {nums[i], i};\\n        }\\n        for(int i = 1; i < nums.size(); i++) {\\n            prefix.push_back(prefix.back() + (long long)nums[i]);\\n        }\\n        sort(sortedArray.begin(), sortedArray.end());\\n        long long ans = 0;\\n        for(auto [num, i] : sortedArray) {\\n            auto it = stick.lower_bound(i);\\n            int r = nums.size(); //right bound\\n            if(it != stick.end()) r = it->first;\\n            int l = -1;\\n            if(it != stick.begin()) {//left bound\\n                --it;\\n                l = it->first;\\n            }\\n            long long cur = (long long)num * (long long)(prefix[r - 1] - (l >= 0 ? prefix[l] : 0));\\n            ans = max(ans, cur);\\n            stick[i] = 1;\\n        }\\n        return ans % M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257389,
                "title": "c-prefix-sum-stack-similar-to-max-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long\\n    int mod=1000000007;\\n    int maxSumMinProduct(vector<int>& nums) \\n    {\\n        ll n=nums.size(),res=0;\\n        vector<ll>prefix(n+1,0);\\n        for(int i=0;i<n;i++)\\n            prefix[i+1]=prefix[i]+nums[i];\\n        nums.push_back(0);\\n        stack<int>stk;\\n        for(int i=0;i<=n;i++)\\n        {\\n            while(!stk.empty() && nums[i]<nums[stk.top()])\\n            {\\n                int top=stk.top();stk.pop();\\n                if(stk.empty())\\n                {\\n                    res=max(res,prefix[i]*nums[top]);\\n                }\\n                else\\n                {\\n                    ll sum=prefix[i]-prefix[stk.top()+1];\\n                    res=max(res,sum*nums[top]);\\n                }\\n            }\\n            stk.push(i);\\n        }\\n        return res%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long\\n    int mod=1000000007;\\n    int maxSumMinProduct(vector<int>& nums) \\n    {\\n        ll n=nums.size(),res=0;\\n        vector<ll>prefix(n+1,0);\\n        for(int i=0;i<n;i++)\\n            prefix[i+1]=prefix[i]+nums[i];\\n        nums.push_back(0);\\n        stack<int>stk;\\n        for(int i=0;i<=n;i++)\\n        {\\n            while(!stk.empty() && nums[i]<nums[stk.top()])\\n            {\\n                int top=stk.top();stk.pop();\\n                if(stk.empty())\\n                {\\n                    res=max(res,prefix[i]*nums[top]);\\n                }\\n                else\\n                {\\n                    ll sum=prefix[i]-prefix[stk.top()+1];\\n                    res=max(res,sum*nums[top]);\\n                }\\n            }\\n            stk.push(i);\\n        }\\n        return res%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240942,
                "title": "maximum-subarray-min-product",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        using ll = long long;\\n        const int mod = 1e9 + 7;\\n        vector<ll> nsl(n + 1), nsr(n + 1), pref(n + 1);\\n        stack<ll> sk;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                pref[i] = nums[i];\\n                continue;\\n            }\\n            pref[i] += pref[i - 1] + nums[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            while (!sk.empty() && nums[i] < nums[sk.top()]) {\\n                nsr[sk.top()] = i;\\n                sk.pop();\\n            }\\n            sk.push(i);\\n        }\\n        while (!sk.empty()) {\\n            nsr[sk.top()] = n;\\n            sk.pop();\\n        }\\n        \\n        while (!sk.empty()) sk.pop();\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!sk.empty() && nums[i] < nums[sk.top()]) {\\n                nsl[sk.top()] = i;\\n                sk.pop();\\n            }\\n            sk.push(i);\\n        }\\n        while (!sk.empty()) {\\n            nsl[sk.top()] = -1;\\n            sk.pop();\\n        }\\n        \\n        // for (int i = 0; i < n; i++)\\n        //     cout << nsl[i] << \\' \\';\\n        // cout << endl;\\n        // for (int i = 0; i < n; i++)\\n        //     cout << nsr[i] << \" \";\\n        // cout << endl;\\n            \\n        ll mx = 0;\\n        for (int i = 0; i < n; i++) {\\n            ll sum = pref[nsr[i] - 1] - (nsl[i] == -1 ? 0: pref[nsl[i]]);\\n            ll val = nums[i] * sum;\\n            mx = max(mx, val);\\n        }\\n        \\n        return mx % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        using ll = long long;\\n        const int mod = 1e9 + 7;\\n        vector<ll> nsl(n + 1), nsr(n + 1), pref(n + 1);\\n        stack<ll> sk;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                pref[i] = nums[i];\\n                continue;\\n            }\\n            pref[i] += pref[i - 1] + nums[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            while (!sk.empty() && nums[i] < nums[sk.top()]) {\\n                nsr[sk.top()] = i;\\n                sk.pop();\\n            }\\n            sk.push(i);\\n        }\\n        while (!sk.empty()) {\\n            nsr[sk.top()] = n;\\n            sk.pop();\\n        }\\n        \\n        while (!sk.empty()) sk.pop();\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!sk.empty() && nums[i] < nums[sk.top()]) {\\n                nsl[sk.top()] = i;\\n                sk.pop();\\n            }\\n            sk.push(i);\\n        }\\n        while (!sk.empty()) {\\n            nsl[sk.top()] = -1;\\n            sk.pop();\\n        }\\n        \\n        // for (int i = 0; i < n; i++)\\n        //     cout << nsl[i] << \\' \\';\\n        // cout << endl;\\n        // for (int i = 0; i < n; i++)\\n        //     cout << nsr[i] << \" \";\\n        // cout << endl;\\n            \\n        ll mx = 0;\\n        for (int i = 0; i < n; i++) {\\n            ll sum = pref[nsr[i] - 1] - (nsl[i] == -1 ? 0: pref[nsl[i]]);\\n            ll val = nums[i] * sum;\\n            mx = max(mx, val);\\n        }\\n        \\n        return mx % mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1205499,
                "title": "c-stack-concept-o-n",
                "content": "The problem here is diverting from the actual problem. \\nLet us consider each element in the nums array as the smallest element in their corresponding subarray. Now the problem reduces to finding the corresponding subarray for  each element. \\nTo find each corresponding element we will use stack.\\nStore the index of next smaller element in the left direction of current element in left array.\\nSimilary do this for right array i.e. next smaller element in the right direction of current element.\\nUsing left and right array we can find window/subarray for each element.\\nNow we will apply this window on prefix sum array to compute the sum of each window in O(1) time.\\n\\nfor each element, the min-product would be, (prefixSum[right[i]] - prefixSum[left[i]+1) * nums[i]\\n\\n```\\nint maxSumMinProduct(vector<int>& nums) {\\n        vector<long>preSum, left(nums.size(),-1), right(nums.size(),nums.size());\\n        preSum.push_back(0);\\n        for(int i=0; i<nums.size(); i++)\\n            preSum.push_back(preSum.back()+nums[i]);\\n        \\n        stack<int>st;\\n        for(int i=0; i<nums.size(); i++){\\n            while(!st.empty() && nums[i]<=nums[st.top()])\\n                st.pop();\\n            if(!st.empty())\\n                left[i]=st.top();\\n            st.push(i);\\n        }\\n        st = stack<int>();\\n        for(int i=nums.size()-1; i>=0; i--){\\n            while(!st.empty() && nums[i]<=nums[st.top()])\\n                st.pop();\\n            if(!st.empty())\\n                right[i]=st.top();\\n            st.push(i);\\n        }\\n        \\n        long ans=0, mod=1e9+7;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            long t=(preSum[right[i]]-preSum[left[i]+1])*nums[i];\\n            ans=max(ans,t);\\n        }\\n        \\n        return ans%mod;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxSumMinProduct(vector<int>& nums) {\\n        vector<long>preSum, left(nums.size(),-1), right(nums.size(),nums.size());\\n        preSum.push_back(0);\\n        for(int i=0; i<nums.size(); i++)\\n            preSum.push_back(preSum.back()+nums[i]);\\n        \\n        stack<int>st;\\n        for(int i=0; i<nums.size(); i++){\\n            while(!st.empty() && nums[i]<=nums[st.top()])\\n                st.pop();\\n            if(!st.empty())\\n                left[i]=st.top();\\n            st.push(i);\\n        }\\n        st = stack<int>();\\n        for(int i=nums.size()-1; i>=0; i--){\\n            while(!st.empty() && nums[i]<=nums[st.top()])\\n                st.pop();\\n            if(!st.empty())\\n                right[i]=st.top();\\n            st.push(i);\\n        }\\n        \\n        long ans=0, mod=1e9+7;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            long t=(preSum[right[i]]-preSum[left[i]+1])*nums[i];\\n            ans=max(ans,t);\\n        }\\n        \\n        return ans%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1199547,
                "title": "using-segment-tree-range-minimum-query-c",
                "content": "This problem can also be solved using segment trees with range minimum queries as well. Here, for a given range , the segment tree should return the *index* of the minimum value of that range(not the minimum value itself but the index of that value). So we can calculate the answer for that range and then check the answer on the left side of the index and on the right side of the index for that range. And we will also maintain a prefix sum array for getting the sum of elements in a given range.\\nTime Complexity : O(NlogN)\\n\\n```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    int minVal(int x, int y) { return (x < y)? x: y; } \\n    int getMid(int s, int e) { return s + (e -s)/2; } \\n    int RMQUtil(int *st, int ss, int se, int qs, int qe, int index, vector<int>& arr) \\n    {  \\n        if (qs <= ss && qe >= se) return st[index]; \\n        if (se < qs || ss > qe) return INT_MAX; \\n        int mid = getMid(ss, se);\\n        int in1 = RMQUtil(st, ss, mid, qs, qe, 2*index+1, arr);\\n        int in2 = RMQUtil(st, mid+1, se, qs, qe, 2*index+2, arr);\\n        if(in1 == INT_MAX && in2 == INT_MAX) return INT_MAX;\\n        else if(in1 == INT_MAX) return in2;\\n        else if(in2 == INT_MAX) return in1;\\n        return (arr[in1] <= arr[in2] ? in1 : in2);\\n    } \\n    int RMQ(int *st, int n, int qs, int qe, vector<int>& arr) { \\n        if (qs < 0 || qe > n-1 || qs > qe) { \\n            return -1; \\n        } \\n        return RMQUtil(st, 0, n-1, qs, qe, 0,arr); \\n    } \\n    int constructSTUtil(vector<int>& arr, int ss, int se,int *st, int si) { \\n        if (ss == se) { \\n            st[si] = ss; \\n            return ss; \\n        } \\n        int mid = getMid(ss, se);\\n        int in1 = constructSTUtil(arr, ss, mid, st, si*2+1);\\n        int in2 = constructSTUtil(arr, mid+1, se, st, si*2+2);\\n        st[si] = (arr[in1] <= arr[in2] ? in1 : in2); \\n        return st[si]; \\n    } \\n    int *constructST(vector<int>& arr, int n) { \\n        int x = (int)(ceil(log2(n)));\\n        int max_size = 2*(int)pow(2, x) - 1; \\n        int *st = new int[max_size]; \\n        constructSTUtil(arr, 0, n-1, st, 0);  \\n        return st; \\n    }\\n    void query(int l, int r, vector<ll>& pre, int* st, vector<int>& arr, ll& maxv){\\n        if(l>r) return;\\n        int in = RMQ(st, arr.size(), l, r, arr);\\n        ll prod = (pre[r] - (l>0?pre[l-1]:0)) * arr[in];\\n        maxv = max(maxv, prod);\\n        query(l, in-1, pre, st, arr, maxv);\\n        query(in+1, r, pre, st, arr, maxv);\\n    }\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pre(n);\\n        for(int i=0; i<n; i++) pre[i] = nums[i];\\n        for(int i=1; i<n; i++) pre[i] += pre[i-1];\\n        ll maxv = LLONG_MIN;\\n        int* st = constructST(nums, n);\\n        query(0,n-1,pre,st,nums,maxv);\\n        maxv %= mod;\\n        return maxv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    int minVal(int x, int y) { return (x < y)? x: y; } \\n    int getMid(int s, int e) { return s + (e -s)/2; } \\n    int RMQUtil(int *st, int ss, int se, int qs, int qe, int index, vector<int>& arr) \\n    {  \\n        if (qs <= ss && qe >= se) return st[index]; \\n        if (se < qs || ss > qe) return INT_MAX; \\n        int mid = getMid(ss, se);\\n        int in1 = RMQUtil(st, ss, mid, qs, qe, 2*index+1, arr);\\n        int in2 = RMQUtil(st, mid+1, se, qs, qe, 2*index+2, arr);\\n        if(in1 == INT_MAX && in2 == INT_MAX) return INT_MAX;\\n        else if(in1 == INT_MAX) return in2;\\n        else if(in2 == INT_MAX) return in1;\\n        return (arr[in1] <= arr[in2] ? in1 : in2);\\n    } \\n    int RMQ(int *st, int n, int qs, int qe, vector<int>& arr) { \\n        if (qs < 0 || qe > n-1 || qs > qe) { \\n            return -1; \\n        } \\n        return RMQUtil(st, 0, n-1, qs, qe, 0,arr); \\n    } \\n    int constructSTUtil(vector<int>& arr, int ss, int se,int *st, int si) { \\n        if (ss == se) { \\n            st[si] = ss; \\n            return ss; \\n        } \\n        int mid = getMid(ss, se);\\n        int in1 = constructSTUtil(arr, ss, mid, st, si*2+1);\\n        int in2 = constructSTUtil(arr, mid+1, se, st, si*2+2);\\n        st[si] = (arr[in1] <= arr[in2] ? in1 : in2); \\n        return st[si]; \\n    } \\n    int *constructST(vector<int>& arr, int n) { \\n        int x = (int)(ceil(log2(n)));\\n        int max_size = 2*(int)pow(2, x) - 1; \\n        int *st = new int[max_size]; \\n        constructSTUtil(arr, 0, n-1, st, 0);  \\n        return st; \\n    }\\n    void query(int l, int r, vector<ll>& pre, int* st, vector<int>& arr, ll& maxv){\\n        if(l>r) return;\\n        int in = RMQ(st, arr.size(), l, r, arr);\\n        ll prod = (pre[r] - (l>0?pre[l-1]:0)) * arr[in];\\n        maxv = max(maxv, prod);\\n        query(l, in-1, pre, st, arr, maxv);\\n        query(in+1, r, pre, st, arr, maxv);\\n    }\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pre(n);\\n        for(int i=0; i<n; i++) pre[i] = nums[i];\\n        for(int i=1; i<n; i++) pre[i] += pre[i-1];\\n        ll maxv = LLONG_MIN;\\n        int* st = constructST(nums, n);\\n        query(0,n-1,pre,st,nums,maxv);\\n        maxv %= mod;\\n        return maxv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198931,
                "title": "easy-to-understand-commented-o-n-cpp",
                "content": "```\\nint maxSumMinProduct(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    // LeftMost[i] represent the farthest element which is greater than or equal to nums[i] in left side\\n    // rightMost[i] represent the farthest element which is greater than or equal to nums[i] in right side\\n\\n    vector<int> leftMost(n), rightMost(n);\\n\\n    vector<long long int> sum(n + 1);\\n\\n    sum[0] = 0;\\n    stack<int> st;\\n    for (int i = 0; i < n; i++) {\\n        sum[i + 1] = sum[i] + nums[i];\\n\\n        // Find farthest\\n        while (st.size() && nums[st.top()] >= nums[i]) st.pop();\\n        if (st.size()) {\\n            leftMost[i] = st.top() + 1;\\n        } else {\\n            // This is the largest till now\\n            leftMost[i] = 0;\\n        }\\n        st.push(i);\\n    }\\n\\n    while (st.size()) st.pop();\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        // Find farthest from right side\\n        while (st.size() && nums[st.top()] >= nums[i]) st.pop();\\n        if (st.size()) {\\n            rightMost[i] = st.top() - 1;\\n        } else {\\n            // This is largest for right side till now\\n            rightMost[i] = n - 1;\\n        }\\n        st.push(i);\\n    }\\n\\n    long long ans = 0;\\n\\n    // let\\'s suppose each nums[i] is the minimum\\n    for (int i = 0; i < nums.size(); i++) {\\n        ans = max(ans, (long long)nums[i] * (sum[rightMost[i] + 1] - sum[leftMost[i]]));\\n    }\\n    return ans % 1000000007;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxSumMinProduct(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    // LeftMost[i] represent the farthest element which is greater than or equal to nums[i] in left side\\n    // rightMost[i] represent the farthest element which is greater than or equal to nums[i] in right side\\n\\n    vector<int> leftMost(n), rightMost(n);\\n\\n    vector<long long int> sum(n + 1);\\n\\n    sum[0] = 0;\\n    stack<int> st;\\n    for (int i = 0; i < n; i++) {\\n        sum[i + 1] = sum[i] + nums[i];\\n\\n        // Find farthest\\n        while (st.size() && nums[st.top()] >= nums[i]) st.pop();\\n        if (st.size()) {\\n            leftMost[i] = st.top() + 1;\\n        } else {\\n            // This is the largest till now\\n            leftMost[i] = 0;\\n        }\\n        st.push(i);\\n    }\\n\\n    while (st.size()) st.pop();\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        // Find farthest from right side\\n        while (st.size() && nums[st.top()] >= nums[i]) st.pop();\\n        if (st.size()) {\\n            rightMost[i] = st.top() - 1;\\n        } else {\\n            // This is largest for right side till now\\n            rightMost[i] = n - 1;\\n        }\\n        st.push(i);\\n    }\\n\\n    long long ans = 0;\\n\\n    // let\\'s suppose each nums[i] is the minimum\\n    for (int i = 0; i < nums.size(); i++) {\\n        ans = max(ans, (long long)nums[i] * (sum[rightMost[i] + 1] - sum[leftMost[i]]));\\n    }\\n    return ans % 1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198798,
                "title": "c-stack-solution-o-n",
                "content": "For each element nums[i] in array nums:\\nWe treat nums[i] as minimum number in subarray which includes nums[i]\\nLeft array storing the index of closest minimum for nums[i] on the left side and right array on the right side.\\nans = max(ans, nums[i] * getSum(left_bound_index, right_bound_index))\\n```\\nclass Solution {\\npublic:\\n    #define frr(i,j,k) for(int i=j;i<k;++i)\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t// prefix sum calculations\\n        vector<long int>sum(n+1,0);\\n        frr(i,0,n){\\n            sum[i+1]=sum[i]+nums[i];\\n        }\\n\\t\\t// array for evaluation of left side\\n        vector<int>v1=getstack(nums);\\n        reverse(nums.begin(),nums.end());\\n\\t\\t// array for evaluation of right side\\n        vector<int>v2=getstack(nums);\\n        reverse(v2.begin(),v2.end());\\n        reverse(nums.begin(),nums.end());\\n        long int ans=0;\\n        frr(i,0,n){\\n            v2[i]=n-1-v2[i];\\n        }\\n        for(int i=0;i<n;++i){\\n            int left=v1[i];\\n            int right=v2[i];\\n            if(nums[i]>nums[left])left++;\\n            if(nums[i]>nums[right])right--;\\n            long int sum1=sum[right+1]-sum[left];\\n            ans=max(ans,nums[i]*sum1);\\n        }\\n        int mod=1e9+7;\\n        return ans%mod;\\n    }\\n    vector<int> getstack(vector<int>&nums){\\n        stack<int>ss;\\n        int n=nums.size();\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;++i){\\n            if(ss.empty()){\\n                ss.push(i);\\n            }\\n            else{\\n                int fl=0;\\n                while(!ss.empty()){\\n                    int idx=ss.top();\\n                    if(nums[idx]<nums[i]){\\n                        ans[i]=idx;\\n                        break;\\n                    }\\n                    ss.pop();\\n                }\\n                ss.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define frr(i,j,k) for(int i=j;i<k;++i)\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t// prefix sum calculations\\n        vector<long int>sum(n+1,0);\\n        frr(i,0,n){\\n            sum[i+1]=sum[i]+nums[i];\\n        }\\n\\t\\t// array for evaluation of left side\\n        vector<int>v1=getstack(nums);\\n        reverse(nums.begin(),nums.end());\\n\\t\\t// array for evaluation of right side\\n        vector<int>v2=getstack(nums);\\n        reverse(v2.begin(),v2.end());\\n        reverse(nums.begin(),nums.end());\\n        long int ans=0;\\n        frr(i,0,n){\\n            v2[i]=n-1-v2[i];\\n        }\\n        for(int i=0;i<n;++i){\\n            int left=v1[i];\\n            int right=v2[i];\\n            if(nums[i]>nums[left])left++;\\n            if(nums[i]>nums[right])right--;\\n            long int sum1=sum[right+1]-sum[left];\\n            ans=max(ans,nums[i]*sum1);\\n        }\\n        int mod=1e9+7;\\n        return ans%mod;\\n    }\\n    vector<int> getstack(vector<int>&nums){\\n        stack<int>ss;\\n        int n=nums.size();\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;++i){\\n            if(ss.empty()){\\n                ss.push(i);\\n            }\\n            else{\\n                int fl=0;\\n                while(!ss.empty()){\\n                    int idx=ss.top();\\n                    if(nums[idx]<nums[i]){\\n                        ans[i]=idx;\\n                        break;\\n                    }\\n                    ss.pop();\\n                }\\n                ss.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198746,
                "title": "python-monotonic-stack-1-pass-very-consice",
                "content": "Basic idea is that for every element, if it is minimal element in certain subarry, we want to find left and right border for that subarray. And we can get it by using monotonic stack.\\n\\n- For element `a` that bigger than element `d` at stack top. The left border of `a` is the index of element `d` plus 1.\\n- For element `b` that smaller than element `c` at stack top. The `c`\\'s right border is index of `b` minus 1. And we can also get min-product of `c` as the min-value element in sub-array, by using prefix sum.\\n\\nFor simplicity, I pre-calculate prefix sum, but you can calculate on the fly for 1 PASS.\\n\\n`left` is left border.\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        p = [0]\\n        for num in nums:\\n            p.append(num+p[-1])\\n        n = len(nums)\\n        ans = 0\\n        left = [0 for _ in range(n)]\\n        s = []\\n        for i in range(n):\\n            while s and nums[s[-1]] >= nums[i]:\\n                j = s.pop()\\n                l, r = left[j], i-1\\n                ans = max(ans, (p[r+1]-p[l])*nums[j])\\n            if s:\\n                left[i] = (s[-1]+1)\\n            else:\\n                left[i] = 0\\n            s.append(i)\\n        \\n        while s:\\n            j = s.pop()\\n            l, r = left[j], n-1\\n            ans = max(ans, (p[r+1]-p[l])*nums[j])\\n        \\n        return ans % (10**9+7)\\n```\\n\\nPlease vote if you find helpful.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        p = [0]\\n        for num in nums:\\n            p.append(num+p[-1])\\n        n = len(nums)\\n        ans = 0\\n        left = [0 for _ in range(n)]\\n        s = []\\n        for i in range(n):\\n            while s and nums[s[-1]] >= nums[i]:\\n                j = s.pop()\\n                l, r = left[j], i-1\\n                ans = max(ans, (p[r+1]-p[l])*nums[j])\\n            if s:\\n                left[i] = (s[-1]+1)\\n            else:\\n                left[i] = 0\\n            s.append(i)\\n        \\n        while s:\\n            j = s.pop()\\n            l, r = left[j], n-1\\n            ans = max(ans, (p[r+1]-p[l])*nums[j])\\n        \\n        return ans % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972823,
                "title": "c-hard-level-problem-made-easy-with-explanation",
                "content": "```\\ntypedef long long ll;\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<ll> pref(n+1,0);//storing the prefix sum\\n        pref[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            pref[i]=nums[i-1]+pref[i-1];\\n        }\\n        vector<ll> right(n);//for storing the index which is smallest in the right of index i\\n        vector<ll> left(n);//for storing the index which is smallest in the left of index i\\n        right[n-1]=n;\\n        stack<ll> st1;\\n        stack<ll>st2;\\n        st1.push(n-1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(!st1.empty() and nums[st1.top()]>=nums[i])\\n                st1.pop();\\n            if(st1.empty())\\n                right[i]=n;\\n            else\\n                right[i]=st1.top();\\n            st1.push(i);\\n        }\\n        left[0]=-1;\\n        st2.push(0);\\n        for(int i=1;i<n;i++)\\n        {\\n            while(!st2.empty() and nums[i]<=nums[st2.top()])\\n                st2.pop();\\n            if(st2.empty())\\n                left[i]=-1;\\n            else\\n                left[i]=st2.top();\\n                st2.push(i);\\n        }\\n        ll maxi=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll ans=(((pref[right[i]]-pref[left[i]+1]))*nums[i]);//considering  nums[i] smaller\\n            maxi=max(maxi,ans);//then finding the corresponding subbarray sum multiplying with nums[i]\\n        }                                  // and finding maximum by considering each element\\n        return maxi%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<ll> pref(n+1,0);//storing the prefix sum\\n        pref[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            pref[i]=nums[i-1]+pref[i-1];\\n        }\\n        vector<ll> right(n);//for storing the index which is smallest in the right of index i\\n        vector<ll> left(n);//for storing the index which is smallest in the left of index i\\n        right[n-1]=n;\\n        stack<ll> st1;\\n        stack<ll>st2;\\n        st1.push(n-1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(!st1.empty() and nums[st1.top()]>=nums[i])\\n                st1.pop();\\n            if(st1.empty())\\n                right[i]=n;\\n            else\\n                right[i]=st1.top();\\n            st1.push(i);\\n        }\\n        left[0]=-1;\\n        st2.push(0);\\n        for(int i=1;i<n;i++)\\n        {\\n            while(!st2.empty() and nums[i]<=nums[st2.top()])\\n                st2.pop();\\n            if(st2.empty())\\n                left[i]=-1;\\n            else\\n                left[i]=st2.top();\\n                st2.push(i);\\n        }\\n        ll maxi=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll ans=(((pref[right[i]]-pref[left[i]+1]))*nums[i]);//considering  nums[i] smaller\\n            maxi=max(maxi,ans);//then finding the corresponding subbarray sum multiplying with nums[i]\\n        }                                  // and finding maximum by considering each element\\n        return maxi%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573787,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Stack && Prefix Sum***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        // find the prefix sum\\n        \\n        vector<long long> prefix(n, 0);\\n        \\n        prefix[0] = arr[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + arr[i];\\n        }\\n        \\n        // declare a stack\\n        \\n        stack<int> st;\\n        \\n        // find the index of next smaller element on left side\\n        \\n        vector<int> left(n, -1);\\n        \\n        vector<int> right(n, n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            while(st.empty() == false && arr[st.top()] >= arr[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            if(st.empty())\\n            {\\n                left[i] = -1;\\n            }\\n            else\\n            {\\n                left[i] = st.top();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        // empty stack\\n        \\n        while(st.empty() == false)\\n        {\\n            st.pop();\\n        }\\n        \\n        // find the next smaller element on right side\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            while(st.empty() == false && arr[st.top()] >= arr[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            if(st.empty())\\n            {\\n                right[i] = n;\\n            }\\n            else\\n            {\\n                right[i] = st.top();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        // calculate maximum min-product \\n       \\n        long long max_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            long long sum = 0;\\n            \\n            sum += prefix[right[i] - 1];\\n            \\n            if(left[i] >= 0)\\n            {\\n                sum -= prefix[left[i]];\\n            }\\n            \\n            sum *= arr[i];\\n            \\n            max_sum = max(max_sum, sum);\\n        }\\n        \\n        return max_sum % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        // find the prefix sum\\n        \\n        vector<long long> prefix(n, 0);\\n        \\n        prefix[0] = arr[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            prefix[i] = prefix[i - 1] + arr[i];\\n        }\\n        \\n        // declare a stack\\n        \\n        stack<int> st;\\n        \\n        // find the index of next smaller element on left side\\n        \\n        vector<int> left(n, -1);\\n        \\n        vector<int> right(n, n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            while(st.empty() == false && arr[st.top()] >= arr[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            if(st.empty())\\n            {\\n                left[i] = -1;\\n            }\\n            else\\n            {\\n                left[i] = st.top();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        // empty stack\\n        \\n        while(st.empty() == false)\\n        {\\n            st.pop();\\n        }\\n        \\n        // find the next smaller element on right side\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            while(st.empty() == false && arr[st.top()] >= arr[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            if(st.empty())\\n            {\\n                right[i] = n;\\n            }\\n            else\\n            {\\n                right[i] = st.top();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        // calculate maximum min-product \\n       \\n        long long max_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            long long sum = 0;\\n            \\n            sum += prefix[right[i] - 1];\\n            \\n            if(left[i] >= 0)\\n            {\\n                sum -= prefix[left[i]];\\n            }\\n            \\n            sum *= arr[i];\\n            \\n            max_sum = max(max_sum, sum);\\n        }\\n        \\n        return max_sum % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383924,
                "title": "python-1856",
                "content": "\\tclass Solution:\\n\\t\\tdef maxSumMinProduct(self, nums: List[int]) -> int:\\n\\t\\t\\tnums.append(0)\\n\\t\\t\\tans = 0\\n\\t\\t\\tstack = []\\n\\t\\t\\tprefix = [0] + list(accumulate(nums))\\n\\n\\n\\t\\t\\tfor i,num in enumerate(nums):\\n\\t\\t\\t\\twhile stack and nums[stack[-1]] > num:\\n\\t\\t\\t\\t\\tminval = nums[stack.pop()]\\n\\t\\t\\t\\t\\tif not stack:\\n\\t\\t\\t\\t\\t\\tsumm = prefix[i]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsumm = prefix[i]-prefix[stack[-1]+1]\\n\\t\\t\\t\\t\\tans = max(ans,minval*summ)\\n\\n\\t\\t\\t\\tstack.append(i)\\n\\n\\t\\t\\treturn (ans% int(1e9+7))",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxSumMinProduct(self, nums: List[int]) -> int:\\n\\t\\t\\tnums.append(0)\\n\\t\\t\\tans = 0\\n\\t\\t\\tstack = []\\n\\t\\t\\tprefix = [0] + list(accumulate(nums))\\n\\n\\n\\t\\t\\tfor i,num in enumerate(nums):\\n\\t\\t\\t\\twhile stack and nums[stack[-1]] > num:\\n\\t\\t\\t\\t\\tminval = nums[stack.pop()]\\n\\t\\t\\t\\t\\tif not stack:\\n\\t\\t\\t\\t\\t\\tsumm = prefix[i]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsumm = prefix[i]-prefix[stack[-1]+1]\\n\\t\\t\\t\\t\\tans = max(ans,minval*summ)\\n\\n\\t\\t\\t\\tstack.append(i)\\n\\n\\t\\t\\treturn (ans% int(1e9+7))",
                "codeTag": "Java"
            },
            {
                "id": 2375169,
                "title": "c-next-smaller-element-stack",
                "content": "```cpp\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    int maxSumMinProduct(vector<int>& a) {\\n        ll ans = 0, n = a.size();\\n        \\n        // calculating prefix sum\\n        vector<ll> pre(n+1, 0);\\n        for(int i=1; i<=n; i++)\\n            pre[i] = pre[i-1] + a[i-1];\\n        \\n        vector<int> lef(n), rig(n);\\n        \\n        // storing index of leftmost element which is >= current element\\n        stack<int> s;\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!s.empty() && (a[s.top()] >= a[i]))\\n                s.pop();       \\n            if(s.empty()) lef[i] = 0;\\n            else lef[i] = s.top()+1;\\n            s.push(i);\\n        }\\n        while(!s.empty()) s.pop();\\n        \\n        // storing index of rightmost element which is >= current element\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            while(!s.empty() && (a[s.top()] >= a[i]))\\n                s.pop();\\n            \\n            if(s.empty()) rig[i] = n-1;\\n            else rig[i] = s.top() - 1;\\n            s.push(i);\\n        }\\n        \\n        // calculating ans, considering each element as min element\\n        for(int i=0; i<n; i++)\\n        {\\n            ll sum = pre[rig[i]+1] - pre[lef[i]];\\n            ans = max(ans, sum * a[i]);\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    int maxSumMinProduct(vector<int>& a) {\\n        ll ans = 0, n = a.size();\\n        \\n        // calculating prefix sum\\n        vector<ll> pre(n+1, 0);\\n        for(int i=1; i<=n; i++)\\n            pre[i] = pre[i-1] + a[i-1];\\n        \\n        vector<int> lef(n), rig(n);\\n        \\n        // storing index of leftmost element which is >= current element\\n        stack<int> s;\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!s.empty() && (a[s.top()] >= a[i]))\\n                s.pop();       \\n            if(s.empty()) lef[i] = 0;\\n            else lef[i] = s.top()+1;\\n            s.push(i);\\n        }\\n        while(!s.empty()) s.pop();\\n        \\n        // storing index of rightmost element which is >= current element\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            while(!s.empty() && (a[s.top()] >= a[i]))\\n                s.pop();\\n            \\n            if(s.empty()) rig[i] = n-1;\\n            else rig[i] = s.top() - 1;\\n            s.push(i);\\n        }\\n        \\n        // calculating ans, considering each element as min element\\n        for(int i=0; i<n; i++)\\n        {\\n            ll sum = pre[rig[i]+1] - pre[lef[i]];\\n            ans = max(ans, sum * a[i]);\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339154,
                "title": "c-intuitive-prefix-sum-array-and-monotonic-stack",
                "content": "This problem has a direct intuition. We observe that if we consider each number as a minimum of some subarray, we just need to find that subarray. Now, the question is \\n**How to find that subarray?** \\nWe just need to use the fact that our current element is the minimum element in that subarray. That means that on both, to its left and to its right, we should have numbers which are greater than or equal to this current number. For ex, \\n```\\nnums[] = [1,2,3,3,4,5,3,2]\\n```\\nFor i = 3, the subarray possible is, [3,3,4,5,3], since beyond these boundaries, we will have numbers which are smaller than 3, which, if included, will change the minimum of this subarray. \\n**Therefore, the problem reduces to finding the previous smaller and next smaller element.**\\nFor that, we use **`monotonic stack`**. If you dont know about monotonic stack, it is a way of using stack in such a way that it finds the next smaller element in an array. \\nFor the sum of a subarray, I used **prefix sum array**. \\n\\nRest can be seen from the code below :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        long long n = nums.size(), sum = 0;\\n        vector<long long> prefix(n,0);\\n\\t\\t\\n\\t\\t// Prefix sum array to find the sum of any subarray in O(1)\\n        for(int i = 0; i<nums.size(); i++){\\n            sum += nums[i];\\n            prefix[i] = sum;\\n        }\\n        \\n        vector <int> prev(n,0), next(n,0);\\n        \\n\\t\\t// Finding the previous smaller element\\n        stack <pair<int,int>> s;\\n        for(int i = 0; i<n; i++){\\n            if(s.empty()) s.push({nums[i],i});\\n            else{\\n                while(!s.empty() and nums[i]<s.top().first) next[s.top().second] = i, s.pop();\\n                s.push({nums[i],i});\\n             }\\n        }\\n        while(!s.empty()) next[s.top().second] = n, s.pop();\\n        \\n\\t\\t// Finding the next smaller element\\n        for(int i = n-1; i>=0; i--){\\n            if(s.empty()) s.push({nums[i],i});\\n            else{\\n                while(!s.empty() and nums[i]<s.top().first) prev[s.top().second] = i, s.pop();\\n                s.push({nums[i],i});\\n            }\\n        }\\n        while(!s.empty()) prev[s.top().second] = 0, s.pop();\\n        \\n\\t\\t// Calculating the answer from prefix array, previous and next smaller array\\n        long long ans = 0;\\n        for(int i = 0; i<n; i++){\\n\\t\\t\\tlong long prod = prefix[next[i]-1];\\n\\t\\t\\t\\n\\t\\t\\t// If current element has no previous smaller element.\\n            if(nums[prev[i]]<nums[i]) prod -= prefix[prev[i]];\\n            prod *= nums[i];\\n            ans = max(ans,prod);\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nnums[] = [1,2,3,3,4,5,3,2]\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        long long n = nums.size(), sum = 0;\\n        vector<long long> prefix(n,0);\\n\\t\\t\\n\\t\\t// Prefix sum array to find the sum of any subarray in O(1)\\n        for(int i = 0; i<nums.size(); i++){\\n            sum += nums[i];\\n            prefix[i] = sum;\\n        }\\n        \\n        vector <int> prev(n,0), next(n,0);\\n        \\n\\t\\t// Finding the previous smaller element\\n        stack <pair<int,int>> s;\\n        for(int i = 0; i<n; i++){\\n            if(s.empty()) s.push({nums[i],i});\\n            else{\\n                while(!s.empty() and nums[i]<s.top().first) next[s.top().second] = i, s.pop();\\n                s.push({nums[i],i});\\n             }\\n        }\\n        while(!s.empty()) next[s.top().second] = n, s.pop();\\n        \\n\\t\\t// Finding the next smaller element\\n        for(int i = n-1; i>=0; i--){\\n            if(s.empty()) s.push({nums[i],i});\\n            else{\\n                while(!s.empty() and nums[i]<s.top().first) prev[s.top().second] = i, s.pop();\\n                s.push({nums[i],i});\\n            }\\n        }\\n        while(!s.empty()) prev[s.top().second] = 0, s.pop();\\n        \\n\\t\\t// Calculating the answer from prefix array, previous and next smaller array\\n        long long ans = 0;\\n        for(int i = 0; i<n; i++){\\n\\t\\t\\tlong long prod = prefix[next[i]-1];\\n\\t\\t\\t\\n\\t\\t\\t// If current element has no previous smaller element.\\n            if(nums[prev[i]]<nums[i]) prod -= prefix[prev[i]];\\n            prod *= nums[i];\\n            ans = max(ans,prod);\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121348,
                "title": "c-solution-using-monotonic-stack-and-prefix-sum",
                "content": "```\\nclass Solution {\\nprivate:\\n    int mod=1000000000+7;\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        //treat each element as the minimum and find its left and right bound using monotonic stack\\n        //use prefix sum to find subarray sum in constant time\\n        int n=nums.size();\\n        vector<long long>prefix(n+1,0);\\n        for(int i=1;i<prefix.size();i++){\\n            prefix[i]=prefix[i-1]+(long long)nums[i-1];\\n        }\\n        vector<int>left(n,0),right(n,n);\\n        vector<int>stack;\\n        for(int i=0;i<n;i++){\\n            while(stack.size() and nums[stack.back()]>nums[i]){\\n                right[stack.back()]=i;\\n                stack.pop_back();\\n            }\\n            stack.push_back(i);\\n        }\\n        stack.clear();\\n        for(int i=n-1;i>=0;i--){\\n            while(stack.size() and nums[stack.back()]>nums[i]){\\n                left[stack.back()]=i+1;\\n                stack.pop_back();\\n            }\\n            stack.push_back(i);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            long long rangeSum=prefix[right[i]]-prefix[left[i]];\\n            long long currProduct=(long long)nums[i]*rangeSum;\\n            ans=max(ans,currProduct);\\n        }\\n        return ans%mod;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\nprivate:\\n    int mod=1000000000+7;\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        //treat each element as the minimum and find its left and right bound using monotonic stack\\n        //use prefix sum to find subarray sum in constant time\\n        int n=nums.size();\\n        vector<long long>prefix(n+1,0);\\n        for(int i=1;i<prefix.size();i++){\\n            prefix[i]=prefix[i-1]+(long long)nums[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2092022,
                "title": "c-solution-using-stack-and-prefix-sum",
                "content": "```\\n// consider each element as it is min value of subarray, then find such subarray and add those elements \\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> leftLimit(n), rightLimit(n);\\n        vector<long long>prefixSum(n+1, 0);\\n        \\n        stack<int> stk;\\n        \\n        // store left index whose value is less than current element\\n        for(int i=0; i<n; i++){\\n            while(!stk.empty() && nums[stk.top()] >= nums[i]){\\n                stk.pop();\\n            }\\n            leftLimit[i] = stk.empty() ? 0 : stk.top() + 1;\\n            stk.push(i);\\n            \\n            prefixSum[i+1] = prefixSum[i] + (long long)nums[i];\\n        }\\n        \\n        while(!stk.empty()) stk.pop();\\n        // store right index whose value is less than current element\\n        for(int i=n-1; i>=0; i--){\\n            while(!stk.empty() && nums[stk.top()] >= nums[i]){\\n                stk.pop();\\n            }\\n            rightLimit[i] = stk.empty() ? n-1 : stk.top() - 1;\\n            stk.push(i);\\n        }\\n        \\n        long long maxMinProduct = 0;\\n        for(int i=0; i<n; i++){\\n            long long rangeSum = prefixSum[rightLimit[i]+1] - prefixSum[leftLimit[i]];\\n            long long curMinProduct = (long long)nums[i]*rangeSum;\\n            maxMinProduct = max(maxMinProduct, curMinProduct);\\n        }\\n        return maxMinProduct % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\n// consider each element as it is min value of subarray, then find such subarray and add those elements \\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> leftLimit(n), rightLimit(n);\\n        vector<long long>prefixSum(n+1, 0);\\n        \\n        stack<int> stk;\\n        \\n        // store left index whose value is less than current element\\n        for(int i=0; i<n; i++){\\n            while(!stk.empty() && nums[stk.top()] >= nums[i]){\\n                stk.pop();\\n            }\\n            leftLimit[i] = stk.empty() ? 0 : stk.top() + 1;\\n            stk.push(i);\\n            \\n            prefixSum[i+1] = prefixSum[i] + (long long)nums[i];\\n        }\\n        \\n        while(!stk.empty()) stk.pop();\\n        // store right index whose value is less than current element\\n        for(int i=n-1; i>=0; i--){\\n            while(!stk.empty() && nums[stk.top()] >= nums[i]){\\n                stk.pop();\\n            }\\n            rightLimit[i] = stk.empty() ? n-1 : stk.top() - 1;\\n            stk.push(i);\\n        }\\n        \\n        long long maxMinProduct = 0;\\n        for(int i=0; i<n; i++){\\n            long long rangeSum = prefixSum[rightLimit[i]+1] - prefixSum[leftLimit[i]];\\n            long long curMinProduct = (long long)nums[i]*rangeSum;\\n            maxMinProduct = max(maxMinProduct, curMinProduct);\\n        }\\n        return maxMinProduct % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900740,
                "title": "c-o-n-stack-solution",
                "content": "Runtime: 243 ms, faster than 83.17% of C++ online submissions for Maximum Subarray Min-Product.\\nMemory Usage: 83.6 MB, less than 81.25% of C++ online submissions for Maximum Subarray Min-Product.\\n\\n```\\nNeed to maintain a monotone increasing order using Stack to find each potential max\\nvalues which are at the top of the Stack until smaller value of nums[i] appears at top.\\n\\nEach max top values can have subarray from previous min value (Stack next top value )\\nto current min value (nums[i]).\\n\\nMin value max product =>  nums[Stack.top()] * Sum between previous min and current min value.\\n\\nPrefix sum array can provide the range sum from previous min to current min.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<long long>prefixSum(n);\\n        \\n        // store prefix sum of the given array\\n        prefixSum[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n            prefixSum[i]+=prefixSum[i-1]+nums[i];\\n        \\n        long long res = 0L;\\n        long long curr;\\n        long long sum;\\n        int index;\\n        stack<int>stak;    // monote stack\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            // for each current value loop until stak is empty or previous min value is found\\n            // stak top values are potential max values who\\'s previous min value is in the stak\\n            // so the product => potential max value * prefixSum[previous min value to current value]\\n            // also at last until stak is empty process all the values\\n            while(!stak.empty() && (i==n || nums[stak.top()]>nums[i]))\\n            {\\n                index = stak.top();\\n                stak.pop();\\n                curr = nums[index];\\n                \\n                // sum between previous min value and current value\\n                sum = (prefixSum[i-1] - (stak.empty() ? 0 : prefixSum[stak.top()]));\\n                \\n                // update max product\\n                res = max(res, curr * sum);                 \\n            }   \\n\\n            rightStak.push(i);\\n        }\\n\\n        return res % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nNeed to maintain a monotone increasing order using Stack to find each potential max\\nvalues which are at the top of the Stack until smaller value of nums[i] appears at top.\\n\\nEach max top values can have subarray from previous min value (Stack next top value )\\nto current min value (nums[i]).\\n\\nMin value max product =>  nums[Stack.top()] * Sum between previous min and current min value.\\n\\nPrefix sum array can provide the range sum from previous min to current min.\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<long long>prefixSum(n);\\n        \\n        // store prefix sum of the given array\\n        prefixSum[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n            prefixSum[i]+=prefixSum[i-1]+nums[i];\\n        \\n        long long res = 0L;\\n        long long curr;\\n        long long sum;\\n        int index;\\n        stack<int>stak;    // monote stack\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            // for each current value loop until stak is empty or previous min value is found\\n            // stak top values are potential max values who\\'s previous min value is in the stak\\n            // so the product => potential max value * prefixSum[previous min value to current value]\\n            // also at last until stak is empty process all the values\\n            while(!stak.empty() && (i==n || nums[stak.top()]>nums[i]))\\n            {\\n                index = stak.top();\\n                stak.pop();\\n                curr = nums[index];\\n                \\n                // sum between previous min value and current value\\n                sum = (prefixSum[i-1] - (stak.empty() ? 0 : prefixSum[stak.top()]));\\n                \\n                // update max product\\n                res = max(res, curr * sum);                 \\n            }   \\n\\n            rightStak.push(i);\\n        }\\n\\n        return res % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888358,
                "title": "python-o-n-space-and-time-solution-detailed-explanation-with-comments",
                "content": "class Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        # O(N) time and space\\n        \\n        stack = []\\n        res = 0\\n        n = len(nums)\\n        prefix = [0]\\n        \\n        # prefix sums will help us get sum for any given subarray in O(1) time\\n        for i in range(n):\\n            prefix.append(prefix[i]+nums[i])\\n            \\n        # We need to maintain a stack with increasing order of elements\\n        # We push a tuple (start, num), start is basically start index of any subarray whose minimum element is num. For every such num being pushed into\\n        # stack, we try to find widest subarray, starting from num\\'s start and \\n        # having num as its minimum element.(Finding widest as we wanna maximize)\\n        # the sum.example - [1,2,3,4,2]. Stack- [[0,1,[1,2],[2,3],[3,4]].Now while\\n        # pushing 2(at idx 5), we see stack top>2. So basically we can\\'t stretch\\n        # the subarray having 4 as it\\'s min anymore. So we pop that out, and calc\\n        # min product for it, which is 4*(prefix[i]-prefix[start]), and update res\\n        # Now we need to insert this 2. What value do we keep as it\\'s start val?\\n        # Since 2 has been the min value since the start of all those elements\\n        # that have been popped (the elements 3 and 4), so start idx of a subarray\\n        # with this 2 as min would be the start idx of 3, which is 2,so push [2,2]\\n        \\n        \\n        for i in range(n):\\n            start = i\\n            while stack and stack[-1][1]>nums[i]:\\n                start, num = stack.pop()\\n                res = max( res, num*(prefix[i]-prefix[start]) )\\n            \\n            stack.append( (start, nums[i]) )\\n        \\n        # Elements still remaining in stack will mean they don\\'t have any\\n        # number to their right which is lesser than them, so we can say\\n        # that for an element in stack, longest subarray would be of size\\n        # n-start, so we take total of all those elements an multiply with element\\n        while stack:\\n            start, num = stack.pop()\\n            res = max(res, num*(prefix[n]-prefix[start]))\\n        \\n        return res%(10**9 + 7)\\n            \\n",
                "solutionTags": [
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        # O(N) time and space\\n        \\n        stack = []\\n        res = 0\\n        n = len(nums)\\n        prefix = [0]\\n        \\n        # prefix sums will help us get sum for any given subarray in O(1) time\\n        for i in range(n):\\n            prefix.append(prefix[i]+nums[i])\\n            \\n        # We need to maintain a stack with increasing order of elements\\n        # We push a tuple (start, num), start is basically start index of any subarray whose minimum element is num. For every such num being pushed into\\n        # stack, we try to find widest subarray, starting from num\\'s start and \\n        # having num as its minimum element.(Finding widest as we wanna maximize)\\n        # the sum.example - [1,2,3,4,2]. Stack- [[0,1,[1,2],[2,3],[3,4]].Now while\\n        # pushing 2(at idx 5), we see stack top>2. So basically we can\\'t stretch\\n        # the subarray having 4 as it\\'s min anymore. So we pop that out, and calc\\n        # min product for it, which is 4*(prefix[i]-prefix[start]), and update res\\n        # Now we need to insert this 2. What value do we keep as it\\'s start val?\\n        # Since 2 has been the min value since the start of all those elements\\n        # that have been popped (the elements 3 and 4), so start idx of a subarray\\n        # with this 2 as min would be the start idx of 3, which is 2,so push [2,2]\\n        \\n        \\n        for i in range(n):\\n            start = i\\n            while stack and stack[-1][1]>nums[i]:\\n                start, num = stack.pop()\\n                res = max( res, num*(prefix[i]-prefix[start]) )\\n            \\n            stack.append( (start, nums[i]) )\\n        \\n        # Elements still remaining in stack will mean they don\\'t have any\\n        # number to their right which is lesser than them, so we can say\\n        # that for an element in stack, longest subarray would be of size\\n        # n-start, so we take total of all those elements an multiply with element\\n        while stack:\\n            start, num = stack.pop()\\n            res = max(res, num*(prefix[n]-prefix[start]))\\n        \\n        return res%(10**9 + 7)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1511161,
                "title": "c-stack-solution",
                "content": "```\\nvector<long long> prefixSum(vector<int> &nums, int n)\\n{\\n\\tvector<long long> prefix;\\n\\n\\tlong long sum = 0;\\n\\n\\tfor(auto &x : nums)\\n\\t{\\n\\t\\tsum += x;\\n\\t\\tprefix.push_back(sum);\\n\\t}\\n\\n\\treturn prefix;\\n}\\n\\nvector<int> nsl(vector<int> &nums, int n)\\n{\\n\\tstack<int> st;\\n\\n\\tvector<int> vect;\\n\\n\\tfor(int i = 0; i < n; i++)\\n\\t{\\n\\t\\twhile(!st.empty() and nums[i] <= nums[st.top()])\\n\\t\\t\\tst.pop();\\n\\n\\t\\tst.empty() ? vect.push_back(0) : vect.push_back(st.top() + 1);\\n\\n\\t\\tst.push(i);\\n\\t}\\n\\n\\treturn vect;\\n}\\n\\nvector<int> nsr(vector<int> &nums, int n)\\n{\\n\\tstack<int> st;\\n\\n\\tvector<int> vect;\\n\\n\\tfor(int i = n-1; i >= 0; i--)\\n\\t{\\n\\t\\twhile(!st.empty() and nums[i] <= nums[st.top()])\\n\\t\\t\\tst.pop();\\n\\n\\t\\tst.empty() ? vect.push_back(n-1) : vect.push_back(st.top()-1);\\n\\n\\t\\tst.push(i);\\n\\t}\\n\\n\\treverse(vect.begin(), vect.end());\\n\\n\\treturn vect;\\n}\\n\\nlong long getSum(vector<long long> &prefix, int l, int r)\\n{\\n\\tif(l == 0)\\n\\t\\treturn prefix[r];\\n\\n\\treturn prefix[r] - prefix[l-1];\\n}\\n\\nint maxSumMinProduct(vector<int>& nums) {\\n\\n\\tint n = nums.size(), mod = 1e9+7;\\n\\n\\tvector<int> left = nsl(nums, n), right = nsr(nums, n); // nearest smaller to left and right respectively/\\n\\n\\tvector<long long> prefix = prefixSum(nums, n);\\n\\n\\tlong long maxProduct = INT_MIN, temp;\\n\\n\\tfor(int i = 0;i < n; i++)\\n\\t{\\n\\t\\ttemp = ((long long)nums[i] * getSum(prefix, left[i], right[i]));\\n\\t\\tmaxProduct = max(maxProduct, temp);\\n\\t}\\n\\n\\treturn maxProduct % mod;\\n}\\n```\\n\\nTime Complexity - `O(n)`\\nSpace Complexity - `O(n)`",
                "solutionTags": [
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<long long> prefixSum(vector<int> &nums, int n)\\n{\\n\\tvector<long long> prefix;\\n\\n\\tlong long sum = 0;\\n\\n\\tfor(auto &x : nums)\\n\\t{\\n\\t\\tsum += x;\\n\\t\\tprefix.push_back(sum);\\n\\t}\\n\\n\\treturn prefix;\\n}\\n\\nvector<int> nsl(vector<int> &nums, int n)\\n{\\n\\tstack<int> st;\\n\\n\\tvector<int> vect;\\n\\n\\tfor(int i = 0; i < n; i++)\\n\\t{\\n\\t\\twhile(!st.empty() and nums[i] <= nums[st.top()])\\n\\t\\t\\tst.pop();\\n\\n\\t\\tst.empty() ? vect.push_back(0) : vect.push_back(st.top() + 1);\\n\\n\\t\\tst.push(i);\\n\\t}\\n\\n\\treturn vect;\\n}\\n\\nvector<int> nsr(vector<int> &nums, int n)\\n{\\n\\tstack<int> st;\\n\\n\\tvector<int> vect;\\n\\n\\tfor(int i = n-1; i >= 0; i--)\\n\\t{\\n\\t\\twhile(!st.empty() and nums[i] <= nums[st.top()])\\n\\t\\t\\tst.pop();\\n\\n\\t\\tst.empty() ? vect.push_back(n-1) : vect.push_back(st.top()-1);\\n\\n\\t\\tst.push(i);\\n\\t}\\n\\n\\treverse(vect.begin(), vect.end());\\n\\n\\treturn vect;\\n}\\n\\nlong long getSum(vector<long long> &prefix, int l, int r)\\n{\\n\\tif(l == 0)\\n\\t\\treturn prefix[r];\\n\\n\\treturn prefix[r] - prefix[l-1];\\n}\\n\\nint maxSumMinProduct(vector<int>& nums) {\\n\\n\\tint n = nums.size(), mod = 1e9+7;\\n\\n\\tvector<int> left = nsl(nums, n), right = nsr(nums, n); // nearest smaller to left and right respectively/\\n\\n\\tvector<long long> prefix = prefixSum(nums, n);\\n\\n\\tlong long maxProduct = INT_MIN, temp;\\n\\n\\tfor(int i = 0;i < n; i++)\\n\\t{\\n\\t\\ttemp = ((long long)nums[i] * getSum(prefix, left[i], right[i]));\\n\\t\\tmaxProduct = max(maxProduct, temp);\\n\\t}\\n\\n\\treturn maxProduct % mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464067,
                "title": "python-clean-minstack",
                "content": "Similiar idea with [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\nFor each element `x`, find the \"largest\" window whose minimum is this `x`.  The \"largeness\" of this window is the sum of all elements inside the window.\\nSince all element are positive number, the \"largest\" window is actually the \"widest\" windows.\\nWe can maintain a min stack to get a window\\'s left and right border in constant time. Each time we pop an element `x` from the min stack, we know the right border is the current element that force `x` being popped out and the left border is the element ahead of `x` in min stack. We can also maintain a presum array to get window\\'s largeness in constant time.\\n\\n```\\ndef maxSumMinProduct(A):\\n\\tP, S = [0], [-1]\\n\\tans, M = 0, 10**9 + 7\\n\\tA.append(0)\\n\\tfor i, x in enumerate(A):\\n\\t\\twhile len(S) > 1 and A[S[-1]] >= x:\\n\\t\\t\\tans = max(ans, A[S.pop()] * (P[-1]-P[S[-1]+1]))\\n\\t\\tP.append(P[-1] + x)\\n\\t\\tS.append(i)\\n\\treturn ans % M\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxSumMinProduct(A):\\n\\tP, S = [0], [-1]\\n\\tans, M = 0, 10**9 + 7\\n\\tA.append(0)\\n\\tfor i, x in enumerate(A):\\n\\t\\twhile len(S) > 1 and A[S[-1]] >= x:\\n\\t\\t\\tans = max(ans, A[S.pop()] * (P[-1]-P[S[-1]+1]))\\n\\t\\tP.append(P[-1] + x)\\n\\t\\tS.append(i)\\n\\treturn ans % M\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1200352,
                "title": "c-1856-maximum-subarray-min-product",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        vector<long> prefix = {0}; \\n        for (auto x : nums) \\n            prefix.push_back(prefix.back() + x); \\n        \\n        long ans = 0; \\n        stack<pair<int, int>> stk; \\n        nums.push_back(0); \\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            int ii = i; \\n            while (stk.size() && stk.top().second >= nums[i]) {\\n                ii = stk.top().first; \\n                int val = stk.top().second; \\n                ans = max(ans, val * (prefix[i] - prefix[ii])); \\n                stk.pop(); \\n            }\\n            stk.push(make_pair(ii, nums[i])); \\n        }\\n        return ans % 1\\'000\\'000\\'007; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        vector<long> prefix = {0}; \\n        for (auto x : nums) \\n            prefix.push_back(prefix.back() + x); \\n        \\n        long ans = 0; \\n        stack<pair<int, int>> stk; \\n        nums.push_back(0); \\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            int ii = i; \\n            while (stk.size() && stk.top().second >= nums[i]) {\\n                ii = stk.top().first; \\n                int val = stk.top().second; \\n                ans = max(ans, val * (prefix[i] - prefix[ii])); \\n                stk.pop(); \\n            }\\n            stk.push(make_pair(ii, nums[i])); \\n        }\\n        return ans % 1\\'000\\'000\\'007; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199805,
                "title": "java-no-stack-beats-100",
                "content": "We can borrow the idea from largest histogram. Using skip array technique to find index faster\\nhere is code\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 1; i <= n; i++) { // prefix Sum\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        for (int i = 0; i < nums.length; i++) {\\n            int index = i - 1;\\n            while (index >= 0 && nums[index] >= nums[i]) { // this is key part\\n                index = left[index];\\n            }\\n            left[i] = index;\\n        }\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int index = i + 1;\\n            while (index < nums.length && nums[index] >= nums[i]) {\\n                index = right[index];\\n            }\\n            right[i] = index;\\n        }\\n        long max = 0;\\n        for (int i = 0; i < n; i++) { // make current element as Min value\\n            int l = left[i];\\n            int r = right[i];\\n            long sum = prefixSum[r] - prefixSum[l + 1];\\n            long prod = sum * nums[i];\\n            max = Math.max(prod, max);\\n        }\\n        return (int)(max % 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 1; i <= n; i++) { // prefix Sum\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        for (int i = 0; i < nums.length; i++) {\\n            int index = i - 1;\\n            while (index >= 0 && nums[index] >= nums[i]) { // this is key part\\n                index = left[index];\\n            }\\n            left[i] = index;\\n        }\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int index = i + 1;\\n            while (index < nums.length && nums[index] >= nums[i]) {\\n                index = right[index];\\n            }\\n            right[i] = index;\\n        }\\n        long max = 0;\\n        for (int i = 0; i < n; i++) { // make current element as Min value\\n            int l = left[i];\\n            int r = right[i];\\n            long sum = prefixSum[r] - prefixSum[l + 1];\\n            long prod = sum * nums[i];\\n            max = Math.max(prod, max);\\n        }\\n        return (int)(max % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199725,
                "title": "c-monotone-stack",
                "content": "Classical variation of Monotonic stack \\n\\n**EXPLANATION** : \\n\\n\\n<details>\\n<summary>Function definition</summary>\\n <pre>\\n \\n ```C++\\n #define ll long long \\nclass Solution {\\npublic:\\n    int maxSumMinProduct(nums) {        \\n        ll prefix[100000+1]{0};\\n        ll suffix[100000+1]{0};        \\n        ll n = nums.size();\\n        unordered_map<ll,ll> minL,minR;        \\n        stack<ll>st,st2; //to store indices, no need of stack of pairs \\n\\t\\tlong long sum = 0 , ans = 0;\\n        }\\n```\\n</pre>\\n</details>\\n<br>\\n<details>\\n<summary>Prefix sum </summary>\\n <pre>\\n \\n```C++\\nfor(ll i=0;;+i){\\n            prefix[i] = nums[i];\\n            if(i-1 >= 0)prefix[i] += prefix[i-1];\\n\\tif(i>=n)break;\\n        }\\n```\\t\\n</pre>\\n</details>\\n<br>\\n<details>\\n<summary>suffix sum </summary>\\n <pre> \\n \\n ```C++\\n for(ll i=n-1;i>=0;--i){\\n            suffix[i] = nums[i];\\n            if(n > i+1)suffix[i] += suffix[i+1];\\n        }\\n```\\n</pre>\\n</details>\\n<br>\\n<details>\\n<summary>Find Previous minimum index for each of the current index </summary>\\n <pre>  \\n \\n ```C++\\n for(int i=n-1;i>=0;--i){\\n            while(!st.empty() and nums[st.top()] >= nums[i])\\n                st.pop();\\n            if(!st.empty() and nums[i] > nums[st.top()] )\\n                minR[i] = st.top();\\n            st.push(i);\\n        }\\n```\\n</pre>\\n</details>\\n<br>\\n<details>\\n<summary>Find Next minimum index for each of the current index </summary>\\n <pre>    \\n \\n ```C++\\n for(int i=0;n>i;++i){\\n            while(!st2.empty() and nums[st2.top()] >= nums[i])\\n                st2.pop();\\n            if(!st2.empty() and nums[i] > nums[st2.top()] )\\n                minL[i] = st2.top();\\n            st2.push(i);\\n        }  \\n```\\n</pre>\\n</details>\\n  <br>\\n<details>\\n<summary>Find by considering each element as the smallest element  </summary>\\n <pre>     \\n \\n ```C++\\n for(int i=0;n>i;++i){                        \\n          long long val = prefix[i] + suffix[i] - nums[i];            \\n          if(minL.count(i))\\n              val -= prefix[minL[i]];\\n          if(minR.count(i))\\n              val -= suffix[minR[i]];                          \\n          val *= nums[i];                        \\n          ans = max(ans,val);            \\n      } \\n```\\t  \\n</pre>\\n</details>\\n   <br>\\n<details>\\n<summary>Modding out </summary>\\n <pre>   \\n \\n ```C++\\n        int mod = 1e9+7;\\n        return ans%mod;\\n    } \\n```\\t\\n</pre>\\n</details>\\n      \\n\\n\\n\\n**Actual code**\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        \\n        ll prefix[100000+1]{0};\\n        ll suffix[100000+1]{0};        \\n        ll n = nums.size();\\n        unordered_map<ll,ll> minL,minR;        \\n        stack<ll>st,st2; //to store indices, no need of stack of pairs \\n\\t\\tlong long sum = 0 , ans = 0;\\n```\\t\\n\\n```\\n\\t\\t//prefix sum\\n        for(ll i=0;i<n;++i){\\n            prefix[i] = nums[i];\\n            if(i-1 >= 0)prefix[i] += prefix[i-1];\\n        }\\n```\\n\\n```\\n\\t\\t//suffix sum\\n        for(ll i=n-1;i>=0;--i){\\n            suffix[i] = nums[i];\\n            if(i+1 < n)suffix[i] += suffix[i+1];\\n        }\\n```\\n```\\n\\t\\t//find left minimum index for each of the present index \\n        for(int i=n-1;i>=0;--i){\\n            while(!st.empty() and nums[st.top()] >= nums[i])\\n                st.pop();\\n            if(!st.empty() and nums[st.top()] < nums[i])\\n                minR[i] = st.top();\\n            st.push(i);\\n        }\\n```      \\n\\n\\n```\\n\\t//find right minimum index for each of the present index \\n        for(int i=0;i<n;++i){\\n            while(!st2.empty() and nums[st2.top()] >= nums[i])\\n                st2.pop();\\n            if(!st2.empty() and nums[st2.top()] < nums[i])\\n                minL[i] = st2.top();\\n            st2.push(i);\\n        }      \\n  ```\\n  \\n  \\n  \\n  ```\\n\\t\\t//find the answer by considering each element as the smallest element and\\n\\t\\t//including the maximum length array from left and right \\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n;++i){                        \\n            long long val = prefix[i] + suffix[i] - nums[i];            \\n            if(minL.count(i))\\n                val -= prefix[minL[i]];\\n            if(minR.count(i))\\n                val -= suffix[minR[i]];                          \\n            val *= nums[i];                        \\n            ans = max(ans,val);            \\n        }\\n```\\n\\n\\n        int mod = 1e9+7;\\n        return ans%mod;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```C++\\n #define ll long long \\nclass Solution {\\npublic:\\n    int maxSumMinProduct(nums) {        \\n        ll prefix[100000+1]{0};\\n        ll suffix[100000+1]{0};        \\n        ll n = nums.size();\\n        unordered_map<ll,ll> minL,minR;        \\n        stack<ll>st,st2; //to store indices, no need of stack of pairs \\n\\t\\tlong long sum = 0 , ans = 0;\\n        }\\n```\n```C++\\nfor(ll i=0;;+i){\\n            prefix[i] = nums[i];\\n            if(i-1 >= 0)prefix[i] += prefix[i-1];\\n\\tif(i>=n)break;\\n        }\\n```\n```C++\\n for(ll i=n-1;i>=0;--i){\\n            suffix[i] = nums[i];\\n            if(n > i+1)suffix[i] += suffix[i+1];\\n        }\\n```\n```C++\\n for(int i=n-1;i>=0;--i){\\n            while(!st.empty() and nums[st.top()] >= nums[i])\\n                st.pop();\\n            if(!st.empty() and nums[i] > nums[st.top()] )\\n                minR[i] = st.top();\\n            st.push(i);\\n        }\\n```\n```C++\\n for(int i=0;n>i;++i){\\n            while(!st2.empty() and nums[st2.top()] >= nums[i])\\n                st2.pop();\\n            if(!st2.empty() and nums[i] > nums[st2.top()] )\\n                minL[i] = st2.top();\\n            st2.push(i);\\n        }  \\n```\n```C++\\n for(int i=0;n>i;++i){                        \\n          long long val = prefix[i] + suffix[i] - nums[i];            \\n          if(minL.count(i))\\n              val -= prefix[minL[i]];\\n          if(minR.count(i))\\n              val -= suffix[minR[i]];                          \\n          val *= nums[i];                        \\n          ans = max(ans,val);            \\n      } \\n```\n```C++\\n        int mod = 1e9+7;\\n        return ans%mod;\\n    } \\n```\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        \\n        ll prefix[100000+1]{0};\\n        ll suffix[100000+1]{0};        \\n        ll n = nums.size();\\n        unordered_map<ll,ll> minL,minR;        \\n        stack<ll>st,st2; //to store indices, no need of stack of pairs \\n\\t\\tlong long sum = 0 , ans = 0;\\n```\n```\\n\\t\\t//prefix sum\\n        for(ll i=0;i<n;++i){\\n            prefix[i] = nums[i];\\n            if(i-1 >= 0)prefix[i] += prefix[i-1];\\n        }\\n```\n```\\n\\t\\t//suffix sum\\n        for(ll i=n-1;i>=0;--i){\\n            suffix[i] = nums[i];\\n            if(i+1 < n)suffix[i] += suffix[i+1];\\n        }\\n```\n```\\n\\t\\t//find left minimum index for each of the present index \\n        for(int i=n-1;i>=0;--i){\\n            while(!st.empty() and nums[st.top()] >= nums[i])\\n                st.pop();\\n            if(!st.empty() and nums[st.top()] < nums[i])\\n                minR[i] = st.top();\\n            st.push(i);\\n        }\\n```\n```\\n\\t//find right minimum index for each of the present index \\n        for(int i=0;i<n;++i){\\n            while(!st2.empty() and nums[st2.top()] >= nums[i])\\n                st2.pop();\\n            if(!st2.empty() and nums[st2.top()] < nums[i])\\n                minL[i] = st2.top();\\n            st2.push(i);\\n        }      \\n  ```\n```\\n\\t\\t//find the answer by considering each element as the smallest element and\\n\\t\\t//including the maximum length array from left and right \\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n;++i){                        \\n            long long val = prefix[i] + suffix[i] - nums[i];            \\n            if(minL.count(i))\\n                val -= prefix[minL[i]];\\n            if(minR.count(i))\\n                val -= suffix[minR[i]];                          \\n            val *= nums[i];                        \\n            ans = max(ans,val);            \\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199491,
                "title": "o-n-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        \\n      int n =nums.size();\\n      stack<int>st1;//prev min\\n      stack<int>st2;//next min\\n      vector<int>prev(n,-1);\\n      vector<int>next(n,-1);\\n      \\n      vector<long long int>pre(n+1,0);\\n      \\n      for(int i=0;i<n;i++){\\n       \\n          pre[i+1]=pre[i]+nums[i];\\n        \\n        \\n        if(st1.empty()){\\n           st1.push(i);\\n        }else{\\n        while(!st1.empty() && nums[i]< nums[st1.top()]){\\n          st1.pop();\\n        }\\n        if(!st1.empty()){\\n          prev[i]=st1.top();\\n        }\\n        st1.push(i);\\n        }\\n        \\n        if(st2.empty()){\\n          st2.push(i);\\n        }else{\\n    \\n          while(!st2.empty() && nums[i]< nums[st2.top()]){\\n          next[st2.top()]=i;\\n          st2.pop();\\n        }\\n          st2.push(i);\\n        \\n        \\n        }\\n        \\n      }\\n      int s,e;\\n      long long int ans=0;\\n      for(int i=0;i<n;i++){\\n        if(next[i]==-1){\\n          e=n-1;\\n        }else{\\n          e=next[i]-1;\\n        }\\n        \\n        if(prev[i]==-1){\\n          s=0;\\n        }else{\\n          s=prev[i]+1;\\n        }\\n        \\n        ans= max(ans, 1ll*nums[i] * (pre[e+1]-pre[s]) );\\n   \\n        \\n      }\\n    \\n      return ans%1000000007;\\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        \\n      int n =nums.size();\\n      stack<int>st1;//prev min\\n      stack<int>st2;//next min\\n      vector<int>prev(n,-1);\\n      vector<int>next(n,-1);\\n      \\n      vector<long long int>pre(n+1,0);\\n      \\n      for(int i=0;i<n;i++){\\n       \\n          pre[i+1]=pre[i]+nums[i];\\n        \\n        \\n        if(st1.empty()){\\n           st1.push(i);\\n        }else{\\n        while(!st1.empty() && nums[i]< nums[st1.top()]){\\n          st1.pop();\\n        }\\n        if(!st1.empty()){\\n          prev[i]=st1.top();\\n        }\\n        st1.push(i);\\n        }\\n        \\n        if(st2.empty()){\\n          st2.push(i);\\n        }else{\\n    \\n          while(!st2.empty() && nums[i]< nums[st2.top()]){\\n          next[st2.top()]=i;\\n          st2.pop();\\n        }\\n          st2.push(i);\\n        \\n        \\n        }\\n        \\n      }\\n      int s,e;\\n      long long int ans=0;\\n      for(int i=0;i<n;i++){\\n        if(next[i]==-1){\\n          e=n-1;\\n        }else{\\n          e=next[i]-1;\\n        }\\n        \\n        if(prev[i]==-1){\\n          s=0;\\n        }else{\\n          s=prev[i]+1;\\n        }\\n        \\n        ans= max(ans, 1ll*nums[i] * (pre[e+1]-pre[s]) );\\n   \\n        \\n      }\\n    \\n      return ans%1000000007;\\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198835,
                "title": "javascript-stack-w-prefix-sum",
                "content": "```javascript\\nvar maxSumMinProduct = function (nums) {\\n    // prefix and postfix nums with a 0 for easy handling\\n    nums = [0, ...nums, 0];\\n\\n    // create a prefix sum array so that we can calculate the sum\\n    // from i to j in constant time.\\n    const prefixSum = [...nums];\\n    for (let i = 1; i < nums.length; i++) {\\n        prefixSum[i] = prefixSum[i - 1] + prefixSum[i];\\n    }\\n\\n    // stackOfIndices holds indices of ascending values\\n    let stackOfIndices = [0];\\n    \\n    // For every index find the first index to the left that is less \\n    // than the value being held at the index i in nums.\\n    const leftIndices = new Array(nums.length).fill(0);\\n    for (let i = 1; i < nums.length; i++) {\\n        // while the current value is less than or equal to the value at the index\\n        // being held at the top of the stack, remove that index from the stack\\n        // since that means indices greater than or equal to the current index\\n        // and indices greater than or equal to the current value will be able to\\n        // expand further left to accumulate a larger sum.\\n        while (nums[i] <= nums[stackOfIndices[stackOfIndices.length - 1]]) {\\n            stackOfIndices.pop();\\n        }\\n        leftIndices[i] = stackOfIndices[stackOfIndices.length - 1];\\n        stackOfIndices.push(i);\\n    }\\n\\n    // clear the stack so that the repeaded measure can be done while iterating to the left\\n    // *see above for implementation\\n    stackOfIndices = [nums.length];\\n    const rightIndices = new Array(nums.length).fill(nums.length - 1);\\n    for (let i = nums.length - 2; i > 0; i--) {\\n        while (nums[i] <= nums[stackOfIndices[stackOfIndices.length - 1]]) {\\n            stackOfIndices.pop();\\n        }\\n        rightIndices[i] = stackOfIndices[stackOfIndices.length - 1] - 1;\\n        stackOfIndices.push(i);\\n    }\\n\\n    let max = BigInt(0);\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        // with j being the furthest right we can expand while keeping the value at the current index\\n        // the smallest value and i being the furthest left we can expand while keeping the value at\\n        // the current index the smallest value.\\n        // sum from indices [0..j] (inclusive) =  prefixSum[rightIndices[i]]\\n        // sum from indices [0...i) (exclusive) = prefixSum[leftIndices[i]]\\n        // current value   = nums[i]\\n        const sum = BigInt(prefixSum[rightIndices[i]] - prefixSum[leftIndices[i]]);\\n        const minProduct = sum * BigInt(nums[i]);\\n        if (max < minProduct) {\\n            max = minProduct;\\n        }\\n    }\\n    return max % BigInt(1000000007);         //  10^9 + 7\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```javascript\\nvar maxSumMinProduct = function (nums) {\\n    // prefix and postfix nums with a 0 for easy handling\\n    nums = [0, ...nums, 0];\\n\\n    // create a prefix sum array so that we can calculate the sum\\n    // from i to j in constant time.\\n    const prefixSum = [...nums];\\n    for (let i = 1; i < nums.length; i++) {\\n        prefixSum[i] = prefixSum[i - 1] + prefixSum[i];\\n    }\\n\\n    // stackOfIndices holds indices of ascending values\\n    let stackOfIndices = [0];\\n    \\n    // For every index find the first index to the left that is less \\n    // than the value being held at the index i in nums.\\n    const leftIndices = new Array(nums.length).fill(0);\\n    for (let i = 1; i < nums.length; i++) {\\n        // while the current value is less than or equal to the value at the index\\n        // being held at the top of the stack, remove that index from the stack\\n        // since that means indices greater than or equal to the current index\\n        // and indices greater than or equal to the current value will be able to\\n        // expand further left to accumulate a larger sum.\\n        while (nums[i] <= nums[stackOfIndices[stackOfIndices.length - 1]]) {\\n            stackOfIndices.pop();\\n        }\\n        leftIndices[i] = stackOfIndices[stackOfIndices.length - 1];\\n        stackOfIndices.push(i);\\n    }\\n\\n    // clear the stack so that the repeaded measure can be done while iterating to the left\\n    // *see above for implementation\\n    stackOfIndices = [nums.length];\\n    const rightIndices = new Array(nums.length).fill(nums.length - 1);\\n    for (let i = nums.length - 2; i > 0; i--) {\\n        while (nums[i] <= nums[stackOfIndices[stackOfIndices.length - 1]]) {\\n            stackOfIndices.pop();\\n        }\\n        rightIndices[i] = stackOfIndices[stackOfIndices.length - 1] - 1;\\n        stackOfIndices.push(i);\\n    }\\n\\n    let max = BigInt(0);\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        // with j being the furthest right we can expand while keeping the value at the current index\\n        // the smallest value and i being the furthest left we can expand while keeping the value at\\n        // the current index the smallest value.\\n        // sum from indices [0..j] (inclusive) =  prefixSum[rightIndices[i]]\\n        // sum from indices [0...i) (exclusive) = prefixSum[leftIndices[i]]\\n        // current value   = nums[i]\\n        const sum = BigInt(prefixSum[rightIndices[i]] - prefixSum[leftIndices[i]]);\\n        const minProduct = sum * BigInt(nums[i]);\\n        if (max < minProduct) {\\n            max = minProduct;\\n        }\\n    }\\n    return max % BigInt(1000000007);         //  10^9 + 7\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198638,
                "title": "java-stack-o-n",
                "content": "```\\npublic int maxSumMinProduct(int[] nums) {\\n        long mod = 1000000007;\\n        int n = nums.length;\\n        long []dp = new long[n];\\n        dp[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + nums[i];\\n        }\\n        long ans = 0;\\n        Stack<Integer> st = new Stack();\\n        for(int i=0;i<nums.length;i++){\\n            if(st.isEmpty()){\\n                st.push(i);\\n            }else{\\n                while(!st.isEmpty() && nums[st.peek()] >= nums[i]){\\n                    int top = st.pop();\\n                    if(st.isEmpty()){\\n                        ans = Math.max(ans, dp[i-1]*nums[top]);\\n                    }else{\\n                        ans = Math.max(ans, (dp[i-1] - dp[st.peek()])*nums[top]);\\n                    }\\n                }\\n                st.push(i);\\n            }\\n        }\\n        while(!st.isEmpty()){\\n            int top = st.pop();\\n            if(st.isEmpty()){\\n                ans = Math.max(ans, dp[n-1]*nums[top]);\\n            }else{\\n                ans = Math.max(ans, (dp[n-1] - dp[st.peek()])*nums[top]);\\n            }\\n        }\\n        return (int)(ans % mod);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSumMinProduct(int[] nums) {\\n        long mod = 1000000007;\\n        int n = nums.length;\\n        long []dp = new long[n];\\n        dp[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i] = dp[i-1] + nums[i];\\n        }\\n        long ans = 0;\\n        Stack<Integer> st = new Stack();\\n        for(int i=0;i<nums.length;i++){\\n            if(st.isEmpty()){\\n                st.push(i);\\n            }else{\\n                while(!st.isEmpty() && nums[st.peek()] >= nums[i]){\\n                    int top = st.pop();\\n                    if(st.isEmpty()){\\n                        ans = Math.max(ans, dp[i-1]*nums[top]);\\n                    }else{\\n                        ans = Math.max(ans, (dp[i-1] - dp[st.peek()])*nums[top]);\\n                    }\\n                }\\n                st.push(i);\\n            }\\n        }\\n        while(!st.isEmpty()){\\n            int top = st.pop();\\n            if(st.isEmpty()){\\n                ans = Math.max(ans, dp[n-1]*nums[top]);\\n            }else{\\n                ans = Math.max(ans, (dp[n-1] - dp[st.peek()])*nums[top]);\\n            }\\n        }\\n        return (int)(ans % mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995788,
                "title": "simple-cpp-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> sum(n);\\n        sum[0] = nums[0];\\n\\n        // Calculate the prefix sum of the input array\\n        for (int i = 1; i < n; i++) {\\n            sum[i] = sum[i - 1] + nums[i];\\n        }\\n\\n        vector<int> left(n);\\n        vector<int> right(n);\\n\\n        stack<int> st;\\n\\n        // Calculate the left boundary for each element\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && nums[st.top()] >= nums[i]) {\\n                st.pop();\\n            }\\n            left[i] = st.empty() ? 0 : st.top() + 1;\\n            st.push(i);\\n        }\\n\\n        // Clear the stack for reuse\\n        while (!st.empty()) {\\n            st.pop();\\n        }\\n\\n        // Calculate the right boundary for each element\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!st.empty() && nums[st.top()] >= nums[i]) {\\n                st.pop();\\n            }\\n            right[i] = st.empty() ? n - 1 : st.top() - 1;\\n            st.push(i);\\n        }\\n\\n        long long res = 0;\\n        const int MOD = 1e9 + 7;\\n\\n        // Calculate the maximum min-product\\n        for (int i = 0; i < n; i++) {\\n            long long a = left[i];\\n            long long b = right[i];\\n            \\n            // Calculate the sum of the subarray [left[i], right[i]]\\n            long long subarray_sum = sum[b] - (a > 0 ? sum[a - 1] : 0);\\n            \\n            // Calculate the min-product for the current subarray\\n            long long min_product = nums[i] * subarray_sum;\\n            \\n            // Update the result\\n            res = max(res, min_product);\\n        }\\n\\n        return res % MOD;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> sum(n);\\n        sum[0] = nums[0];\\n\\n        // Calculate the prefix sum of the input array\\n        for (int i = 1; i < n; i++) {\\n            sum[i] = sum[i - 1] + nums[i];\\n        }\\n\\n        vector<int> left(n);\\n        vector<int> right(n);\\n\\n        stack<int> st;\\n\\n        // Calculate the left boundary for each element\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && nums[st.top()] >= nums[i]) {\\n                st.pop();\\n            }\\n            left[i] = st.empty() ? 0 : st.top() + 1;\\n            st.push(i);\\n        }\\n\\n        // Clear the stack for reuse\\n        while (!st.empty()) {\\n            st.pop();\\n        }\\n\\n        // Calculate the right boundary for each element\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!st.empty() && nums[st.top()] >= nums[i]) {\\n                st.pop();\\n            }\\n            right[i] = st.empty() ? n - 1 : st.top() - 1;\\n            st.push(i);\\n        }\\n\\n        long long res = 0;\\n        const int MOD = 1e9 + 7;\\n\\n        // Calculate the maximum min-product\\n        for (int i = 0; i < n; i++) {\\n            long long a = left[i];\\n            long long b = right[i];\\n            \\n            // Calculate the sum of the subarray [left[i], right[i]]\\n            long long subarray_sum = sum[b] - (a > 0 ? sum[a - 1] : 0);\\n            \\n            // Calculate the min-product for the current subarray\\n            long long min_product = nums[i] * subarray_sum;\\n            \\n            // Update the result\\n            res = max(res, min_product);\\n        }\\n\\n        return res % MOD;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623029,
                "title": "step-by-step-intuition-for-dp-solution",
                "content": "# Intuition\\nTo find the maximum min-product, we want to check all min products. This means for each element in nums, we want to find the min product it is associated with assuming that element is the minimum.\\n\\nNow finding and summing up the longest subarray in which each element is the minimum is very costly. **Prefix sums** seem like a good idea, since if we could track a running sum, we wouldn\\'t have to recompute subarray sums multiple times. But how can we find the right prefix sum on both sides of the minimum?\\n\\nOne intuitive idea is that if the elements were sorted, it would be much easier to reason about the subarrays. However, since order must be preserved, this means we can\\'t sort the array. Instead, we can maintain an increasing **monotonic stack**. This way, we have structure we can work with. More specifically, if we maintain a monotonic stack, we know that for any element x, any element to the left x must be less than it.\\n\\n# Approach\\nWe will use the strategy outlined above, tracking a stack containing (value, prefix sum) pairs and the current maximum min product.\\n\\nWe then for loop over nums. At each item, we pop the stack while the top of the stack is greater than the current it, adding the top stack\\'s value and its prefix sum to a running total that is initialized at 0. During each pop, we update our answer if (new total * the item we just popped) is the new largest min product. All the while, we track the new prefix sum by adding each stack element greater than or equal to our current item to a running total **psum**.\\n\\nAfter all elements greater than the current item have been removed, we append the new item with an additional field **psum**.\\n\\nThen at the end we pop everything from the stack using the same process in order to clean up the remaining elements.\\n\\n# Complexity\\n- Time complexity:\\nO(n), since everything can only be added to and removed from the stack once each.\\n\\n- Space complexity:\\nO(n), since the stack only holds one pair of data for every entry in nums.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        modulo = 10**9+7\\n        stack = []\\n        ans = 0 \\n\\n        for i in nums:\\n            psum = 0\\n            if stack and stack[len(stack)-1][0] > i:\\n                total = 0\\n                while stack and stack[len(stack)-1][0] >= i:\\n                    c, csum = stack.pop()\\n                    if c >= i:\\n                        psum += c + csum\\n                    total += c + csum\\n                    ans = max(ans, (total)*c) \\n            stack.append((i, psum))\\n\\n        # clean up the remaining stack\\n        total = 0\\n        while stack:\\n            c, csum = stack.pop()\\n            total += c + csum\\n            ans = max(ans, (total)*c)\\n        return ans % modulo\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        modulo = 10**9+7\\n        stack = []\\n        ans = 0 \\n\\n        for i in nums:\\n            psum = 0\\n            if stack and stack[len(stack)-1][0] > i:\\n                total = 0\\n                while stack and stack[len(stack)-1][0] >= i:\\n                    c, csum = stack.pop()\\n                    if c >= i:\\n                        psum += c + csum\\n                    total += c + csum\\n                    ans = max(ans, (total)*c) \\n            stack.append((i, psum))\\n\\n        # clean up the remaining stack\\n        total = 0\\n        while stack:\\n            c, csum = stack.pop()\\n            total += c + csum\\n            ans = max(ans, (total)*c)\\n        return ans % modulo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077409,
                "title": "monostack-prefix-sum-concise-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maxSumMinProduct(vector<int> &n)\\n    {\\n        // Initialize a variable \\'res\\' to store the maximum sum of the subarray\\n        long res = 0;\\n        // Create a vector \\'dp\\' to store the prefix sums of the input vector \\'n\\'\\n        vector<long> dp(n.size() + 1);\\n        // Create a vector \\'st\\' to store the indices of the integers in \\'n\\' that are used to calculate the maximum sum\\n        vector<long> st;\\n        // Calculate the prefix sums of the input vector \\'n\\' and store them in the \\'dp\\' vector\\n        for (int i = 0; i < n.size(); ++i)\\n        {\\n            dp[i + 1] = dp[i] + n[i];\\n        }\\n        // Iterate through the input vector \\'n\\'\\n        for (int i = 0; i <= n.size(); ++i)\\n        {\\n            // While the \\'st\\' vector is not empty and the current integer in \\'n\\' is greater than or equal to the last integer in \\'st\\'\\n            while (!st.empty() && (i == n.size() || n[st.back()] > n[i]))\\n            {\\n                // Pop the last integer in \\'st\\' and store it in the variable \\'j\\'\\n                int j = st.back();\\n                st.pop_back();\\n                // Update the maximum sum of the subarray by calculating the sum of the subarray between the last element in \\'st\\' and the current element \\'i\\'\\n                // and multiplying it by the value of the popped integer \\'j\\'\\n                res = max(res, n[j] * (dp[i] - dp[st.empty() ? 0 : st.back() + 1]));\\n            }\\n            // Push the current index \\'i\\' into the \\'st\\' vector\\n            st.push_back(i);\\n        }\\n        // Return the maximum sum of the subarray mod 1000000007 to prevent overflow\\n        return res % 1000000007;\\n    }\\n};\\n```\\n\\n# Code without comments\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& n) {\\n        long res = 0;\\n        vector<long> dp(n.size() + 1), st;\\n        for (int i = 0; i < n.size(); ++i)\\n        dp[i + 1] = dp[i] + n[i];\\n        for (int i = 0; i <= n.size(); ++i) {\\n            while (!st.empty() && (i == n.size() || n[st.back()] > n[i])) {\\n                int j = st.back();\\n                st.pop_back();\\n                res = max(res, n[j] * (dp[i] - dp[st.empty() ? 0 : st.back() + 1]));\\n            }\\n            st.push_back(i);\\n        }\\n         return res % 1000000007;\\n    }\\n};\\n\\n```\\n\\n\\nDO UPVOTE!",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxSumMinProduct(vector<int> &n)\\n    {\\n        // Initialize a variable \\'res\\' to store the maximum sum of the subarray\\n        long res = 0;\\n        // Create a vector \\'dp\\' to store the prefix sums of the input vector \\'n\\'\\n        vector<long> dp(n.size() + 1);\\n        // Create a vector \\'st\\' to store the indices of the integers in \\'n\\' that are used to calculate the maximum sum\\n        vector<long> st;\\n        // Calculate the prefix sums of the input vector \\'n\\' and store them in the \\'dp\\' vector\\n        for (int i = 0; i < n.size(); ++i)\\n        {\\n            dp[i + 1] = dp[i] + n[i];\\n        }\\n        // Iterate through the input vector \\'n\\'\\n        for (int i = 0; i <= n.size(); ++i)\\n        {\\n            // While the \\'st\\' vector is not empty and the current integer in \\'n\\' is greater than or equal to the last integer in \\'st\\'\\n            while (!st.empty() && (i == n.size() || n[st.back()] > n[i]))\\n            {\\n                // Pop the last integer in \\'st\\' and store it in the variable \\'j\\'\\n                int j = st.back();\\n                st.pop_back();\\n                // Update the maximum sum of the subarray by calculating the sum of the subarray between the last element in \\'st\\' and the current element \\'i\\'\\n                // and multiplying it by the value of the popped integer \\'j\\'\\n                res = max(res, n[j] * (dp[i] - dp[st.empty() ? 0 : st.back() + 1]));\\n            }\\n            // Push the current index \\'i\\' into the \\'st\\' vector\\n            st.push_back(i);\\n        }\\n        // Return the maximum sum of the subarray mod 1000000007 to prevent overflow\\n        return res % 1000000007;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& n) {\\n        long res = 0;\\n        vector<long> dp(n.size() + 1), st;\\n        for (int i = 0; i < n.size(); ++i)\\n        dp[i + 1] = dp[i] + n[i];\\n        for (int i = 0; i <= n.size(); ++i) {\\n            while (!st.empty() && (i == n.size() || n[st.back()] > n[i])) {\\n                int j = st.back();\\n                st.pop_back();\\n                res = max(res, n[j] * (dp[i] - dp[st.empty() ? 0 : st.back() + 1]));\\n            }\\n            st.push_back(i);\\n        }\\n         return res % 1000000007;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664455,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int left[n], right[n];\\n        long long int sum[n];\\n        sum[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            sum[i] = sum[i-1]+nums[i];\\n        }\\n        stack<pair<int, int> > s1, s2;\\n        for (int i = 0; i < n; ++i) {\\n            int cnt = 1;\\n            while (!s1.empty() && (s1.top().first) > nums[i]) {\\n                cnt += s1.top().second;\\n                s1.pop();\\n            }\\n            s1.push({ nums[i], cnt });\\n            left[i] = cnt;\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            int cnt = 1;\\n            while (!s2.empty() && (s2.top().first) >= nums[i]) {\\n                cnt += s2.top().second;\\n                s2.pop();\\n            }\\n\\n            s2.push({ nums[i], cnt });\\n            right[i] = cnt;\\n        }\\n        long long int res =0;\\n        for(int i=0;i<n;i++){\\n            int a = i-left[i]+1;\\n            int b = i+right[i]-1;\\n            long long int subArraySum;\\n            if(a>0)\\n                subArraySum = sum[b]-sum[a-1];\\n            else\\n                subArraySum = sum[b];\\n            res = max(res, subArraySum*nums[i]);\\n        }\\n        return res%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int left[n], right[n];\\n        long long int sum[n];\\n        sum[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            sum[i] = sum[i-1]+nums[i];\\n        }\\n        stack<pair<int, int> > s1, s2;\\n        for (int i = 0; i < n; ++i) {\\n            int cnt = 1;\\n            while (!s1.empty() && (s1.top().first) > nums[i]) {\\n                cnt += s1.top().second;\\n                s1.pop();\\n            }\\n            s1.push({ nums[i], cnt });\\n            left[i] = cnt;\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            int cnt = 1;\\n            while (!s2.empty() && (s2.top().first) >= nums[i]) {\\n                cnt += s2.top().second;\\n                s2.pop();\\n            }\\n\\n            s2.push({ nums[i], cnt });\\n            right[i] = cnt;\\n        }\\n        long long int res =0;\\n        for(int i=0;i<n;i++){\\n            int a = i-left[i]+1;\\n            int b = i+right[i]-1;\\n            long long int subArraySum;\\n            if(a>0)\\n                subArraySum = sum[b]-sum[a-1];\\n            else\\n                subArraySum = sum[b];\\n            res = max(res, subArraySum*nums[i]);\\n        }\\n        return res%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423467,
                "title": "easy-c-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        \\n        // take every element as minimum and calculate the min product till left and right smaller element\\n        int n=nums.size();\\n        vector<int>left_smaller(n,-1);\\n        vector<int>right_smaller(n,n);\\n        vector<long long>prefix_sum(n,0);\\n        long long ans=INT_MIN;\\n        int mod=1e9+7;\\n        \\n        stack<int>st;\\n        \\n        \\n        // left smaller \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && nums[st.top()]>=nums[i])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                left_smaller[i]=-1;\\n            }\\n            else\\n            {\\n                left_smaller[i]=st.top();\\n            }\\n            st.push(i);\\n        }\\n        \\n        while(!st.empty())st.pop();\\n        \\n        // right smaller\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[st.top()]>=nums[i])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                right_smaller[i]=n;\\n            }\\n            else\\n            {\\n                right_smaller[i]=st.top();\\n            }\\n            st.push(i);\\n        }\\n        \\n        // find prefix sum\\n        prefix_sum[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix_sum[i]=prefix_sum[i-1]+nums[i];\\n        }\\n        \\n        // calculating maximum subarray min-product\\n        for(int i=0;i<n;i++)\\n        {\\n            long long left=(left_smaller[i]==-1)?0:prefix_sum[left_smaller[i]];\\n            long long right=prefix_sum[right_smaller[i]-1];\\n            \\n            long long curr=((right-left)*nums[i]);\\n            ans=max(ans,curr);\\n            \\n        }\\n        return ans%mod;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        \\n        // take every element as minimum and calculate the min product till left and right smaller element\\n        int n=nums.size();\\n        vector<int>left_smaller(n,-1);\\n        vector<int>right_smaller(n,n);\\n        vector<long long>prefix_sum(n,0);\\n        long long ans=INT_MIN;\\n        int mod=1e9+7;\\n        \\n        stack<int>st;\\n        \\n        \\n        // left smaller \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && nums[st.top()]>=nums[i])\\n            {\\n                st.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2413561,
                "title": "monotonic-stack-prefix-sum",
                "content": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        Point = namedtuple(\\'Point\\', [\\'val\\', \\'prefix\\'])\\n        stack = [Point(-1, 0)]\\n        maxval = 0\\n        for n in nums:\\n            if n > stack[-1].val:\\n                stack.append(Point(n, stack[-1].prefix+n))\\n            else:\\n                prev_prefix = stack[-1].prefix\\n                while n < stack[-1].val:\\n                    point = stack.pop()\\n                    maxval = max(maxval, (prev_prefix - stack[-1].prefix) * point.val)\\n                stack.append(Point(n, prev_prefix+n))\\n        \\n        prev_prefix = stack[-1].prefix\\n        while stack[-1].val != -1:\\n            point = stack.pop()\\n            maxval = max(maxval, (prev_prefix - stack[-1].prefix) * point.val)\\n            \\n        return maxval % (10**9+7)\\n```\\nThis is almost the exact same question as `84. Largest Rectangle in Histogram ` except that you have to compute the prefix sum instead of using just the indices/width",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        Point = namedtuple(\\'Point\\', [\\'val\\', \\'prefix\\'])\\n        stack = [Point(-1, 0)]\\n        maxval = 0\\n        for n in nums:\\n            if n > stack[-1].val:\\n                stack.append(Point(n, stack[-1].prefix+n))\\n            else:\\n                prev_prefix = stack[-1].prefix\\n                while n < stack[-1].val:\\n                    point = stack.pop()\\n                    maxval = max(maxval, (prev_prefix - stack[-1].prefix) * point.val)\\n                stack.append(Point(n, prev_prefix+n))\\n        \\n        prev_prefix = stack[-1].prefix\\n        while stack[-1].val != -1:\\n            point = stack.pop()\\n            maxval = max(maxval, (prev_prefix - stack[-1].prefix) * point.val)\\n            \\n        return maxval % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370864,
                "title": "c-using-stack-finding-next-smaller-and-prev-smaller-of-each-element",
                "content": "**Intuition:** \\n1.Next smaller and prev smaller will be used to get the range of the subarrays in which a particular element if occurs will always be minimum.\\n2.Prefix sum will be used to get the sum of subarray using lr and rl arrays.\\n3.At last the answer will be mx with mod 1e9+7.\\n\\nclass Solution {\\npublic:\\n\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t// lr stores next smaller of each element.\\n\\t\\t// rl stores prev smaller of each element.\\n\\t\\t// pre stores prefix sum of nums.\\n\\t\\t// v is used to simulate as a stack.\\n        vector<long long> lr(n, n), rl(n, -1), pre(n+1, 0), v;\\n        \\n\\t\\t// calculating next smaller of each element in nums and storing index in lr, using same for loop to find the prefix sum.\\n        for(int i=0; i<n; ++i){\\n            pre[i+1] = pre[i] + nums[i]; // calculating prefix sum array\\n            while(!v.empty() and nums[i] < nums[v.back()]){\\n                lr[v.back()] = i;\\n                v.pop_back();\\n            }\\n            v.push_back(i);\\n        }\\n        \\n        v.clear();\\n        \\n\\t\\t// calculating the prev smaller of each element of nums and storing index in rl\\n        for(int i=n-1; i >= 0; --i){\\n            while(!v.empty() and nums[i] < nums[v.back()]){\\n                rl[v.back()] = i;\\n                v.pop_back();\\n            }\\n            v.push_back(i);\\n        }\\n        \\n        long long mx = 0, mod = 1e9+7;\\n        \\n        for(int i=0; i<n; ++i){\\n            long long sum = pre[lr[i]] - pre[rl[i] + 1];\\n            mx = max(mx, 1LL * nums[i] * sum);// multiplying with 1LL to convert the number to long long integer.\\n        }\\n        \\n        return mx % mod;\\n    }\\n};\\n\\n**Time: O(N), Space: O(N)**\\n**PLEASE UPVOTE IF HELPFUL!!!**\\nFor doubt or query, comment below.\\n\\nSimilar Question: **Leetcode 84. Largest Rectangle in Histogram, just change the histogram width with sum.**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t// lr stores next smaller of each element.\\n\\t\\t// rl stores prev smaller of each element.\\n\\t\\t// pre stores prefix sum of nums.\\n\\t\\t// v is used to simulate as a stack.\\n        vector<long long> lr(n, n), rl(n, -1), pre(n+1, 0), v;\\n        \\n\\t\\t// calculating next smaller of each element in nums and storing index in lr, using same for loop to find the prefix sum.\\n        for(int i=0; i<n; ++i){\\n            pre[i+1] = pre[i] + nums[i]; // calculating prefix sum array\\n            while(!v.empty() and nums[i] < nums[v.back()]){\\n                lr[v.back()] = i;\\n                v.pop_back();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2285098,
                "title": "similar-to-problem-max-area-in-histogram",
                "content": "It is similar to the problem of finding maximum area in a histogram,.\\nsimply do the following things -\\n* Find the nearest position to the left that is smaller than current position.\\n* Find the nearest position to the right that is smaller than current position.\\n* Get the subarray (inbetween above 2 positions) sum with prefix-sum.\\n**Finding next and previous elements using brute force**   (TLE)\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        long long  n = size(nums);\\n        vector<long long>pre(n+1,0);\\n        for(long long  i=0;i<n;i++){\\n            pre[i+1] = pre[i]+nums[i];\\n         }\\n        long long ans = 0;\\n        for(long long  i=0;i<n;i++){\\n            long long  j=i-1;\\n            while(j>=0 && nums[i]<=nums[j]) j--;\\n            long long  k = i+1;\\n            while(k<n && nums[i]<=nums[k]) k++;\\n             ans = max(ans,nums[i]*(pre[k]-pre[j+1]));\\n         }\\n        long long M = 1e9+7;\\n        return ans%(M);\\n    }    \\n};\\n```\\n**Using Stack**\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        long long  n = size(nums);\\n        vector<long long>pre(n+1,0),l(n,-1),r(n,n);\\n        for(long long  i=0;i<n;i++){\\n            pre[i+1] = pre[i]+nums[i];\\n         }\\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            while(size(st) && nums[st.top()]>nums[i]){\\n                r[st.top()]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(size(st)) st.pop();\\n        for(int i=n-1;i>=0;i--){\\n            while(size(st) && nums[st.top()]>nums[i]){\\n                l[st.top()]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        long long ans = 0;\\n        for(long long  i=0;i<n;i++){\\n             ans = max(ans,nums[i]*(pre[r[i]]-pre[l[i]+1]));\\n         }\\n        long long M = 1e9+7;\\n        return ans%(M);\\n    }    \\n};\\n```\\n**Pls Upvote if you found it useful**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        long long  n = size(nums);\\n        vector<long long>pre(n+1,0);\\n        for(long long  i=0;i<n;i++){\\n            pre[i+1] = pre[i]+nums[i];\\n         }\\n        long long ans = 0;\\n        for(long long  i=0;i<n;i++){\\n            long long  j=i-1;\\n            while(j>=0 && nums[i]<=nums[j]) j--;\\n            long long  k = i+1;\\n            while(k<n && nums[i]<=nums[k]) k++;\\n             ans = max(ans,nums[i]*(pre[k]-pre[j+1]));\\n         }\\n        long long M = 1e9+7;\\n        return ans%(M);\\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        long long  n = size(nums);\\n        vector<long long>pre(n+1,0),l(n,-1),r(n,n);\\n        for(long long  i=0;i<n;i++){\\n            pre[i+1] = pre[i]+nums[i];\\n         }\\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            while(size(st) && nums[st.top()]>nums[i]){\\n                r[st.top()]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        while(size(st)) st.pop();\\n        for(int i=n-1;i>=0;i--){\\n            while(size(st) && nums[st.top()]>nums[i]){\\n                l[st.top()]=i;\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        long long ans = 0;\\n        for(long long  i=0;i<n;i++){\\n             ans = max(ans,nums[i]*(pre[r[i]]-pre[l[i]+1]));\\n         }\\n        long long M = 1e9+7;\\n        return ans%(M);\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266672,
                "title": "just-find-nsl-nsr-simple-c",
                "content": "**give chance to every elem to be that min elem**\\n\\n**now to what extent it has  its influence to its left ? until it finds a smaller elem than itself .\\nso find nearest smaller to left**\\n\\n**now to what extent it has  its influence to its right ? until it finds a greater elem than itself .\\nso find nearest smaller to right**\\n\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:int mod = 1e9+7;\\n    int maxSumMinProduct(vector<int>& a) {\\n        ll n = a.size(),sum = 0,ans = 0; stack<int> s;\\n        vector<ll> nsl(n) , nsr(n),pref(n);\\n        \\n\\t\\t//compute prefsix sum\\n        for(int i = 0;i<n;i++){ \\n            sum+=a[i]; pref[i] = sum;\\n        }\\n\\t\\t\\n\\t\\t//compute next smaller to  left\\n        \\n        for(int i = 0;i<n;i++){\\n            while(s.size() and a[s.top()] >= a[i]) s.pop();\\n            \\n            if(s.size()==0) nsl[i] = -1;\\n            else nsl[i] = s.top();\\n            \\n            s.push(i);\\n        }\\n        \\n        //there is no clear in stack so empty by popping\\n        while(s.size()) s.pop();\\n        \\n\\t\\t//compute next smaller to  right\\n\\t\\t\\n        for(int i = n-1;i>=0;i--){\\n            while(s.size() and a[s.top()]>=a[i]) s.pop();\\n    \\n            if(s.size()==0) nsr[i] = n;\\n            else nsr[i] = s.top();\\n            \\n            s.push(i);\\n        }\\n        \\n\\t\\t//Compute the required answer\\n\\t\\t\\n        for(int i = 0;i<n;i++){\\n            int min_elem = a[i]; int l = nsl[i] , r = nsr[i];\\n            \\n            ll sum = pref[r-1] - (l==-1? 0 : pref[l]);\\n            \\n            ans = max(ans, min_elem*sum); \\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:int mod = 1e9+7;\\n    int maxSumMinProduct(vector<int>& a) {\\n        ll n = a.size(),sum = 0,ans = 0; stack<int> s;\\n        vector<ll> nsl(n) , nsr(n),pref(n);\\n        \\n\\t\\t//compute prefsix sum\\n        for(int i = 0;i<n;i++){ \\n            sum+=a[i]; pref[i] = sum;\\n        }\\n\\t\\t\\n\\t\\t//compute next smaller to  left\\n        \\n        for(int i = 0;i<n;i++){\\n            while(s.size() and a[s.top()] >= a[i]) s.pop();\\n            \\n            if(s.size()==0) nsl[i] = -1;\\n            else nsl[i] = s.top();\\n            \\n            s.push(i);\\n        }\\n        \\n        //there is no clear in stack so empty by popping\\n        while(s.size()) s.pop();\\n        \\n\\t\\t//compute next smaller to  right\\n\\t\\t\\n        for(int i = n-1;i>=0;i--){\\n            while(s.size() and a[s.top()]>=a[i]) s.pop();\\n    \\n            if(s.size()==0) nsr[i] = n;\\n            else nsr[i] = s.top();\\n            \\n            s.push(i);\\n        }\\n        \\n\\t\\t//Compute the required answer\\n\\t\\t\\n        for(int i = 0;i<n;i++){\\n            int min_elem = a[i]; int l = nsl[i] , r = nsr[i];\\n            \\n            ll sum = pref[r-1] - (l==-1? 0 : pref[l]);\\n            \\n            ans = max(ans, min_elem*sum); \\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261900,
                "title": "python",
                "content": "```python\\n        nums.append(0)\\n        stack, res = [], 0\\n        for i, n in enumerate(nums):\\n            accu = 0\\n            while stack and stack[-1][0] > n:\\n                x, y = stack.pop()\\n                accu += y\\n                res = max(res, x * accu)\\n            stack.append((n, n + accu))\\n        return res % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        nums.append(0)\\n        stack, res = [], 0\\n        for i, n in enumerate(nums):\\n            accu = 0\\n            while stack and stack[-1][0] > n:\\n                x, y = stack.pop()\\n                accu += y\\n                res = max(res, x * accu)\\n            stack.append((n, n + accu))\\n        return res % (10**9+7)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226204,
                "title": "o-n-prefix-sum-and-monotonic-stack-approach-c",
                "content": "```\\nstatic int speedUp=[](){\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7 ; \\n    vector<int> evalLeft(vector<int>& arr) // Evaluate previous smaller element for every index i \\n    {\\n        stack<pair<int, int>> st ;\\n        vector<int> left ; \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            if (st.empty() == true)\\n                left.push_back(-1) ;\\n            else \\n            {\\n                while(st.empty() == false && st.top().first >= arr[i]) \\n                    st.pop() ; \\n                if (st.empty() == true)\\n                    left.push_back(-1) ;\\n                else \\n                    left.push_back(st.top().second) ; \\n            }\\n            st.push({arr[i], i}) ; \\n        } \\n        return left ; \\n    }\\n    vector<int> evalRight(vector<int>& arr) // Evaluate next smaller element for every index i \\n    {\\n        stack<pair<int, int>> st ;\\n        vector<int> right ;\\n        for(int i = arr.size()-1; i >=0 ; i--)\\n        {\\n            if (st.empty() == true)\\n                right.push_back(-1) ;\\n            else \\n            {\\n                while(st.empty() == false && st.top().first >= arr[i]) \\n                    st.pop() ;\\n                if (st.empty() == true)\\n                    right.push_back(-1) ;\\n                else \\n                    right.push_back(st.top().second) ; \\n            }\\n            st.push({arr[i], i}) ;\\n        }\\n        reverse(right.begin(), right.end()) ;\\n        return right ; \\n    }\\n    int maxSumMinProduct(vector<int>& arr) {\\n        int n = arr.size() ;\\n        vector<int> left = evalLeft(arr) ;\\n        vector<int> right = evalRight(arr) ;\\n        vector<long long> prefix(n) ; \\n        prefix[0] = arr[0] ;\\n        for(int i = 1; i < n; i++) // Compute prefix sum \\n            prefix[i] = prefix[i-1] + arr[i] ; \\n        long long ans = 0 ; \\n        for(int i = 0; i < n; i++)\\n        {\\n            long long sum = 0 ; \\n\\t\\t\\t// Assuming curr element / index to be i \\n            // Obtaining left sum \\n\\t\\t\\tif (left[i] == -1) \\n                sum += prefix[i] ;\\n            else \\n                sum += prefix[i] - prefix[left[i]] ;\\n\\t\\t\\t// Obtaining right sum \\n            if (right[i] == -1){\\n                if (i != 0)\\n                    sum += prefix[n-1] - prefix[i-1] ; \\n                else \\n                    sum += prefix[n-1] ; \\n            }\\n            else \\n            {\\n                if (i != 0)\\n                    sum += prefix[right[i]-1] - prefix[i-1] ; \\n                else \\n                    sum += prefix[right[i]-1] ; \\n            }\\n\\t\\t\\t// arr[i] added twice, subtract it once \\n            sum -= arr[i] ; \\n            ans = max(ans, sum*arr[i]) ;\\n        }\\n        return ans % mod ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nstatic int speedUp=[](){\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7 ; \\n    vector<int> evalLeft(vector<int>& arr) // Evaluate previous smaller element for every index i \\n    {\\n        stack<pair<int, int>> st ;\\n        vector<int> left ; \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            if (st.empty() == true)\\n                left.push_back(-1) ;\\n            else \\n            {\\n                while(st.empty() == false && st.top().first >= arr[i]) \\n                    st.pop() ; \\n                if (st.empty() == true)\\n                    left.push_back(-1) ;\\n                else \\n                    left.push_back(st.top().second) ; \\n            }\\n            st.push({arr[i], i}) ; \\n        } \\n        return left ; \\n    }\\n    vector<int> evalRight(vector<int>& arr) // Evaluate next smaller element for every index i \\n    {\\n        stack<pair<int, int>> st ;\\n        vector<int> right ;\\n        for(int i = arr.size()-1; i >=0 ; i--)\\n        {\\n            if (st.empty() == true)\\n                right.push_back(-1) ;\\n            else \\n            {\\n                while(st.empty() == false && st.top().first >= arr[i]) \\n                    st.pop() ;\\n                if (st.empty() == true)\\n                    right.push_back(-1) ;\\n                else \\n                    right.push_back(st.top().second) ; \\n            }\\n            st.push({arr[i], i}) ;\\n        }\\n        reverse(right.begin(), right.end()) ;\\n        return right ; \\n    }\\n    int maxSumMinProduct(vector<int>& arr) {\\n        int n = arr.size() ;\\n        vector<int> left = evalLeft(arr) ;\\n        vector<int> right = evalRight(arr) ;\\n        vector<long long> prefix(n) ; \\n        prefix[0] = arr[0] ;\\n        for(int i = 1; i < n; i++) // Compute prefix sum \\n            prefix[i] = prefix[i-1] + arr[i] ; \\n        long long ans = 0 ; \\n        for(int i = 0; i < n; i++)\\n        {\\n            long long sum = 0 ; \\n\\t\\t\\t// Assuming curr element / index to be i \\n            // Obtaining left sum \\n\\t\\t\\tif (left[i] == -1) \\n                sum += prefix[i] ;\\n            else \\n                sum += prefix[i] - prefix[left[i]] ;\\n\\t\\t\\t// Obtaining right sum \\n            if (right[i] == -1){\\n                if (i != 0)\\n                    sum += prefix[n-1] - prefix[i-1] ; \\n                else \\n                    sum += prefix[n-1] ; \\n            }\\n            else \\n            {\\n                if (i != 0)\\n                    sum += prefix[right[i]-1] - prefix[i-1] ; \\n                else \\n                    sum += prefix[right[i]-1] ; \\n            }\\n\\t\\t\\t// arr[i] added twice, subtract it once \\n            sum -= arr[i] ; \\n            ans = max(ans, sum*arr[i]) ;\\n        }\\n        return ans % mod ; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2209097,
                "title": "previous-next-smaller-element-and-prefix-sum-will-together-will-solve-this",
                "content": "\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        \"\"\"\\n        How can we solve this problem?\\n        \\n        is sorting comes into the picture ?\\n        Nope right otherwise order will be ignored\\n        \\n        It is not like that we need to take min element of an array\\n        so basically for each subarray we will get sum and its minimum element\\n        then its product is its weight and we need the max weight subarray\\n        \\n        can we come from back?\\n        without generating subarray can we do that?\\n        si there any observation which we can make?\\n        \\n        we need non empty subarray weight\\n        \\n        is there any prefix and suffix sum logic\\n        [1,2,3,2]\\n        [1,3,6,8]\\n        [8,7,5,2]\\n        \\n        stack => not getting how stack comes into the picture\\n        Monotonic stack => \\n        not getting anything\\n        queue => not getting anything\\n        Heap => Nope\\n        tree, graph => do we need to convert this array to tree or graph\\n        still we need to poll n ^ 2 subarrays\\n        \\n        what things will help us in subarray problem?\\n        sliding window\\n        bit manipulation\\n        \\n        if we sort by val and attached by indices\\n        [(1,0),(2,1),(2,3),(3,2)]\\n        \\n        first ele can be min for whole array\\n        second can be min for array range from \\n        \\n        is this prev smaller and next smaller ele problem\\n        and to we need prefix sum array to get sum of subarray\\n        based on prev smaller and next smaller ele index\\n        \\n        tc = O(n + n + n + n) => O(4n) => O(n)\\n        sc = O(n + n + n) => O(3n) => O(n)\\n        \"\"\"\\n        def prevSmallerElement(nums):\\n            n = len(nums)\\n            stack = []\\n            pse = [-1] * n\\n            for idx in range(n - 1,-1,-1):\\n                while stack and nums[stack[-1]] > nums[idx]:\\n                    top = stack.pop()\\n                    pse[top] = idx\\n                stack.append(idx)\\n            return pse\\n        \\n        def nextSmallerElement(nums):\\n            stack = []\\n            n = len(nums)\\n            nse = [n] * n\\n            for idx in range(n):\\n                while stack and nums[stack[-1]] > nums[idx]:\\n                    top = stack.pop()\\n                    nse[top] = idx\\n                stack.append(idx)\\n            return nse\\n        \\n        def preparePrefixArr(nums):\\n            n = len(nums)\\n            prefixArr = [0] * n\\n            prefixArr[0] = nums[0]\\n            for idx in range(1,n):\\n                prefixArr[idx] = prefixArr[idx - 1] + nums[idx]\\n            return prefixArr\\n                \\n        \\n        pse = prevSmallerElement(nums)\\n        nse = nextSmallerElement(nums)\\n        prefixArr = preparePrefixArr(nums)\\n        maxSumMinProduct = -math.inf\\n        mod = (10 ** 9) + 7\\n        for idx in range(len(nums)):\\n            currentMinElement = nums[idx]\\n            leftBoundary = pse[idx]\\n            rightBoundary = nse[idx]\\n            subarraySumWhereCurrentEleIsMin = prefixArr[rightBoundary - 1] - (0 if leftBoundary == -1 else prefixArr[leftBoundary])\\n            currentSubarrayWeight = currentMinElement * subarraySumWhereCurrentEleIsMin\\n            maxSumMinProduct = max(maxSumMinProduct, currentSubarrayWeight)\\n        \\n        return maxSumMinProduct % mod\\n    def bruteForce(self,nums):\\n        \"\"\"\\n        brute force is for every subarray \\n        keep track of sum and minimum and then keep track of maximum\\n        among them\\n        \"\"\"\\n        windowSum = 0\\n        minInWindow = math.inf\\n        maxSumMinProd = -math.inf\\n        n = len(nums)\\n        for i in range(n):\\n            windowSum = 0\\n            minInWindow = math.inf\\n            for j in range(i,n):\\n                minInWindow = min(minInWindow, nums[j])\\n                windowSum += nums[j]\\n                currSumMinProd = minInWindow * windowSum\\n                maxSumMinProd = max(maxSumMinProd, currSumMinProd)\\n        return maxSumMinProd",
                "solutionTags": [
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        \"\"\"\\n        How can we solve this problem?\\n        \\n        is sorting comes into the picture ?\\n        Nope right otherwise order will be ignored\\n        \\n        It is not like that we need to take min element of an array\\n        so basically for each subarray we will get sum and its minimum element\\n        then its product is its weight and we need the max weight subarray\\n        \\n        can we come from back?\\n        without generating subarray can we do that?\\n        si there any observation which we can make?\\n        \\n        we need non empty subarray weight\\n        \\n        is there any prefix and suffix sum logic\\n        [1,2,3,2]\\n        [1,3,6,8]\\n        [8,7,5,2]\\n        \\n        stack => not getting how stack comes into the picture\\n        Monotonic stack => \\n        not getting anything\\n        queue => not getting anything\\n        Heap => Nope\\n        tree, graph => do we need to convert this array to tree or graph\\n        still we need to poll n ^ 2 subarrays\\n        \\n        what things will help us in subarray problem?\\n        sliding window\\n        bit manipulation\\n        \\n        if we sort by val and attached by indices\\n        [(1,0),(2,1),(2,3),(3,2)]\\n        \\n        first ele can be min for whole array\\n        second can be min for array range from \\n        \\n        is this prev smaller and next smaller ele problem\\n        and to we need prefix sum array to get sum of subarray\\n        based on prev smaller and next smaller ele index\\n        \\n        tc = O(n + n + n + n) => O(4n) => O(n)\\n        sc = O(n + n + n) => O(3n) => O(n)\\n        \"\"\"\\n        def prevSmallerElement(nums):\\n            n = len(nums)\\n            stack = []\\n            pse = [-1] * n\\n            for idx in range(n - 1,-1,-1):\\n                while stack and nums[stack[-1]] > nums[idx]:\\n                    top = stack.pop()\\n                    pse[top] = idx\\n                stack.append(idx)\\n            return pse\\n        \\n        def nextSmallerElement(nums):\\n            stack = []\\n            n = len(nums)\\n            nse = [n] * n\\n            for idx in range(n):\\n                while stack and nums[stack[-1]] > nums[idx]:\\n                    top = stack.pop()\\n                    nse[top] = idx\\n                stack.append(idx)\\n            return nse\\n        \\n        def preparePrefixArr(nums):\\n            n = len(nums)\\n            prefixArr = [0] * n\\n            prefixArr[0] = nums[0]\\n            for idx in range(1,n):\\n                prefixArr[idx] = prefixArr[idx - 1] + nums[idx]\\n            return prefixArr\\n                \\n        \\n        pse = prevSmallerElement(nums)\\n        nse = nextSmallerElement(nums)\\n        prefixArr = preparePrefixArr(nums)\\n        maxSumMinProduct = -math.inf\\n        mod = (10 ** 9) + 7\\n        for idx in range(len(nums)):\\n            currentMinElement = nums[idx]\\n            leftBoundary = pse[idx]\\n            rightBoundary = nse[idx]\\n            subarraySumWhereCurrentEleIsMin = prefixArr[rightBoundary - 1] - (0 if leftBoundary == -1 else prefixArr[leftBoundary])\\n            currentSubarrayWeight = currentMinElement * subarraySumWhereCurrentEleIsMin\\n            maxSumMinProduct = max(maxSumMinProduct, currentSubarrayWeight)\\n        \\n        return maxSumMinProduct % mod\\n    def bruteForce(self,nums):\\n        \"\"\"\\n        brute force is for every subarray \\n        keep track of sum and minimum and then keep track of maximum\\n        among them\\n        \"\"\"\\n        windowSum = 0\\n        minInWindow = math.inf\\n        maxSumMinProd = -math.inf\\n        n = len(nums)\\n        for i in range(n):\\n            windowSum = 0\\n            minInWindow = math.inf\\n            for j in range(i,n):\\n                minInWindow = min(minInWindow, nums[j])\\n                windowSum += nums[j]\\n                currSumMinProd = minInWindow * windowSum\\n                maxSumMinProd = max(maxSumMinProd, currSumMinProd)\\n        return maxSumMinProd",
                "codeTag": "Python3"
            },
            {
                "id": 2144805,
                "title": "go-monotonic-stack-explanation-in-comments",
                "content": "A monotonic stack is a stack that keeps an invariant. \\nAn **increasing** monotonic stack, keeps the invariant that the items on the stack are in increasing order.\\nA **decreasing** monotonic stack, keeps the invariant that the items on the stack are in decreasing order.\\n\\n**key note:** we don\\'t keep the values on the stack, we keep their indeces as long as the values at these indeces keep the invariant described above.\\n\\nWhat does the monotonic stack give us? It allows us to find the Next *increasing/decreasing* Element and the Previous *increasing/decreasing* Element. \\n\\n```\\nfunc maxSumMinProduct(nums []int) int {\\n    // maintain an increasing stack\\n    // store indeces on the stack rather than actual values (important)\\n    //          storing indeces provides us with a window\\n    // the invariant on the stack is like this\\n    //\\n    //                ..... j-th item is the item we\\'re on                           j\\n    //                |     this is the END BORDER of our window                ....][....\\n    //                |\\n    //          [1,2] 1\\n    //           |  \\\\___stack.Pop() is the *previous* minimum,                       j\\n    //           |                  so its the previous windows minimum   .....m....][......\\n    //            \\\\stack.Top() is the prev-previous minimum \\n    //                         the minimum BEFORE the beginning          i           j\\n    //                         of this window                       .....][....m....][......\\n    //\\n    // therefore the window we\\'re looking at is between (i:j)  - exclusive \\n    //                                     therefore [i+1:j-1] - inclusive\\n    //\\n    // the FORMULA becomes m * prefix_sum(i+1:j-1)\\n    \\n    // set up boundaries [-1] + [nums] + [-1]\\n    nums = append([]int{-1}, append(nums, -1)...)\\n    \\n    prefix, stak := NewPrefixSum(nums), NewStack()\\n    maxProd := 0\\n    // i = start; j = end; m = curr\\n    for end := range nums {\\n        for stak.Len() > 0 && nums[end] < nums[stak.Top()] {\\n            curr, start := stak.Pop(), stak.Top()\\n            maxProd = max(maxProd, nums[curr] * prefix.Sum(start+1, end-1))\\n        }\\n\\n        stak.Push(end)\\n    }\\n\\n    return maxProd % (1e9+7)\\n}\\n\\ntype pSum struct {\\n    Sum   func(i, j int) int\\n}\\n\\nfunc NewPrefixSum(arr []int) pSum {\\n    // build the sums\\n    sums := make([]int, len(arr) + 1)\\n    for i:=0; i<len(arr); i++ { \\n        sums[i+1] = sums[i] + arr[i]\\n    }\\n    return pSum{\\n        Sum: func(i, j int) int {\\n          return sums[j+1] - sums[i]  \\n        },\\n    }\\n}\\n\\ntype stack struct {\\n    Len     func() int\\n    Push    func(x int)\\n    Pop     func() int\\n    Top     func() int\\n    Print   func() string\\n}\\n\\nfunc NewStack() stack {\\n    arr := make([]int, 0)\\n    return stack{\\n        Len: func() int {\\n            return len(arr)\\n        },\\n        Push: func(x int) {\\n            arr = append(arr, x)\\n        },\\n        Pop:  func() int {\\n            item := arr[len(arr)-1]\\n            arr = arr[:len(arr)-1]\\n            return item\\n        },\\n        Top: func() int {\\n            return arr[len(arr)-1]\\n        },\\n        Print: func() string {\\n            return fmt.Sprintf(\"%d\", arr)\\n        },\\n    }\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Monotonic Stack"
                ],
                "code": "```\\nfunc maxSumMinProduct(nums []int) int {\\n    // maintain an increasing stack\\n    // store indeces on the stack rather than actual values (important)\\n    //          storing indeces provides us with a window\\n    // the invariant on the stack is like this\\n    //\\n    //                ..... j-th item is the item we\\'re on                           j\\n    //                |     this is the END BORDER of our window                ....][....\\n    //                |\\n    //          [1,2] 1\\n    //           |  \\\\___stack.Pop() is the *previous* minimum,                       j\\n    //           |                  so its the previous windows minimum   .....m....][......\\n    //            \\\\stack.Top() is the prev-previous minimum \\n    //                         the minimum BEFORE the beginning          i           j\\n    //                         of this window                       .....][....m....][......\\n    //\\n    // therefore the window we\\'re looking at is between (i:j)  - exclusive \\n    //                                     therefore [i+1:j-1] - inclusive\\n    //\\n    // the FORMULA becomes m * prefix_sum(i+1:j-1)\\n    \\n    // set up boundaries [-1] + [nums] + [-1]\\n    nums = append([]int{-1}, append(nums, -1)...)\\n    \\n    prefix, stak := NewPrefixSum(nums), NewStack()\\n    maxProd := 0\\n    // i = start; j = end; m = curr\\n    for end := range nums {\\n        for stak.Len() > 0 && nums[end] < nums[stak.Top()] {\\n            curr, start := stak.Pop(), stak.Top()\\n            maxProd = max(maxProd, nums[curr] * prefix.Sum(start+1, end-1))\\n        }\\n\\n        stak.Push(end)\\n    }\\n\\n    return maxProd % (1e9+7)\\n}\\n\\ntype pSum struct {\\n    Sum   func(i, j int) int\\n}\\n\\nfunc NewPrefixSum(arr []int) pSum {\\n    // build the sums\\n    sums := make([]int, len(arr) + 1)\\n    for i:=0; i<len(arr); i++ { \\n        sums[i+1] = sums[i] + arr[i]\\n    }\\n    return pSum{\\n        Sum: func(i, j int) int {\\n          return sums[j+1] - sums[i]  \\n        },\\n    }\\n}\\n\\ntype stack struct {\\n    Len     func() int\\n    Push    func(x int)\\n    Pop     func() int\\n    Top     func() int\\n    Print   func() string\\n}\\n\\nfunc NewStack() stack {\\n    arr := make([]int, 0)\\n    return stack{\\n        Len: func() int {\\n            return len(arr)\\n        },\\n        Push: func(x int) {\\n            arr = append(arr, x)\\n        },\\n        Pop:  func() int {\\n            item := arr[len(arr)-1]\\n            arr = arr[:len(arr)-1]\\n            return item\\n        },\\n        Top: func() int {\\n            return arr[len(arr)-1]\\n        },\\n        Print: func() string {\\n            return fmt.Sprintf(\"%d\", arr)\\n        },\\n    }\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086869,
                "title": "c-increasing-mono-stack-simple-solution-with-explanation",
                "content": "We maintain a mono increasing stack and using a trick that add `0` to `nums`.\\nAlso, we maintain a prefix sum `psum[i]` that can make us easily find any subarray sum `nums[i...j]`.\\n\\nSo when we process `nums` and if `nums[sk.back()] > nums[i]` by checking top of stack , we know that there is a subarray starting from index `sk.back()` to `i-1` that `nums[sk.back()]` is minimum. \\n\\nSo the sum from `sk.back() ... i-1` can be calculate by `sum = psum[i-1] - psum[sk.back()]` , and the subarray min-product is `sum * nums[sk.back()]`\\n \\n* time: `O(n)`\\n* space: `O(n)`\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size(), mod = 1e9+7;\\n        vector<ll> psum = {nums[0]};\\n        for (int i = 1; i < n; ++i) {\\n            psum.push_back(psum.back()+nums[i]);\\n        }\\n        ll res = 0;\\n        vector<int> sk;\\n        nums.push_back(0);\\n        ++n;\\n        for (int i = 0; i < n; ++i) {\\n            while (sk.size() && nums[sk.back()] > nums[i]) {\\n                int idx = sk.back();\\n                sk.pop_back();\\n                ll lsum = sk.size() ? psum[sk.back()] : 0;\\n                res = max(res, (psum[i-1]-lsum)*nums[idx]);\\n            }\\n            sk.push_back(i);\\n        }\\n        return res%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size(), mod = 1e9+7;\\n        vector<ll> psum = {nums[0]};\\n        for (int i = 1; i < n; ++i) {\\n            psum.push_back(psum.back()+nums[i]);\\n        }\\n        ll res = 0;\\n        vector<int> sk;\\n        nums.push_back(0);\\n        ++n;\\n        for (int i = 0; i < n; ++i) {\\n            while (sk.size() && nums[sk.back()] > nums[i]) {\\n                int idx = sk.back();\\n                sk.pop_back();\\n                ll lsum = sk.size() ? psum[sk.back()] : 0;\\n                res = max(res, (psum[i-1]-lsum)*nums[idx]);\\n            }\\n            sk.push_back(i);\\n        }\\n        return res%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945791,
                "title": "python3-monostack-and-prefix-sum-with-detailed-explanation",
                "content": "# Core:\\nRecommend trying https://leetcode.com/problems/largest-rectangle-in-histogram first.\\nThen use monotonic stack with prefix sum.\\n\\nThe core is we know the sum of subarray easily by using prefix sum.\\n**But the minimal number of subarray is hard to know.**\\n\\nmonostack is hard for me to understand. So I hope I can help other.\\n\\nIncreasing monostack: A stack with non-decreasing order.\\nWhy can monostack help us? \\n**Monostack can easily help us find that the number v is the minimal number between index i and j with O(N) time like a magic.**\\n\\nWhenever we iterate the nums one by one and find a number A smaller than the stack top number B. Pop all the number larger than A in the stack.\\n\\nTo be clear, the index here is the index of number in the nums.\\nnumber A index i\\npop number B index i - 1\\nthe previous number C in the monostack with index x\\nC < B\\nA < B\\nC is the most recent number smaller than B.\\nAny number after C must be larger than or equal to B.\\n**B is the smallest number in this closed interval [x + 1, i -1]**\\n\\nsubarray min-product: sum(nums[x+1: i]) * B\\n**If we can try every number as the min number with the interval as wide as possible(since nums[i] > 1), we will guarantee the result.**\\n\\n\\nTake 1 3 6 5 2 for example.\\nThe moment we iterate to value 2(index 4).\\n\\nThe current monostack (In the code only index . Value here is easy for readers to understand the concept.)\\nindex [0, 1, 3]\\nvalue [1, 3, 5]\\n\\npop 5\\nnew monostack\\nindex [0, 1]\\nvalue [1, 3]\\npop value 5 means 5 is the smallest number between (monostack[-1] + 1) and ((index 4) - 1) which are 2 and 3\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nnew monostack\\nindex [0]\\nvalue [1]\\npop value 3 means 3 in the smallest number between (monostack[-1] + 1) and ((index 4) - 1) which are 1 and 3\\n\\n# A trick here:\\nAdd 0 to the end of nums array. We won\\'t miss the edge case of increasing array. At the same time 0 < any number in nums\\nAdd -1 to the monostack to avoid the first num compare with the empty mono_stack. \\nmonostack[-1] == -1      nums[-1] == 0\\nThere is no way to find a number in nums less than the last number of nums.\\n\\n# Full walkthrough:\\nTake 1 3 5 2 1 for example.\\nAdd 0 to the end. New array is 1 3 5 2 1 0.\\n\\nTo make the monostack easy to understand, I use the value in the stack for explanation. \\nBut in the code the index is saved in the stack so that we can calculate the sum of subarray with left index and right index.\\n```\\nStack\\t\\tCompare \\tAction\\t\\tsubarray min-product\\n0\\t\\t\\t\\n0 1        \\t1 > 0\\t\\tappend 1\\n0 1 3\\t\\t3 > 1\\t\\tappend 3\\n0 1 3 5\\t\\t5 > 3\\t\\tappend 5\\n0 1 3 \\t\\t2 < 5 \\t\\tpop 5\\t\\t5 * 5\\n0 1\\t\\t\\t2 < 3 \\t\\tpop 3\\t\\t3 * (3 + 5)\\n0 1 2\\t\\t\\t\\t\\tappend 2\\n0 1\\t\\t\\t1 < 2\\t\\tpop 2\\t\\t2 * (3 + 5 + 2)\\n0 1 1\\t\\t\\t\\t\\tappend 1\\n0 1\\t\\t\\t0 < 1\\t\\tpop 1\\t\\t1 * (3 + 5 + 2 + 1)\\n0\\t\\t\\t0 < 1\\t\\tpop 1\\t\\t1 * (3 + 5 + 2 + 1)\\n0 0\\t\\t\\t\\t\\t\\tappend 0\\n\\nResult 25\\n```\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n            \\n        prefix_sum = [0]\\n        for i in range(n):\\n            prefix_sum.append(prefix_sum[-1] + nums[i])\\n        \\n        def subarray_sum(left, right):\\n            return prefix_sum[right + 1] - prefix_sum[left]\\n        \\n        nums.append(0)\\n        mono_stack = [-1]\\n        \\n        res = 0\\n        for i in range(n + 1):\\n            while nums[i] < nums[mono_stack[-1]]:\\n                next_larger = mono_stack.pop()\\n                res = max(res, nums[next_larger] * subarray_sum(mono_stack[-1] + 1, i - 1))\\n            mono_stack.append(i)\\n        return res % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nStack\\t\\tCompare \\tAction\\t\\tsubarray min-product\\n0\\t\\t\\t\\n0 1        \\t1 > 0\\t\\tappend 1\\n0 1 3\\t\\t3 > 1\\t\\tappend 3\\n0 1 3 5\\t\\t5 > 3\\t\\tappend 5\\n0 1 3 \\t\\t2 < 5 \\t\\tpop 5\\t\\t5 * 5\\n0 1\\t\\t\\t2 < 3 \\t\\tpop 3\\t\\t3 * (3 + 5)\\n0 1 2\\t\\t\\t\\t\\tappend 2\\n0 1\\t\\t\\t1 < 2\\t\\tpop 2\\t\\t2 * (3 + 5 + 2)\\n0 1 1\\t\\t\\t\\t\\tappend 1\\n0 1\\t\\t\\t0 < 1\\t\\tpop 1\\t\\t1 * (3 + 5 + 2 + 1)\\n0\\t\\t\\t0 < 1\\t\\tpop 1\\t\\t1 * (3 + 5 + 2 + 1)\\n0 0\\t\\t\\t\\t\\t\\tappend 0\\n\\nResult 25\\n```\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n            \\n        prefix_sum = [0]\\n        for i in range(n):\\n            prefix_sum.append(prefix_sum[-1] + nums[i])\\n        \\n        def subarray_sum(left, right):\\n            return prefix_sum[right + 1] - prefix_sum[left]\\n        \\n        nums.append(0)\\n        mono_stack = [-1]\\n        \\n        res = 0\\n        for i in range(n + 1):\\n            while nums[i] < nums[mono_stack[-1]]:\\n                next_larger = mono_stack.pop()\\n                res = max(res, nums[next_larger] * subarray_sum(mono_stack[-1] + 1, i - 1))\\n            mono_stack.append(i)\\n        return res % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375676,
                "title": "solution-with-three-example-explanation",
                "content": "# Exp1\\n```\\nYour input\\n[1,2,3,2]\\nYour stdout\\nselect value= 1\\nrunning_sum= 1\\nstack= [(-1, 0), (1, 1)]\\n\\nselect value= 2\\nrunning_sum= 3\\nstack= [(-1, 0), (1, 1), (2, 3)]\\n\\nselect value= 3\\nrunning_sum= 6\\nstack= [(-1, 0), (1, 1), (2, 3), (3, 6)]\\n\\nselect value= 2\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 6 stack[-1][1] 3\\n[(-1, 0), (1, 1), (2, 3)]\\nrunning_max 9\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 6 stack[-1][1] 1\\n[(-1, 0), (1, 1)]\\nrunning_max 10\\n\\nrunning_sum= 8\\nstack= [(-1, 0), (1, 1), (2, 8)]\\n\\nselect value= 0\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 8 stack[-1][1] 1\\n[(-1, 0), (1, 1)]\\nrunning_max 14\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 1 running sum= 8 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 14\\n\\nrunning_sum= 8\\nstack= [(-1, 0), (0, 8)]\\n\\n\\nYour answer\\n14\\nExpected answer\\n14\\n```\\n# Ex2\\n```\\n\\n\\nYour input\\n[2,3,3,1,2]\\nYour stdout\\nselect value= 2\\nrunning_sum= 2\\nstack= [(-1, 0), (2, 2)]\\n\\nselect value= 3\\nrunning_sum= 5\\nstack= [(-1, 0), (2, 2), (3, 5)]\\n\\nselect value= 3\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 5 stack[-1][1] 2\\n[(-1, 0), (2, 2)]\\nrunning_max 9\\n\\nrunning_sum= 8\\nstack= [(-1, 0), (2, 2), (3, 8)]\\n\\nselect value= 1\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 8 stack[-1][1] 2\\n[(-1, 0), (2, 2)]\\nrunning_max 18\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 8 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 18\\n\\nrunning_sum= 9\\nstack= [(-1, 0), (1, 9)]\\n\\nselect value= 2\\nrunning_sum= 11\\nstack= [(-1, 0), (1, 9), (2, 11)]\\n\\nselect value= 0\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 11 stack[-1][1] 9\\n[(-1, 0), (1, 9)]\\nrunning_max 18\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 1 running sum= 11 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 18\\n\\nrunning_sum= 11\\nstack= [(-1, 0), (0, 11)]\\n\\n\\nYour answer\\n18\\nExpected answer\\n18\\n```\\n\\n\\n# Ex:3\\n```\\n\\n\\nYour input\\n [3,1,5,6,4,2]\\nYour stdout\\nselect value= 3\\nrunning_sum= 3\\nstack= [(-1, 0), (3, 3)]\\n\\nselect value= 1\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 3 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 9\\n\\nrunning_sum= 4\\nstack= [(-1, 0), (1, 4)]\\n\\nselect value= 5\\nrunning_sum= 9\\nstack= [(-1, 0), (1, 4), (5, 9)]\\n\\nselect value= 6\\nrunning_sum= 15\\nstack= [(-1, 0), (1, 4), (5, 9), (6, 15)]\\n\\nselect value= 4\\nstack[-1][0]>=selectvalue True\\npop minvalue= 6 running sum= 15 stack[-1][1] 9\\n[(-1, 0), (1, 4), (5, 9)]\\nrunning_max 36\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 5 running sum= 15 stack[-1][1] 4\\n[(-1, 0), (1, 4)]\\nrunning_max 55\\n\\nrunning_sum= 19\\nstack= [(-1, 0), (1, 4), (4, 19)]\\n\\nselect value= 2\\nstack[-1][0]>=selectvalue True\\npop minvalue= 4 running sum= 19 stack[-1][1] 4\\n[(-1, 0), (1, 4)]\\nrunning_max 60\\n\\nrunning_sum= 21\\nstack= [(-1, 0), (1, 4), (2, 21)]\\n\\nselect value= 0\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 21 stack[-1][1] 4\\n[(-1, 0), (1, 4)]\\nrunning_max 60\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 1 running sum= 21 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 60\\n\\nrunning_sum= 21\\nstack= [(-1, 0), (0, 21)]\\n\\n\\nYour answer\\n60\\nExpected answer\\n60\\n```\\n\\n```\\n\\nYour input\\n\\n[2,5,4,2,4,5,3,1,2,4]\\nYour stdout\\nselect value= 2\\nrunning_sum= 2\\nstack= [(-1, 0), (2, 2)]\\n\\nselect value= 5\\nrunning_sum= 7\\nstack= [(-1, 0), (2, 2), (5, 7)]\\n\\nselect value= 4\\nstack[-1][0]>=selectvalue True\\npop minvalue= 5 running sum= 7 stack[-1][1] 2\\n[(-1, 0), (2, 2)]\\nrunning_max 25\\n\\nrunning_sum= 11\\nstack= [(-1, 0), (2, 2), (4, 11)]\\n\\nselect value= 2\\nstack[-1][0]>=selectvalue True\\npop minvalue= 4 running sum= 11 stack[-1][1] 2\\n[(-1, 0), (2, 2)]\\nrunning_max 36\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 11 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 36\\n\\nrunning_sum= 13\\nstack= [(-1, 0), (2, 13)]\\n\\nselect value= 4\\nrunning_sum= 17\\nstack= [(-1, 0), (2, 13), (4, 17)]\\n\\nselect value= 5\\nrunning_sum= 22\\nstack= [(-1, 0), (2, 13), (4, 17), (5, 22)]\\n\\nselect value= 3\\nstack[-1][0]>=selectvalue True\\npop minvalue= 5 running sum= 22 stack[-1][1] 17\\n[(-1, 0), (2, 13), (4, 17)]\\nrunning_max 36\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 4 running sum= 22 stack[-1][1] 13\\n[(-1, 0), (2, 13)]\\nrunning_max 36\\n\\nrunning_sum= 25\\nstack= [(-1, 0), (2, 13), (3, 25)]\\n\\nselect value= 1\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 25 stack[-1][1] 13\\n[(-1, 0), (2, 13)]\\nrunning_max 36\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 25 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 50\\n\\nrunning_sum= 26\\nstack= [(-1, 0), (1, 26)]\\n\\nselect value= 2\\nrunning_sum= 28\\nstack= [(-1, 0), (1, 26), (2, 28)]\\n\\nselect value= 4\\nrunning_sum= 32\\nstack= [(-1, 0), (1, 26), (2, 28), (4, 32)]\\n\\nselect value= 0\\nstack[-1][0]>=selectvalue True\\npop minvalue= 4 running sum= 32 stack[-1][1] 28\\n[(-1, 0), (1, 26), (2, 28)]\\nrunning_max 50\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 32 stack[-1][1] 26\\n[(-1, 0), (1, 26)]\\nrunning_max 50\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 1 running sum= 32 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 50\\n\\nrunning_sum= 32\\nstack= [(-1, 0), (0, 32)]\\n\\n\\nYour answer\\n50\\nExpected answer\\n50\\n```\\n\\n\\n\\n```\\n\\n\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        stack = [(-1, 0)] # minimum value and running sum\\n        running_max = running_sum = 0\\n        nums.append(0)\\n        for v in nums:\\n            while stack[-1][0] >= v:\\n                min_value, _ = stack.pop()\\n                running_max = max(running_max, min_value * (running_sum - stack[-1][1]))\\n            running_sum += v\\n            stack.append((v, running_sum))\\n        return running_max % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nYour input\\n[1,2,3,2]\\nYour stdout\\nselect value= 1\\nrunning_sum= 1\\nstack= [(-1, 0), (1, 1)]\\n\\nselect value= 2\\nrunning_sum= 3\\nstack= [(-1, 0), (1, 1), (2, 3)]\\n\\nselect value= 3\\nrunning_sum= 6\\nstack= [(-1, 0), (1, 1), (2, 3), (3, 6)]\\n\\nselect value= 2\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 6 stack[-1][1] 3\\n[(-1, 0), (1, 1), (2, 3)]\\nrunning_max 9\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 6 stack[-1][1] 1\\n[(-1, 0), (1, 1)]\\nrunning_max 10\\n\\nrunning_sum= 8\\nstack= [(-1, 0), (1, 1), (2, 8)]\\n\\nselect value= 0\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 8 stack[-1][1] 1\\n[(-1, 0), (1, 1)]\\nrunning_max 14\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 1 running sum= 8 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 14\\n\\nrunning_sum= 8\\nstack= [(-1, 0), (0, 8)]\\n\\n\\nYour answer\\n14\\nExpected answer\\n14\\n```\n```\\n\\n\\nYour input\\n[2,3,3,1,2]\\nYour stdout\\nselect value= 2\\nrunning_sum= 2\\nstack= [(-1, 0), (2, 2)]\\n\\nselect value= 3\\nrunning_sum= 5\\nstack= [(-1, 0), (2, 2), (3, 5)]\\n\\nselect value= 3\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 5 stack[-1][1] 2\\n[(-1, 0), (2, 2)]\\nrunning_max 9\\n\\nrunning_sum= 8\\nstack= [(-1, 0), (2, 2), (3, 8)]\\n\\nselect value= 1\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 8 stack[-1][1] 2\\n[(-1, 0), (2, 2)]\\nrunning_max 18\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 8 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 18\\n\\nrunning_sum= 9\\nstack= [(-1, 0), (1, 9)]\\n\\nselect value= 2\\nrunning_sum= 11\\nstack= [(-1, 0), (1, 9), (2, 11)]\\n\\nselect value= 0\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 11 stack[-1][1] 9\\n[(-1, 0), (1, 9)]\\nrunning_max 18\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 1 running sum= 11 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 18\\n\\nrunning_sum= 11\\nstack= [(-1, 0), (0, 11)]\\n\\n\\nYour answer\\n18\\nExpected answer\\n18\\n```\n```\\n\\n\\nYour input\\n [3,1,5,6,4,2]\\nYour stdout\\nselect value= 3\\nrunning_sum= 3\\nstack= [(-1, 0), (3, 3)]\\n\\nselect value= 1\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 3 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 9\\n\\nrunning_sum= 4\\nstack= [(-1, 0), (1, 4)]\\n\\nselect value= 5\\nrunning_sum= 9\\nstack= [(-1, 0), (1, 4), (5, 9)]\\n\\nselect value= 6\\nrunning_sum= 15\\nstack= [(-1, 0), (1, 4), (5, 9), (6, 15)]\\n\\nselect value= 4\\nstack[-1][0]>=selectvalue True\\npop minvalue= 6 running sum= 15 stack[-1][1] 9\\n[(-1, 0), (1, 4), (5, 9)]\\nrunning_max 36\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 5 running sum= 15 stack[-1][1] 4\\n[(-1, 0), (1, 4)]\\nrunning_max 55\\n\\nrunning_sum= 19\\nstack= [(-1, 0), (1, 4), (4, 19)]\\n\\nselect value= 2\\nstack[-1][0]>=selectvalue True\\npop minvalue= 4 running sum= 19 stack[-1][1] 4\\n[(-1, 0), (1, 4)]\\nrunning_max 60\\n\\nrunning_sum= 21\\nstack= [(-1, 0), (1, 4), (2, 21)]\\n\\nselect value= 0\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 21 stack[-1][1] 4\\n[(-1, 0), (1, 4)]\\nrunning_max 60\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 1 running sum= 21 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 60\\n\\nrunning_sum= 21\\nstack= [(-1, 0), (0, 21)]\\n\\n\\nYour answer\\n60\\nExpected answer\\n60\\n```\n```\\n\\nYour input\\n\\n[2,5,4,2,4,5,3,1,2,4]\\nYour stdout\\nselect value= 2\\nrunning_sum= 2\\nstack= [(-1, 0), (2, 2)]\\n\\nselect value= 5\\nrunning_sum= 7\\nstack= [(-1, 0), (2, 2), (5, 7)]\\n\\nselect value= 4\\nstack[-1][0]>=selectvalue True\\npop minvalue= 5 running sum= 7 stack[-1][1] 2\\n[(-1, 0), (2, 2)]\\nrunning_max 25\\n\\nrunning_sum= 11\\nstack= [(-1, 0), (2, 2), (4, 11)]\\n\\nselect value= 2\\nstack[-1][0]>=selectvalue True\\npop minvalue= 4 running sum= 11 stack[-1][1] 2\\n[(-1, 0), (2, 2)]\\nrunning_max 36\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 11 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 36\\n\\nrunning_sum= 13\\nstack= [(-1, 0), (2, 13)]\\n\\nselect value= 4\\nrunning_sum= 17\\nstack= [(-1, 0), (2, 13), (4, 17)]\\n\\nselect value= 5\\nrunning_sum= 22\\nstack= [(-1, 0), (2, 13), (4, 17), (5, 22)]\\n\\nselect value= 3\\nstack[-1][0]>=selectvalue True\\npop minvalue= 5 running sum= 22 stack[-1][1] 17\\n[(-1, 0), (2, 13), (4, 17)]\\nrunning_max 36\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 4 running sum= 22 stack[-1][1] 13\\n[(-1, 0), (2, 13)]\\nrunning_max 36\\n\\nrunning_sum= 25\\nstack= [(-1, 0), (2, 13), (3, 25)]\\n\\nselect value= 1\\nstack[-1][0]>=selectvalue True\\npop minvalue= 3 running sum= 25 stack[-1][1] 13\\n[(-1, 0), (2, 13)]\\nrunning_max 36\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 25 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 50\\n\\nrunning_sum= 26\\nstack= [(-1, 0), (1, 26)]\\n\\nselect value= 2\\nrunning_sum= 28\\nstack= [(-1, 0), (1, 26), (2, 28)]\\n\\nselect value= 4\\nrunning_sum= 32\\nstack= [(-1, 0), (1, 26), (2, 28), (4, 32)]\\n\\nselect value= 0\\nstack[-1][0]>=selectvalue True\\npop minvalue= 4 running sum= 32 stack[-1][1] 28\\n[(-1, 0), (1, 26), (2, 28)]\\nrunning_max 50\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 2 running sum= 32 stack[-1][1] 26\\n[(-1, 0), (1, 26)]\\nrunning_max 50\\n\\nstack[-1][0]>=selectvalue True\\npop minvalue= 1 running sum= 32 stack[-1][1] 0\\n[(-1, 0)]\\nrunning_max 50\\n\\nrunning_sum= 32\\nstack= [(-1, 0), (0, 32)]\\n\\n\\nYour answer\\n50\\nExpected answer\\n50\\n```\n```\\n\\n\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        stack = [(-1, 0)] # minimum value and running sum\\n        running_max = running_sum = 0\\n        nums.append(0)\\n        for v in nums:\\n            while stack[-1][0] >= v:\\n                min_value, _ = stack.pop()\\n                running_max = max(running_max, min_value * (running_sum - stack[-1][1]))\\n            running_sum += v\\n            stack.append((v, running_sum))\\n        return running_max % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309455,
                "title": "java-monotonic-stack-solution-time-o-n",
                "content": "```\\n// Monotonic Stack Solution\\n// The idea is same as Leetcode 84 \"Largest Rectangle in Histogram\"\\n// 1. Get prefix sum array.\\n// 2. While cur num is less than the num in the top of stack, calculate the prod.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    private static final int MOD = (int) 1E9 + 7;\\n    public int maxSumMinProduct(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        final int N = nums.length;\\n        long[] sums = new long[N+1];\\n        for (int i = 1; i <= N; i++) {\\n            sums[i] = sums[i-1] + nums[i-1];\\n        }\\n        long res = Long.MIN_VALUE;\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0; i <= N; i++) {\\n            int cur = i == N ? 0 : nums[i];\\n            while (!stack.isEmpty() && cur <= nums[stack.peek()]) {\\n                int min = nums[stack.pop()];\\n                int j = stack.isEmpty() ? 0 : stack.peek() + 1;\\n                long sum = sums[i] - sums[j];\\n                long prod = min * sum;\\n                res = Math.max(res, prod);\\n            }\\n            stack.push(i);\\n        }\\n        return (int) (res % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Monotonic Stack Solution\\n// The idea is same as Leetcode 84 \"Largest Rectangle in Histogram\"\\n// 1. Get prefix sum array.\\n// 2. While cur num is less than the num in the top of stack, calculate the prod.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    private static final int MOD = (int) 1E9 + 7;\\n    public int maxSumMinProduct(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        final int N = nums.length;\\n        long[] sums = new long[N+1];\\n        for (int i = 1; i <= N; i++) {\\n            sums[i] = sums[i-1] + nums[i-1];\\n        }\\n        long res = Long.MIN_VALUE;\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0; i <= N; i++) {\\n            int cur = i == N ? 0 : nums[i];\\n            while (!stack.isEmpty() && cur <= nums[stack.peek()]) {\\n                int min = nums[stack.pop()];\\n                int j = stack.isEmpty() ? 0 : stack.peek() + 1;\\n                long sum = sums[i] - sums[j];\\n                long prod = min * sum;\\n                res = Math.max(res, prod);\\n            }\\n            stack.push(i);\\n        }\\n        return (int) (res % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293356,
                "title": "java-solution-using-prefix-and-stack-42-ms-faster-than-74-40",
                "content": "\\'\\'\\'\\n\\n\\tpublic int maxSumMinProduct(int[] nums) {\\n\\t\\tfinal long kmod = (long) 1e9 + 7;\\n\\n\\t\\tlong ans = 0;\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tlong[] prefix = new long[nums.length + 1];\\n\\n\\t\\tfor (int i = 0; i < nums.length; ++i)\\n\\t\\t  prefix[i + 1] = prefix[i] + nums[i];\\n\\n\\t\\tfor (int i = 0; i <= nums.length; ++i) {\\n\\t\\t  while (!stack.isEmpty() && (i == nums.length || nums[stack.peek()] > nums[i])) {\\n\\t\\t\\tfinal int minVal = nums[stack.pop()];\\n\\t\\t\\tfinal long sum = stack.isEmpty() ? prefix[i] : prefix[i] - prefix[stack.peek() + 1];\\n\\t\\t\\tans = Math.max(ans, minVal * sum);\\n\\t\\t  }\\n\\t\\t  stack.push(i);\\n\\t\\t}\\n\\n\\t\\treturn (int) (ans % kmod);\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "\\'\\'\\'\\n\\n\\tpublic int maxSumMinProduct(int[] nums) {\\n\\t\\tfinal long kmod = (long) 1e9 + 7;\\n\\n\\t\\tlong ans = 0;\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tlong[] prefix = new long[nums.length + 1];\\n\\n\\t\\tfor (int i = 0; i < nums.length; ++i)\\n\\t\\t  prefix[i + 1] = prefix[i] + nums[i];\\n\\n\\t\\tfor (int i = 0; i <= nums.length; ++i) {\\n\\t\\t  while (!stack.isEmpty() && (i == nums.length || nums[stack.peek()] > nums[i])) {\\n\\t\\t\\tfinal int minVal = nums[stack.pop()];\\n\\t\\t\\tfinal long sum = stack.isEmpty() ? prefix[i] : prefix[i] - prefix[stack.peek() + 1];\\n\\t\\t\\tans = Math.max(ans, minVal * sum);\\n\\t\\t  }\\n\\t\\t  stack.push(i);\\n\\t\\t}\\n\\n\\t\\treturn (int) (ans % kmod);\\n}\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1288772,
                "title": "python-monotonic-stack",
                "content": "- Add each number + its index to the stack while iterating through `nums`.\\n - pop all values greater than the current value from the stack (its the end of a subarray that we need to calculate)\\n - when pushing to the stack, use either the current index, or the earliest index of numbers that were greater than the current number (that we popped from the stack)\\n\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        ps = [0] + list(accumulate(nums))\\n        stack, ans = [], 0\\n        for i, num in enumerate(nums + [-inf]):\\n            j = i\\n            while stack and num < stack[-1][0]:\\n                lo, j = stack.pop()\\n                ans = max(ans, lo * (ps[i] - ps[j]))\\n            stack.append((num, j))\\n        return ans % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        ps = [0] + list(accumulate(nums))\\n        stack, ans = [], 0\\n        for i, num in enumerate(nums + [-inf]):\\n            j = i\\n            while stack and num < stack[-1][0]:\\n                lo, j = stack.pop()\\n                ans = max(ans, lo * (ps[i] - ps[j]))\\n            stack.append((num, j))\\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226963,
                "title": "c-finally-got-it",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        long mod = 1e9 + 7;\\n\\t\\tlong res = 0;\\n\\t\\tnums.push_back(-1);\\n\\t\\tint length = nums.size();\\n\\t\\t//Monotone Stack\\n\\t\\tstack<int> st;\\n\\t\\tvector<long> dp(length);\\n\\t\\tdp[0] = nums[0];\\n\\t\\tfor (int i = 1; i < length-1; i++) { \\n\\t\\t\\tdp[i] = dp[i - 1] + nums[i]; \\n\\t\\t}\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\twhile (!st.empty() && nums[i] < nums[st.top()]) {\\n\\t\\t\\t\\tint top = st.top();\\n\\t\\t\\t\\tst.pop();\\n\\n\\t\\t\\t\\tif (!st.empty()) {\\n\\t\\t\\t\\t\\tlong x = dp[i - 1] - dp[st.top()];\\n\\t\\t\\t\\t\\t//cout << x<<endl;\\n\\t\\t\\t\\t\\tres = (x * nums[top]) > res ? (x * nums[top]) : res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t//cout << \"enter?\"<< top<<endl;\\n\\t\\t\\t\\t\\tlong x = dp[i-1];\\n\\t\\t\\t\\t\\tres = (x * nums[top]) > res ? (x * nums[top]) : res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tst.push(i);\\n\\t\\t}\\n\\t\\treturn res % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        long mod = 1e9 + 7;\\n\\t\\tlong res = 0;\\n\\t\\tnums.push_back(-1);\\n\\t\\tint length = nums.size();\\n\\t\\t//Monotone Stack\\n\\t\\tstack<int> st;\\n\\t\\tvector<long> dp(length);\\n\\t\\tdp[0] = nums[0];\\n\\t\\tfor (int i = 1; i < length-1; i++) { \\n\\t\\t\\tdp[i] = dp[i - 1] + nums[i]; \\n\\t\\t}\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\twhile (!st.empty() && nums[i] < nums[st.top()]) {\\n\\t\\t\\t\\tint top = st.top();\\n\\t\\t\\t\\tst.pop();\\n\\n\\t\\t\\t\\tif (!st.empty()) {\\n\\t\\t\\t\\t\\tlong x = dp[i - 1] - dp[st.top()];\\n\\t\\t\\t\\t\\t//cout << x<<endl;\\n\\t\\t\\t\\t\\tres = (x * nums[top]) > res ? (x * nums[top]) : res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t//cout << \"enter?\"<< top<<endl;\\n\\t\\t\\t\\t\\tlong x = dp[i-1];\\n\\t\\t\\t\\t\\tres = (x * nums[top]) > res ? (x * nums[top]) : res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tst.push(i);\\n\\t\\t}\\n\\t\\treturn res % mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1215709,
                "title": "java-dp-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    long find(long arr[],int l,int r){\\n        return arr[r]-(l-1>=0 ? arr[l-1] : 0);\\n    }\\n    public int maxSumMinProduct(int[] nums) {\\n        int n=nums.length;\\n       long preSum[]=new long[n];\\n       for(int i=0;i<n;i++)\\n           preSum[i]=nums[i]+(i-1>=0 ? preSum[i-1] : 0 );\\n        Stack<Integer>stack=new Stack<>();\\n        int arr[][]=new int[n][2];\\n        //to-find how long we can expand it in left\\n        for(int i=0;i<n;i++){\\n            while(!stack.isEmpty()&&nums[stack.peek()]>=nums[i])stack.pop();\\n            arr[i][0]=stack.isEmpty() ? -1 : stack.peek();\\n            stack.push(i);\\n        }\\n        stack=new Stack<>();\\n        //to-find hoe long we can expand it in right;\\n        for(int i=n-1;i>=0;i--){\\n             while(!stack.isEmpty()&&nums[stack.peek()]>=nums[i])stack.pop();\\n            arr[i][1]=stack.isEmpty() ? n : stack.peek();\\n            stack.push(i);\\n        }\\n        long res=0;\\n        for(int i=0;i<n;i++){\\n            res=Math.max(res,nums[i]*find(preSum,arr[i][0]+1,arr[i][1]-1));\\n        }\\n        return (int)(res%(1000000007));\\n    }\\n}\\n\\n```\\n***Please,Upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long find(long arr[],int l,int r){\\n        return arr[r]-(l-1>=0 ? arr[l-1] : 0);\\n    }\\n    public int maxSumMinProduct(int[] nums) {\\n        int n=nums.length;\\n       long preSum[]=new long[n];\\n       for(int i=0;i<n;i++)\\n           preSum[i]=nums[i]+(i-1>=0 ? preSum[i-1] : 0 );\\n        Stack<Integer>stack=new Stack<>();\\n        int arr[][]=new int[n][2];\\n        //to-find how long we can expand it in left\\n        for(int i=0;i<n;i++){\\n            while(!stack.isEmpty()&&nums[stack.peek()]>=nums[i])stack.pop();\\n            arr[i][0]=stack.isEmpty() ? -1 : stack.peek();\\n            stack.push(i);\\n        }\\n        stack=new Stack<>();\\n        //to-find hoe long we can expand it in right;\\n        for(int i=n-1;i>=0;i--){\\n             while(!stack.isEmpty()&&nums[stack.peek()]>=nums[i])stack.pop();\\n            arr[i][1]=stack.isEmpty() ? n : stack.peek();\\n            stack.push(i);\\n        }\\n        long res=0;\\n        for(int i=0;i<n;i++){\\n            res=Math.max(res,nums[i]*find(preSum,arr[i][0]+1,arr[i][1]-1));\\n        }\\n        return (int)(res%(1000000007));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210476,
                "title": "java-o-n-prefix-sum-next-smallest-with-stack",
                "content": "```\\nclass Solution \\n{\\n    private final int MOD = 1000000007;\\n    public int maxSumMinProduct(int[] nums) \\n    {\\n        long[] prefix = new long[nums.length + 1];\\n        long max = 0;\\n        \\n        for(int i = 1; i <= nums.length; i++)\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        \\n        Stack<Integer> stack = new Stack<Integer>();\\n\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            while(stack.size() > 0 && nums[stack.peek()] >= nums[i])\\n                max = Math.max(max, nums[stack.pop()] * FindRange(prefix, stack.size() > 0 ? stack.peek() + 1 : 0, i - 1));\\n            \\n            stack.push(i);\\n        }\\n        \\n        while(stack.size() > 0)\\n        {\\n            int index = stack.pop();\\n            \\n            if(stack.size() > 0)\\n                max = Math.max(max, nums[index] * (FindRange(prefix, stack.peek() + 1, index - 1) + FindRange(prefix, index, nums.length - 1)));\\n            else\\n                max = Math.max(max, nums[index] * prefix[nums.length]);\\n        }\\n        \\n        return (int)(max % MOD);\\n    }\\n    \\n    private long FindRange(long[] prefix, int x, int y)\\n    {\\n        if(x > y)\\n            return 0;\\n        \\n        return prefix[y + 1] - prefix[x];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\n    private final int MOD = 1000000007;\\n    public int maxSumMinProduct(int[] nums) \\n    {\\n        long[] prefix = new long[nums.length + 1];\\n        long max = 0;\\n        \\n        for(int i = 1; i <= nums.length; i++)\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        \\n        Stack<Integer> stack = new Stack<Integer>();\\n\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            while(stack.size() > 0 && nums[stack.peek()] >= nums[i])\\n                max = Math.max(max, nums[stack.pop()] * FindRange(prefix, stack.size() > 0 ? stack.peek() + 1 : 0, i - 1));\\n            \\n            stack.push(i);\\n        }\\n        \\n        while(stack.size() > 0)\\n        {\\n            int index = stack.pop();\\n            \\n            if(stack.size() > 0)\\n                max = Math.max(max, nums[index] * (FindRange(prefix, stack.peek() + 1, index - 1) + FindRange(prefix, index, nums.length - 1)));\\n            else\\n                max = Math.max(max, nums[index] * prefix[nums.length]);\\n        }\\n        \\n        return (int)(max % MOD);\\n    }\\n    \\n    private long FindRange(long[] prefix, int x, int y)\\n    {\\n        if(x > y)\\n            return 0;\\n        \\n        return prefix[y + 1] - prefix[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206016,
                "title": "should-be-marked-as-hard-o-n-solution",
                "content": "It is similar problem to Largest Rectangle in Histogram. First solve it, then it will be easy.\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n```\\n\\tint maxSumMinProduct(vector<int>& nums)\\n    {\\n        stack<int> st;\\n        int mod = 1e9 + 7;\\n        nums.push_back(0);\\n        vector<long long int> vec(nums.size()+1);\\n        long long int max_sum = 0;\\n        \\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            vec[i+1] = vec[i] + nums[i]; \\n        }\\n        int i = 0;\\n        \\n        while(i < nums.size())\\n        {\\n            if(!st.size() or nums[i] >= nums[st.top()]) st.push(i++);\\n            else\\n            {\\n                int mid_d = nums[st.top()];\\n                st.pop();\\n                int j = st.size() ? st.top():-1;\\n                if(max_sum < mid_d*(vec[i] - vec[j+1])) max_sum = mid_d*(vec[i] - vec[j+1]);\\n            }\\n        }\\n        return max_sum%mod;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint maxSumMinProduct(vector<int>& nums)\\n    {\\n        stack<int> st;\\n        int mod = 1e9 + 7;\\n        nums.push_back(0);\\n        vector<long long int> vec(nums.size()+1);\\n        long long int max_sum = 0;\\n        \\n        for(int i = 0;i < nums.size();i++)\\n        {\\n            vec[i+1] = vec[i] + nums[i]; \\n        }\\n        int i = 0;\\n        \\n        while(i < nums.size())\\n        {\\n            if(!st.size() or nums[i] >= nums[st.top()]) st.push(i++);\\n            else\\n            {\\n                int mid_d = nums[st.top()];\\n                st.pop();\\n                int j = st.size() ? st.top():-1;\\n                if(max_sum < mid_d*(vec[i] - vec[j+1])) max_sum = mid_d*(vec[i] - vec[j+1]);\\n            }\\n        }\\n        return max_sum%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1205052,
                "title": "c-stack-solution-using-nearest-smaller-element-explained",
                "content": "**Basic idea:**\\n\\nThe subarray where nums[i] will be minimum will be from (left[i], right[i]) both **exclusive.**\\n\\nExample: 3,1,5,6,4,2\\nThe index of nearest elements to the left (left array) (-1, if no smaller element to the right)\\n[-1,-1,1,2,1,1]\\nThe index of nearest elements to the right (right array) (n, if no smaller element to the right)\\n[1,6,4,4,5,6]\\n\\nThe subarray where nums[4] will be minimum will be from (left[4] - right[4]), which is (1,5) which is[5,6,4]\\nSimilarly, the subarray where nums[1]  is minimum will be (left[1] - right[1]), which is (-1,6) which is [3,1,5,6,4,2]\\n\\nSo for each item in the nums, we find the minProduct for the subarray which contains nums[i] as the minimum.\\nWe do that by multiplying nums[i] with the sum of the subarray.\\n\\nThe answer will be the maximum of such minProducts.\\n\\n### **Code:**\\n```\\ntypedef long long ll;\\nclass Solution {\\n   public:\\n    // get sum of subarray using prefix sum array\\n    ll getSumRange(vector<ll>& vec, int l, int r) {\\n        if (l == -1) return vec[r - 1];\\n        return vec[r - 1] - vec[l];\\n    }\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> s;\\n        //find index of nearest smaller element to the left\\n        vector<int> left(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            while (!s.empty() && nums[s.top()] >= nums[i]) {\\n                s.pop();\\n            }\\n            if (!s.empty())\\n                left[i] = s.top();\\n            s.push(i);\\n        }\\n        //clear stack\\n        while (!s.empty()) s.pop();\\n        //find index of nearest smaller element to the right\\n        vector<int> right(n, n);\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.empty() && nums[s.top()] >= nums[i]) {\\n                s.pop();\\n            }\\n            if (!s.empty())\\n                right[i] = s.top();\\n            s.push(i);\\n        }\\n        //generate prefix array\\n        vector<ll> prefix(n);\\n        for (int i = 0; i < n; i++)\\n            if (i == 0)\\n                prefix[i] = nums[i];\\n            else\\n                prefix[i] = nums[i] + prefix[i - 1];\\n        //generate answer\\n        ll ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ll val = (ll)nums[i] * (ll)(getSumRange(prefix, left[i], right[i]));\\n            ans = max(ans, val);\\n        }\\n        return int(ans % int(1e9 + 7));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\n   public:\\n    // get sum of subarray using prefix sum array\\n    ll getSumRange(vector<ll>& vec, int l, int r) {\\n        if (l == -1) return vec[r - 1];\\n        return vec[r - 1] - vec[l];\\n    }\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> s;\\n        //find index of nearest smaller element to the left\\n        vector<int> left(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            while (!s.empty() && nums[s.top()] >= nums[i]) {\\n                s.pop();\\n            }\\n            if (!s.empty())\\n                left[i] = s.top();\\n            s.push(i);\\n        }\\n        //clear stack\\n        while (!s.empty()) s.pop();\\n        //find index of nearest smaller element to the right\\n        vector<int> right(n, n);\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.empty() && nums[s.top()] >= nums[i]) {\\n                s.pop();\\n            }\\n            if (!s.empty())\\n                right[i] = s.top();\\n            s.push(i);\\n        }\\n        //generate prefix array\\n        vector<ll> prefix(n);\\n        for (int i = 0; i < n; i++)\\n            if (i == 0)\\n                prefix[i] = nums[i];\\n            else\\n                prefix[i] = nums[i] + prefix[i - 1];\\n        //generate answer\\n        ll ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ll val = (ll)nums[i] * (ll)(getSumRange(prefix, left[i], right[i]));\\n            ans = max(ans, val);\\n        }\\n        return int(ans % int(1e9 + 7));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204416,
                "title": "c-solution-in-o-n-using-stack-with-explanation",
                "content": "The basic idea of the solution is that, for a particular element we want to find the range in which it will act as the minimum element. And for that particular range we find the sum of the range and multiply it with this element and keep track of maximum of these values.\\n\\n1. Calculate the prefix and suffix sum of the given array.\\n2. Now using stacks and the concept of next smaller element we find the index of the element just smaller than the given element, on the right as well as the left side in the array.\\n3. Now iterating over the array and finding the index of smaller element on the left and the right side and using prefix and suffix sum we can calculate the sum for that given range.\\n\\nCode:\\n\\n```\\n#define mod 1000000007\\n    \\n    int maxSumMinProduct(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        long long int pref[n];\\n        long long int suf[n];\\n\\t\\t\\n\\t\\t//Calculating the prefix sum\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+nums[i];\\n        }\\n\\t\\t\\n\\t\\t//Calculating the suffix sum\\n        suf[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+nums[i];\\n        }\\n        int left[n];\\n        int right[n];\\n        stack<int> s;\\n\\t\\t\\n\\t\\t//Calculating the next smaller element on the right side\\n        s.push(0);\\n        for(int i=1;i<n;i++){\\n            if(s.empty()){\\n                s.push(i);\\n            }else{\\n                while(!s.empty()&&nums[s.top()]>nums[i]){\\n                    right[s.top()]=i;\\n                    s.pop();\\n                }\\n                s.push(i);\\n            }\\n        }\\n        while(!s.empty()){\\n            right[s.top()]=n;\\n            s.pop();\\n        }\\n\\t\\t\\n\\t\\t//Calculating the next smaller element on the left side\\n        s.push(n-1);\\n        for(int i=n-2;i>=0;i--){\\n            if(s.empty()){\\n                s.push(i);\\n            }else{\\n                while(!s.empty()&&nums[s.top()]>nums[i]){\\n                    left[s.top()]=i;\\n                    s.pop();\\n                }\\n                s.push(i);\\n            }\\n        }\\n        while(!s.empty()){\\n            left[s.top()]=-1;\\n            s.pop();\\n        }\\n\\t\\t\\n\\t\\t//Calculating the answer for each of the elements and storing the maximum of them\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            long long int l=0;\\n            if(left[i]==-1){\\n                l=pref[i];\\n            }else{\\n                l=pref[i]-pref[left[i]];\\n            }\\n            long long int r=0;\\n            if(right[i]==n){\\n                r=suf[i];\\n            }else{\\n                r=suf[i]-suf[right[i]];\\n            }\\n            ans=max(ans,(l+r-nums[i])*nums[i]*1ll);\\n        }\\n        return (ans)%mod;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "The basic idea of the solution is that, for a particular element we want to find the range in which it will act as the minimum element. And for that particular range we find the sum of the range and multiply it with this element and keep track of maximum of these values.\\n\\n1. Calculate the prefix and suffix sum of the given array.\\n2. Now using stacks and the concept of next smaller element we find the index of the element just smaller than the given element, on the right as well as the left side in the array.\\n3. Now iterating over the array and finding the index of smaller element on the left and the right side and using prefix and suffix sum we can calculate the sum for that given range.\\n\\nCode:\\n\\n```\\n#define mod 1000000007\\n    \\n    int maxSumMinProduct(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        long long int pref[n];\\n        long long int suf[n];\\n\\t\\t\\n\\t\\t//Calculating the prefix sum\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=pref[i-1]+nums[i];\\n        }\\n\\t\\t\\n\\t\\t//Calculating the suffix sum\\n        suf[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+nums[i];\\n        }\\n        int left[n];\\n        int right[n];\\n        stack<int> s;\\n\\t\\t\\n\\t\\t//Calculating the next smaller element on the right side\\n        s.push(0);\\n        for(int i=1;i<n;i++){\\n            if(s.empty()){\\n                s.push(i);\\n            }else{\\n                while(!s.empty()&&nums[s.top()]>nums[i]){\\n                    right[s.top()]=i;\\n                    s.pop();\\n                }\\n                s.push(i);\\n            }\\n        }\\n        while(!s.empty()){\\n            right[s.top()]=n;\\n            s.pop();\\n        }\\n\\t\\t\\n\\t\\t//Calculating the next smaller element on the left side\\n        s.push(n-1);\\n        for(int i=n-2;i>=0;i--){\\n            if(s.empty()){\\n                s.push(i);\\n            }else{\\n                while(!s.empty()&&nums[s.top()]>nums[i]){\\n                    left[s.top()]=i;\\n                    s.pop();\\n                }\\n                s.push(i);\\n            }\\n        }\\n        while(!s.empty()){\\n            left[s.top()]=-1;\\n            s.pop();\\n        }\\n\\t\\t\\n\\t\\t//Calculating the answer for each of the elements and storing the maximum of them\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            long long int l=0;\\n            if(left[i]==-1){\\n                l=pref[i];\\n            }else{\\n                l=pref[i]-pref[left[i]];\\n            }\\n            long long int r=0;\\n            if(right[i]==n){\\n                r=suf[i];\\n            }else{\\n                r=suf[i]-suf[right[i]];\\n            }\\n            ans=max(ans,(l+r-nums[i])*nums[i]*1ll);\\n        }\\n        return (ans)%mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1203532,
                "title": "rust-dynamic-programming-prefix-sums-with-monotonic-stack",
                "content": "[Problem List of Dedicated \"Prefix Sums\" - github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_algorithm/dynamic_programming/prefix_vs_suffix_sums.txt)\\n\\n[Problem List of \"Special Array\" techinique - github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/dynamic_programming/by_technique/with_help_of/special_array)\\n\\n[Problem List of \"Monotonic Stack\" - github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/stack/stack_monotonic.txt)\\n\\n[Problem List of \"Subarray\" - github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/array/by_data_structure/subarray.txt)\\n\\n```\\n/// https://leetcode.com/problems/maximum-subarray-min-product/\\n/// \\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(`len_n`)\\n/// \\n/// Reference:\\n/// https://leetcode.com/problems/maximum-subarray-min-product/discuss/1198718/JavaPython-Stack-keeps-index-of-elements-less-than-numsi-O(N)\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn max_sum_min_product(nums: Vec<i32>) -> i32 {\\n        const MOD: u64 = 1e9 as u64 + 7;\\n        let len_n = nums.len();\\n        \\n        let mut left_bound: Vec<usize> = vec![0; len_n];\\n        let mut right_bound: Vec<usize> = vec![0; len_n];\\n        \\n        let mut stack: VecDeque<usize> = VecDeque::new();\\n        for i in 0..len_n{\\n            while let Some(&top) = stack.back(){\\n                if nums[top] >= nums[i] {\\n                    stack.pop_back();\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            if let Some(&top) = stack.back(){\\n                left_bound[i] = top + 1;\\n            }else{\\n                left_bound[i] = 0;\\n            }\\n            \\n            stack.push_back(i);\\n        }\\n        \\n        stack.clear();\\n        \\n        for i in (0..len_n).rev(){\\n            while let Some(&top) = stack.back(){\\n                if nums[top] >= nums[i]{\\n                    stack.pop_back();\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            if let Some(&top) = stack.back(){\\n                right_bound[i] = top - 1;\\n            }else{\\n                right_bound[i] = len_n - 1;\\n            }\\n            \\n            stack.push_back(i);\\n        }\\n        \\n        let mut prefix_sums: Vec<u64> = vec![0; len_n + 1];\\n        for i in 0..len_n{\\n            prefix_sums[i + 1] = prefix_sums[i] + nums[i] as u64; \\n        }\\n        \\n        let mut max_product: u64 = 0;\\n        for i in 0..len_n{\\n            max_product = std::cmp::max(max_product, Self::get_sum(left_bound[i], right_bound[i], &prefix_sums) * (nums[i] as u64));\\n        }\\n        \\n        (max_product % MOD) as i32\\n    }\\n    \\n    fn get_sum(lo: usize, hi: usize, prefix_sums: &Vec<u64>) -> u64{\\n        return prefix_sums[hi + 1] - prefix_sums[lo];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Monotonic Stack"
                ],
                "code": "```\\n/// https://leetcode.com/problems/maximum-subarray-min-product/\\n/// \\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(`len_n`)\\n/// \\n/// Reference:\\n/// https://leetcode.com/problems/maximum-subarray-min-product/discuss/1198718/JavaPython-Stack-keeps-index-of-elements-less-than-numsi-O(N)\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn max_sum_min_product(nums: Vec<i32>) -> i32 {\\n        const MOD: u64 = 1e9 as u64 + 7;\\n        let len_n = nums.len();\\n        \\n        let mut left_bound: Vec<usize> = vec![0; len_n];\\n        let mut right_bound: Vec<usize> = vec![0; len_n];\\n        \\n        let mut stack: VecDeque<usize> = VecDeque::new();\\n        for i in 0..len_n{\\n            while let Some(&top) = stack.back(){\\n                if nums[top] >= nums[i] {\\n                    stack.pop_back();\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            if let Some(&top) = stack.back(){\\n                left_bound[i] = top + 1;\\n            }else{\\n                left_bound[i] = 0;\\n            }\\n            \\n            stack.push_back(i);\\n        }\\n        \\n        stack.clear();\\n        \\n        for i in (0..len_n).rev(){\\n            while let Some(&top) = stack.back(){\\n                if nums[top] >= nums[i]{\\n                    stack.pop_back();\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            if let Some(&top) = stack.back(){\\n                right_bound[i] = top - 1;\\n            }else{\\n                right_bound[i] = len_n - 1;\\n            }\\n            \\n            stack.push_back(i);\\n        }\\n        \\n        let mut prefix_sums: Vec<u64> = vec![0; len_n + 1];\\n        for i in 0..len_n{\\n            prefix_sums[i + 1] = prefix_sums[i] + nums[i] as u64; \\n        }\\n        \\n        let mut max_product: u64 = 0;\\n        for i in 0..len_n{\\n            max_product = std::cmp::max(max_product, Self::get_sum(left_bound[i], right_bound[i], &prefix_sums) * (nums[i] as u64));\\n        }\\n        \\n        (max_product % MOD) as i32\\n    }\\n    \\n    fn get_sum(lo: usize, hi: usize, prefix_sums: &Vec<u64>) -> u64{\\n        return prefix_sums[hi + 1] - prefix_sums[lo];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203027,
                "title": "kadane-s-algo",
                "content": "Has anyone tried this with a variation of Kadane\\'s algorithm ?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1202234,
                "title": "java-solution-similar-to-max-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        \\n    ArrayDeque<Integer> dq = new ArrayDeque<Integer>();\\n        long prefix[] = new long[nums.length];\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n          prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        dq.push(-1);\\n        long product = 0;\\n        long mp = 0;\\n        long M = (int)1e9 + 7;\\n        \\n        \\n        \\n        for(int i= 0; i<=nums.length;i++)\\n        {\\n           while((dq.peek()!=-1) && \\n               nums[dq.peek()] > (i== nums.length? 0: nums[i]))\\n           {\\n               int pi = dq.pop();\\n               long sum = 0;\\n               if(dq.peek() == -1)\\n               {\\n                 sum = prefix[i-1];\\n               }\\n               else\\n               {\\n               sum = prefix[i-1]-prefix[dq.peek()];\\n               }\\n               \\n               product = sum*nums[pi];\\n              \\n               \\n               mp = Math.max(mp,product);\\n           }\\n           dq.push(i);\\n        }\\n        \\n        mp = mp%M;\\n        \\n        return (int)mp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        \\n    ArrayDeque<Integer> dq = new ArrayDeque<Integer>();\\n        long prefix[] = new long[nums.length];\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n          prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        dq.push(-1);\\n        long product = 0;\\n        long mp = 0;\\n        long M = (int)1e9 + 7;\\n        \\n        \\n        \\n        for(int i= 0; i<=nums.length;i++)\\n        {\\n           while((dq.peek()!=-1) && \\n               nums[dq.peek()] > (i== nums.length? 0: nums[i]))\\n           {\\n               int pi = dq.pop();\\n               long sum = 0;\\n               if(dq.peek() == -1)\\n               {\\n                 sum = prefix[i-1];\\n               }\\n               else\\n               {\\n               sum = prefix[i-1]-prefix[dq.peek()];\\n               }\\n               \\n               product = sum*nums[pi];\\n              \\n               \\n               mp = Math.max(mp,product);\\n           }\\n           dq.push(i);\\n        }\\n        \\n        mp = mp%M;\\n        \\n        return (int)mp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200079,
                "title": "swift-solution",
                "content": "Swift solution\\nAt first, prepare three arrays:\\n1. for i in 0..<c : leftBounds[i] = min index where nums[i] is min value in nums[left...i]\\n2. for i in 0..<c : rightBounds[i] = max index where nums[i] is min value in nums[i...right]\\n3. for i in 0...c : preSum[i] = sum of nums[0..<i]\\n\\nuse stacks of indexes to find left and right bounds.\\nThen find result using these three arrays\\n```\\nclass Solution {\\n    func maxSumMinProduct(_ nums: [Int]) -> Int {\\n        let c = nums.count\\n        var leftBounds = [Int](repeating: 0, count: c), rightBounds = leftBounds, preSum = [Int](repeating: 0, count: c + 1), leftStack = [Int](), rightStack = leftStack, result = 0\\n        for i in 0..<c {\\n            // leftBounds\\n            while !leftStack.isEmpty && nums[leftStack.last!] >= nums[i] { leftStack.removeLast() }\\n            leftBounds[i] = leftStack.isEmpty ? 0 : (leftStack.last! + 1)\\n            leftStack.append(i)\\n            // rightBounds\\n            while !rightStack.isEmpty && nums[rightStack.last!] >= nums[c - 1 - i] { rightStack.removeLast() }\\n            rightBounds[c - 1 - i] = rightStack.isEmpty ? (c - 1) : (rightStack.last! - 1)\\n            rightStack.append(c - 1 - i)\\n            // preSum\\n            preSum[i + 1] = preSum[i] + nums[i]\\n        }\\n        for i in 0..<c {\\n            result = max(result, (preSum[rightBounds[i] + 1] - preSum[leftBounds[i]]) * nums[i])\\n        }\\n        return result % 1_000_000_007\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSumMinProduct(_ nums: [Int]) -> Int {\\n        let c = nums.count\\n        var leftBounds = [Int](repeating: 0, count: c), rightBounds = leftBounds, preSum = [Int](repeating: 0, count: c + 1), leftStack = [Int](), rightStack = leftStack, result = 0\\n        for i in 0..<c {\\n            // leftBounds\\n            while !leftStack.isEmpty && nums[leftStack.last!] >= nums[i] { leftStack.removeLast() }\\n            leftBounds[i] = leftStack.isEmpty ? 0 : (leftStack.last! + 1)\\n            leftStack.append(i)\\n            // rightBounds\\n            while !rightStack.isEmpty && nums[rightStack.last!] >= nums[c - 1 - i] { rightStack.removeLast() }\\n            rightBounds[c - 1 - i] = rightStack.isEmpty ? (c - 1) : (rightStack.last! - 1)\\n            rightStack.append(c - 1 - i)\\n            // preSum\\n            preSum[i + 1] = preSum[i] + nums[i]\\n        }\\n        for i in 0..<c {\\n            result = max(result, (preSum[rightBounds[i] + 1] - preSum[leftBounds[i]]) * nums[i])\\n        }\\n        return result % 1_000_000_007\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199840,
                "title": "c-using-stack-100-similar-to-largest-rectangle-in-histogram",
                "content": "```\\npublic class Solution {\\n    public int MaxSumMinProduct(int[] nums) {\\n        \\n        //*** Method 1 : Using Monotonic Increasing Stack ***//\\n        var MOD = 1000000007;\\n        long res = 0;       \\n        int n = nums.Length;\\n        var st = new Stack<int>();\\n        var preSum = new long[n + 1];\\n        for (int i = 0; i < nums.Length; ++i)\\n           preSum[i + 1] = preSum[i] + nums[i];\\n        \\n        for (int i = 0; i <= n; i++) {\\n            while (st.Count > 0 && (i == n || nums[st.Peek()] > nums[i])) {\\n                int j = st.Pop();                \\n                res = Math.Max(res, nums[j] * (preSum[i] - preSum[st.Count == 0 ? 0 : st.Peek() + 1]));\\n            }\\n            st.Push(i);\\n        }\\n        return (int)(res % MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxSumMinProduct(int[] nums) {\\n        \\n        //*** Method 1 : Using Monotonic Increasing Stack ***//\\n        var MOD = 1000000007;\\n        long res = 0;       \\n        int n = nums.Length;\\n        var st = new Stack<int>();\\n        var preSum = new long[n + 1];\\n        for (int i = 0; i < nums.Length; ++i)\\n           preSum[i + 1] = preSum[i] + nums[i];\\n        \\n        for (int i = 0; i <= n; i++) {\\n            while (st.Count > 0 && (i == n || nums[st.Peek()] > nums[i])) {\\n                int j = st.Pop();                \\n                res = Math.Max(res, nums[j] * (preSum[i] - preSum[st.Count == 0 ? 0 : st.Peek() + 1]));\\n            }\\n            st.Push(i);\\n        }\\n        return (int)(res % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199635,
                "title": "java-simple-and-easy-understood",
                "content": "class Solution {\\n\\tlong MOD=1_000_000_007;\\n\\t   \\n\\n    public int maxSumMinProduct(int[] nums) {\\n\\t   long ret = 0;\\n\\t   \\n\\t   for (int i = 0; i < nums.length; i++) {\\n\\t\\t   \\n\\t\\t   if (i == 0 || nums[i] !=nums[i-1]) {\\n\\t\\t\\t   long temp = getSum(nums, i);\\n\\t\\t\\t   \\n\\t\\t\\t   long t2 = (temp * nums[i]);\\n\\t\\t\\t   if (t2 > ret) {\\n\\t\\t\\t\\t   ret = t2;\\n\\t\\t\\t   }\\t\\t\\t   \\n\\t\\t   }\\n\\n\\t   }\\n        ret = ret%MOD;\\n\\t   return (int)ret;\\n        \\n    }\\n   \\n   \\tlong getSum(int[] nums, int cur) {\\n   \\t\\tlong ret = nums[cur];\\n   \\t\\t\\n   \\t\\tlong left = 0;\\n   \\t\\tint val = nums[cur];\\n   \\t\\t\\n   \\t\\tfor (int i = cur-1; i>= 0 && nums[i]>=val;i--) {\\n   \\t\\t\\tleft += nums[i];\\n   \\t\\t}\\n   \\t\\t\\n        \\n   \\t\\tret += left;\\n        ret = ret;\\n   \\t\\t\\n   \\t\\tlong right = 0;\\n   \\t\\tfor (int i = cur+1; i < nums.length && nums[i]>=val; i++)  {\\n            right += nums[i];\\n        }\\n   \\t\\t\\t\\n   \\t\\t\\n   \\t\\tret += right;\\n   \\t\\treturn ret;\\n   \\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tlong MOD=1_000_000_007;\\n\\t   \\n\\n    public int maxSumMinProduct(int[] nums) {\\n\\t   long ret = 0;\\n\\t   \\n\\t   for (int i = 0; i < nums.length; i++) {\\n\\t\\t   \\n\\t\\t   if (i == 0 || nums[i] !=nums[i-1]) {\\n\\t\\t\\t   long temp = getSum(nums, i);\\n\\t\\t\\t   \\n\\t\\t\\t   long t2 = (temp * nums[i]);\\n\\t\\t\\t   if (t2 > ret) {\\n\\t\\t\\t\\t   ret = t2;\\n\\t\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1199538,
                "title": "stack-with-100-faster",
                "content": "class Solution {\\npublic:\\n    int mod=1000000007;\\n    int maxSumMinProduct(vector<int>& nums) {\\n                    int n=nums.size();\\n                  stack<int>s1,s2;\\n                  vector<long long>prefix(n),suffix(n);\\n                  for(int i=0;i<n;i++){\\n                       while(!s1.empty()&&nums[s1.top()]>=nums[i])\\n                           s1.pop();\\n                      if(!s1.empty())\\n                          prefix[i]=s1.top();\\n                      else\\n                          prefix[i]=-1;\\n                      s1.push(i);\\n                  }\\n                  for(int i=n-1;i>=0;i--){\\n                       while(!s2.empty()&&nums[s2.top()]>=nums[i])\\n                           s2.pop();\\n                      if(!s2.empty())\\n                          suffix[i]=s2.top();\\n                      else\\n                          suffix[i]=n;\\n                      s2.push(i);\\n                  }\\n                  vector<long long int>prefix1(n);\\n                  prefix1[0]=nums[0];\\n                  for(int i=1;i<n;i++){\\n                      long long int a=(prefix1[i-1]+nums[i]);\\n                      prefix1[i]=a;\\n                    //  cout<<prefix\\n                  }\\n                 long long int max1=LONG_MIN;\\n                 for(int i=0;i<n;i++){\\n                      long long int a;\\n                      if(prefix[i]!=-1)\\n                          a=(prefix1[suffix[i]-1]-prefix1[prefix[i]]);\\n                      else\\n                          a=(prefix1[suffix[i]-1]);\\n                      long long int b=((nums[i])*(a));\\n                      max1=max(max1,b);\\n                    //  cout<<suffix[i]<<\" \"<<prefix[i]<<\" \"<<b<<\" \"<<a<<endl;\\n                 }\\n         return max1%mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mod=1000000007;\\n    int maxSumMinProduct(vector<int>& nums) {\\n                    int n=nums.size();\\n                  stack<int>s1,s2;\\n                  vector<long long>prefix(n),suffix(n);\\n                  for(int i=0;i<n;i++){\\n                       while(!s1.empty()&&nums[s1.top()]>=nums[i])\\n                           s1.pop();\\n                      if(!s1.empty())\\n                          prefix[i]=s1.top();\\n                      else\\n                          prefix[i]=-1;\\n                      s1.push(i);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 1199368,
                "title": "cpp-100-faster-stack-o-n",
                "content": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();long rt[n+2],lf[n+2];\\n        long preSum[n+2];preSum[0]=0;\\n        // preSum \\n        for(int i=1;i<=n;i++)\\n            preSum[i]=preSum[i-1]+nums[i-1];\\n        stack<int>st;\\n        // first leftmost index where element are less than current\\n        for(int i=1;i<=n;i++)\\n        {\\n            while(st.size()&&nums[st.top()-1]>=nums[i-1])\\n                st.pop();\\n            if(st.size()==0)lf[i]=0;\\n            else lf[i]=st.top();\\n            st.push(i);\\n        }\\n        while(st.size())\\n            st.pop();\\n        //rightMost index where element are not less than current\\n        for(int i=n;i>=1;i--)\\n        {\\n            while(st.size()&&nums[st.top()-1]>=nums[i-1])\\n                st.pop();\\n            if(st.size()==0)rt[i]=n;\\n            else rt[i]=st.top()-1;\\n            st.push(i);\\n        }\\n        long ans=0;\\n        for(int i=1;i<=n;i++)\\n            {\\n          long tmp=(nums[i-1]*(preSum[rt[i]]-preSum[lf[i]]));\\n           ans=max(ans,tmp);\\n        }\\n        int z=ans%mod;\\n        return z;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();long rt[n+2],lf[n+2];\\n        long preSum[n+2];preSum[0]=0;\\n        // preSum \\n        for(int i=1;i<=n;i++)\\n            preSum[i]=preSum[i-1]+nums[i-1];\\n        stack<int>st;\\n        // first leftmost index where element are less than current\\n        for(int i=1;i<=n;i++)\\n        {\\n            while(st.size()&&nums[st.top()-1]>=nums[i-1])\\n                st.pop();\\n            if(st.size()==0)lf[i]=0;\\n            else lf[i]=st.top();\\n            st.push(i);\\n        }\\n        while(st.size())\\n            st.pop();\\n        //rightMost index where element are not less than current\\n        for(int i=n;i>=1;i--)\\n        {\\n            while(st.size()&&nums[st.top()-1]>=nums[i-1])\\n                st.pop();\\n            if(st.size()==0)rt[i]=n;\\n            else rt[i]=st.top()-1;\\n            st.push(i);\\n        }\\n        long ans=0;\\n        for(int i=1;i<=n;i++)\\n            {\\n          long tmp=(nums[i-1]*(preSum[rt[i]]-preSum[lf[i]]));\\n           ans=max(ans,tmp);\\n        }\\n        int z=ans%mod;\\n        return z;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199244,
                "title": "c-o-n-solution-nearest-smaller-element-prefix-sum-explained",
                "content": "class Solution {\\n\\npublic:\\n    const int mod = 1e9 + 7;\\n    \\n    // inutition: for a given i we can include those elements in the subarray which are greater than or equal to nums[i] , in this case the\\n\\t//resuling min array product will be maximum, hence we can compute this for all i\\'s , now to compute the \\n\\t//given range (l, r) we need to find the nearest smallest element to the left and nearest smallest element to the right\\n\\t//which can be done using stack , and we can precomput this for all the elements using stack and array, rest is how we can get the sum in the range \\n\\t//using prefix sum technique (do make sure indexing is 1-based else it causes a lot of problems).\\n    \\n    \\n    // steps to get it done: \\n    // 1) understand finding nearest element to the left\\n    // 2) understand finding nearest element to the right\\n    // 3) finding sum of the range using prefix sum technique\\n    int maxSumMinProduct(vector<int> &nums)\\n    {\\n        int n = (int)nums.size();\\n        \\n        vector<long long int> prefix(n + 1, 0); // for computing the prefix sum\\n        vector<int> left(n, 0);// for computing nearest smaller element to the left\\n        vector<int> right(n, 0);// for computing nearest smaller element to the right\\n        \\n        stack<int> s;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            while(s.size() > 0 && nums[s.top()] >= nums[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.size() > 0)\\n            {\\n                left[i] = s.top();\\n            }\\n         // if at the moment stack gets empty it means there is no element smaller left to it\\n        // so we can say element at -1 th position is smaller than ith element\\n            else\\n                left[i] = -1;\\n            s.push(i);\\n        }\\n        \\n        while(s.size() > 0)\\n            s.pop();\\n        for(int i = n - 1; i >= 0 ;i--)\\n        {\\n            while(s.size() > 0 && nums[s.top()] >= nums[i])\\n            {\\n                s.pop();\\n            }\\n            \\n            if(s.size() > 0)\\n            {\\n               right[i] = s.top();\\n            }\\n            // if at the moment stack gets empty it means there is no element smaller right to it\\n            // so we can say element at nth position is smaller that ith element\\n            else\\n                right[i] = n;\\n            s.push(i);\\n        }\\n        \\n   \\n        for(int i = 1; i <= n; i++)\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        \\n        long long int maxSum = 0, currSum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            currSum = nums[i] * 1LL * (prefix[right[i]] - prefix[left[i] + 1]);\\n            maxSum = max(maxSum, currSum);\\n        }\\n        return maxSum % mod;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n    const int mod = 1e9 + 7;\\n    \\n    // inutition: for a given i we can include those elements in the subarray which are greater than or equal to nums[i] , in this case the\\n\\t//resuling min array product will be maximum, hence we can compute this for all i\\'s , now to compute the \\n\\t//given range (l, r) we need to find the nearest smallest element to the left and nearest smallest element to the right\\n\\t//which can be done using stack , and we can precomput this for all the elements using stack and array, rest is how we can get the sum in the range \\n\\t//using prefix sum technique (do make sure indexing is 1-based else it causes a lot of problems).\\n    \\n    \\n    // steps to get it done: \\n    // 1) understand finding nearest element to the left\\n    // 2) understand finding nearest element to the right\\n    // 3) finding sum of the range using prefix sum technique\\n    int maxSumMinProduct(vector<int> &nums)\\n    {\\n        int n = (int)nums.size();\\n        \\n        vector<long long int> prefix(n + 1, 0); // for computing the prefix sum\\n        vector<int> left(n, 0);// for computing nearest smaller element to the left\\n        vector<int> right(n, 0);// for computing nearest smaller element to the right\\n        \\n        stack<int> s;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            while(s.size() > 0 && nums[s.top()] >= nums[i])\\n            {\\n                s.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1199242,
                "title": "java-simple-stack-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        Stack<Long> st  = new Stack<Long>();\\n        Stack<Long> cnt = new Stack<Long>();\\n        long max = 0,c = 0;\\n        final int MOD = 1_000_000_007;\\n        \\n        for(int i=0;i<nums.length;++i){\\n            c = nums[i];\\n            while(!st.isEmpty() && st.peek() >= nums[i]){\\n                c += cnt.pop();\\n                max = Math.max(max,(c - nums[i]) * st.pop());\\n            }\\n            \\n            st.push((long)nums[i]);\\n            cnt.push(c);\\n            max = Math.max(max,c * nums[i]);\\n        }\\n        \\n        c = 0;\\n        while(!st.isEmpty()){\\n            c += cnt.pop();\\n            max = Math.max(max,c * st.pop());\\n        }\\n        \\n        return (int)(max % MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        Stack<Long> st  = new Stack<Long>();\\n        Stack<Long> cnt = new Stack<Long>();\\n        long max = 0,c = 0;\\n        final int MOD = 1_000_000_007;\\n        \\n        for(int i=0;i<nums.length;++i){\\n            c = nums[i];\\n            while(!st.isEmpty() && st.peek() >= nums[i]){\\n                c += cnt.pop();\\n                max = Math.max(max,(c - nums[i]) * st.pop());\\n            }\\n            \\n            st.push((long)nums[i]);\\n            cnt.push(c);\\n            max = Math.max(max,c * nums[i]);\\n        }\\n        \\n        c = 0;\\n        while(!st.isEmpty()){\\n            c += cnt.pop();\\n            max = Math.max(max,c * st.pop());\\n        }\\n        \\n        return (int)(max % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199232,
                "title": "java-o-n-using-largest-area-in-histogram-easy-to-understand",
                "content": "**Please upvote if it helps you.**\\nSolution is commented to understand it better.\\n\\nThis problem can be solved with **Largest rectangle in Histogram** concept which can be further solved with concept of *Nearest Smaller Index to Left*  and *Nearest Smaller Index to Right*.\\n\\n**Nearest Smaller Index to Left :**-  Take array nsil of length n where n is length of nums. Take empty Stack of Integer. For every element in nums \\nwhile  stack is not  empty and the top element of stack is greator than or equal to current num element , pop the stack.\\nassign nsil[i] value as -1 if stack is Empty otherwise assign the index of current num.\\nAfter this nsil will be filled with nearest smaller index to left for every element in nums.\\nfor nums  [3,1,5,6,4,2]\\nngil ----> [-1, -1, 1, 2, 1, 1] \\n\\n**Nearest Smaller Index to Right :**-  Take array nsir of length n where n is length of nums. Take empty Stack of Integer. For every element in nums but in decreasing order of index from n-1 to 0.\\nwhile  stack is not  empty and the top element of stack is greator than or equal to current num element , pop the stack.\\nassign nsir[i] value as n if stack is Empty otherwise assign the index of current num.\\nAfter this nsir will be filled with nearest smaller index to right for every element in nums.\\nfor nums [3,1,5,6,4,2] \\nngir ---->[1, 6, 4, 4, 5, 6] \\n-------------------------------------------------------------\\n\\ntake sum[n+1]\\nsum array is taken as long to avoid integer overflow.\\nsum array is filled in loop used for nsir to avoid unecessary loop traversing again.\\nset sum[n] = 0 this case to be used if nsil[i] == -1\\nfor nums [3,1,5,6,4,2]\\nsum ---->[3, 4, 9, 15, 19, 21, 0]\\n\\n\\nfor every element in nums calculate \\n**(current element in nums) * (sum(nearest smaller index right - 1 ) - sum(nearest smaller index light))**\\ncompare it with previous ans\\n\\nreturn ans with mod of 1000000007\\n\\nNote -:\\nif nsir[i] >= n it means no element in right is smaller than nums[i] so we have to take sum[n-1].\\nif nsil[i] == -1 it means no element in left is smaller than nums[i] so we have to take sum[n] which stores 0.\\nuse (int)(ans%mod) instead of (int)ans%mod      ----> (wasted 40 min. because of this)\\n\\n\\nclass Solution {\\n    \\n    int mod  = 1000000007;\\n    \\n    public int maxSumMinProduct(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int n = nums.length;        \\n        if(n==1)\\n            return nums[n]%mod;        \\n        int[] nsil = new int[n]; //  nsil -  stores nearest smaller index left\\n        int[] nsir = new int[n];  // nsir -  stores nearest smaller index right\\n        long[] sum = new long[n+1];  // stores cumulative sum of nums\\n        \\n        // calculating cumulative sum of nums\\n        // with the help of stack filling nsil\\n        for(int i =0 ; i < n; i++)\\n        {            \\n            sum[i] = i==0 ? nums[i] : sum[i-1] + nums[i];  // cumulative sum of nums\\n               while(!st.isEmpty() && nums[st.peek()] >= nums[i])\\n                {\\n                    st.pop();\\n                }\\n                nsil[i] = st.isEmpty() ? -1 : st.peek();\\n                st.push(i);            \\n        }\\n        sum[n] = 0;        // used in case if nsil[i] == -1         \\n\\t\\t\\n        st  = new Stack<>();  // reinitialling stack for filling nsir        \\n        // with the help of stack filling nsil\\n        for(int i =n-1 ; i >= 0; i--)\\n        {            \\n                while(!st.isEmpty() && nums[st.peek()] >= nums[i])\\n                {\\n                    st.pop();\\n                }\\n                nsir[i] = st.isEmpty() ? n : st.peek();\\n                st.push(i);           \\n        }        \\n               \\n        long ans =0;              // taken as long to avoid integer overflow        \\n        //for every index supposing it as storing minimum number and using nsil and nsir to find the left and right index \\n        for(int i=0; i < n ; i++)\\n        {\\n            long temp = (nums[i] * (sum[(nsir[i] >= n ? n-1 : nsir[i]-1)] - sum[nsil[i] == -1 ? n :nsil[i] ]));\\n            ans = Math.max(ans, temp);\\n        }        \\n        return (int)(ans%mod);  // returning final ans as mod of 1000000007\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    \\n    int mod  = 1000000007;\\n    \\n    public int maxSumMinProduct(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int n = nums.length;        \\n        if(n==1)\\n            return nums[n]%mod;        \\n        int[] nsil = new int[n]; //  nsil -  stores nearest smaller index left\\n        int[] nsir = new int[n];  // nsir -  stores nearest smaller index right\\n        long[] sum = new long[n+1];  // stores cumulative sum of nums\\n        \\n        // calculating cumulative sum of nums\\n        // with the help of stack filling nsil\\n        for(int i =0 ; i < n; i++)\\n        {            \\n            sum[i] = i==0 ? nums[i] : sum[i-1] + nums[i];  // cumulative sum of nums\\n               while(!st.isEmpty() && nums[st.peek()] >= nums[i])\\n                {\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1199112,
                "title": "javascript-union-find-600ms",
                "content": "```\\nconst find = (x) => {\\n    return parent[x] == x ? x : parent[x] = find(parent[x]);\\n};\\n\\nconst union = (x, y) => {\\n    let px = find(x);\\n    let py = find(y);\\n    parent[px] = py;\\n    sum[py] += sum[px];\\n};\\n\\nconst BMOD = BigInt(1e9 + 7);\\nlet parent, sum;\\nconst maxSumMinProduct = (a) => {\\n    let n = a.length;\\n    let pos = Array(n).fill(0); // index array\\n    let visit = Array(n).fill(0); // boolean value check if visited, has child\\n    parent = Array(n).fill(0); // parent array save/update parent based on index\\n    sum = Array(n).fill(0n); // accumlated sum array based on index\\n    for (let i = 0; i < n; i++) {\\n        parent[i] = i;\\n        sum[i] = BigInt(a[i]);\\n        pos[i] = i;\\n    }\\n    pos.sort((x, y) => a[y] - a[x]); // sort index array by array value decreasing\\n    let res = 0n;\\n    for (const i of pos) {\\n        if (i - 1 >= 0 && visit[i - 1]) union(i - 1, i);\\n        if (i + 1 < n && visit[i + 1]) union(i, i + 1);\\n        visit[i] = 1;\\n        let tmp = BigInt(a[i]) * sum[find(i)]; // min product\\n        if (tmp > res) res = tmp;\\n    }\\n    return Number(res % BMOD);\\n};\\n```\\nAnother version use class way\\n```\\nfunction DJSet(a, n) {\\n    let parent = Array(n).fill(0);\\n    let sum = Array(n).fill(0n);\\n    for (let i = 0; i < n; i++) parent[i] = i, sum[i] = BigInt(a[i]);\\n    return { find, union, sm }\\n    function find(x) {\\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return;\\n        parent[x] = y;\\n        sum[y] += sum[x];\\n    }\\n    function sm() {\\n        return sum;\\n    }\\n}\\n\\nconst BMOD = BigInt(1e9 + 7);\\nconst maxSumMinProduct = (a) => {\\n    let n = a.length;\\n    let ds = new DJSet(a, n);\\n    let pos = Array(n).fill(0);\\n    let visit = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) pos[i] = i;\\n    pos.sort((x, y) => a[y] - a[x]);\\n    let res = 0n;\\n    for (const p of pos) {\\n        visit[p] = 1;\\n        if (p - 1 >= 0 && visit[p - 1]) ds.union(p, p - 1);\\n        if (p + 1 < n && visit[p + 1]) ds.union(p, p + 1);\\n        let tmp = BigInt(a[p]) * ds.sm()[ds.find(p)];\\n        if (tmp > res) res = tmp;\\n    }\\n    return Number(res % BMOD);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nconst find = (x) => {\\n    return parent[x] == x ? x : parent[x] = find(parent[x]);\\n};\\n\\nconst union = (x, y) => {\\n    let px = find(x);\\n    let py = find(y);\\n    parent[px] = py;\\n    sum[py] += sum[px];\\n};\\n\\nconst BMOD = BigInt(1e9 + 7);\\nlet parent, sum;\\nconst maxSumMinProduct = (a) => {\\n    let n = a.length;\\n    let pos = Array(n).fill(0); // index array\\n    let visit = Array(n).fill(0); // boolean value check if visited, has child\\n    parent = Array(n).fill(0); // parent array save/update parent based on index\\n    sum = Array(n).fill(0n); // accumlated sum array based on index\\n    for (let i = 0; i < n; i++) {\\n        parent[i] = i;\\n        sum[i] = BigInt(a[i]);\\n        pos[i] = i;\\n    }\\n    pos.sort((x, y) => a[y] - a[x]); // sort index array by array value decreasing\\n    let res = 0n;\\n    for (const i of pos) {\\n        if (i - 1 >= 0 && visit[i - 1]) union(i - 1, i);\\n        if (i + 1 < n && visit[i + 1]) union(i, i + 1);\\n        visit[i] = 1;\\n        let tmp = BigInt(a[i]) * sum[find(i)]; // min product\\n        if (tmp > res) res = tmp;\\n    }\\n    return Number(res % BMOD);\\n};\\n```\n```\\nfunction DJSet(a, n) {\\n    let parent = Array(n).fill(0);\\n    let sum = Array(n).fill(0n);\\n    for (let i = 0; i < n; i++) parent[i] = i, sum[i] = BigInt(a[i]);\\n    return { find, union, sm }\\n    function find(x) {\\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return;\\n        parent[x] = y;\\n        sum[y] += sum[x];\\n    }\\n    function sm() {\\n        return sum;\\n    }\\n}\\n\\nconst BMOD = BigInt(1e9 + 7);\\nconst maxSumMinProduct = (a) => {\\n    let n = a.length;\\n    let ds = new DJSet(a, n);\\n    let pos = Array(n).fill(0);\\n    let visit = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) pos[i] = i;\\n    pos.sort((x, y) => a[y] - a[x]);\\n    let res = 0n;\\n    for (const p of pos) {\\n        visit[p] = 1;\\n        if (p - 1 >= 0 && visit[p - 1]) ds.union(p, p - 1);\\n        if (p + 1 < n && visit[p + 1]) ds.union(p, p + 1);\\n        let tmp = BigInt(a[p]) * ds.sm()[ds.find(p)];\\n        if (tmp > res) res = tmp;\\n    }\\n    return Number(res % BMOD);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198977,
                "title": "python-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef maxSumMinProduct(self, nums: List[int]) -> int:\\n\\t\\t\\tprefixSum = [0]\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tprefixSum.append(prefixSum[-1] + num)\\n\\t\\t\\tstack = [-1]\\n\\t\\t\\tfor i, num in enumerate(nums + [0]):\\n\\t\\t\\t\\twhile len(stack) > 1 and num < nums[stack[-1]]:\\n\\t\\t\\t\\t\\tlast = stack.pop()\\n\\t\\t\\t\\t\\tres = max(res, nums[last] * (prefixSum[i] - prefixSum[stack[-1] + 1]))\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\treturn res % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxSumMinProduct(self, nums: List[int]) -> int:\\n\\t\\t\\tprefixSum = [0]\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tprefixSum.append(prefixSum[-1] + num)\\n\\t\\t\\tstack = [-1]\\n\\t\\t\\tfor i, num in enumerate(nums + [0]):\\n\\t\\t\\t\\twhile len(stack) > 1 and num < nums[stack[-1]]:\\n\\t\\t\\t\\t\\tlast = stack.pop()\\n\\t\\t\\t\\t\\tres = max(res, nums[last] * (prefixSum[i] - prefixSum[stack[-1] + 1]))\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\treturn res % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 1198947,
                "title": "java-prefix-sum-mono-stack-o-n-beat-100-21-lines",
                "content": "\\n\\n```\\n    // Mono Stack\\n    // Time: O(N)\\n    // Rank: 100%\\n    public int maxSumMinProduct(int[] nums) {\\n        long ans = 0;\\n        int n = nums.length, top = -1;\\n        int[][] st = new int[n][];\\n        long[] prefix = new long[n + 1];\\n        for (int i = 0; i < n; i ++) {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n        for (int i = 0, start = 0; i < n; i ++) {\\n            for (start = i; top >= 0 && st[top][1] > nums[i]; ) {\\n                int[] less = st[top --];\\n                int index = less[0], val = less[1];\\n                ans = Math.max(ans, (prefix[i] - prefix[index]) * val);\\n                start = index;\\n            }\\n            st[++ top] = new int[] { start, nums[i] };\\n        }\\n        for (int i = 0; i <= top; i ++) {\\n            int start = st[i][0], val = st[i][1];\\n            ans = Math.max(ans, (prefix[n] - prefix[start]) * val);\\n        }\\n        return (int)(ans % 1_000_000_007);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // Mono Stack\\n    // Time: O(N)\\n    // Rank: 100%\\n    public int maxSumMinProduct(int[] nums) {\\n        long ans = 0;\\n        int n = nums.length, top = -1;\\n        int[][] st = new int[n][];\\n        long[] prefix = new long[n + 1];\\n        for (int i = 0; i < n; i ++) {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n        for (int i = 0, start = 0; i < n; i ++) {\\n            for (start = i; top >= 0 && st[top][1] > nums[i]; ) {\\n                int[] less = st[top --];\\n                int index = less[0], val = less[1];\\n                ans = Math.max(ans, (prefix[i] - prefix[index]) * val);\\n                start = index;\\n            }\\n            st[++ top] = new int[] { start, nums[i] };\\n        }\\n        for (int i = 0; i <= top; i ++) {\\n            int start = st[i][0], val = st[i][1];\\n            ans = Math.max(ans, (prefix[n] - prefix[start]) * val);\\n        }\\n        return (int)(ans % 1_000_000_007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198880,
                "title": "java-o-n-without-using-stack",
                "content": "1. For each nums[i], find its left num `leftLower[i]` that\\'s smaller than nums[i], \\n2. Find its right num `rightLower[i]` that\\'s smaller than nums[i]\\n3. Then the min product with nums[i] as the min value, is nums[i] * sum(leftLower[i]+1, ..., rightLower[i] - 1).\\n4. Iterate through the array, and get the min product for each nums[i] as the min value. \\n```java\\npublic int maxSumMinProduct(int[] nums) {\\n\\tint[] leftLower = new int[nums.length];\\n\\tleftLower[0] = -1;\\n\\tfor (int i = 1; i < nums.length; ++i) {\\n\\t\\tint j = i - 1;\\n\\t\\twhile (j >= 0 && nums[j] >= nums[i]) {\\n\\t\\t\\tj = leftLower[j];\\n\\t\\t}\\n\\t\\tleftLower[i] = j;\\n\\t}\\n\\tint[] rightLower = new int[nums.length];\\n\\trightLower[nums.length - 1] = nums.length;\\n\\tfor (int i = nums.length - 2; i >= 0; --i) {\\n\\t\\tint j = i + 1;\\n\\t\\twhile (j < nums.length && nums[j] >= nums[i]) {\\n\\t\\t\\tj = rightLower[j];\\n\\t\\t}\\n\\t\\trightLower[i] = j;\\n\\t}\\n\\n\\tlong[] presums = new long[nums.length + 1];\\n\\tfor (int i = 1; i <= nums.length; ++i) {\\n\\t\\tpresums[i] = presums[i - 1] + nums[i - 1];\\n\\t}\\n\\n\\tlong ans = 0;\\n\\tfor (int i = 0; i < nums.length; ++i) {\\n\\t\\tlong sum = presums[rightLower[i]] - presums[leftLower[i] + 1];\\n\\t\\tans = Math.max(ans, nums[i] * sum);\\n\\t}\\n\\treturn (int)(ans % 1000_000_007);\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int maxSumMinProduct(int[] nums) {\\n\\tint[] leftLower = new int[nums.length];\\n\\tleftLower[0] = -1;\\n\\tfor (int i = 1; i < nums.length; ++i) {\\n\\t\\tint j = i - 1;\\n\\t\\twhile (j >= 0 && nums[j] >= nums[i]) {\\n\\t\\t\\tj = leftLower[j];\\n\\t\\t}\\n\\t\\tleftLower[i] = j;\\n\\t}\\n\\tint[] rightLower = new int[nums.length];\\n\\trightLower[nums.length - 1] = nums.length;\\n\\tfor (int i = nums.length - 2; i >= 0; --i) {\\n\\t\\tint j = i + 1;\\n\\t\\twhile (j < nums.length && nums[j] >= nums[i]) {\\n\\t\\t\\tj = rightLower[j];\\n\\t\\t}\\n\\t\\trightLower[i] = j;\\n\\t}\\n\\n\\tlong[] presums = new long[nums.length + 1];\\n\\tfor (int i = 1; i <= nums.length; ++i) {\\n\\t\\tpresums[i] = presums[i - 1] + nums[i - 1];\\n\\t}\\n\\n\\tlong ans = 0;\\n\\tfor (int i = 0; i < nums.length; ++i) {\\n\\t\\tlong sum = presums[rightLower[i]] - presums[leftLower[i] + 1];\\n\\t\\tans = Math.max(ans, nums[i] * sum);\\n\\t}\\n\\treturn (int)(ans % 1000_000_007);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198861,
                "title": "javascript-two-pointer-check-at-each-index-bigint",
                "content": "Notes:\\n- when compute the product, do NOT mod, I failed at here for a long time:\\n\\t```\\n\\t// WRONG !!!\\n\\tprod = (sum * nums[i] ) % mod\\n\\t```\\n- I see many stack solution, it might be better and time saving than my solution, but my solution with two pointer to check at each index, is a pretty easy and direct solution. \\n- But also you can use **stack to pre-procossing range index**\\n\\n\\n```js\\nvar maxSumMinProduct = function(nums) {\\n    var mod = BigInt(1000000007);\\n    var n = nums.length;\\n    var max = 0n;\\n    if(n === 1)\\n    {\\n        return (nums[0]*nums[0]) % mod;\\n    }\\n    var sum = new Array(n+1).fill(0);\\n    for(var i = 1; i<=n; i++)\\n    {\\n        sum[i] = sum[i-1] + nums[i-1];\\n    }\\n    for(var i = 0;i<n; i++)\\n    {\\n        var l = i-1;\\n        var r = i+1;\\n        while(l>=0 && nums[l]>=nums[i])\\n        {\\n            l--;\\n        }\\n        l++;\\n        while(r<n && nums[r]>=nums[i])\\n        {\\n            r++;\\n        }\\n        r--;\\n        var s = BigInt(sum[r+1] - sum[l]);\\n        var factor = BigInt(nums[i]);\\n        var prod = s*factor;\\n        if(prod > max)\\n        {\\n            max = prod;\\n        }\\n    }\\n    return Number(max % mod); \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n\\t// WRONG !!!\\n\\tprod = (sum * nums[i] ) % mod\\n\\t```\n```js\\nvar maxSumMinProduct = function(nums) {\\n    var mod = BigInt(1000000007);\\n    var n = nums.length;\\n    var max = 0n;\\n    if(n === 1)\\n    {\\n        return (nums[0]*nums[0]) % mod;\\n    }\\n    var sum = new Array(n+1).fill(0);\\n    for(var i = 1; i<=n; i++)\\n    {\\n        sum[i] = sum[i-1] + nums[i-1];\\n    }\\n    for(var i = 0;i<n; i++)\\n    {\\n        var l = i-1;\\n        var r = i+1;\\n        while(l>=0 && nums[l]>=nums[i])\\n        {\\n            l--;\\n        }\\n        l++;\\n        while(r<n && nums[r]>=nums[i])\\n        {\\n            r++;\\n        }\\n        r--;\\n        var s = BigInt(sum[r+1] - sum[l]);\\n        var factor = BigInt(nums[i]);\\n        var prod = s*factor;\\n        if(prod > max)\\n        {\\n            max = prod;\\n        }\\n    }\\n    return Number(max % mod); \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198802,
                "title": "stack-prefix-sum-technique",
                "content": "**Approach** : \\n1. For every element at index **i**, find the next smaller element\\'s index and previous smaller element\\'s index. This will  give us an idea about the **size of the subarray in which ith element is minimum**. \\n2. Now since we know the boundary of the subarray in which ith element in minimum  , **we can query for the sum of this subarray** and **multiply it with** ith **element** and track the maximum answer.   \\n3. To query the subarray sum, we will take a prefix sum and then answer the query in O(1). \\n\\n**Time Complexity**:\\n* Prefix sum pre-calculation O(N)\\n* Finding next smaller element for every element : O(N) \\n* Finding previous smaller element for every element : O(N) \\n* Calculating the answer , considering every ith element as minimum : O(N)\\n**Overall : O(N)**\\n\\n**Space Complexity**: O(N)\\n\\n**Note** : Take care of overflows  , use long long int wherever necessary. \\n\\n##### Code \\n```\\n#define cmax(x,y)         (x >= y ? x : y)\\n\\nclass Solution {\\npublic:\\n\\tvector<int> nextSmallerElement(vector<int>& arr, int n) {\\n\\t\\tvector<int> ans(n);\\n\\t\\tstack < int > stk;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (!stk.empty() && arr[stk.top()] > arr[i]) {\\n\\t\\t\\t\\tans[stk.top()] = i;\\n\\t\\t\\t\\tstk.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstk.push(i);\\n\\t\\t}\\n\\t\\twhile (!stk.empty()) {\\n\\t\\t\\tans[stk.top()] = n;\\n\\t\\t\\tstk.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\tvector<int> prevSmaller(vector<int> &A) {\\n\\t\\tvector<int> ans;\\n\\t\\tans.resize(A.size());\\n\\t\\tstack<int> st;\\n\\t\\tfor (int i = 0; i < A.size(); i++) {\\n\\t\\t\\twhile (!st.empty() && A[st.top()] >= A[i]) st.pop();\\n\\t\\t\\tif (st.empty()) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = st.top();\\n\\t\\t\\t}\\n\\t\\t\\tst.push(i);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\tint maxSumMinProduct(vector<int>& nums) {\\n\\t\\tvector<int> a = nextSmallerElement(nums, nums.size());\\n\\t\\tvector<int> b = prevSmaller(nums);\\n\\t\\tvector<long long int> pref(nums.size());\\n\\t\\tpref[0] = nums[0];\\n\\t\\tfor (int i = 1; i < nums.size(); i++)\\n\\t\\t\\tpref[i] = pref[i - 1] + nums[i];\\n\\t\\tlong long ans = LLONG_MIN;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tint x = b[i] + 1;\\n\\t\\t\\tint y = a[i] - 1;\\n            if(x==0)\\n                ans = cmax(ans, nums[i] * (pref[y]));\\n\\t\\t\\telse ans = cmax(ans, nums[i] * (pref[y] - pref[x - 1]));\\n\\t\\t}\\n\\t\\treturn ans % 1000000007;\\n\\t}\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n#define cmax(x,y)         (x >= y ? x : y)\\n\\nclass Solution {\\npublic:\\n\\tvector<int> nextSmallerElement(vector<int>& arr, int n) {\\n\\t\\tvector<int> ans(n);\\n\\t\\tstack < int > stk;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (!stk.empty() && arr[stk.top()] > arr[i]) {\\n\\t\\t\\t\\tans[stk.top()] = i;\\n\\t\\t\\t\\tstk.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstk.push(i);\\n\\t\\t}\\n\\t\\twhile (!stk.empty()) {\\n\\t\\t\\tans[stk.top()] = n;\\n\\t\\t\\tstk.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\tvector<int> prevSmaller(vector<int> &A) {\\n\\t\\tvector<int> ans;\\n\\t\\tans.resize(A.size());\\n\\t\\tstack<int> st;\\n\\t\\tfor (int i = 0; i < A.size(); i++) {\\n\\t\\t\\twhile (!st.empty() && A[st.top()] >= A[i]) st.pop();\\n\\t\\t\\tif (st.empty()) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = st.top();\\n\\t\\t\\t}\\n\\t\\t\\tst.push(i);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\tint maxSumMinProduct(vector<int>& nums) {\\n\\t\\tvector<int> a = nextSmallerElement(nums, nums.size());\\n\\t\\tvector<int> b = prevSmaller(nums);\\n\\t\\tvector<long long int> pref(nums.size());\\n\\t\\tpref[0] = nums[0];\\n\\t\\tfor (int i = 1; i < nums.size(); i++)\\n\\t\\t\\tpref[i] = pref[i - 1] + nums[i];\\n\\t\\tlong long ans = LLONG_MIN;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tint x = b[i] + 1;\\n\\t\\t\\tint y = a[i] - 1;\\n            if(x==0)\\n                ans = cmax(ans, nums[i] * (pref[y]));\\n\\t\\t\\telse ans = cmax(ans, nums[i] * (pref[y] - pref[x - 1]));\\n\\t\\t}\\n\\t\\treturn ans % 1000000007;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198745,
                "title": "python-mono-stack",
                "content": "One possible solution is to use a mono stack. It is monotone in that we append groups in increasing value of multiplier.\\nThe following cases occur at current value of `x`:\\n* If the stack is empty or if `x` is greater than last multiplier (i.e. `stack[-1][0]`) we append.\\n* If `x` smaller than `stack[-1][0]` there are two cases: (i) if the length of the stack is `1`, we just merge with current smaller multiplier. (ii) if the length of the stack is more than `1`, first check the last two elements, if the multiplier in `stack[-2]` is greater than the current, first merge them, do this until the multiplier at `stack[-2]` is less than `x`. We also keep track of min products that occur. At the end, we merge from last entry to first one-by-one, again keeping track of min product.\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n```python\\nclass Solution:\\n    def maxSumMinProduct(self, A):\\n        ans = 0\\n        stack = []\\n        for x in A:\\n            if not stack or x > stack[-1][0]:\\n                stack.append([x, x])\\n                ans = max(ans, stack[-1][0] * stack[-1][1])\\n                continue\\n            if x == stack[-1][0]:\\n                stack[-1][1] += x\\n                ans = max(ans, stack[-1][0] * stack[-1][1])\\n                continue\\n            if x < stack[-1][0]:\\n                while len(stack) >= 2 and stack[-2][0] >= x:\\n                    a, b = stack.pop()\\n                    stack[-1][1] += b\\n                    ans = max(ans, stack[-1][0] * stack[-1][1])\\n                stack[-1][0] = x\\n                stack[-1][1] += x\\n                ans = max(ans, stack[-1][0] * stack[-1][1])\\n        while len(stack) >= 2:\\n            a, b = stack.pop()\\n            stack[-1][1] += b\\n            ans = max(ans, stack[-1][0] * stack[-1][1])\\n        \\n        return ans % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxSumMinProduct(self, A):\\n        ans = 0\\n        stack = []\\n        for x in A:\\n            if not stack or x > stack[-1][0]:\\n                stack.append([x, x])\\n                ans = max(ans, stack[-1][0] * stack[-1][1])\\n                continue\\n            if x == stack[-1][0]:\\n                stack[-1][1] += x\\n                ans = max(ans, stack[-1][0] * stack[-1][1])\\n                continue\\n            if x < stack[-1][0]:\\n                while len(stack) >= 2 and stack[-2][0] >= x:\\n                    a, b = stack.pop()\\n                    stack[-1][1] += b\\n                    ans = max(ans, stack[-1][0] * stack[-1][1])\\n                stack[-1][0] = x\\n                stack[-1][1] += x\\n                ans = max(ans, stack[-1][0] * stack[-1][1])\\n        while len(stack) >= 2:\\n            a, b = stack.pop()\\n            stack[-1][1] += b\\n            ans = max(ans, stack[-1][0] * stack[-1][1])\\n        \\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198663,
                "title": "c-monotonous-stack-to-find-a-range-that-takes-nums-i-as-the-minimum-element",
                "content": "int maxSumMinProduct(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        vector<long> prefix(n + 1);\\n        \\n        for (int i = 1 ; i <= n ; ++i) {\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        }\\n\\n        vector<int> right(n, n), left(n, -1);\\n        stack<int> stk_r, stk_l;\\n\\n        for (int i = 0, j = n - 1 ; i < n ; ++i, --j) {\\n            while (!stk_r.empty() && nums[i] < nums[stk_r.top()]) {\\n                int index = stk_r.top();\\n                right[index] = i;\\n                stk_r.pop();\\n            }\\n            stk_r.emplace(i);\\n\\n            while (!stk_l.empty() && nums[j] < nums[stk_l.top()]) {\\n                int index = stk_l.top();\\n                left[index] = j;\\n                stk_l.pop();\\n            }\\n            stk_l.emplace(j);              \\n        }\\n        \\n        long ans = LONG_MIN;\\n        \\n        for (int i = 0 ; i < n ; ++i) {\\n            int l = left[i];\\n            int r = right[i];\\n            \\n            long sum = static_cast<long>(nums[i]) * (prefix[r] - prefix[l + 1]);\\n            ans = max(ans, sum);\\n        }\\n        \\n        long mod = 1e9 + 7;\\n        return ans % mod;\\n    }",
                "solutionTags": [],
                "code": "int maxSumMinProduct(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        vector<long> prefix(n + 1);\\n        \\n        for (int i = 1 ; i <= n ; ++i) {\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        }\\n\\n        vector<int> right(n, n), left(n, -1);\\n        stack<int> stk_r, stk_l;\\n\\n        for (int i = 0, j = n - 1 ; i < n ; ++i, --j) {\\n            while (!stk_r.empty() && nums[i] < nums[stk_r.top()]) {\\n                int index = stk_r.top();\\n                right[index] = i;\\n                stk_r.pop();\\n            }\\n            stk_r.emplace(i);\\n\\n            while (!stk_l.empty() && nums[j] < nums[stk_l.top()]) {\\n                int index = stk_l.top();\\n                left[index] = j;\\n                stk_l.pop();\\n            }\\n            stk_l.emplace(j);              \\n        }\\n        \\n        long ans = LONG_MIN;\\n        \\n        for (int i = 0 ; i < n ; ++i) {\\n            int l = left[i];\\n            int r = right[i];\\n            \\n            long sum = static_cast<long>(nums[i]) * (prefix[r] - prefix[l + 1]);\\n            ans = max(ans, sum);\\n        }\\n        \\n        long mod = 1e9 + 7;\\n        return ans % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4097063,
                "title": "o-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmin product = min(array) * sum(array)\\n\\nTo find max min-product, we need to check all min products. To get all min products, we will consider n longest subarrays i.e a subarray for each element in which the element is the minimum. \\n\\nmin-product[i] = arr[i] * (prefix-sum[r[i]] \\u2013 prefix-sum[l[i]-1])\\n\\nUse a monotonic stack to track the left and right boundary (smallest and greatest elements) of each element, and prefix sum to avoid recomputing the subarray sums multiple times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- create a stack. Each element is a pair representing (min element, prefix sum)\\n- set res = 0 to track the max min-product\\n- set cur_sum = 0 to track the current running sum\\n- add an extra 0 to the end of the input array\\n- for each number n in the input \\n    - loop until stack is empty and stack top value >= n. In each iteration\\n        - pop stack and get the minimum of the subarray\\n        - find the min product by multiplying the subarray min and subarray sum (current prefix sum - stack top prefix sum)\\n        - update res by taking max of current min-product and previous max min-product\\n    - add current number to cur_sum\\n    - add (current number, current prefix sum) to stack\\n- mod the max min-product by 10$^9$ + 7 and return it\\n\\n# Complexity\\n- Time complexity: O(nums) \\u2192 O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(stack) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        stack = [(-1, 0)]\\n        res, cur_sum = 0, 0\\n        nums.append(0)\\n        for n in nums:\\n            while stack and stack[-1][0] >= n:\\n                mini = stack.pop()[0]\\n                product = mini * (cur_sum - stack[-1][1])\\n                res = max(res, product)\\n            cur_sum += n\\n            stack.append((n, cur_sum))\\n        return res % 1000000007\\n     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        stack = [(-1, 0)]\\n        res, cur_sum = 0, 0\\n        nums.append(0)\\n        for n in nums:\\n            while stack and stack[-1][0] >= n:\\n                mini = stack.pop()[0]\\n                product = mini * (cur_sum - stack[-1][1])\\n                res = max(res, product)\\n            cur_sum += n\\n            stack.append((n, cur_sum))\\n        return res % 1000000007\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095922,
                "title": "lessons-learned",
                "content": "**Concept**: [votrubac](https://leetcode.com/problems/maximum-subarray-min-product/discuss/1198896/O(n)-Monostack-with-picture)\\n\\n**Observation**: \\n* For a decreasing sequence, each element is multiplied to its number only (ie, the subarray is the element itself since it is the min), if the subarray is viewed from the element to the right.\\n* For an increasing sequence, each element is multiplied to all the numbers to its right, if the subarray is viewed from the element to the right.\\n\\n**Code**:\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long [] prefixSum = new long[n];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i] = i == 0 ? nums[i] : nums[i] + prefixSum[i - 1];\\n        }\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        long maxProduct = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; ++i) {\\n            int num = nums[i];\\n            while (!stack.isEmpty() && num < nums[stack.peek()]) {\\n                int min = nums[stack.pop()];\\n                int left = stack.isEmpty() ? -1 : stack.peek();\\n                int right = i - 1;\\n                long sum = left == -1 ? prefixSum[right] : prefixSum[right] - prefixSum[left];\\n                long product = min * sum;\\n                maxProduct = Math.max(maxProduct, product);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            int poppedIndex = stack.pop();\\n            int min = nums[poppedIndex];\\n            int left = stack.isEmpty() ? -1 : stack.peek();\\n            int right = n - 1;\\n            long sum = left == -1 ? prefixSum[right] : prefixSum[right] - prefixSum[left];\\n            long product = min * sum;\\n            maxProduct = Math.max(maxProduct, product);\\n        }\\n        \\n        return (int)(maxProduct % 1000000007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long [] prefixSum = new long[n];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i] = i == 0 ? nums[i] : nums[i] + prefixSum[i - 1];\\n        }\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        long maxProduct = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; ++i) {\\n            int num = nums[i];\\n            while (!stack.isEmpty() && num < nums[stack.peek()]) {\\n                int min = nums[stack.pop()];\\n                int left = stack.isEmpty() ? -1 : stack.peek();\\n                int right = i - 1;\\n                long sum = left == -1 ? prefixSum[right] : prefixSum[right] - prefixSum[left];\\n                long product = min * sum;\\n                maxProduct = Math.max(maxProduct, product);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            int poppedIndex = stack.pop();\\n            int min = nums[poppedIndex];\\n            int left = stack.isEmpty() ? -1 : stack.peek();\\n            int right = n - 1;\\n            long sum = left == -1 ? prefixSum[right] : prefixSum[right] - prefixSum[left];\\n            long product = min * sum;\\n            maxProduct = Math.max(maxProduct, product);\\n        }\\n        \\n        return (int)(maxProduct % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072944,
                "title": "o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        res = 0\\n        stack = []\\n        prefix = [0]\\n\\n        for n in nums:\\n            prefix.append(prefix[-1]+n)\\n\\n        for i,n in enumerate(nums):\\n            newStart = i\\n            while stack and stack[-1][1] > n:\\n                start,val = stack.pop()\\n                total = prefix[i]-prefix[start]\\n                res = max(res,total*val)\\n                newStart = start\\n            stack.append((newStart,n))\\n        \\n        for start,val in stack:\\n            total = prefix[len(nums)] - prefix[start]\\n            res = max(res,total*val)\\n        \\n        return res % (10**9+7)\\n# time/space complexity -> O(N)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        res = 0\\n        stack = []\\n        prefix = [0]\\n\\n        for n in nums:\\n            prefix.append(prefix[-1]+n)\\n\\n        for i,n in enumerate(nums):\\n            newStart = i\\n            while stack and stack[-1][1] > n:\\n                start,val = stack.pop()\\n                total = prefix[i]-prefix[start]\\n                res = max(res,total*val)\\n                newStart = start\\n            stack.append((newStart,n))\\n        \\n        for start,val in stack:\\n            total = prefix[len(nums)] - prefix[start]\\n            res = max(res,total*val)\\n        \\n        return res % (10**9+7)\\n# time/space complexity -> O(N)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040407,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        vector<int>nsl(nums.size(),-1);\\n        vector<int>nsr(nums.size(),-1);\\n        stack<int>st;\\n        long long  ans=0;\\n        st.push(0); \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            while(!st.empty() and nums[st.top()]>=nums[i])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                nsl[i]=-1;\\n            }\\n            else\\n            {\\n                nsl[i]=st.top();\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n        {\\n            st.pop();\\n        }\\n        st.push(nums.size()-1); \\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            while(!st.empty() and nums[st.top()]>=nums[i])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                nsr[i]=-1;\\n            }\\n            else\\n            {\\n                nsr[i]=st.top();\\n            }\\n            st.push(i);\\n        }\\n        vector<long long >v(nums.size());\\n        v[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            v[i]=v[i-1]+nums[i];\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nsl[i]==-1 and nsr[i]==-1)\\n            {\\n                // minimum in complete array\\n                long long  a=((nums[i])*(v[v.size()-1]));\\n                ans=max(ans,a);\\n            }\\n            else if(nsl[i]==-1 and nsr[i]!=-1)\\n            {\\n                // minimum in left subarray\\n                long long  a=((nums[i])*(v[nsr[i]-1]));\\n                ans=max(ans,a);\\n            }\\n            else if(nsl[i]!=-1 and nsr[i]==-1)\\n            {\\n                //minimum in right subarray\\n                long long  a=((nums[i])*((v[v.size()-1]-v[nsl[i]])));\\n                ans=max(ans,a);\\n            }\\n            else\\n            {\\n                long long  a=((nums[i])*((v[nsr[i]-1]-v[nsl[i]])));\\n                ans=max(ans,a);\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        vector<int>nsl(nums.size(),-1);\\n        vector<int>nsr(nums.size(),-1);\\n        stack<int>st;\\n        long long  ans=0;\\n        st.push(0); \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            while(!st.empty() and nums[st.top()]>=nums[i])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                nsl[i]=-1;\\n            }\\n            else\\n            {\\n                nsl[i]=st.top();\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n        {\\n            st.pop();\\n        }\\n        st.push(nums.size()-1); \\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            while(!st.empty() and nums[st.top()]>=nums[i])\\n            {\\n                st.pop();\\n            }\\n            if(st.empty())\\n            {\\n                nsr[i]=-1;\\n            }\\n            else\\n            {\\n                nsr[i]=st.top();\\n            }\\n            st.push(i);\\n        }\\n        vector<long long >v(nums.size());\\n        v[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            v[i]=v[i-1]+nums[i];\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nsl[i]==-1 and nsr[i]==-1)\\n            {\\n                // minimum in complete array\\n                long long  a=((nums[i])*(v[v.size()-1]));\\n                ans=max(ans,a);\\n            }\\n            else if(nsl[i]==-1 and nsr[i]!=-1)\\n            {\\n                // minimum in left subarray\\n                long long  a=((nums[i])*(v[nsr[i]-1]));\\n                ans=max(ans,a);\\n            }\\n            else if(nsl[i]!=-1 and nsr[i]==-1)\\n            {\\n                //minimum in right subarray\\n                long long  a=((nums[i])*((v[v.size()-1]-v[nsl[i]])));\\n                ans=max(ans,a);\\n            }\\n            else\\n            {\\n                long long  a=((nums[i])*((v[nsr[i]-1]-v[nsl[i]])));\\n                ans=max(ans,a);\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038745,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int maxSumMinProduct(vector<int>& nums) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    long ans = 0;\\n    stack<int> stack;\\n    vector<long> prefix(nums.size() + 1);\\n\\n    for (int i = 0; i < nums.size(); ++i)\\n      prefix[i + 1] = prefix[i] + nums[i];\\n\\n    for (int i = 0; i <= nums.size(); ++i) {\\n      while (!stack.empty() &&\\n             (i == nums.size() || nums[stack.top()] > nums[i])) {\\n        const int minVal = nums[stack.top()];\\n        stack.pop();\\n        const long sum =\\n            stack.empty() ? prefix[i] : prefix[i] - prefix[stack.top() + 1];\\n        ans = max(ans, minVal * sum);\\n      }\\n      stack.push(i);\\n    }\\n\\n    return ans % kMod;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int maxSumMinProduct(vector<int>& nums) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    long ans = 0;\\n    stack<int> stack;\\n    vector<long> prefix(nums.size() + 1);\\n\\n    for (int i = 0; i < nums.size(); ++i)\\n      prefix[i + 1] = prefix[i] + nums[i];\\n\\n    for (int i = 0; i <= nums.size(); ++i) {\\n      while (!stack.empty() &&\\n             (i == nums.size() || nums[stack.top()] > nums[i])) {\\n        const int minVal = nums[stack.top()];\\n        stack.pop();\\n        const long sum =\\n            stack.empty() ? prefix[i] : prefix[i] - prefix[stack.top() + 1];\\n        ans = max(ans, minVal * sum);\\n      }\\n      stack.push(i);\\n    }\\n\\n    return ans % kMod;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027834,
                "title": "c-o-n-solution",
                "content": "# Intuition\\nmonotonic stack for min element before and after, then consider the array with $a[i]$ as minimum, using prefix sum calculate subarray sum. \\n$ans=max(ans,a[i]*sub\\\\_array\\\\_sum)$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) \\n    {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        vector<int> prev(n,-1),next(n,n);\\n\\n        stack<int>st;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            while(st.size() && nums[st.top()]>nums[i])\\n            st.pop();\\n\\n            if(st.empty())\\n            prev[i]=-1;\\n\\n            else \\n            prev[i]=st.top();\\n\\n            st.push(i);\\n        }    \\n\\n        while(st.size())\\n        st.pop();\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(st.size() && nums[st.top()]>=nums[i])\\n            st.pop();\\n\\n            if(st.empty())\\n            next[i]=n;\\n\\n            else \\n            next[i]=st.top();\\n\\n            st.push(i);\\n\\n        }\\n\\n        vector<long long int> p(n+2,0);\\n        p[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            p[i]+=(nums[i]+p[i-1]);\\n            p[i]=p[i];\\n        }\\n\\n        long long int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long int u=0;\\n            if(prev[i]!=-1)\\n            u=(nums[i]*(p[next[i]-1]-p[prev[i]]));\\n            else \\n            u=(nums[i]*(p[next[i]-1]));\\n\\n            \\n            ans=max(ans,u);\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) \\n    {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        vector<int> prev(n,-1),next(n,n);\\n\\n        stack<int>st;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            while(st.size() && nums[st.top()]>nums[i])\\n            st.pop();\\n\\n            if(st.empty())\\n            prev[i]=-1;\\n\\n            else \\n            prev[i]=st.top();\\n\\n            st.push(i);\\n        }    \\n\\n        while(st.size())\\n        st.pop();\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(st.size() && nums[st.top()]>=nums[i])\\n            st.pop();\\n\\n            if(st.empty())\\n            next[i]=n;\\n\\n            else \\n            next[i]=st.top();\\n\\n            st.push(i);\\n\\n        }\\n\\n        vector<long long int> p(n+2,0);\\n        p[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            p[i]+=(nums[i]+p[i-1]);\\n            p[i]=p[i];\\n        }\\n\\n        long long int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long int u=0;\\n            if(prev[i]!=-1)\\n            u=(nums[i]*(p[next[i]-1]-p[prev[i]]));\\n            else \\n            u=(nums[i]*(p[next[i]-1]));\\n\\n            \\n            ans=max(ans,u);\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945963,
                "title": "prefix-sum-trapping-rainwater",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Prefix Sum Concept + Max Area Histogram concept \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> prefix_sum(n + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            long long sum = prefix_sum[i - 1] + nums[i - 1];\\n            prefix_sum[i] = sum;\\n        }\\n\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        stack<int> st, st1;\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && nums[i] <= nums[st.top()]) {\\n                st.pop();\\n            }\\n\\n            if (st.empty()) {\\n                left[i] = -1;\\n            } else {\\n                left[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!st1.empty() && nums[i] <= nums[st1.top()]) {\\n                st1.pop();\\n            }\\n\\n            if (st1.empty()) {\\n                right[i] = n;\\n            } else {\\n                right[i] = st1.top();\\n            }\\n\\n            st1.push(i);\\n        }\\n\\n        long long maxlen = 0;\\n        for (int i = 0; i < n; i++) {\\n            long long sum = prefix_sum[right[i]] - prefix_sum[left[i] + 1];\\n            maxlen = max(maxlen, sum * nums[i]);\\n        }\\n        return maxlen % 1000000007;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> prefix_sum(n + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            long long sum = prefix_sum[i - 1] + nums[i - 1];\\n            prefix_sum[i] = sum;\\n        }\\n\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        stack<int> st, st1;\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && nums[i] <= nums[st.top()]) {\\n                st.pop();\\n            }\\n\\n            if (st.empty()) {\\n                left[i] = -1;\\n            } else {\\n                left[i] = st.top();\\n            }\\n\\n            st.push(i);\\n        }\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!st1.empty() && nums[i] <= nums[st1.top()]) {\\n                st1.pop();\\n            }\\n\\n            if (st1.empty()) {\\n                right[i] = n;\\n            } else {\\n                right[i] = st1.top();\\n            }\\n\\n            st1.push(i);\\n        }\\n\\n        long long maxlen = 0;\\n        for (int i = 0; i < n; i++) {\\n            long long sum = prefix_sum[right[i]] - prefix_sum[left[i] + 1];\\n            maxlen = max(maxlen, sum * nums[i]);\\n        }\\n        return maxlen % 1000000007;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938511,
                "title": "python3-stack-o-n-o-n-monotonic-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to find out the min product at each element of the array. i.e. What is the min product if A[i] is the minimum value of a subarray.\\nNow, it would sound familier to a problem that youve solved before:\\n[largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the nearest smaller to the left and to the right of an element and then take sum of the subarray between those.\\nWe can use prefix sum technique to calculate the subarray sum efficiently.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        \\n        def nsl(nums):\\n            res = []\\n            stack = []\\n            for idx, elem in enumerate(nums):\\n                while stack and nums[stack[-1]] >= elem:\\n                    stack.pop()\\n                if stack:\\n                    res.append(stack[-1])\\n                else:\\n                    res.append(-1)\\n                stack.append(idx)\\n            \\n            return res\\n        \\n        def nsr(nums):\\n            res = []\\n            stack = []\\n            n = len(nums)\\n            for idx in range(n-1, -1, -1):\\n                while stack and nums[stack[-1]] >= nums[idx]:\\n                    stack.pop()\\n                if stack:\\n                    res.append(stack[-1])\\n                else:\\n                    res.append(n)\\n                stack.append(idx)\\n            \\n            return res[::-1]\\n        \\n\\n        prefix_sum = nums[:]\\n        n = len(nums)\\n        for i in range(1, n):\\n            prefix_sum[i] += prefix_sum[i-1]\\n\\n        left_small = nsl(nums)\\n        right_small = nsr(nums)\\n\\n        res = float(\\'-inf\\')\\n        for idx in range(n):\\n            left_small_idx = left_small[idx]\\n            right_small_idx = right_small[idx]\\n            subarray_sum = prefix_sum[right_small_idx - 1] - prefix_sum[left_small_idx + 1] + nums[left_small_idx + 1]\\n            min_product = subarray_sum * nums[idx]\\n            res = max(res, min_product)\\n        \\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        \\n        def nsl(nums):\\n            res = []\\n            stack = []\\n            for idx, elem in enumerate(nums):\\n                while stack and nums[stack[-1]] >= elem:\\n                    stack.pop()\\n                if stack:\\n                    res.append(stack[-1])\\n                else:\\n                    res.append(-1)\\n                stack.append(idx)\\n            \\n            return res\\n        \\n        def nsr(nums):\\n            res = []\\n            stack = []\\n            n = len(nums)\\n            for idx in range(n-1, -1, -1):\\n                while stack and nums[stack[-1]] >= nums[idx]:\\n                    stack.pop()\\n                if stack:\\n                    res.append(stack[-1])\\n                else:\\n                    res.append(n)\\n                stack.append(idx)\\n            \\n            return res[::-1]\\n        \\n\\n        prefix_sum = nums[:]\\n        n = len(nums)\\n        for i in range(1, n):\\n            prefix_sum[i] += prefix_sum[i-1]\\n\\n        left_small = nsl(nums)\\n        right_small = nsr(nums)\\n\\n        res = float(\\'-inf\\')\\n        for idx in range(n):\\n            left_small_idx = left_small[idx]\\n            right_small_idx = right_small[idx]\\n            subarray_sum = prefix_sum[right_small_idx - 1] - prefix_sum[left_small_idx + 1] + nums[left_small_idx + 1]\\n            min_product = subarray_sum * nums[idx]\\n            res = max(res, min_product)\\n        \\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858399,
                "title": "c-stack-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The intution comes simple as we need to calculate the min-product for every element.\\n- Now, how can we calculate for every element?\\n    1. If we know the first smallest element on left as well as on right sides of the element.\\n    2. And we need the sum of the array between those two left and right elements.\\n    3. We can obtain the sum of subarray using pre-computed prefixSum.\\n- ### [3,1,5,6,4,2] is the given array.\\n- ### [3,4,9,15,19,21] is the prefixSum array.\\n-  Now for example take the current computing element as 4 (nums[4]).\\n- #### Left smallest of 4 is nums[1]=> \\'1\\'\\n- #### Right smallest of 4 is nums[5]=> \\'2\\'\\n- Now 4 is valid, that is we can multiply the subarray between \\'1\\' and \\'2\\' by 4. Take the entire subarray sum between 1 and 2.\\n- #### leftBound=prefixSum[1]=> 4\\n- #### RightBound is =prefixSum[5]=> 21 but we take the right bound 1 step before it that is 19 {at idx=4 in prefixSum} as we compute the prefixSums.\\n- #### subtract 19-4=15. This is seen by subarray [5,6,4] as we require this sum only.\\n- ##### We multiply the sum of this subarray by the curr element. 15 * 4=70.\\n- ## <--NOTE-->\\n- #### As we can have no element on left at th min element of the array, we need to consider 0 as the leftbound. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        int mod=1e9+7;\\n        vector<long long> prefixSum(n);\\n        vector<int> minIndices(n);\\n        stack<int> st;\\n        prefixSum[0]=nums[0];\\n        st.push(0);minIndices[0]=-1;\\n        for(int i=1;i<n;i++){\\n            prefixSum[i]=prefixSum[i-1]+nums[i];\\n            while(!st.empty() && nums[i]<=nums[st.top()])st.pop();\\n            minIndices[i]=st.empty()?-1:st.top();\\n            st.push(i);\\n        }\\n        stack<int> st1;\\n        long long ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            while(!st1.empty() && nums[i]<=nums[st1.top()])st1.pop();\\n            long long right=st1.empty()?prefixSum[n-1]:prefixSum[st1.top()-1];\\n            long long left=minIndices[i]==-1?0:prefixSum[minIndices[i]];\\n            ans=max(ans,(right-left)*nums[i]);\\n            st1.push(i);\\n        }\\n        return (int)(ans%mod);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        int mod=1e9+7;\\n        vector<long long> prefixSum(n);\\n        vector<int> minIndices(n);\\n        stack<int> st;\\n        prefixSum[0]=nums[0];\\n        st.push(0);minIndices[0]=-1;\\n        for(int i=1;i<n;i++){\\n            prefixSum[i]=prefixSum[i-1]+nums[i];\\n            while(!st.empty() && nums[i]<=nums[st.top()])st.pop();\\n            minIndices[i]=st.empty()?-1:st.top();\\n            st.push(i);\\n        }\\n        stack<int> st1;\\n        long long ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            while(!st1.empty() && nums[i]<=nums[st1.top()])st1.pop();\\n            long long right=st1.empty()?prefixSum[n-1]:prefixSum[st1.top()-1];\\n            long long left=minIndices[i]==-1?0:prefixSum[minIndices[i]];\\n            ans=max(ans,(right-left)*nums[i]);\\n            st1.push(i);\\n        }\\n        return (int)(ans%mod);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850950,
                "title": "application-stack-histogram-fast-c-solution-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        //Consider each element to be a min element. Use conceto of histogram to find the range of subarray for a particular index having min element.\\n        vector<long long> pre(nums.size(),nums[0]);\\n        for(int i=1;i<nums.size();i++)pre[i]=pre[i-1]+(1LL*nums[i]);\\n        stack<int> st1,st2;\\n        vector<int> prevSmaller(nums.size()),nextSmaller(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            while(!st1.empty() && nums[st1.top()]>=nums[i]){\\n                st1.pop();\\n            }\\n            if(st1.empty())prevSmaller[i]=-1;\\n            else prevSmaller[i]=st1.top();\\n            st1.push(i);\\n        }\\n        for(int i=nums.size()-1;i>=0;i--){\\n            while(!st2.empty() && nums[st2.top()]>=nums[i]){\\n                st2.pop();\\n            }\\n            if(st2.empty())nextSmaller[i]=-1;\\n            else nextSmaller[i]=st2.top();\\n            st2.push(i);\\n        }\\n        long long ans = 0;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            if(prevSmaller[i]==-1 && nextSmaller[i]==-1)ans=max(ans,pre[n-1]*nums[i]);\\n            else if(prevSmaller[i]==-1)ans=max(ans, nums[i]*(pre[nextSmaller[i]-1]));\\n            else if(nextSmaller[i]==-1)ans=max(ans, nums[i]*(pre[n-1]-pre[prevSmaller[i]]));\\n            else ans=max(ans, nums[i]*(pre[nextSmaller[i]-1]-pre[prevSmaller[i]]));\\n        }return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        //Consider each element to be a min element. Use conceto of histogram to find the range of subarray for a particular index having min element.\\n        vector<long long> pre(nums.size(),nums[0]);\\n        for(int i=1;i<nums.size();i++)pre[i]=pre[i-1]+(1LL*nums[i]);\\n        stack<int> st1,st2;\\n        vector<int> prevSmaller(nums.size()),nextSmaller(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            while(!st1.empty() && nums[st1.top()]>=nums[i]){\\n                st1.pop();\\n            }\\n            if(st1.empty())prevSmaller[i]=-1;\\n            else prevSmaller[i]=st1.top();\\n            st1.push(i);\\n        }\\n        for(int i=nums.size()-1;i>=0;i--){\\n            while(!st2.empty() && nums[st2.top()]>=nums[i]){\\n                st2.pop();\\n            }\\n            if(st2.empty())nextSmaller[i]=-1;\\n            else nextSmaller[i]=st2.top();\\n            st2.push(i);\\n        }\\n        long long ans = 0;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            if(prevSmaller[i]==-1 && nextSmaller[i]==-1)ans=max(ans,pre[n-1]*nums[i]);\\n            else if(prevSmaller[i]==-1)ans=max(ans, nums[i]*(pre[nextSmaller[i]-1]));\\n            else if(nextSmaller[i]==-1)ans=max(ans, nums[i]*(pre[n-1]-pre[prevSmaller[i]]));\\n            else ans=max(ans, nums[i]*(pre[nextSmaller[i]-1]-pre[prevSmaller[i]]));\\n        }return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838139,
                "title": "c-similar-to-max-area-in-histogram-beats-99",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n    \\n    int n = nums.size();\\n    const int mod = pow(10,9)+7;\\n    long long maxx=0;\\n     vector<long long> cumm(n,0);\\n     cumm[0]=nums[0];\\n\\n     for(int i=1;i<n;i++)\\n     cumm[i]=cumm[i-1]+nums[i];\\n\\n     stack<int> st;\\n\\n     int i=0;\\n\\n     while(i<n){\\n\\n         if(st.empty() || nums[st.top()]<=nums[i]){\\n             st.push(i);\\n             i++;\\n         }\\n         \\n         else if(nums[st.top()]>nums[i]){\\n             int curr = st.top();\\n             st.pop();\\n             long long r = cumm[i-1];\\n             long long l = 0;\\n             if(!st.empty())\\n             l=cumm[st.top()];\\n\\n             maxx=max((r-l)*nums[curr],maxx);\\n         }\\n     }  \\n\\n     while(!st.empty()){\\n         int curr = st.top();\\n         st.pop();\\n         long long r = cumm[n-1];\\n         long long l=0;\\n         if(!st.empty())\\n         l=cumm[st.top()];\\n\\n         maxx=max((r-l)*nums[curr],maxx);\\n     }\\n\\n\\n\\n     return maxx%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n    \\n    int n = nums.size();\\n    const int mod = pow(10,9)+7;\\n    long long maxx=0;\\n     vector<long long> cumm(n,0);\\n     cumm[0]=nums[0];\\n\\n     for(int i=1;i<n;i++)\\n     cumm[i]=cumm[i-1]+nums[i];\\n\\n     stack<int> st;\\n\\n     int i=0;\\n\\n     while(i<n){\\n\\n         if(st.empty() || nums[st.top()]<=nums[i]){\\n             st.push(i);\\n             i++;\\n         }\\n         \\n         else if(nums[st.top()]>nums[i]){\\n             int curr = st.top();\\n             st.pop();\\n             long long r = cumm[i-1];\\n             long long l = 0;\\n             if(!st.empty())\\n             l=cumm[st.top()];\\n\\n             maxx=max((r-l)*nums[curr],maxx);\\n         }\\n     }  \\n\\n     while(!st.empty()){\\n         int curr = st.top();\\n         st.pop();\\n         long long r = cumm[n-1];\\n         long long l=0;\\n         if(!st.empty())\\n         l=cumm[st.top()];\\n\\n         maxx=max((r-l)*nums[curr],maxx);\\n     }\\n\\n\\n\\n     return maxx%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836916,
                "title": "easy-java-solution-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public static final long MOD = (int) (1e9 + 7);\\n\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Calculate the prefix sum of the input array\\n        long prefixSum[] = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (nums[i] * 1l);\\n        }\\n        \\n        // Stack to keep track of the elements and their indices in a decreasing order\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        long max = 0;\\n        \\n        // Traverse through the array to find the maximum product of minimum values\\n        for (int i = 0; i < n; i++) {\\n            int index = i;\\n            \\n            // Remove elements from the stack while the current element is smaller than the top of the stack\\n            while (!stack.isEmpty() && stack.peek().getValue() > nums[i]) {\\n                long minValue = stack.peek().getValue() * 1l;\\n                int minIndex = stack.peek().getKey();\\n                \\n                // Calculate the prefix sum of the current segment between two minimum elements\\n                long preSum = prefixSum[i] - nums[i] * 1l - ((minIndex - 1) < 0 ? 0 : prefixSum[minIndex - 1]);\\n                \\n                // Update the maximum product if a larger product is found\\n                max = Math.max(max, (preSum * minValue));\\n                \\n                // Pop the element from the stack and update the index to be used for next iteration\\n                stack.pop();\\n                index = minIndex;\\n            }\\n            \\n            // Push the current element and its index to the stack\\n            stack.push(new Pair(index, nums[i]));\\n        }\\n        \\n        // Process the remaining elements in the stack\\n        while (!stack.isEmpty()) {\\n            long minValue = stack.peek().getValue() * 1l;\\n            int minIndex = stack.peek().getKey();\\n            \\n            // Calculate the prefix sum for the remaining segment\\n            long preSum = prefixSum[n - 1] - ((minIndex - 1) < 0 ? 0 : prefixSum[minIndex - 1]);\\n            \\n            // Update the maximum product if a larger product is found\\n            max = Math.max(max, (preSum * minValue));\\n            \\n            // Pop the element from the stack\\n            stack.pop();\\n        }\\n        \\n        // Return the maximum product modulo the specified MOD value\\n        return (int) (max % MOD);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public static final long MOD = (int) (1e9 + 7);\\n\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Calculate the prefix sum of the input array\\n        long prefixSum[] = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (nums[i] * 1l);\\n        }\\n        \\n        // Stack to keep track of the elements and their indices in a decreasing order\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        long max = 0;\\n        \\n        // Traverse through the array to find the maximum product of minimum values\\n        for (int i = 0; i < n; i++) {\\n            int index = i;\\n            \\n            // Remove elements from the stack while the current element is smaller than the top of the stack\\n            while (!stack.isEmpty() && stack.peek().getValue() > nums[i]) {\\n                long minValue = stack.peek().getValue() * 1l;\\n                int minIndex = stack.peek().getKey();\\n                \\n                // Calculate the prefix sum of the current segment between two minimum elements\\n                long preSum = prefixSum[i] - nums[i] * 1l - ((minIndex - 1) < 0 ? 0 : prefixSum[minIndex - 1]);\\n                \\n                // Update the maximum product if a larger product is found\\n                max = Math.max(max, (preSum * minValue));\\n                \\n                // Pop the element from the stack and update the index to be used for next iteration\\n                stack.pop();\\n                index = minIndex;\\n            }\\n            \\n            // Push the current element and its index to the stack\\n            stack.push(new Pair(index, nums[i]));\\n        }\\n        \\n        // Process the remaining elements in the stack\\n        while (!stack.isEmpty()) {\\n            long minValue = stack.peek().getValue() * 1l;\\n            int minIndex = stack.peek().getKey();\\n            \\n            // Calculate the prefix sum for the remaining segment\\n            long preSum = prefixSum[n - 1] - ((minIndex - 1) < 0 ? 0 : prefixSum[minIndex - 1]);\\n            \\n            // Update the maximum product if a larger product is found\\n            max = Math.max(max, (preSum * minValue));\\n            \\n            // Pop the element from the stack\\n            stack.pop();\\n        }\\n        \\n        // Return the maximum product modulo the specified MOD value\\n        return (int) (max % MOD);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832968,
                "title": "best-sol-stack-pair-and-prefix-sum-neetcode-sol",
                "content": "# Intuition\\n[https://youtu.be/YLesLbNkyjA]()\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long int>prefix;\\n        prefix.push_back(0);\\n        for(auto i:nums){\\n            prefix.push_back(i+prefix.back());\\n        }\\n        stack<pair<int,int>>st;\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            int newstart=i;\\n            while(!st.empty() && st.top().second>nums[i]){\\n                int start=st.top().first;\\n                int val=st.top().second;\\n                st.pop();\\n                long long int total=prefix[i]-prefix[start];\\n                ans=max(ans,val*total);\\n                newstart=start;\\n            }\\n            st.push({newstart,nums[i]});\\n        }\\n        while(!st.empty()){\\n            int start=st.top().first;\\n            int val=st.top().second;\\n            st.pop();\\n            ans=max(ans,val*(prefix[n]-prefix[start]));\\n        }\\n        const int MOD = 1000000007;\\n        return ans%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long int>prefix;\\n        prefix.push_back(0);\\n        for(auto i:nums){\\n            prefix.push_back(i+prefix.back());\\n        }\\n        stack<pair<int,int>>st;\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            int newstart=i;\\n            while(!st.empty() && st.top().second>nums[i]){\\n                int start=st.top().first;\\n                int val=st.top().second;\\n                st.pop();\\n                long long int total=prefix[i]-prefix[start];\\n                ans=max(ans,val*total);\\n                newstart=start;\\n            }\\n            st.push({newstart,nums[i]});\\n        }\\n        while(!st.empty()){\\n            int start=st.top().first;\\n            int val=st.top().second;\\n            st.pop();\\n            ans=max(ans,val*(prefix[n]-prefix[start]));\\n        }\\n        const int MOD = 1000000007;\\n        return ans%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823500,
                "title": "using-monotonic-increasing-stack-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int mod = 1e9 + 7;\\n        int n = nums.size();\\n        vector<long long> nse(n, 0);\\n        vector<long long> pse(n, 0);\\n        stack <long long> st;\\n        long long mxp = INT_MIN;\\n        // using increasing monotonic stack \\n        for(int i = 0; i<n; i++){\\n            long long sum = nums[i];\\n            while(!st.empty() && nums[st.top()] > nums[i]){\\n                sum += pse[st.top()];\\n                st.pop(); \\n            }\\n            pse[i] = sum;\\n            st.push(i);\\n        }\\n        while(!st.empty()) st.pop();\\n        for(int i = n-1; i>=0; i--){\\n            long long sum = nums[i];\\n            while(!st.empty() && nums[st.top()] >= nums[i]){\\n                sum += nse[st.top()];\\n                st.pop(); \\n            }\\n            nse[i] = sum;\\n            st.push(i);\\n        }\\n\\n        for(int i = 0; i<n; i++){\\n            long long ans = 1LL*nums[i]*(nse[i] + pse[i] - nums[i]);\\n            mxp = max(mxp, ans);\\n        }\\n        return mxp%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int mod = 1e9 + 7;\\n        int n = nums.size();\\n        vector<long long> nse(n, 0);\\n        vector<long long> pse(n, 0);\\n        stack <long long> st;\\n        long long mxp = INT_MIN;\\n        // using increasing monotonic stack \\n        for(int i = 0; i<n; i++){\\n            long long sum = nums[i];\\n            while(!st.empty() && nums[st.top()] > nums[i]){\\n                sum += pse[st.top()];\\n                st.pop(); \\n            }\\n            pse[i] = sum;\\n            st.push(i);\\n        }\\n        while(!st.empty()) st.pop();\\n        for(int i = n-1; i>=0; i--){\\n            long long sum = nums[i];\\n            while(!st.empty() && nums[st.top()] >= nums[i]){\\n                sum += nse[st.top()];\\n                st.pop(); \\n            }\\n            nse[i] = sum;\\n            st.push(i);\\n        }\\n\\n        for(int i = 0; i<n; i++){\\n            long long ans = 1LL*nums[i]*(nse[i] + pse[i] - nums[i]);\\n            mxp = max(mxp, ans);\\n        }\\n        return mxp%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800781,
                "title": "c-stack-prefix-sum-next-smaller-and-previous-smaller",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> pref(n);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+(long long)nums[i];\\n        vector<long long> sum(n);\\n        stack<int> st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(st.size()==0)\\n            {\\n                sum[i] = pref[n-1];\\n            }\\n            else if(nums[st.top()]<nums[i])\\n            {\\n                sum[i] = pref[st.top()-1];\\n            }\\n            else\\n            {\\n                while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n                if(st.size()==0)\\n                {\\n                    sum[i] = pref[n-1];\\n                }\\n                else\\n                {\\n                    sum[i] = pref[st.top()-1];\\n                }\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n        st.pop();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty() && nums[st.top()]<nums[i])\\n            {\\n                sum[i]-= pref[st.top()];\\n            }\\n            else\\n            {\\n                while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n                if(st.size()>0)\\n                {\\n                    sum[i]-= pref[st.top()];\\n                }\\n            }\\n            st.push(i);\\n        }\\n        long long maxi = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi = max(maxi,(long long)nums[i]*(sum[i]));\\n        }\\n        return maxi%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> pref(n);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+(long long)nums[i];\\n        vector<long long> sum(n);\\n        stack<int> st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(st.size()==0)\\n            {\\n                sum[i] = pref[n-1];\\n            }\\n            else if(nums[st.top()]<nums[i])\\n            {\\n                sum[i] = pref[st.top()-1];\\n            }\\n            else\\n            {\\n                while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n                if(st.size()==0)\\n                {\\n                    sum[i] = pref[n-1];\\n                }\\n                else\\n                {\\n                    sum[i] = pref[st.top()-1];\\n                }\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n        st.pop();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty() && nums[st.top()]<nums[i])\\n            {\\n                sum[i]-= pref[st.top()];\\n            }\\n            else\\n            {\\n                while(!st.empty() && nums[st.top()]>=nums[i])\\n                st.pop();\\n                if(st.size()>0)\\n                {\\n                    sum[i]-= pref[st.top()];\\n                }\\n            }\\n            st.push(i);\\n        }\\n        long long maxi = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi = max(maxi,(long long)nums[i]*(sum[i]));\\n        }\\n        return maxi%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798360,
                "title": "step-by-step-performance-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxSumMinProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\'\\'\\'\\n#This question can be divided into 3 steps. The most basic way will time out, since the time complexity of sum() and min() is n, 2n*n take forever to run. (case pass 22/42)\\nrs = 0\\nnums.append(0)\\nfor k in range(1,len(nums)):\\n  start=k\\n  while nums[start-1] > nums[k]:\\n    start-=1\\n    summ=sum(nums[start:k]) #n(n)================\\n    minn=min(nums[start:k]) #o(n)================\\n    rs=max(summ*minn,rs)\\nreturn rs\\n\\n#The feature of the monotonic stack can find the smallest value in subsequence. So the stack can replace min(). Hoever, sum() time complexity is n, it still times out. (case pass 36/42)\\nrs = 0\\nnums.append(0)\\nstack = [-1]\\nfor k,v in enumerate(nums):\\n  while stack and nums[stack[-1]] > v:\\n    curr = stack.pop()\\n    summ = sum(nums[stack[-1]+1:k]) #o(n)================\\n    minn=nums[curr]                 #o(1)================\\n    rs=max(summ*minn,rs)\\n  stack.append(k)\\n\\nreturn rs%(10**9+7)\\n\\n#Finally, use the feature of prefix array. sum() can be replaced with subtraction.\\nrs = 0\\nnums.append(0)\\nstack = [-1]\\nprefix=[0]\\nfor v in nums:\\n    prefix.append(prefix[-1]+v)\\n\\nfor k,v in enumerate(nums):\\n    while stack and nums[stack[-1]] > v:\\n        curr = stack.pop()\\n        summ = prefix[k]-prefix[stack[-1]+1]  #o(1)================\\n        minn=nums[curr]                       #o(1)================\\n        rs = max(rs,minn*summ)\\n    stack.append(k)\\nreturn rs%(10**9+7)\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumMinProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\'\\'\\'\\n#This question can be divided into 3 steps. The most basic way will time out, since the time complexity of sum() and min() is n, 2n*n take forever to run. (case pass 22/42)\\nrs = 0\\nnums.append(0)\\nfor k in range(1,len(nums)):\\n  start=k\\n  while nums[start-1] > nums[k]:\\n    start-=1\\n    summ=sum(nums[start:k]) #n(n)================\\n    minn=min(nums[start:k]) #o(n)================\\n    rs=max(summ*minn,rs)\\nreturn rs\\n\\n#The feature of the monotonic stack can find the smallest value in subsequence. So the stack can replace min(). Hoever, sum() time complexity is n, it still times out. (case pass 36/42)\\nrs = 0\\nnums.append(0)\\nstack = [-1]\\nfor k,v in enumerate(nums):\\n  while stack and nums[stack[-1]] > v:\\n    curr = stack.pop()\\n    summ = sum(nums[stack[-1]+1:k]) #o(n)================\\n    minn=nums[curr]                 #o(1)================\\n    rs=max(summ*minn,rs)\\n  stack.append(k)\\n\\nreturn rs%(10**9+7)\\n\\n#Finally, use the feature of prefix array. sum() can be replaced with subtraction.\\nrs = 0\\nnums.append(0)\\nstack = [-1]\\nprefix=[0]\\nfor v in nums:\\n    prefix.append(prefix[-1]+v)\\n\\nfor k,v in enumerate(nums):\\n    while stack and nums[stack[-1]] > v:\\n        curr = stack.pop()\\n        summ = prefix[k]-prefix[stack[-1]+1]  #o(1)================\\n        minn=nums[curr]                       #o(1)================\\n        rs = max(rs,minn*summ)\\n    stack.append(k)\\nreturn rs%(10**9+7)\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736119,
                "title": "simple-c-solution-prefix-sum-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        vector<int>left(nums.size(),-1);\\n        vector<int>right(nums.size(),nums.size());\\n        stack<pair<int,int>>stl;\\n        stack<pair<int,int>>str;\\n        for(int i=0;i<nums.size();i++){\\n            if(str.size()==0){\\n                str.push({nums[i],i});\\n            }\\n            else if(str.size()!=0){\\n                while(str.size()!=0){\\n                    auto it=str.top();\\n                    int number=it.first;\\n                    int index=it.second;\\n                    if(number>nums[i]){\\n                        str.pop();\\n                        right[index]=i;\\n                    }\\n                    else if(number<=nums[i])break;\\n                }\\n                str.push({nums[i],i});\\n            }\\n\\n        }\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(stl.size()==0){\\n                stl.push({nums[i],i});\\n            }\\n            else if(stl.size()!=0){\\n                while(stl.size()!=0){\\n                    auto it=stl.top();\\n                    int number=it.first;\\n                    int index=it.second;\\n                    if(number>nums[i]){\\n                        stl.pop();\\n                        left[index]=i;\\n                    }\\n                    else if(number<=nums[i])break;\\n                }\\n                stl.push({nums[i],i});\\n            }\\n\\n        }\\n    vector<long long>prefix(nums.size()+1,0);\\n    prefix[0]=0;\\n    for(int i=0;i<nums.size();i++){\\n        prefix[i+1]=(prefix[i]+nums[i]);\\n    }\\n    long long int ans=0;\\n    for(int i=0;i<nums.size();i++){\\n        long long curr=(nums[i]*(prefix[right[i]]-prefix[left[i]+1]));\\n        ans=max(ans,curr);\\n    }\\n       \\n    return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        vector<int>left(nums.size(),-1);\\n        vector<int>right(nums.size(),nums.size());\\n        stack<pair<int,int>>stl;\\n        stack<pair<int,int>>str;\\n        for(int i=0;i<nums.size();i++){\\n            if(str.size()==0){\\n                str.push({nums[i],i});\\n            }\\n            else if(str.size()!=0){\\n                while(str.size()!=0){\\n                    auto it=str.top();\\n                    int number=it.first;\\n                    int index=it.second;\\n                    if(number>nums[i]){\\n                        str.pop();\\n                        right[index]=i;\\n                    }\\n                    else if(number<=nums[i])break;\\n                }\\n                str.push({nums[i],i});\\n            }\\n\\n        }\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(stl.size()==0){\\n                stl.push({nums[i],i});\\n            }\\n            else if(stl.size()!=0){\\n                while(stl.size()!=0){\\n                    auto it=stl.top();\\n                    int number=it.first;\\n                    int index=it.second;\\n                    if(number>nums[i]){\\n                        stl.pop();\\n                        left[index]=i;\\n                    }\\n                    else if(number<=nums[i])break;\\n                }\\n                stl.push({nums[i],i});\\n            }\\n\\n        }\\n    vector<long long>prefix(nums.size()+1,0);\\n    prefix[0]=0;\\n    for(int i=0;i<nums.size();i++){\\n        prefix[i+1]=(prefix[i]+nums[i]);\\n    }\\n    long long int ans=0;\\n    for(int i=0;i<nums.size();i++){\\n        long long curr=(nums[i]*(prefix[right[i]]-prefix[left[i]+1]));\\n        ans=max(ans,curr);\\n    }\\n       \\n    return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720357,
                "title": "nsl-nsr-prefix-sum-solution-easy-java-solution-must-watch-upvote",
                "content": "# Intuition\\n1. Prefix sum : for find the sum of the window\\n2. Stack : very similar to questions like max area in histogram and tapping rainwater.\\n         Find the next smallest element in left and next smallest element in the ryt and calculate min product by considering each element as minimum element. \\n\\nExample:\\nnums = [2, 3, 3, 1, 2];\\n\\nPrefix sum : [0, 2, 5, 8, 9, 11 ]\\nRight : [3, 3, 3, 5, 5]; // NSR\\nLeft : [-1, 0, 0, -1, 3]; // NSL\\n\\nlong s = (prefixsum(right) - prefixsum[left + 1]) * nums[i];\\nans = Math.max(ans, s)\\n\\n(8-0)*2 = 16\\n(8-2)*3 = 18\\n(8-2)*3 = 18\\n(11 - 0)*1 = 11\\n(11 - 8)*2 = 6\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long sum[] = new long[n+1];\\n        long s = 0;\\n\\n        for(int i = 1; i <= nums.length; i++){ \\n            sum[i] = sum[i-1] + nums[i-1];\\n        }\\n\\n        int mod = 1000000000 + 7;\\n\\n        int[] left = new int[n]; // smallest on the left\\n        int[] ryt = new int[n]; // smallest on the ryt\\n        Stack<Integer> st = new Stack<>();\\n\\n        // first min in left\\n        for(int i = 0; i < n; i++){\\n            while(!st.isEmpty() && nums[i] <= nums[st.peek()]){\\n                st.pop();\\n            }\\n            if(st.isEmpty()){\\n                left[i] = -1;\\n            }\\n            else{\\n                left[i] = st.peek();\\n            }\\n            st.add(i);\\n        }\\n\\n        st.clear();\\n        // first min in ryt\\n        for(int i = n-1; i>=0 ; i--){\\n            while(!st.isEmpty() && nums[i] <= nums[st.peek()]){\\n                st.pop();\\n            }\\n            if(st.isEmpty()){\\n                ryt[i] = n;\\n            }\\n            else{\\n                ryt[i] = st.peek();\\n            }\\n            st.add(i);\\n        }\\n\\n        long max = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            int l = left[i];\\n            int r = ryt[i];\\n\\n            long temp_s = sum[r] - sum[l + 1];\\n            long pro = temp_s * nums[i];\\n            max = Math.max(max, pro);\\n        }\\n\\n        return (int)(max % mod);\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long sum[] = new long[n+1];\\n        long s = 0;\\n\\n        for(int i = 1; i <= nums.length; i++){ \\n            sum[i] = sum[i-1] + nums[i-1];\\n        }\\n\\n        int mod = 1000000000 + 7;\\n\\n        int[] left = new int[n]; // smallest on the left\\n        int[] ryt = new int[n]; // smallest on the ryt\\n        Stack<Integer> st = new Stack<>();\\n\\n        // first min in left\\n        for(int i = 0; i < n; i++){\\n            while(!st.isEmpty() && nums[i] <= nums[st.peek()]){\\n                st.pop();\\n            }\\n            if(st.isEmpty()){\\n                left[i] = -1;\\n            }\\n            else{\\n                left[i] = st.peek();\\n            }\\n            st.add(i);\\n        }\\n\\n        st.clear();\\n        // first min in ryt\\n        for(int i = n-1; i>=0 ; i--){\\n            while(!st.isEmpty() && nums[i] <= nums[st.peek()]){\\n                st.pop();\\n            }\\n            if(st.isEmpty()){\\n                ryt[i] = n;\\n            }\\n            else{\\n                ryt[i] = st.peek();\\n            }\\n            st.add(i);\\n        }\\n\\n        long max = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            int l = left[i];\\n            int r = ryt[i];\\n\\n            long temp_s = sum[r] - sum[l + 1];\\n            long pro = temp_s * nums[i];\\n            max = Math.max(max, pro);\\n        }\\n\\n        return (int)(max % mod);\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671556,
                "title": "monotone-stack-prefix-sum-time-o-n-space-o-n",
                "content": "class Solution(object):\\n    def maxSumMinProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(nums)\\n        \\n        if n == 1:\\n            return (nums[0]*nums[0])%(10**9 + 7)\\n        \\n        \\n        stack = [[0, nums[0]]]\\n        \\n        cur_sum = nums[0]\\n        \\n        res = 0\\n        for i in range(1,n):\\n            \\n            while len(stack) > 0:\\n                if nums[stack[-1][0]] > nums[i]:\\n                    [p_index, p_sum] = stack.pop(-1)\\n                    \\n                    if len(stack) > 0:\\n                        prefix_sum = stack[-1][1]\\n                    else:\\n                        prefix_sum = 0\\n                    \\n                    res = max(res, nums[p_index]*(cur_sum - prefix_sum))\\n                else:\\n                    break\\n            \\n            cur_sum += nums[i]\\n            stack.append([i, cur_sum])\\n        \\n                    \\n        #print stack\\n        prev_sum = 0\\n        \\n        for [p_index, p_sum] in stack:\\n            res = max(res, nums[p_index]*(cur_sum - prev_sum))\\n            prev_sum = p_sum\\n        \\n        #print res\\n        return res%(10**9 + 7)\\n                    \\n                \\n        \\n        \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxSumMinProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(nums)\\n        \\n        if n == 1:\\n            return (nums[0]*nums[0])%(10**9 + 7)\\n        \\n        \\n        stack = [[0, nums[0]]]\\n        \\n        cur_sum = nums[0]\\n        \\n        res = 0\\n        for i in range(1,n):\\n            \\n            while len(stack) > 0:\\n                if nums[stack[-1][0]] > nums[i]:\\n                    [p_index, p_sum] = stack.pop(-1)\\n                    \\n                    if len(stack) > 0:\\n                        prefix_sum = stack[-1][1]\\n                    else:\\n                        prefix_sum = 0\\n                    \\n                    res = max(res, nums[p_index]*(cur_sum - prefix_sum))\\n                else:\\n                    break\\n            \\n            cur_sum += nums[i]\\n            stack.append([i, cur_sum])\\n        \\n                    \\n        #print stack\\n        prev_sum = 0\\n        \\n        for [p_index, p_sum] in stack:\\n            res = max(res, nums[p_index]*(cur_sum - prev_sum))\\n            prev_sum = p_sum\\n        \\n        #print res\\n        return res%(10**9 + 7)\\n                    \\n                \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3663321,
                "title": "nsl-nsr-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nsl;\\n        vector<int> nsr;\\n        stack<int> s;\\n        for (int i = 0; i < n; i++) {\\n            while (!s.empty() && nums[s.top()] >= nums[i]) {\\n                s.pop();\\n            }\\n            if (s.empty()) {\\n                nsl.push_back(-1);\\n            } else {\\n                nsl.push_back(s.top());\\n            }\\n            s.push(i);\\n        }\\n        while (!s.empty()) {\\n            s.pop();\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.empty() && nums[s.top()] >= nums[i]) {\\n                s.pop();\\n            }\\n            if (s.empty()) {\\n                nsr.push_back(n);\\n            } else {\\n                nsr.push_back(s.top());\\n            }\\n            s.push(i);\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n        vector<long long> pre(n + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            pre[i] = pre[i - 1] + nums[i - 1];\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n          ans = max(ans,(nums[i]) * (pre[nsr[i]] - pre[nsl[i] + 1]));\\n        }\\n        return (ans % mod);\\n    }\\n};\\n\\n     \\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nsl;\\n        vector<int> nsr;\\n        stack<int> s;\\n        for (int i = 0; i < n; i++) {\\n            while (!s.empty() && nums[s.top()] >= nums[i]) {\\n                s.pop();\\n            }\\n            if (s.empty()) {\\n                nsl.push_back(-1);\\n            } else {\\n                nsl.push_back(s.top());\\n            }\\n            s.push(i);\\n        }\\n        while (!s.empty()) {\\n            s.pop();\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!s.empty() && nums[s.top()] >= nums[i]) {\\n                s.pop();\\n            }\\n            if (s.empty()) {\\n                nsr.push_back(n);\\n            } else {\\n                nsr.push_back(s.top());\\n            }\\n            s.push(i);\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n        vector<long long> pre(n + 1, 0);\\n        for (int i = 1; i <= n; i++) {\\n            pre[i] = pre[i - 1] + nums[i - 1];\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n          ans = max(ans,(nums[i]) * (pre[nsr[i]] - pre[nsl[i] + 1]));\\n        }\\n        return (ans % mod);\\n    }\\n};\\n\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625373,
                "title": "my-solutions",
                "content": "**1. Use the monotonously-increasing stack**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int maxSumMinProduct(const vector<int> &nums) {\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(nums.size());\\n    long long presums[n + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + nums[i];\\n    }\\n\\n    int left[n];\\n    memset(left, 0, sizeof(left));\\n    int right[n];\\n    fill(right, right + n, n);\\n    /**\\n     * a monotonously-increasing stack is employed\\n     * whose element is the index of the vector `nums`\\n     */\\n    stack<int> st;\\n    for (int i = 0; i < n; ++i) {\\n      while (!st.empty() && nums[st.top()] > nums[i]) {\\n        right[st.top()] = i;\\n        st.pop();\\n      }\\n      if (!st.empty()) {\\n        left[i] = st.top() + 1;\\n      }\\n      st.emplace(i);\\n    }\\n    \\n    long long ret = numeric_limits<long long>::min();\\n    for (int i = 0; i < n; ++i) {\\n      ret = max(ret, static_cast<long long>(nums[i]) * (presums[right[i]] - presums[left[i]]));\\n    }\\n    return static_cast<int>(ret % mod);\\n  }\\n};\\n```\\n**2. Calculate the left boundary and the right boundary for every element**\\n```\\nclass Solution {\\n public:\\n  int maxSumMinProduct(const vector<int> &nums) {\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(nums.size());\\n    long long presums[n + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + nums[i];\\n    }\\n\\n    int left[n];\\n    memset(left, 0, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      left[i] = i;\\n      while (left[i] > 0 && nums[left[i] - 1] >= nums[i]) {\\n        left[i] = left[left[i] - 1];\\n      }\\n    }\\n    \\n    int right[n];\\n    memset(right, 0, sizeof(right));\\n    for (int i = n - 1; i > -1; --i) {\\n      right[i] = i;\\n      while (right[i] + 1 < n && nums[right[i] + 1] >= nums[i]) {\\n        right[i] = right[right[i] + 1];\\n      }\\n    }\\n    \\n    long long ret = numeric_limits<long long>::min();\\n    for (int i = 0; i < n; ++i) {\\n      ret = max(ret, static_cast<long long>(nums[i]) * (presums[right[i] + 1] - presums[left[i]]));\\n    }\\n    return static_cast<int>(ret % mod);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int maxSumMinProduct(const vector<int> &nums) {\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(nums.size());\\n    long long presums[n + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + nums[i];\\n    }\\n\\n    int left[n];\\n    memset(left, 0, sizeof(left));\\n    int right[n];\\n    fill(right, right + n, n);\\n    /**\\n     * a monotonously-increasing stack is employed\\n     * whose element is the index of the vector `nums`\\n     */\\n    stack<int> st;\\n    for (int i = 0; i < n; ++i) {\\n      while (!st.empty() && nums[st.top()] > nums[i]) {\\n        right[st.top()] = i;\\n        st.pop();\\n      }\\n      if (!st.empty()) {\\n        left[i] = st.top() + 1;\\n      }\\n      st.emplace(i);\\n    }\\n    \\n    long long ret = numeric_limits<long long>::min();\\n    for (int i = 0; i < n; ++i) {\\n      ret = max(ret, static_cast<long long>(nums[i]) * (presums[right[i]] - presums[left[i]]));\\n    }\\n    return static_cast<int>(ret % mod);\\n  }\\n};\\n```\n```\\nclass Solution {\\n public:\\n  int maxSumMinProduct(const vector<int> &nums) {\\n    constexpr int mod = 1000000007;\\n    const int n = static_cast<int>(nums.size());\\n    long long presums[n + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + nums[i];\\n    }\\n\\n    int left[n];\\n    memset(left, 0, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      left[i] = i;\\n      while (left[i] > 0 && nums[left[i] - 1] >= nums[i]) {\\n        left[i] = left[left[i] - 1];\\n      }\\n    }\\n    \\n    int right[n];\\n    memset(right, 0, sizeof(right));\\n    for (int i = n - 1; i > -1; --i) {\\n      right[i] = i;\\n      while (right[i] + 1 < n && nums[right[i] + 1] >= nums[i]) {\\n        right[i] = right[right[i] + 1];\\n      }\\n    }\\n    \\n    long long ret = numeric_limits<long long>::min();\\n    for (int i = 0; i < n; ++i) {\\n      ret = max(ret, static_cast<long long>(nums[i]) * (presums[right[i] + 1] - presums[left[i]]));\\n    }\\n    return static_cast<int>(ret % mod);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567081,
                "title": "easy-understandable-solution-using-monotonic-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind next minimum element for a particular element using stack for both back and forward direction. Now the elements in between the next minimum and the current element will all be greater than the current element so in that case minimum value will be the current element. So for the answer we can simply calculate the sum between next min element from back and forward(excluding both) using suffix or prefix sum and maximize the product for the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed suffix sum for calculation regarding sum, vector named back for storing next min element when iterating from back and front for storing next min element while iterating from front and sum for storing the sum for each element. Storing maximum product in res\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size(), mod = 1000000007;\\n        vector<long long>back(n, 0), front(n, 0), suffix(n+1, 0);\\n        vector<long long>sum(n, 0);\\n        stack<long long>s;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s.empty() && nums[s.top()] >= nums[i])\\n            {\\n                s.pop();\\n            }\\n\\n            if(s.empty())back[i] = n;\\n            else back[i] = s.top();\\n\\n            s.push(i);\\n            suffix[i] = (suffix[i+1] + nums[i]);\\n        }\\n        \\n        long long res = 0;\\n        while(!s.empty())s.pop();\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && nums[s.top()] >= nums[i])\\n            {\\n                s.pop();\\n            }\\n\\n            if(s.empty())front[i] = -1;\\n            else front[i] = s.top();\\n            \\n            s.push(i);\\n            sum[i] = nums[i]*(suffix[front[i]+1] - suffix[back[i]]);\\n            res = max(res, sum[i]);\\n        }\\n        return res%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size(), mod = 1000000007;\\n        vector<long long>back(n, 0), front(n, 0), suffix(n+1, 0);\\n        vector<long long>sum(n, 0);\\n        stack<long long>s;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s.empty() && nums[s.top()] >= nums[i])\\n            {\\n                s.pop();\\n            }\\n\\n            if(s.empty())back[i] = n;\\n            else back[i] = s.top();\\n\\n            s.push(i);\\n            suffix[i] = (suffix[i+1] + nums[i]);\\n        }\\n        \\n        long long res = 0;\\n        while(!s.empty())s.pop();\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && nums[s.top()] >= nums[i])\\n            {\\n                s.pop();\\n            }\\n\\n            if(s.empty())front[i] = -1;\\n            else front[i] = s.top();\\n            \\n            s.push(i);\\n            sum[i] = nums[i]*(suffix[front[i]+1] - suffix[back[i]]);\\n            res = max(res, sum[i]);\\n        }\\n        return res%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545547,
                "title": "solution-based-on-stack-prefixsum-easily-understandable-code-c-solution",
                "content": "# Intuition\\n After Solving Below Problems This question becomes super easy\\nhttps://leetcode.com/problems/sum-of-subarray-ranges\\nhttps://leetcode.com/problems/sum-of-subarray-minimums\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>nextMin(n,n),previousMin(n,-1);\\n       vector<long long>prefixSum(n,0),suffixSum(n,0);\\n        prefixSum[0]=nums[0];\\n        suffixSum[n-1]=nums[n-1];\\n        for(int i=1,j=n-2;i<n;i++,j--)\\n        {\\n           prefixSum[i]=(long long)prefixSum[i]+(prefixSum[i-1]+nums[i]);\\n           suffixSum[j]=(long long)suffixSum[j]+(suffixSum[j+1]+nums[j]);\\n        }\\n        stack<int>s;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty()&&nums[i]<=nums[s.top()])\\n            {\\n                nextMin[s.top()]=i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty()) s.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s.empty()&&nums[i]<nums[s.top()])\\n            {\\n                previousMin[s.top()]=i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        long long  minProduct=0,subarraySum=0,mod=1e9+7;\\n        for(int i=0;i<n;i++)\\n        {\\n            subarraySum=prefixSum[n-1];\\n            if(previousMin[i]!=-1)\\n            {\\n                subarraySum-=prefixSum[previousMin[i]];\\n            }\\n            if(nextMin[i]!=n)\\n            {\\n               subarraySum-=suffixSum[nextMin[i]];\\n\\n            }\\n            minProduct=max(minProduct,subarraySum*nums[i]);\\n        }\\n        return minProduct%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>nextMin(n,n),previousMin(n,-1);\\n       vector<long long>prefixSum(n,0),suffixSum(n,0);\\n        prefixSum[0]=nums[0];\\n        suffixSum[n-1]=nums[n-1];\\n        for(int i=1,j=n-2;i<n;i++,j--)\\n        {\\n           prefixSum[i]=(long long)prefixSum[i]+(prefixSum[i-1]+nums[i]);\\n           suffixSum[j]=(long long)suffixSum[j]+(suffixSum[j+1]+nums[j]);\\n        }\\n        stack<int>s;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty()&&nums[i]<=nums[s.top()])\\n            {\\n                nextMin[s.top()]=i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty()) s.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s.empty()&&nums[i]<nums[s.top()])\\n            {\\n                previousMin[s.top()]=i;\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        long long  minProduct=0,subarraySum=0,mod=1e9+7;\\n        for(int i=0;i<n;i++)\\n        {\\n            subarraySum=prefixSum[n-1];\\n            if(previousMin[i]!=-1)\\n            {\\n                subarraySum-=prefixSum[previousMin[i]];\\n            }\\n            if(nextMin[i]!=n)\\n            {\\n               subarraySum-=suffixSum[nextMin[i]];\\n\\n            }\\n            minProduct=max(minProduct,subarraySum*nums[i]);\\n        }\\n        return minProduct%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527058,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) \\n    {\\n        int i,n;\\n        n=nums.size();\\n\\n        vector<long long> sum(n+1);\\n        long long ans,mod;\\n        ans=0;\\n        mod=1e9+7;\\n\\n        sum[0]=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum[i+1]=sum[i]+nums[i];\\n        } \\n\\n        vector<int> low(n,-1),high(n,-1);\\n        stack<int> s1,s2;\\n\\n        for(i=n-1;i>=0;i--)\\n        {\\n            while(!s1.empty() && nums[s1.top()]>nums[i])\\n            {\\n                s1.pop();\\n            }\\n\\n            if(!s1.empty())\\n            {\\n                high[i]=s1.top();\\n            }\\n\\n            s1.push(i);\\n        }\\n\\n        for(i=0;i<n;i++)\\n        {\\n            while(!s2.empty() && nums[s2.top()]>=nums[i])\\n            {\\n                s2.pop();\\n            }\\n\\n            if(!s2.empty())\\n            {\\n                low[i]=s2.top();\\n            }\\n\\n            s2.push(i);\\n        }\\n\\n        for(i=0;i<n;i++)\\n        {\\n            low[i]=low[i]==-1?0:low[i]+1;\\n            high[i]=high[i]==-1?n-1:high[i]-1;\\n\\n            ans=max(ans,1LL*nums[i]*(sum[high[i]+1]-sum[low[i]]));\\n        }\\n\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) \\n    {\\n        int i,n;\\n        n=nums.size();\\n\\n        vector<long long> sum(n+1);\\n        long long ans,mod;\\n        ans=0;\\n        mod=1e9+7;\\n\\n        sum[0]=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum[i+1]=sum[i]+nums[i];\\n        } \\n\\n        vector<int> low(n,-1),high(n,-1);\\n        stack<int> s1,s2;\\n\\n        for(i=n-1;i>=0;i--)\\n        {\\n            while(!s1.empty() && nums[s1.top()]>nums[i])\\n            {\\n                s1.pop();\\n            }\\n\\n            if(!s1.empty())\\n            {\\n                high[i]=s1.top();\\n            }\\n\\n            s1.push(i);\\n        }\\n\\n        for(i=0;i<n;i++)\\n        {\\n            while(!s2.empty() && nums[s2.top()]>=nums[i])\\n            {\\n                s2.pop();\\n            }\\n\\n            if(!s2.empty())\\n            {\\n                low[i]=s2.top();\\n            }\\n\\n            s2.push(i);\\n        }\\n\\n        for(i=0;i<n;i++)\\n        {\\n            low[i]=low[i]==-1?0:low[i]+1;\\n            high[i]=high[i]==-1?n-1:high[i]-1;\\n\\n            ans=max(ans,1LL*nums[i]*(sum[high[i]+1]-sum[low[i]]));\\n        }\\n\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464657,
                "title": "kotlin-o-n-using-monotonic-stack",
                "content": "# Intuition & Approach\\nSolution is similar to [problen 84](https://leetcode.com/problems/largest-rectangle-in-histogram/) but much harder. For a very good explanation please check [this](https://leetcode.com/problems/maximum-subarray-min-product/solutions/1198896/o-n-monostack-with-picture/?orderBy=most_votes), much better than I can explain..\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxSumMinProduct(nums: IntArray): Int {\\n        val prefix = LongArray(nums.size + 1)\\n        val stack = ArrayDeque<Pair<Int, Long>>()\\n        val mod = 1000000007L\\n        \\n        for (i in nums.indices) {\\n            prefix[i + 1] = prefix[i] + nums[i]\\n        }\\n\\n        var res = 0L\\n        for ((i, n) in nums.withIndex()) {\\n            var start = i\\n\\n            while (stack.isNotEmpty() && stack.peekLast().second > n) {\\n                val (lastStart, value) = stack.removeLast()\\n                val total = prefix[i] - prefix[lastStart]\\n                res = maxOf(res, total * value)\\n                start = lastStart\\n            }\\n\\n            stack.addLast(start to n.toLong())\\n        }\\n        \\n        for ((start, value) in stack) {\\n            val total = prefix[nums.size] - prefix[start]\\n            res = maxOf(res, total * value)\\n        }\\n\\n\\n        return (res % mod).toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    fun maxSumMinProduct(nums: IntArray): Int {\\n        val prefix = LongArray(nums.size + 1)\\n        val stack = ArrayDeque<Pair<Int, Long>>()\\n        val mod = 1000000007L\\n        \\n        for (i in nums.indices) {\\n            prefix[i + 1] = prefix[i] + nums[i]\\n        }\\n\\n        var res = 0L\\n        for ((i, n) in nums.withIndex()) {\\n            var start = i\\n\\n            while (stack.isNotEmpty() && stack.peekLast().second > n) {\\n                val (lastStart, value) = stack.removeLast()\\n                val total = prefix[i] - prefix[lastStart]\\n                res = maxOf(res, total * value)\\n                start = lastStart\\n            }\\n\\n            stack.addLast(start to n.toLong())\\n        }\\n        \\n        for ((start, value) in stack) {\\n            val total = prefix[nums.size] - prefix[start]\\n            res = maxOf(res, total * value)\\n        }\\n\\n\\n        return (res % mod).toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447290,
                "title": "java-closest-left-minimum-closest-right-minimum",
                "content": "```\\nclass Solution {\\n    class Entry{\\n        int lMin;\\n        int rMin;\\n        Entry(int lM, int rM){\\n            lMin=lM;\\n            rMin=rM;\\n        }\\n    }\\n    int n;\\n    long[] prefSum;\\n    public int maxSumMinProduct(int[] nums) {\\n        n=nums.length;\\n        prefSum=new long[n];\\n        prefSum[0]=nums[0];\\n        for(int i=1; i<n; i++){\\n            prefSum[i]+=prefSum[i-1]+nums[i];\\n        }\\n        Entry[] min=new Entry[n]; \\n        Stack<Integer> st=new Stack<Integer>();\\n        for(int i=0; i<n; i++){\\n            while(!st.empty() && nums[i]<nums[st.peek()]){\\n                min[st.pop()]=new Entry(0, i-1);\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty()){\\n            min[st.pop()]=new Entry(0, n-1);\\n        }\\n        st=new Stack<Integer>();\\n        for(int i=n-1; i>=0; i--){\\n            while(!st.empty() && nums[i]<nums[st.peek()]){\\n                min[st.pop()].lMin=i+1;\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty()){\\n            min[st.pop()].lMin=0;\\n        }\\n        long ans=0;\\n        for(int i=0; i<n; i++){\\n            long sum=prefSum[min[i].rMin];\\n            if(min[i].lMin>0){\\n                sum-=prefSum[min[i].lMin-1];\\n            }\\n            long prod=sum*nums[i];\\n            ans=Math.max(ans, prod);\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    class Entry{\\n        int lMin;\\n        int rMin;\\n        Entry(int lM, int rM){\\n            lMin=lM;\\n            rMin=rM;\\n        }\\n    }\\n    int n;\\n    long[] prefSum;\\n    public int maxSumMinProduct(int[] nums) {\\n        n=nums.length;\\n        prefSum=new long[n];\\n        prefSum[0]=nums[0];\\n        for(int i=1; i<n; i++){\\n            prefSum[i]+=prefSum[i-1]+nums[i];\\n        }\\n        Entry[] min=new Entry[n]; \\n        Stack<Integer> st=new Stack<Integer>();\\n        for(int i=0; i<n; i++){\\n            while(!st.empty() && nums[i]<nums[st.peek()]){\\n                min[st.pop()]=new Entry(0, i-1);\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty()){\\n            min[st.pop()]=new Entry(0, n-1);\\n        }\\n        st=new Stack<Integer>();\\n        for(int i=n-1; i>=0; i--){\\n            while(!st.empty() && nums[i]<nums[st.peek()]){\\n                min[st.pop()].lMin=i+1;\\n            }\\n            st.push(i);\\n        }\\n        while(!st.empty()){\\n            min[st.pop()].lMin=0;\\n        }\\n        long ans=0;\\n        for(int i=0; i<n; i++){\\n            long sum=prefSum[min[i].rMin];\\n            if(min[i].lMin>0){\\n                sum-=prefSum[min[i].lMin-1];\\n            }\\n            long prod=sum*nums[i];\\n            ans=Math.max(ans, prod);\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406732,
                "title": "o-n-one-sweep-solution-with-explanation",
                "content": "# Intuition\\nThis problem is very similar to https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/3333607/c-concise-sweeping-solution/\\n\\nSimilar to the above problem, you want to find the next smallest value to the left and to the right for a given index.\\n\\n# Approach\\nAs we sweep through nums, we maintain a stack with indices with an invariant: stack[i] < stack[j] for i < j. \\n\\nWith this, stack[i] is the left boundary of stack[i + 1] because stack[i] is the next smaller element to the left for stack[i + 1]. \\n\\nAdditionally, if we come across a value x where x < stack.top(), this is the right boundary for stack.top().\\n\\nKeeping the invariant, we sweep through the nums vector. \\n\\n### pSum\\nBecause this problem deals with partial sum, we precompute pSum at the beginning of the function to use it in O(1) time.\\n\\n# Complexity\\n- Time complexity: O(n)\\nEach element in nums is pushed and popped exactly once in inc.\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        const int MOD = 1e9 + 7;\\n        nums.push_back(0);\\n\\n        vector<long long> pSum(nums.size() + 1, 0);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            pSum[i + 1] = pSum[i] + nums[i];\\n        }\\n\\n        long long ans = 0;\\n        stack<int> inc;\\n        for (int right = 0; right < nums.size(); ++right) {\\n            while (!inc.empty() && nums[inc.top()] >= nums[right]) {\\n                int min = nums[inc.top()];\\n                inc.pop();\\n\\n                int left = -1;\\n                if (!inc.empty()) {\\n                    left = inc.top();\\n                }\\n\\n                ans = max(ans, (pSum[right] - pSum[left + 1]) * min);\\n            }\\n\\n            inc.push(right);\\n        }\\n\\n        return ans % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        const int MOD = 1e9 + 7;\\n        nums.push_back(0);\\n\\n        vector<long long> pSum(nums.size() + 1, 0);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            pSum[i + 1] = pSum[i] + nums[i];\\n        }\\n\\n        long long ans = 0;\\n        stack<int> inc;\\n        for (int right = 0; right < nums.size(); ++right) {\\n            while (!inc.empty() && nums[inc.top()] >= nums[right]) {\\n                int min = nums[inc.top()];\\n                inc.pop();\\n\\n                int left = -1;\\n                if (!inc.empty()) {\\n                    left = inc.top();\\n                }\\n\\n                ans = max(ans, (pSum[right] - pSum[left + 1]) * min);\\n            }\\n\\n            inc.push(right);\\n        }\\n\\n        return ans % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403691,
                "title": "9-11-lines-in-python-beats-96-27",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        stack, res = deque(), 0\\n        for n in nums + [-inf]:\\n            s = 0\\n            while stack and stack[-1][0] > n:\\n                stack[-1][1] += s\\n                v, s = stack.pop()\\n                res = max(res, v*s)\\n            stack.append([n, n + s])\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        stack, res = deque(), 0\\n        for n in nums + [-inf]:\\n            s = 0\\n            while stack and stack[-1][0] > n:\\n                stack[-1][1] += s\\n                v, s = stack.pop()\\n                res = max(res, v*s)\\n            stack.append([n, n + s])\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400164,
                "title": "using-prev-smaller-and-next-smaller-and-prefix-sum",
                "content": "class Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int mod=1e9+7;\\n        stack<pair<int,pair<int,int>>>st;\\n         int n=nums.size();\\n        vector<long long>ans(n,0),ans1(n,0);\\n       \\n        for(int i=n-1;i>=0;i--){\\n            if(st.size()==0){\\n                st.push({nums[i],{n,i}});\\n            }\\n            else{\\n                 if(nums[i]>st.top().first){\\n                     st.push({nums[i],{st.top().second.second,i}});\\n                 }\\n                else{\\n                    while(st.size()>0&&nums[i]<=st.top().first){\\n                        int id=st.top().second.second;\\n                        int id1=st.top().second.first;\\n                        ans[id]=id1;\\n                        st.pop();\\n                    }\\n                    if(st.size()==0){\\n                        st.push({nums[i],{n,i}});\\n                    }\\n                    else{\\n                              \\n                        int id=st.top().second.second;\\n                        st.push({nums[i],{id,i}});\\n                    \\n                    \\n                    }\\n                }\\n                }\\n            }\\n        \\n        \\n                     while(st.size()>0){\\n                        int id=st.top().second.first;\\n                        int id1=st.top().second.second;\\n                        ans[id1]=id;\\n                        st.pop();\\n                    }\\n        \\n        \\n                     for(int i=0;i<n;i++){\\n            if(st.size()==0){\\n                st.push({nums[i],{-1,i}});\\n            }\\n            else{\\n                 if(nums[i]>st.top().first){\\n                     st.push({nums[i],{st.top().second.second,i}});\\n                 }\\n                else{\\n                    while(st.size()>0&&nums[i]<=st.top().first){\\n                        int id=st.top().second.second;\\n                        int id1=st.top().second.first;\\n                        ans1[id]=id1;\\n                        st.pop();\\n                    }\\n                    if(st.size()==0){\\n                        st.push({nums[i],{-1,i}});\\n                    }\\n                    else{\\n                              \\n                        int id=st.top().second.second;\\n                        st.push({nums[i],{id,i}});\\n                    \\n                    \\n                    }\\n                }\\n                }\\n            }\\n        \\n        \\n        \\n                     while(st.size()>0){\\n                        int id=st.top().second.first;\\n                        int id1=st.top().second.second;\\n                        ans1[id1]=id;\\n                        st.pop();\\n                     }\\n\\n\\n         vector<long long>pre;\\n                  long long total=0;\\n                   for(int i=0;i<n;i++){\\n                       total+=nums[i];\\n                       total=(total);\\n                       pre.push_back(total);\\n                   }\\n        \\n                   long long res=0;\\n        \\n        \\n        \\n                    for(int i=0;i<n;i++){\\n                      long long left=ans1[i];\\n                      long long right=ans[i];\\n                       if(right<=n-1&&nums[right]==nums[i])right++;\\n                        if(left>=0&&nums[left]==nums[i])left--;\\n                         left++;\\n                         if(left==0){\\n                             long long val=pre[right-1];\\n                             val=(val*1ll*nums[i]);\\n                             res=max(res,val);\\n                         }\\n                         else{\\n                             long long val=(pre[right-1]-pre[left-1]);\\n                             val=(val*1ll*nums[i]);\\n                             res=max(res,val);\\n                         }\\n                        \\n                        \\n                    }\\n                     \\n                      return res%mod;\\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int mod=1e9+7;\\n        stack<pair<int,pair<int,int>>>st;\\n         int n=nums.size();\\n        vector<long long>ans(n,0),ans1(n,0);\\n       \\n        for(int i=n-1;i>=0;i--){\\n            if(st.size()==0){\\n                st.push({nums[i],{n,i}",
                "codeTag": "Java"
            },
            {
                "id": 3352772,
                "title": "java-solution-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long max = Long.MIN_VALUE;\\n        long[] psum = new long[n+1]; // prefix sum\\n        for(int i = 0; i < n; i++){\\n            psum[i+1] = psum[i] + nums[i];\\n        }\\n        int[] NSEL = smallerOnLeft(nums); // next smaller element on left\\n        int[] NSER = smallerOnRight(nums); // next smaller element on right\\n        for(int i = 0; i < n; i++){\\n            long min = nums[i];\\n            int lr = NSEL[i];// left range\\n            int rr = NSER[i];// right range\\n            long sum = psum[rr] - psum[lr+1];\\n            long minProduct = sum * min;\\n            max = Math.max(minProduct,max);\\n        }\\n        return (int)(max % 1000000007);\\n\\n    }\\n    public int[] smallerOnLeft(int[] arr){\\n        \\n    int[] lb = new int[arr.length]; // nse on the left\\n    Stack<Integer> st = new Stack<>();\\n\\n    st.push(0);\\n    lb[0] = -1;\\n    for (int i = 1; i < arr.length; i++) {\\n      while (st.size() > 0 && arr[i] <= arr[st.peek()]) {\\n        st.pop();\\n      }\\n\\n      if (st.size() == 0) {\\n        lb[i] = -1;\\n      } else {\\n        lb[i] = st.peek();\\n      }\\n\\n      st.push(i);\\n    }\\n    return lb;\\n\\n    }\\n    public int[] smallerOnRight(int[] arr){\\n        \\n    int[] rb = new int[arr.length]; // nse on the right\\n    Stack<Integer> st = new Stack<>();\\n\\n    st.push(arr.length - 1);\\n    rb[arr.length - 1] = arr.length;\\n    for (int i = arr.length - 2; i >= 0; i--) {\\n      while (st.size() > 0 && arr[i] <= arr[st.peek()]) {\\n        st.pop();\\n      }\\n\\n      if (st.size() == 0) {\\n        rb[i] = arr.length;\\n      } else {\\n        rb[i] = st.peek();\\n      }\\n\\n      st.push(i);\\n    }\\n    return rb;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        long max = Long.MIN_VALUE;\\n        long[] psum = new long[n+1]; // prefix sum\\n        for(int i = 0; i < n; i++){\\n            psum[i+1] = psum[i] + nums[i];\\n        }\\n        int[] NSEL = smallerOnLeft(nums); // next smaller element on left\\n        int[] NSER = smallerOnRight(nums); // next smaller element on right\\n        for(int i = 0; i < n; i++){\\n            long min = nums[i];\\n            int lr = NSEL[i];// left range\\n            int rr = NSER[i];// right range\\n            long sum = psum[rr] - psum[lr+1];\\n            long minProduct = sum * min;\\n            max = Math.max(minProduct,max);\\n        }\\n        return (int)(max % 1000000007);\\n\\n    }\\n    public int[] smallerOnLeft(int[] arr){\\n        \\n    int[] lb = new int[arr.length]; // nse on the left\\n    Stack<Integer> st = new Stack<>();\\n\\n    st.push(0);\\n    lb[0] = -1;\\n    for (int i = 1; i < arr.length; i++) {\\n      while (st.size() > 0 && arr[i] <= arr[st.peek()]) {\\n        st.pop();\\n      }\\n\\n      if (st.size() == 0) {\\n        lb[i] = -1;\\n      } else {\\n        lb[i] = st.peek();\\n      }\\n\\n      st.push(i);\\n    }\\n    return lb;\\n\\n    }\\n    public int[] smallerOnRight(int[] arr){\\n        \\n    int[] rb = new int[arr.length]; // nse on the right\\n    Stack<Integer> st = new Stack<>();\\n\\n    st.push(arr.length - 1);\\n    rb[arr.length - 1] = arr.length;\\n    for (int i = arr.length - 2; i >= 0; i--) {\\n      while (st.size() > 0 && arr[i] <= arr[st.peek()]) {\\n        st.pop();\\n      }\\n\\n      if (st.size() == 0) {\\n        rb[i] = arr.length;\\n      } else {\\n        rb[i] = st.peek();\\n      }\\n\\n      st.push(i);\\n    }\\n    return rb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310414,
                "title": "python-prefix-sum-nsr-nsl",
                "content": "This problem may seem like a hard problem at first but if you break it down, you will understand that the main idea is really simple.\\n\\nSee, we want to find the maximum min-product  of any subarray of given array.\\n\\nSo, doesn\\'t it make sense that if we \"maximize\" the minimum value of a subarray and at the same time we \"maximize\" the number of elements in a subarray, we will get the maximum min-product?\\n\\n\\tThat is, if we have a list  -> [1,2,3,2]\\n\\n    If we take \"1\" as the minimum value, we know we can take the whole list as a subarray\\n\\tBut here, we are only maximizing the count of elements.\\n\\n\\tWe also want to maximize the minimum value in the subarray\\n\\t\\n\\tNow, we have two choices. We can take \"2\" as minimum value in a subarray and in that case,\\n\\tWe have two subarrays to choose from [2,3] and [2,3,2]\\n\\t\\n\\tIt doesn\\'t makes sense to choose [2,3] because we want to maximize the count of elements as well.\\n\\t\\n\\tHence, we always take the maximum possible subarray that we can get by taking a certain element as the minimum element.\\n\\t\\n\\tThe other choice is to take \"3\" as the minimum element. This will maximize the minimum element in subarray\\n\\tBut then again, it will minimize the count of elements because we can have only [3] as the subarray with minimum value as 3.\\n\\t\\n\\tSo, eventually, we see that the subarray that gives us the maximum min-product is [2,3,2]\\n\\nSo, what did we actually do in above case is to take each element of the given list and consider it as the minimum element of the subarray to which it belongs. Now, we want to see how far this subarray can be extended to left and right side such that this element still remains the minimum element.\\n\\nAnd in this way, for every element, we can find the largest subarray with that element as the smallest.\\n\\nNow you may think - How to find how far we can extend any subarray to left and right side?\\n\\nThat\\'s where we use the Nearest Smaller on Left & Nearest Smaller on Right  (NSL and NSR). These are the basic problems that we go through when dealing with stacks so I am assuming you know how to find NSL and NSR in O(N) time.\\n\\nNow, take the above example and let\\'s say our list was like [1,2,3,2,1]\\n\\nEven in this case, the subarray that would give us the maximum min product would be [2,3,2]\\n\\nNow notice one thing. When we take \"2\" as the minimum value in subarray, we can only go till index = 1 on left. Because before that index, we have \"1\" which is smaller than 2. And it is also the \"Nearest smaller element to left\".\\n\\nSimilarly, we can only go till index = 3 on right because after that index, we have \"1\" which is smaller than 2 and it is also the \"Nearest smaller element to right\".\\n\\nAnd now you can see that we can quickly get the left and right bound for any value by simply using the NSL and NSR arrays.\\n\\nSo that solves one part of the problem.\\n\\nThe next part is how to quickly get the sum of a subarray. That\\'s where prefix sum comes into the picture.\\n\\n\\tSuppose, we have [1,2,3,2]\\n\\t\\n\\tPrefix sum will be [1,3,6,8]\\n\\t\\n\\tNow, from this prefix sum, we can find sum of any subarray that starts at any index \"x\" and ends at any index \"y\"\\n\\t\\n\\tBy simply doing -> prefixSum[y] - prefixSum[x - 1]\\n\\t\\n\\tSuppose, we want sum of subarray [2,3,2] which starts at x = 1 and ends at y = 3\\n\\t\\n\\tSo we will do -> prefixSum[3] - prefixSum[1-1]\\n\\t\\n\\tWe get -> 8 - 1 => 7\\n\\t\\n\\tAnd indeed the sum of [2,3,2] is 7\\n\\t\\n\\tDo note that if x is 0 then in that case we cannot just do prefixSum[0 - 1]\\n\\t\\n\\tIn that case, it simply means, there is no left boundary and we can take all elements on left into a subarray.\\n\\t\\n\\tSo in that case, we will do -> prefixSum[y] - 0 or simply prefixSum[y]\\n\\t\\n\\t\\nAnd now, you see this problem became so easy after we broke it down into smaller problems and solved those first.\\n\\n```\\ndef maxSumMinProduct(self, nums: List[int]) -> int:\\n        # Output to return\\n        maxMinProduct = 0\\n        \\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Prefix Sum array\\n        # So that we can get the sum of any subarray in O(1) time\\n        prefixSum = [nums[0]];\\n        for i in range(1,n): prefixSum.append(nums[i] + prefixSum[i - 1])\\n            \\n        # Nearest smaller on left array\\n        NSL = [-1] * n\\n        stack = []\\n        for i in range(n):\\n            # First remove all the useless values\\n            # That is, all the indices in stack with greater or equal values\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            # If stack is not empty, it means top of stack has index of nearest smaller on left\\n            if stack: NSL[i] = stack[-1]\\n                \\n            # Also don\\'t forget to push current index to the stack\\n            stack.append(i)\\n            \\n        # Nearest smaller on right array\\n        NSR = [n] * n\\n        stack = []\\n        for i in range(n - 1, -1, -1):\\n            # First remove all the useless values\\n            # That is, all the indices in stack with greater or equal values\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            # If stack is not empty, it means top of stack has index of nearest smaller on left\\n            if stack: NSR[i] = stack[-1]\\n                \\n            # Also don\\'t forget to push current index to the stack\\n            stack.append(i)\\n            \\n        # Now, once we get the nearest smaller on left and nearest smaller on right array\\n        # We can start with the main logic for this problem\\n        \\n        # For each number in the array\\n        # Consider this number to be the smallest in subarray\\n        # Now, we want to check how far this subarray can extend to left and right\\n        # Such that this number is still the smallest\\n        # For that, we will use NSL and NSR arrays\\n        # Because we can extend our subarray to left till be don\\'t get to the NSL index\\n        # And same for right side\\n        for i in range(n):\\n            # Left boundary\\n            left = NSL[i] + 1\\n            \\n            # Right boundary\\n            right = NSR[i] - 1\\n            \\n            \\n            # What is the subarray sum\\n            # If NSL is -1 for any index, then it means we can take the whole subarray till right boundary\\n            # In other words, in that case, subarray sum will simply be = prefixSum[right]\\n            # That\\'s why below check for left == 0 (since we already incremented left by 1 above)\\n            subarraySum = prefixSum[right] - (0 if left == 0 else prefixSum[left - 1])\\n            \\n            # And finally, update the maxMinProduct if required\\n            maxMinProduct = max(maxMinProduct, nums[i] * subarraySum)\\n            \\n        # Return the maximum min-product modulo 109 + 7\\n        return maxMinProduct % (10**9 + 7)\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\ndef maxSumMinProduct(self, nums: List[int]) -> int:\\n        # Output to return\\n        maxMinProduct = 0\\n        \\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Prefix Sum array\\n        # So that we can get the sum of any subarray in O(1) time\\n        prefixSum = [nums[0]];\\n        for i in range(1,n): prefixSum.append(nums[i] + prefixSum[i - 1])\\n            \\n        # Nearest smaller on left array\\n        NSL = [-1] * n\\n        stack = []\\n        for i in range(n):\\n            # First remove all the useless values\\n            # That is, all the indices in stack with greater or equal values\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            # If stack is not empty, it means top of stack has index of nearest smaller on left\\n            if stack: NSL[i] = stack[-1]\\n                \\n            # Also don\\'t forget to push current index to the stack\\n            stack.append(i)\\n            \\n        # Nearest smaller on right array\\n        NSR = [n] * n\\n        stack = []\\n        for i in range(n - 1, -1, -1):\\n            # First remove all the useless values\\n            # That is, all the indices in stack with greater or equal values\\n            while stack and nums[stack[-1]] >= nums[i]: stack.pop()\\n                \\n            # If stack is not empty, it means top of stack has index of nearest smaller on left\\n            if stack: NSR[i] = stack[-1]\\n                \\n            # Also don\\'t forget to push current index to the stack\\n            stack.append(i)\\n            \\n        # Now, once we get the nearest smaller on left and nearest smaller on right array\\n        # We can start with the main logic for this problem\\n        \\n        # For each number in the array\\n        # Consider this number to be the smallest in subarray\\n        # Now, we want to check how far this subarray can extend to left and right\\n        # Such that this number is still the smallest\\n        # For that, we will use NSL and NSR arrays\\n        # Because we can extend our subarray to left till be don\\'t get to the NSL index\\n        # And same for right side\\n        for i in range(n):\\n            # Left boundary\\n            left = NSL[i] + 1\\n            \\n            # Right boundary\\n            right = NSR[i] - 1\\n            \\n            \\n            # What is the subarray sum\\n            # If NSL is -1 for any index, then it means we can take the whole subarray till right boundary\\n            # In other words, in that case, subarray sum will simply be = prefixSum[right]\\n            # That\\'s why below check for left == 0 (since we already incremented left by 1 above)\\n            subarraySum = prefixSum[right] - (0 if left == 0 else prefixSum[left - 1])\\n            \\n            # And finally, update the maxMinProduct if required\\n            maxMinProduct = max(maxMinProduct, nums[i] * subarraySum)\\n            \\n        # Return the maximum min-product modulo 109 + 7\\n        return maxMinProduct % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3294129,
                "title": "mono-stack-w-explanation-of-the-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee code comment for details \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxSumMinProduct(nums: number[]): number {\\n    const prefixSum = Array(nums.length + 1)\\n    prefixSum[0] = 0\\n    for (let i = 1; i < prefixSum.length; i++) {\\n        prefixSum[i] = nums[i - 1] + prefixSum[i - 1]\\n    }\\n    const peek = (stack: number[]) => {\\n        return stack[stack.length - 1]\\n    }\\n\\n    nums.push(0)\\n    let res = 0n\\n    const stack = [] // non-decreasing stack \\n    for (let i = 0; i < nums.length; i++) {\\n        while (stack.length && nums[peek(stack)] > nums[i]) {\\n            const topIndex = stack.pop()\\n            // The stack stores the index instead of actual number,\\n            // because we can always use index to access the number\\n\\n            // Since the stack stores number (that the index refers to) \\n            // in a non-decreasing manner, when \\'topIndex\\' is poped out, \\n            // all the remaining number in the stack are smaller than\\n            // nums[topIndex], and the stack\\'s peak is the FIRST\\n            // number that is smaller than nums[topIndex]\\n            // from right to left. \\n\\n            // Assuming stack\\'s peak is \\'j\\', nums[topIndex] would be \\n            // the smallest number among nums[j+1...i-1].\\n            // To calculate the min-product, use prefixSum array to \\n            // get the prefix sum of nums[j+1...i-1]\\n\\n            // Note that if stack is empty, it means there\\'re no \\n            // numbers smaller than nums[topIndex], and so \\n            // nums[j+1...i-1] becomes nums[...i-1]\\n\\n            const subSum = prefixSum[i] - prefixSum[stack.length ? peek(stack) + 1 : 0]\\n            const bi = BigInt(subSum) * BigInt(nums[topIndex])\\n            if (bi > res) {\\n                res = bi\\n            }\\n        }\\n        stack.push(i)\\n    }\\n    return Number(res % (1000000007n))\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Monotonic Stack"
                ],
                "code": "```\\nfunction maxSumMinProduct(nums: number[]): number {\\n    const prefixSum = Array(nums.length + 1)\\n    prefixSum[0] = 0\\n    for (let i = 1; i < prefixSum.length; i++) {\\n        prefixSum[i] = nums[i - 1] + prefixSum[i - 1]\\n    }\\n    const peek = (stack: number[]) => {\\n        return stack[stack.length - 1]\\n    }\\n\\n    nums.push(0)\\n    let res = 0n\\n    const stack = [] // non-decreasing stack \\n    for (let i = 0; i < nums.length; i++) {\\n        while (stack.length && nums[peek(stack)] > nums[i]) {\\n            const topIndex = stack.pop()\\n            // The stack stores the index instead of actual number,\\n            // because we can always use index to access the number\\n\\n            // Since the stack stores number (that the index refers to) \\n            // in a non-decreasing manner, when \\'topIndex\\' is poped out, \\n            // all the remaining number in the stack are smaller than\\n            // nums[topIndex], and the stack\\'s peak is the FIRST\\n            // number that is smaller than nums[topIndex]\\n            // from right to left. \\n\\n            // Assuming stack\\'s peak is \\'j\\', nums[topIndex] would be \\n            // the smallest number among nums[j+1...i-1].\\n            // To calculate the min-product, use prefixSum array to \\n            // get the prefix sum of nums[j+1...i-1]\\n\\n            // Note that if stack is empty, it means there\\'re no \\n            // numbers smaller than nums[topIndex], and so \\n            // nums[j+1...i-1] becomes nums[...i-1]\\n\\n            const subSum = prefixSum[i] - prefixSum[stack.length ? peek(stack) + 1 : 0]\\n            const bi = BigInt(subSum) * BigInt(nums[topIndex])\\n            if (bi > res) {\\n                res = bi\\n            }\\n        }\\n        stack.push(i)\\n    }\\n    return Number(res % (1000000007n))\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3278029,
                "title": "monotonic-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        auto vl = maxLeft(nums);\\n        reverse(nums.begin(), nums.end());\\n        auto vr = maxLeft(nums);\\n        reverse(nums.begin(), nums.end());\\n        reverse(vr.begin(), vr.end());\\n        long long res = 0;\\n        for(int i=0;i<nums.size();i++) \\n            res = max(res, (vl[i] + vr[i] + nums[i])*nums[i]);\\n        return res % 1000000007;\\n    }\\n\\n    vector<long long> maxLeft(vector<int>& v){\\n        vector<long long> res(v.size()), vsum(1,0);\\n        vector<pair<int,int>> st = {{-1, -1}}; //val, index\\n        for(int i=0;i<v.size();i++){\\n            vsum.push_back(vsum.back()+v[i]);\\n            while(st.back().first >= v[i]) st.pop_back();\\n            res[i] = vsum[i] - vsum[st.back().second+1];\\n            st.emplace_back(v[i], i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        auto vl = maxLeft(nums);\\n        reverse(nums.begin(), nums.end());\\n        auto vr = maxLeft(nums);\\n        reverse(nums.begin(), nums.end());\\n        reverse(vr.begin(), vr.end());\\n        long long res = 0;\\n        for(int i=0;i<nums.size();i++) \\n            res = max(res, (vl[i] + vr[i] + nums[i])*nums[i]);\\n        return res % 1000000007;\\n    }\\n\\n    vector<long long> maxLeft(vector<int>& v){\\n        vector<long long> res(v.size()), vsum(1,0);\\n        vector<pair<int,int>> st = {{-1, -1}}; //val, index\\n        for(int i=0;i<v.size();i++){\\n            vsum.push_back(vsum.back()+v[i]);\\n            while(st.back().first >= v[i]) st.pop_back();\\n            res[i] = vsum[i] - vsum[st.back().second+1];\\n            st.emplace_back(v[i], i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201176,
                "title": "easy-c-solution-using-stacks",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WhatsApp Image 2023-02-18 at 17.43.58.jpeg](https://assets.leetcode.com/users/images/52aab44b-2f0d-4ca6-9cc8-5a11113a99a7_1676722471.0670478.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<long> preFixSum(n), left(n, -1), right(n, n);\\n    preFixSum.push_back(0);\\n    preFixSum[0] = nums[0];\\n    // Getting perfix sum of given array to reduce complexity by avoiding recalculation\\n    for (int i = 1; i < nums.size(); i++)\\n        preFixSum[i] = preFixSum[i - 1] + nums[i];\\n    stack<int> st1, st2;\\n    for (int i = 0; i < n; i++)\\n    {\\n        while (!st1.empty() && nums[i] < nums[st1.top()])\\n        {\\n            right[st1.top()] = i;\\n            st1.pop();\\n        }\\n        st1.push(i);\\n    }\\n\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n        while (!st2.empty() && nums[i] < nums[st2.top()])\\n        {\\n            left[st2.top()] = i;\\n            st2.pop();\\n        }\\n\\n        st2.push(i);\\n    }\\n    // for (auto val : nums)\\n    // {\\n    //     cout << val << \" \";\\n    // }\\n    // cout << endl;\\n    // for (auto val : right)\\n    // {\\n    //     cout << val << \" \";\\n    // }\\n    // cout << endl;\\n    // for (auto val : left)\\n    // {\\n    //     cout << val << \" \";\\n    // }\\n    // cout << endl;\\n    long long ans = 0, mod = 1e9 + 7;\\n\\n    // finally calculating the contribution of each element\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        int lm = left[i];\\n        int rm = right[i];\\n        long long temp = 1ll * nums[i] * (1ll) * (preFixSum[rm - 1] - preFixSum[lm + 1] + nums[lm + 1]);\\n        ans = max(ans, temp);\\n    }\\n\\n    return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<long> preFixSum(n), left(n, -1), right(n, n);\\n    preFixSum.push_back(0);\\n    preFixSum[0] = nums[0];\\n    // Getting perfix sum of given array to reduce complexity by avoiding recalculation\\n    for (int i = 1; i < nums.size(); i++)\\n        preFixSum[i] = preFixSum[i - 1] + nums[i];\\n    stack<int> st1, st2;\\n    for (int i = 0; i < n; i++)\\n    {\\n        while (!st1.empty() && nums[i] < nums[st1.top()])\\n        {\\n            right[st1.top()] = i;\\n            st1.pop();\\n        }\\n        st1.push(i);\\n    }\\n\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n        while (!st2.empty() && nums[i] < nums[st2.top()])\\n        {\\n            left[st2.top()] = i;\\n            st2.pop();\\n        }\\n\\n        st2.push(i);\\n    }\\n    // for (auto val : nums)\\n    // {\\n    //     cout << val << \" \";\\n    // }\\n    // cout << endl;\\n    // for (auto val : right)\\n    // {\\n    //     cout << val << \" \";\\n    // }\\n    // cout << endl;\\n    // for (auto val : left)\\n    // {\\n    //     cout << val << \" \";\\n    // }\\n    // cout << endl;\\n    long long ans = 0, mod = 1e9 + 7;\\n\\n    // finally calculating the contribution of each element\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        int lm = left[i];\\n        int rm = right[i];\\n        long long temp = 1ll * nums[i] * (1ll) * (preFixSum[rm - 1] - preFixSum[lm + 1] + nums[lm + 1]);\\n        ans = max(ans, temp);\\n    }\\n\\n    return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3165864,
                "title": "monotonic-stack",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maxSumMinProduct(_ nums: [Int]) -> Int {\\n        var prefixSum = Array(repeating: 0, count: nums.count + 1)\\n        for i in 0..<nums.count {\\n            prefixSum[i+1] = prefixSum[i] + nums[i]\\n        }\\n\\n        var maxMinProd = Int.min\\n        var minStack = [Int]()\\n        for i in 0...nums.count {\\n            while !minStack.isEmpty && (i == nums.count || nums[i] < nums[minStack.last!]) {\\n                let mid = minStack.removeLast()\\n                let left = minStack.isEmpty ? 0 : minStack.last! + 1\\n                let new = (prefixSum[i] - prefixSum[left]) * nums[mid]\\n                maxMinProd = max(maxMinProd, new)\\n            }\\n            minStack.append(i)\\n        }\\n        return maxMinProd % (Int(pow(10.0, 9.0)) + 7)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSumMinProduct(_ nums: [Int]) -> Int {\\n        var prefixSum = Array(repeating: 0, count: nums.count + 1)\\n        for i in 0..<nums.count {\\n            prefixSum[i+1] = prefixSum[i] + nums[i]\\n        }\\n\\n        var maxMinProd = Int.min\\n        var minStack = [Int]()\\n        for i in 0...nums.count {\\n            while !minStack.isEmpty && (i == nums.count || nums[i] < nums[minStack.last!]) {\\n                let mid = minStack.removeLast()\\n                let left = minStack.isEmpty ? 0 : minStack.last! + 1\\n                let new = (prefixSum[i] - prefixSum[left]) * nums[mid]\\n                maxMinProd = max(maxMinProd, new)\\n            }\\n            minStack.append(i)\\n        }\\n        return maxMinProd % (Int(pow(10.0, 9.0)) + 7)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146527,
                "title": "c",
                "content": "```\\ntypedef unsigned long long ULL ;\\nint maxSumMinProduct(int* nums, int numsSize){\\n    int n= numsSize ;\\n    int* nextSmaller = malloc(n * sizeof(int)) ;\\n    int* prevSmaller = malloc(n * sizeof(int)) ;\\n    int mod = 1e9 + 7 ;\\n    for(int i = 0; i < n; i++){\\n        nextSmaller[i] = n ;\\n        prevSmaller[i] = -1 ;\\n    }\\n    int* stack = malloc(n * sizeof(int)) ;\\n    int s_idx = 0 ;\\n    for(int i = 0; i < n; i++){\\n        while(s_idx > 0 && nums[stack[s_idx-1]] > nums[i]){\\n            nextSmaller[ stack[s_idx-1] ] = i ;\\n            s_idx-- ;\\n        }\\n        stack[s_idx] = i ;\\n        s_idx++ ;\\n    }\\n\\n    s_idx = 0 ;  //clear stack\\n    for(int i = n-1; i >=0; i--){\\n        while(s_idx > 0 && nums[stack[s_idx-1]] > nums[i]){\\n            prevSmaller[ stack[s_idx-1] ] = i ;\\n            s_idx-- ;\\n        }\\n        stack[s_idx] = i ;\\n        s_idx++ ;\\n    }\\n    ULL* presum = malloc(n * sizeof (ULL)) ;\\n    presum[0] = nums[0] ;\\n    for(int i = 1; i < n; i++){\\n        presum[i] = presum[i-1] + nums[i] ; \\n    }\\n    \\n    ULL ans = 0 ;\\n    for(int i = 0; i < n; i++){\\n        ULL sum ;\\n        int a = prevSmaller[i] ;\\n        int b = nextSmaller[i] ;        \\n        sum = presum[b-1] - ((a == -1) ? 0 : presum[a]) ;\\n        sum *= nums[i] ;\\n        ans = fmaxl(ans, sum) ;  //must to use fmaxl : long double fmaxl(long double, long double);   \\n    }\\n            \\n    return ans % mod ;\\n}\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\ntypedef unsigned long long ULL ;\\nint maxSumMinProduct(int* nums, int numsSize){\\n    int n= numsSize ;\\n    int* nextSmaller = malloc(n * sizeof(int)) ;\\n    int* prevSmaller = malloc(n * sizeof(int)) ;\\n    int mod = 1e9 + 7 ;\\n    for(int i = 0; i < n; i++){\\n        nextSmaller[i] = n ;\\n        prevSmaller[i] = -1 ;\\n    }\\n    int* stack = malloc(n * sizeof(int)) ;\\n    int s_idx = 0 ;\\n    for(int i = 0; i < n; i++){\\n        while(s_idx > 0 && nums[stack[s_idx-1]] > nums[i]){\\n            nextSmaller[ stack[s_idx-1] ] = i ;\\n            s_idx-- ;\\n        }\\n        stack[s_idx] = i ;\\n        s_idx++ ;\\n    }\\n\\n    s_idx = 0 ;  //clear stack\\n    for(int i = n-1; i >=0; i--){\\n        while(s_idx > 0 && nums[stack[s_idx-1]] > nums[i]){\\n            prevSmaller[ stack[s_idx-1] ] = i ;\\n            s_idx-- ;\\n        }\\n        stack[s_idx] = i ;\\n        s_idx++ ;\\n    }\\n    ULL* presum = malloc(n * sizeof (ULL)) ;\\n    presum[0] = nums[0] ;\\n    for(int i = 1; i < n; i++){\\n        presum[i] = presum[i-1] + nums[i] ; \\n    }\\n    \\n    ULL ans = 0 ;\\n    for(int i = 0; i < n; i++){\\n        ULL sum ;\\n        int a = prevSmaller[i] ;\\n        int b = nextSmaller[i] ;        \\n        sum = presum[b-1] - ((a == -1) ? 0 : presum[a]) ;\\n        sum *= nums[i] ;\\n        ans = fmaxl(ans, sum) ;  //must to use fmaxl : long double fmaxl(long double, long double);   \\n    }\\n            \\n    return ans % mod ;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3119433,
                "title": "simple-c-solution-stack-prefixsum-o-n",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long>dp(n+1,0);\\n        for(int i=0;i<n;i++){\\n            dp[i+1] = dp[i] + nums[i];\\n        }\\n\\n        stack<long>st;\\n\\n        long ans = 0;\\n        \\n        for(int i=0;i<=n;i++){\\n            while(!st.empty() && (i == n || nums[st.top()] > nums[i])){\\n                int j = st.top();\\n                st.pop();\\n                ans = max(ans,nums[j]*(dp[i] - dp[st.empty() ? 0 : st.top()+1]));\\n            }\\n            st.push(i);\\n        }\\n        int mod = 1e9+7;\\n        return ans%mod;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long>dp(n+1,0);\\n        for(int i=0;i<n;i++){\\n            dp[i+1] = dp[i] + nums[i];\\n        }\\n\\n        stack<long>st;\\n\\n        long ans = 0;\\n        \\n        for(int i=0;i<=n;i++){\\n            while(!st.empty() && (i == n || nums[st.top()] > nums[i])){\\n                int j = st.top();\\n                st.pop();\\n                ans = max(ans,nums[j]*(dp[i] - dp[st.empty() ? 0 : st.top()+1]));\\n            }\\n            st.push(i);\\n        }\\n        int mod = 1e9+7;\\n        return ans%mod;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115820,
                "title": "beginner-friendly-o-n-approach-using-stack",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long int mod=1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        //FIND THE PREFIX SUM FOR FINDING THE SUM OF EACH SUBARRAY\\n        vector<long long int> prefixsum(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            prefixsum[i]=(prefixsum[i-1]+nums[i-1]);\\n        }\\n\\n        //FIND THE MIN VALUE INDEX FROM LEFT\\n        vector<int> mnleft(n+1,-1);\\n        stack<int> left;\\n        for(int i=0;i<n;i++){\\n            while(!left.empty() and nums[left.top()]>=nums[i])\\n                left.pop();\\n            if(!left.empty())\\n                mnleft[i]=left.top();\\n            left.push(i);\\n        }\\n\\n         //FIND THE MIN VALUE INDEX FROM right\\n        vector<int> mnright(n+1,n);\\n        stack<int> right;\\n        for(int i=n-1;i>=0;i--){\\n            while(!right.empty() and nums[right.top()]>=nums[i])\\n                right.pop();\\n            if(!right.empty())\\n                mnright[i]=right.top();\\n            right.push(i);\\n        }\\n        //USE THE FORMULA DERIVED\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            int prev=mnleft[i];\\n            int next=mnright[i];\\n            long long a=(prefixsum[next]-prefixsum[prev+1])*nums[i];\\n            ans=max(ans,a);\\n        }\\n         return ans%mod;\\n    }\\n};\\n//UPVOTE IF U LIKE THE SOLUTION\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long int mod=1e9+7;\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        //FIND THE PREFIX SUM FOR FINDING THE SUM OF EACH SUBARRAY\\n        vector<long long int> prefixsum(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            prefixsum[i]=(prefixsum[i-1]+nums[i-1]);\\n        }\\n\\n        //FIND THE MIN VALUE INDEX FROM LEFT\\n        vector<int> mnleft(n+1,-1);\\n        stack<int> left;\\n        for(int i=0;i<n;i++){\\n            while(!left.empty() and nums[left.top()]>=nums[i])\\n                left.pop();\\n            if(!left.empty())\\n                mnleft[i]=left.top();\\n            left.push(i);\\n        }\\n\\n         //FIND THE MIN VALUE INDEX FROM right\\n        vector<int> mnright(n+1,n);\\n        stack<int> right;\\n        for(int i=n-1;i>=0;i--){\\n            while(!right.empty() and nums[right.top()]>=nums[i])\\n                right.pop();\\n            if(!right.empty())\\n                mnright[i]=right.top();\\n            right.push(i);\\n        }\\n        //USE THE FORMULA DERIVED\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            int prev=mnleft[i];\\n            int next=mnright[i];\\n            long long a=(prefixsum[next]-prefixsum[prev+1])*nums[i];\\n            ans=max(ans,a);\\n        }\\n         return ans%mod;\\n    }\\n};\\n//UPVOTE IF U LIKE THE SOLUTION\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111003,
                "title": "c-easy-stack-prefix-sum",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmaller(vector<int>& nums){\\n        stack<int> st;\\n        int n=nums.size();\\n        vector<int> left(n,-1);\\n        for(int ind=0;ind<n;ind++){\\n            while(!st.empty() && nums[ind]<=nums[st.top()]){\\n                st.pop();\\n            }\\n            if(!st.empty()) left[ind]=st.top();\\n            st.push(ind);\\n        }\\n        return left;\\n    }\\n    vector<int> nextGreater(vector<int>& nums){\\n        stack<int> st;\\n        int n=nums.size();\\n        vector<int> right(n,n);\\n        for(int ind=n-1;ind>=0;ind--){\\n            while(!st.empty() && nums[ind]<=nums[st.top()]){\\n                st.pop();\\n            }\\n            if(!st.empty()) right[ind]=st.top();\\n            st.push(ind);\\n        }\\n        return right;\\n    }\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        //S1 find the prefix sum\\n        vector<long long> prefix;\\n        prefix.push_back(0);\\n        int n=nums.size();\\n        for(int ind=0;ind<n;ind++){\\n            prefix.push_back(prefix.back()+nums[ind]);\\n        }\\n        //make two vectors containing next greater element and next smaller element\\n        vector<int> left=nextSmaller(nums);\\n        vector<int> right=nextGreater(nums);\\n        \\n        //now calculating the min product\\n        long long ans=0,mod=1e9+7;\\n        for(int ind=0;ind<n;ind++){\\n            long long temp=(prefix[right[ind]] - prefix[left[ind] + 1]) * nums[ind];\\n            ans=max(ans,temp);\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmaller(vector<int>& nums){\\n        stack<int> st;\\n        int n=nums.size();\\n        vector<int> left(n,-1);\\n        for(int ind=0;ind<n;ind++){\\n            while(!st.empty() && nums[ind]<=nums[st.top()]){\\n                st.pop();\\n            }\\n            if(!st.empty()) left[ind]=st.top();\\n            st.push(ind);\\n        }\\n        return left;\\n    }\\n    vector<int> nextGreater(vector<int>& nums){\\n        stack<int> st;\\n        int n=nums.size();\\n        vector<int> right(n,n);\\n        for(int ind=n-1;ind>=0;ind--){\\n            while(!st.empty() && nums[ind]<=nums[st.top()]){\\n                st.pop();\\n            }\\n            if(!st.empty()) right[ind]=st.top();\\n            st.push(ind);\\n        }\\n        return right;\\n    }\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        //S1 find the prefix sum\\n        vector<long long> prefix;\\n        prefix.push_back(0);\\n        int n=nums.size();\\n        for(int ind=0;ind<n;ind++){\\n            prefix.push_back(prefix.back()+nums[ind]);\\n        }\\n        //make two vectors containing next greater element and next smaller element\\n        vector<int> left=nextSmaller(nums);\\n        vector<int> right=nextGreater(nums);\\n        \\n        //now calculating the min product\\n        long long ans=0,mod=1e9+7;\\n        for(int ind=0;ind<n;ind++){\\n            long long temp=(prefix[right[ind]] - prefix[left[ind] + 1]) * nums[ind];\\n            ans=max(ans,temp);\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109314,
                "title": "simple-java-short-code-full-algorithm-explained",
                "content": "# Intuition\\nWe will be using prefix sum and stack to find the next smallest integer on left and right\\n\\n# Approach\\n1.We will first find a prefix sum of the array having size(n+1).\\n2.Then we will be initializing 2 stacks one for left min and another for right min.\\n3.We will be using stack to find the next smallest no on the left and on the right and then using the prefix sum we will find the final sum of the window and then multiply wth current element.\\n4.We will do it for each element and the take the maximum of it.\\n5.In the left min if there are no elements on the left we will assign valueto -1 and in right min if there are no values on the right we will assign value to n.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        \\n        //prefix sum\\n        long prefixsum[]=new long[n+1];\\n        for(int i=1;i<=n;i++){\\n            prefixsum[i] = prefixsum[i-1]+nums[i-1];\\n        }\\n\\n        Stack<Integer>st1=new Stack<>();\\n        Stack<Integer>st2=new Stack<>();\\n\\n        int left[]=new int[n];\\n        int right[]=new int[n];\\n        \\n        //left MIN\\n        for(int i=0;i<n;i++){\\n            while(!st1.isEmpty() && nums[i]<=nums[st1.peek()])st1.pop();\\n            if(st1.isEmpty())left[i]=-1;\\n            else left[i]=st1.peek();\\n            st1.push(i);\\n        }\\n        //right MIN\\n        for(int i=n-1;i>=0;i--){\\n            while(!st2.isEmpty() && nums[i]<=nums[st2.peek()])st2.pop();\\n            if(st2.isEmpty())right[i]=n;\\n            else right[i]=st2.peek();\\n            st2.push(i);\\n        }\\n\\n        long max=0;\\n        for(int i=0;i<n;i++){\\n            int l = left[i];\\n            int r = right[i];\\n            long sum = prefixsum[r]-prefixsum[l+1];\\n            long prod = sum*nums[i];\\n            max = Math.max(max,prod);\\n        }\\n        return (int)(max%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n = nums.length;\\n        \\n        //prefix sum\\n        long prefixsum[]=new long[n+1];\\n        for(int i=1;i<=n;i++){\\n            prefixsum[i] = prefixsum[i-1]+nums[i-1];\\n        }\\n\\n        Stack<Integer>st1=new Stack<>();\\n        Stack<Integer>st2=new Stack<>();\\n\\n        int left[]=new int[n];\\n        int right[]=new int[n];\\n        \\n        //left MIN\\n        for(int i=0;i<n;i++){\\n            while(!st1.isEmpty() && nums[i]<=nums[st1.peek()])st1.pop();\\n            if(st1.isEmpty())left[i]=-1;\\n            else left[i]=st1.peek();\\n            st1.push(i);\\n        }\\n        //right MIN\\n        for(int i=n-1;i>=0;i--){\\n            while(!st2.isEmpty() && nums[i]<=nums[st2.peek()])st2.pop();\\n            if(st2.isEmpty())right[i]=n;\\n            else right[i]=st2.peek();\\n            st2.push(i);\\n        }\\n\\n        long max=0;\\n        for(int i=0;i<n;i++){\\n            int l = left[i];\\n            int r = right[i];\\n            long sum = prefixsum[r]-prefixsum[l+1];\\n            long prod = sum*nums[i];\\n            max = Math.max(max,prod);\\n        }\\n        return (int)(max%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108584,
                "title": "same-as-maximum-area-in-histogram-question-c-easy-approach",
                "content": "# Intuition\\nSame as maximum Area in histogram\\n\\n# Approach\\n\\n-> In maximum area of histogram using stack question , we have seen that till which index in left and right , this  current element is less OR equal, (Basically we have to find first less Element in Both left and right and accorging to that we will calculate answer and take maximum). \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int left[n], right[n];\\n        long long int sum[n];\\n        sum[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            sum[i] = sum[i-1]+nums[i];\\n        }\\n        stack<pair<int, int> > s1, s2;\\n        for (int i = 0; i < n; ++i) {\\n            int cnt = 1;\\n            while (!s1.empty() && (s1.top().first) >= nums[i]) {\\n                cnt += s1.top().second;\\n                s1.pop();\\n            }\\n            s1.push({ nums[i], cnt });\\n            left[i] = cnt;\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            int cnt = 1;\\n            while (!s2.empty() && (s2.top().first) > nums[i]) {\\n                cnt += s2.top().second;\\n                s2.pop();\\n            }\\n\\n            s2.push({ nums[i], cnt });\\n            right[i] = cnt;\\n        }\\n        long long int res =0;\\n        for(int i=0;i<n;i++){\\n            int a = i-left[i]+1;\\n            int b = i+right[i]-1;\\n            long long int subArraySum;\\n            if(a>0)\\n                subArraySum = sum[b]-sum[a-1];\\n            else\\n                subArraySum = sum[b];\\n            res = max(res, subArraySum*nums[i]);\\n        }\\n        return res%1000000007;\\n    }\\n};\\n```\\nQuestion Link of Maximum Area in Histogram : https://leetcode.com/problems/largest-rectangle-in-histogram/description/\\n\\n\\nUpvote If like Solution and Relation between this questions.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int left[n], right[n];\\n        long long int sum[n];\\n        sum[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            sum[i] = sum[i-1]+nums[i];\\n        }\\n        stack<pair<int, int> > s1, s2;\\n        for (int i = 0; i < n; ++i) {\\n            int cnt = 1;\\n            while (!s1.empty() && (s1.top().first) >= nums[i]) {\\n                cnt += s1.top().second;\\n                s1.pop();\\n            }\\n            s1.push({ nums[i], cnt });\\n            left[i] = cnt;\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            int cnt = 1;\\n            while (!s2.empty() && (s2.top().first) > nums[i]) {\\n                cnt += s2.top().second;\\n                s2.pop();\\n            }\\n\\n            s2.push({ nums[i], cnt });\\n            right[i] = cnt;\\n        }\\n        long long int res =0;\\n        for(int i=0;i<n;i++){\\n            int a = i-left[i]+1;\\n            int b = i+right[i]-1;\\n            long long int subArraySum;\\n            if(a>0)\\n                subArraySum = sum[b]-sum[a-1];\\n            else\\n                subArraySum = sum[b];\\n            res = max(res, subArraySum*nums[i]);\\n        }\\n        return res%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074191,
                "title": "java-single-monostack-presum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n=nums.length;\\n        long[] presum=new long[1+n];\\n        long mod=(long)1e9+7;\\n        for(int i=1;i<=n;i++){\\n            presum[i]=(nums[i-1]+presum[i-1]);\\n            // System.out.println(presum[i]);\\n        }\\n        \\n        Stack<Integer> stack=new Stack<>();\\n        long max=-1L;\\n        for(int i=0;i<n+1;i++){\\n            while(!stack.isEmpty() && (i==n||nums[i]<=nums[stack.peek()] )){\\n                int indexmin=stack.pop();\\n                int r=i;\\n                int l=stack.isEmpty()? -1:stack.peek();\\n                l++;\\n                long val=presum[r]-presum[l];\\n                \\n                max=Math.max(max,(nums[indexmin]*val));\\n            }\\n            if(i<n){\\n                stack.push(i);\\n            }\\n        }\\n        return (int)(max%mod);\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int n=nums.length;\\n        long[] presum=new long[1+n];\\n        long mod=(long)1e9+7;\\n        for(int i=1;i<=n;i++){\\n            presum[i]=(nums[i-1]+presum[i-1]);\\n            // System.out.println(presum[i]);\\n        }\\n        \\n        Stack<Integer> stack=new Stack<>();\\n        long max=-1L;\\n        for(int i=0;i<n+1;i++){\\n            while(!stack.isEmpty() && (i==n||nums[i]<=nums[stack.peek()] )){\\n                int indexmin=stack.pop();\\n                int r=i;\\n                int l=stack.isEmpty()? -1:stack.peek();\\n                l++;\\n                long val=presum[r]-presum[l];\\n                \\n                max=Math.max(max,(nums[indexmin]*val));\\n            }\\n            if(i<n){\\n                stack.push(i);\\n            }\\n        }\\n        return (int)(max%mod);\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069864,
                "title": "c-begginer-friendly-stack-solution",
                "content": "# Intuition\\nif we take notice of the operation it says we meed to multiply sum of the subarray with the minimum present in that subarray;\\n\\nhence we can store all the possible subarrays candidates in the monotonic increasing stack. \\n\\n# Approach\\nfor each element we say it is the minimum and we try to extend the subarray to the right and to the left ;\\npoint to note is as we are mainting a increasing stack we cannot extend this element to the left beyond top of the stack element.\\n\\nwe can only extend the element to the right of the element;\\n### note \\nwe have written the code in such a way that we are considering the stack element to be the first element in the subarray which we can extend \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n#define ll long long\\nconst int M = 1000000007;\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> psum(n+1, 0);\\n        for(int i=0; i<n; i++){\\n            psum[i+1] = psum[i] + nums[i];\\n        }\\n        ll ans = 0;\\n        stack<pair<ll, ll>> st; // store {start, minval} of the corrosponding subarray;\\n        for(ll i=0; i<n; i++){\\n            ll start = i; //setting the left of the subarrayint which this element is the smallest one;\\n            while(!st.empty() && st.top().second > nums[i]){\\n                //there is the possibility to extend subarray to left in which this element is the minimum \\n//At the same time we have reached the end of subarray in which st.top() is the minimum element \\n                ll minproduct = st.top().second * (psum[i] - psum[st.top().first]); //update ans for st.top();\\n                ans = max(ans, minproduct);\\n                start = st.top().first; //update start of current element;\\n                st.pop();\\n            }\\n            st.push({start, nums[i]});\\n        }\\n\\n        while(!st.empty()){ //all of these elements can be extended to the right till the end of the array;\\n            ll minproduct =( st.top().second * (psum[n] - psum[st.top().first]));\\n            ans = max(ans, minproduct);\\n            st.pop();\\n        }\\n        return (int)(ans%M);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nconst int M = 1000000007;\\nclass Solution {\\npublic:\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> psum(n+1, 0);\\n        for(int i=0; i<n; i++){\\n            psum[i+1] = psum[i] + nums[i];\\n        }\\n        ll ans = 0;\\n        stack<pair<ll, ll>> st; // store {start, minval} of the corrosponding subarray;\\n        for(ll i=0; i<n; i++){\\n            ll start = i; //setting the left of the subarrayint which this element is the smallest one;\\n            while(!st.empty() && st.top().second > nums[i]){\\n                //there is the possibility to extend subarray to left in which this element is the minimum \\n//At the same time we have reached the end of subarray in which st.top() is the minimum element \\n                ll minproduct = st.top().second * (psum[i] - psum[st.top().first]); //update ans for st.top();\\n                ans = max(ans, minproduct);\\n                start = st.top().first; //update start of current element;\\n                st.pop();\\n            }\\n            st.push({start, nums[i]});\\n        }\\n\\n        while(!st.empty()){ //all of these elements can be extended to the right till the end of the array;\\n            ll minproduct =( st.top().second * (psum[n] - psum[st.top().first]));\\n            ans = max(ans, minproduct);\\n            st.pop();\\n        }\\n        return (int)(ans%M);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051623,
                "title": "subarray-sum-stack-explained-python",
                "content": "![image.png](https://assets.leetcode.com/users/images/b814d8cd-236f-4c3c-bde4-aa878c158904_1673722669.0058727.png)\\n\\n**Approach 1**\\nAs we make a non decreasing stack from elements of nums,\\nThe moment some previous element `j` gets popped, we can say that `j` is the minimum element between `j` and `i-1`, `i is current element < j`\\n\\nWhen the larger element `j` gets popped, the sum of the subarray over which `j` was minimum get transferred to the sum of subarray over which `i` is minimum.\\n\\nSo in stack we also keep track of sum of subarray over which the element is mimimum.\\n\\n**Time: O(n)\\nSpace: O(n)**\\n```\\ndef maxSumMinProduct(self, nums: List[int]) -> int:\\n    n = len(nums)\\n\\n    min_prod = 0\\n    stack = []\\n    for i in range(n):\\n        i_sum = 0 #the subarray sum over which i is minimum\\n        while stack and stack[-1][0] >= nums[i]:\\n            j, j_sum = stack.pop()\\n            min_prod = max(min_prod, j*(i_sum + j_sum))\\n            i_sum += j_sum #subarray sum gets transferred to new smaller element\\n        stack.append([nums[i], i_sum + nums[i]])\\n    \\n    c_sum = 0\\n    while stack:\\n        j, j_sum = stack.pop()\\n        c_sum += j_sum\\n        min_prod = max(min_prod, j*c_sum)\\n    return min_prod%(10**9 + 7)\\n```\\n\\n**Approach 2**\\nIn this approach we use stack to find the nearest smaller element to the left and right for each element. \\nAlso need store prefix sum for each subarray sum calculation\\n\\n**Time: O(n)\\nSpace: O(n)**\\n```\\ndef maxSumMinProduct(self, nums: List[int]) -> int:\\n    n = len(nums)\\n\\n    def nextSmaller(iterator, default):\\n        res = [default]*n\\n        stack = []\\n        for i in iterator:\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            if stack: res[i] = stack[-1]\\n            stack.append(i)\\n        return res\\n    \\n    smallerLeft = nextSmaller(range(n), -1)\\n    smallerRight = nextSmaller(reversed(range(n)), n)\\n    prefix = list(accumulate(nums))\\n\\n    min_prod = nums[0]\\n    for i in range(n):\\n        l = smallerLeft[i]; r = smallerRight[i]\\n        subarraySum = prefix[r-1] - (prefix[l] if l>-1 else 0)\\n        min_prod = max(min_prod, subarraySum*nums[i])\\n\\n    return min_prod%(10**9 + 7)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Monotonic Stack",
                    "Prefix Sum"
                ],
                "code": "```\\ndef maxSumMinProduct(self, nums: List[int]) -> int:\\n    n = len(nums)\\n\\n    min_prod = 0\\n    stack = []\\n    for i in range(n):\\n        i_sum = 0 #the subarray sum over which i is minimum\\n        while stack and stack[-1][0] >= nums[i]:\\n            j, j_sum = stack.pop()\\n            min_prod = max(min_prod, j*(i_sum + j_sum))\\n            i_sum += j_sum #subarray sum gets transferred to new smaller element\\n        stack.append([nums[i], i_sum + nums[i]])\\n    \\n    c_sum = 0\\n    while stack:\\n        j, j_sum = stack.pop()\\n        c_sum += j_sum\\n        min_prod = max(min_prod, j*c_sum)\\n    return min_prod%(10**9 + 7)\\n```\n```\\ndef maxSumMinProduct(self, nums: List[int]) -> int:\\n    n = len(nums)\\n\\n    def nextSmaller(iterator, default):\\n        res = [default]*n\\n        stack = []\\n        for i in iterator:\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            if stack: res[i] = stack[-1]\\n            stack.append(i)\\n        return res\\n    \\n    smallerLeft = nextSmaller(range(n), -1)\\n    smallerRight = nextSmaller(reversed(range(n)), n)\\n    prefix = list(accumulate(nums))\\n\\n    min_prod = nums[0]\\n    for i in range(n):\\n        l = smallerLeft[i]; r = smallerRight[i]\\n        subarraySum = prefix[r-1] - (prefix[l] if l>-1 else 0)\\n        min_prod = max(min_prod, subarraySum*nums[i])\\n\\n    return min_prod%(10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3042257,
                "title": "c-solution-using-stack-most-optimized-well-explained-with-example",
                "content": "```\\nclass Solution {\\npublic:\\n    // this problem can be solved by taking each ith element minimum and \\n      // taking longest window considering that ith element minimum in that window\\n    \\n\\t// example : 2 3 3 1 2\\n    vector<int> nsl(vector<int>&nums){\\n        vector<int>ans;\\n        stack<int>s;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(s.size()==0)ans.push_back(-1);    // in case of no small ele in left taking -1\\n            else{\\n                if(nums[s.top()]<nums[i])ans.push_back(s.top());\\n                else{\\n                    while(s.size()>0 && nums[s.top()]>=nums[i])s.pop();\\n                    if(s.size()==0)ans.push_back(-1);\\n                    else ans.push_back(s.top());\\n                }\\n            }\\n            s.push(i);\\n        }\\n      \\n        return ans;\\n    }\\n    \\n    vector<int> nsr(vector<int>&nums){\\n        vector<int>ans;\\n        stack<int>s;\\n        int n=nums.size();\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(s.size()==0)ans.push_back(n);   // in case of no small ele in right taking n\\n            else{\\n                if(nums[s.top()]<nums[i])ans.push_back(s.top());\\n                else{\\n                    while(s.size()>0 && nums[s.top()]>=nums[i])s.pop();\\n                    if(s.size()==0)ans.push_back(n);\\n                    else ans.push_back(s.top());\\n                }\\n            }\\n            s.push(i);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    \\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        int mod=1e9+7;\\n        vector<long long int>pre_sum(n+1,0);\\n        \\n        for(int i=1;i<n+1;i++){\\n            pre_sum[i]=pre_sum[i-1]+nums[i-1];     //prefix sum for subarray range sum\\n        }\\n        // pre_sum: 0 2 5 8 9 11 \\n\\t\\t\\n        vector<int>left = nsl(nums);\\n\\t\\t// -1 0 0 -1 3\\n        vector<int>right = nsr(nums);\\n        //  3 3 3 5 5\\n\\t\\t\\n        long long int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n            long long int sum=(pre_sum[right[i]]-pre_sum[left[i]+1])*nums[i];\\n\\t\\t\\t// here taking left[i]+1 beacause of -1 indexing we used in ngl \\n\\t\\t\\t/*\\n\\t\\t\\t(8-0)*2\\n\\t\\t\\t(8-2)*3\\n\\t\\t\\t(8-2)*3\\n\\t\\t\\t(11-0)*1\\n\\t\\t\\t(11-9)*2\\n\\t\\t\\t*/\\n            ans=max(ans,sum);\\n        }\\n        \\n        ans=ans%mod;\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // this problem can be solved by taking each ith element minimum and \\n      // taking longest window considering that ith element minimum in that window\\n    \\n\\t// example : 2 3 3 1 2\\n    vector<int> nsl(vector<int>&nums){\\n        vector<int>ans;\\n        stack<int>s;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(s.size()==0)ans.push_back(-1);    // in case of no small ele in left taking -1\\n            else{\\n                if(nums[s.top()]<nums[i])ans.push_back(s.top());\\n                else{\\n                    while(s.size()>0 && nums[s.top()]>=nums[i])s.pop();\\n                    if(s.size()==0)ans.push_back(-1);\\n                    else ans.push_back(s.top());\\n                }\\n            }\\n            s.push(i);\\n        }\\n      \\n        return ans;\\n    }\\n    \\n    vector<int> nsr(vector<int>&nums){\\n        vector<int>ans;\\n        stack<int>s;\\n        int n=nums.size();\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(s.size()==0)ans.push_back(n);   // in case of no small ele in right taking n\\n            else{\\n                if(nums[s.top()]<nums[i])ans.push_back(s.top());\\n                else{\\n                    while(s.size()>0 && nums[s.top()]>=nums[i])s.pop();\\n                    if(s.size()==0)ans.push_back(n);\\n                    else ans.push_back(s.top());\\n                }\\n            }\\n            s.push(i);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    \\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n=nums.size();\\n        int mod=1e9+7;\\n        vector<long long int>pre_sum(n+1,0);\\n        \\n        for(int i=1;i<n+1;i++){\\n            pre_sum[i]=pre_sum[i-1]+nums[i-1];     //prefix sum for subarray range sum\\n        }\\n        // pre_sum: 0 2 5 8 9 11 \\n\\t\\t\\n        vector<int>left = nsl(nums);\\n\\t\\t// -1 0 0 -1 3\\n        vector<int>right = nsr(nums);\\n        //  3 3 3 5 5\\n\\t\\t\\n        long long int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n            long long int sum=(pre_sum[right[i]]-pre_sum[left[i]+1])*nums[i];\\n\\t\\t\\t// here taking left[i]+1 beacause of -1 indexing we used in ngl \\n\\t\\t\\t/*\\n\\t\\t\\t(8-0)*2\\n\\t\\t\\t(8-2)*3\\n\\t\\t\\t(8-2)*3\\n\\t\\t\\t(11-0)*1\\n\\t\\t\\t(11-9)*2\\n\\t\\t\\t*/\\n            ans=max(ans,sum);\\n        }\\n        \\n        ans=ans%mod;\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991252,
                "title": "java-stack-monotonic",
                "content": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] psum = new long[n+1];\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            psum[i+1] = psum[i] + nums[i];  // psum of nums[i] will be at psum[i+1];\\n        }\\n        \\n        int[] nsL = smallLeft(nums);  // get Index small to the Left\\n        int[] nsR = smallRight(nums);  // get Index small to the Right\\n        \\n        long ans = Long.MIN_VALUE;\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            \\n            int min = nums[i];\\n            int smallL = nsL[i];\\n            int smallR = nsR[i];\\n            \\n            long sum = psum[smallR] - psum[smallL + 1]; // sum in the raneg from left to right.\\n            long candidate = min * sum;\\n            ans = Math.max(ans , candidate);\\n                \\n        }\\n        \\n        return (int)(ans%1000000007);\\n        \\n    }\\n    \\n    public int[] smallLeft(int[] nums){\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int[] res = new int[nums.length];\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            \\n            while(st.size() > 0 && nums[st.peek()] >= nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0){\\n                res[i] = -1;\\n            }else{\\n                res[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int[] smallRight(int[] nums){\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int[] res = new int[nums.length];\\n        \\n        for(int i = nums.length - 1 ; i >= 0 ; i--){\\n            while(st.size() > 0 && nums[st.peek()] >= nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0){\\n                res[i] = nums.length;\\n            }else{\\n                res[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] psum = new long[n+1];\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            psum[i+1] = psum[i] + nums[i];  // psum of nums[i] will be at psum[i+1];\\n        }\\n        \\n        int[] nsL = smallLeft(nums);  // get Index small to the Left\\n        int[] nsR = smallRight(nums);  // get Index small to the Right\\n        \\n        long ans = Long.MIN_VALUE;\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            \\n            int min = nums[i];\\n            int smallL = nsL[i];\\n            int smallR = nsR[i];\\n            \\n            long sum = psum[smallR] - psum[smallL + 1]; // sum in the raneg from left to right.\\n            long candidate = min * sum;\\n            ans = Math.max(ans , candidate);\\n                \\n        }\\n        \\n        return (int)(ans%1000000007);\\n        \\n    }\\n    \\n    public int[] smallLeft(int[] nums){\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int[] res = new int[nums.length];\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            \\n            while(st.size() > 0 && nums[st.peek()] >= nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0){\\n                res[i] = -1;\\n            }else{\\n                res[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int[] smallRight(int[] nums){\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int[] res = new int[nums.length];\\n        \\n        for(int i = nums.length - 1 ; i >= 0 ; i--){\\n            while(st.size() > 0 && nums[st.peek()] >= nums[i]){\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0){\\n                res[i] = nums.length;\\n            }else{\\n                res[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972977,
                "title": "java-monotonic-stack-prefixsum-o-n",
                "content": "The main idea is to compute the contribution of each number in the array.\\nMonotonic stack could find the range of subarray where each number is minimum. \\nonce we have the range, we could use the range to access prefixSum and get the sum of any subarray in O(1)\\nand find the maximum min-product\\n\\n```java\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int mod = (int)Math.pow(10,9)+7;\\n\\t\\t// increasing stack to keep track of minimum number\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.add(-1);\\n        \\n        long accum = 0;\\n        long product = 0;\\n        \\n\\t\\t// prefixSum to save the summation of any subarray\\n        long[] prefixSum = new long[nums.length+1]; \\n        for(int i = 0;i <= nums.length; ++i){\\n            while(stack.peek() != -1 && (i == nums.length || nums[stack.peek()] > nums[i])){\\n                int mid = stack.pop();\\n\\t\\t\\t\\t// find the range of subarray where poped number is minimum in the array.\\n                long sum = prefixSum[i] - prefixSum[stack.peek()+1];\\n                long result = nums[mid]*sum;\\n                product = Math.max(product, result);\\n            }\\n            stack.push(i);\\n            \\n            if(i < nums.length) {\\n                accum += nums[i];\\n                prefixSum[i+1] = accum;\\n            }\\n        }\\n        \\n        return (int) (product % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        int mod = (int)Math.pow(10,9)+7;\\n\\t\\t// increasing stack to keep track of minimum number\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.add(-1);\\n        \\n        long accum = 0;\\n        long product = 0;\\n        \\n\\t\\t// prefixSum to save the summation of any subarray\\n        long[] prefixSum = new long[nums.length+1]; \\n        for(int i = 0;i <= nums.length; ++i){\\n            while(stack.peek() != -1 && (i == nums.length || nums[stack.peek()] > nums[i])){\\n                int mid = stack.pop();\\n\\t\\t\\t\\t// find the range of subarray where poped number is minimum in the array.\\n                long sum = prefixSum[i] - prefixSum[stack.peek()+1];\\n                long result = nums[mid]*sum;\\n                product = Math.max(product, result);\\n            }\\n            stack.push(i);\\n            \\n            if(i < nums.length) {\\n                accum += nums[i];\\n                prefixSum[i+1] = accum;\\n            }\\n        }\\n        \\n        return (int) (product % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970638,
                "title": "python-stack-o-n",
                "content": "# Code\\n```\\nfrom itertools import accumulate\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left = []\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            left.append(stack[-1] if stack else -1)\\n            stack.append(i)\\n        right = []\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            right.append(stack[-1] if stack else n)\\n            stack.append(i)\\n        right.reverse()\\n        acc = list(accumulate(nums, initial = 0))\\n        res = 0\\n        for i in range(n):\\n            res = max(res, nums[i]*(acc[i+1]-acc[left[i]+1]+acc[right[i]]-acc[i]-nums[i]))\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left = []\\n        stack = []\\n        for i in range(n):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            left.append(stack[-1] if stack else -1)\\n            stack.append(i)\\n        right = []\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and nums[stack[-1]] >= nums[i]:\\n                stack.pop()\\n            right.append(stack[-1] if stack else n)\\n            stack.append(i)\\n        right.reverse()\\n        acc = list(accumulate(nums, initial = 0))\\n        res = 0\\n        for i in range(n):\\n            res = max(res, nums[i]*(acc[i+1]-acc[left[i]+1]+acc[right[i]]-acc[i]-nums[i]))\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919495,
                "title": "java-o-n-prefix-sum-stack",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        \\n        long[] prefixsum = new long[nums.length];\\n        prefixsum[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            prefixsum[i] = prefixsum[i-1]+nums[i];\\n        }\\n\\n        LinkedList<Integer> stack = new LinkedList<>();\\n        long[] leftsum = new long[nums.length];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            while ( ! stack.isEmpty() && nums[i] <= nums[stack.peek()]) {\\n                stack.pop();\\n            }\\n\\n            leftsum[i] = prefixsum[i];\\n            if ( ! stack.isEmpty()) {\\n                leftsum[i] -= prefixsum[stack.peek()];\\n            }\\n\\n            stack.push(i);\\n        }\\n\\n        stack.clear();\\n        long max = 0;\\n\\n        for (int i = nums.length-1; i >= 0; i--) {\\n            while ( ! stack.isEmpty() && nums[i] <= nums[stack.peek()]) {\\n                stack.pop();\\n            }\\n            int prev = stack.isEmpty() ? nums.length : stack.peek();\\n            leftsum[i] += (prefixsum[prev-1]-prefixsum[i]);\\n\\n            max = Math.max(max, leftsum[i]*nums[i]);\\n\\n            stack.push(i);\\n        }\\n\\n        return (int)(max % 1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumMinProduct(int[] nums) {\\n        \\n        long[] prefixsum = new long[nums.length];\\n        prefixsum[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            prefixsum[i] = prefixsum[i-1]+nums[i];\\n        }\\n\\n        LinkedList<Integer> stack = new LinkedList<>();\\n        long[] leftsum = new long[nums.length];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            while ( ! stack.isEmpty() && nums[i] <= nums[stack.peek()]) {\\n                stack.pop();\\n            }\\n\\n            leftsum[i] = prefixsum[i];\\n            if ( ! stack.isEmpty()) {\\n                leftsum[i] -= prefixsum[stack.peek()];\\n            }\\n\\n            stack.push(i);\\n        }\\n\\n        stack.clear();\\n        long max = 0;\\n\\n        for (int i = nums.length-1; i >= 0; i--) {\\n            while ( ! stack.isEmpty() && nums[i] <= nums[stack.peek()]) {\\n                stack.pop();\\n            }\\n            int prev = stack.isEmpty() ? nums.length : stack.peek();\\n            leftsum[i] += (prefixsum[prev-1]-prefixsum[i]);\\n\\n            max = Math.max(max, leftsum[i]*nums[i]);\\n\\n            stack.push(i);\\n        }\\n\\n        return (int)(max % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899177,
                "title": "python-solution-explained-monotonically-increasing-stack-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        # create a prefix sum array\\n        prefixSum = [0]\\n\\n        for n in nums:\\n            prefixSum.append(prefixSum[-1]+n)\\n\\n        res = -1\\n        stack = []\\n\\n        \\'\\'\\'\\n            the idea is to have a monotonically increasing stack\\n            whenver an element greater than or equal to the top of the stack is encountered\\n                => We push the element onto the stack\\n            whenever an element smaller than the top of the stack is encountered.\\n            That means we have encountered the an element which terminates the expansion of the current\\n            minimum element in consideration throughout the array.\\n                => We start popping the elements to the point when stack.top <= current element\\n        \\'\\'\\'\\n\\n        for start, num in enumerate(nums):\\n            newStart = start\\n            while stack and stack[-1][1] > num:\\n                i,val = stack.pop()\\n                res = max(res, (prefixSum[start]-prefixSum[i])*val)\\n                \\'\\'\\'\\n                    Now this new start assignment might be confusing.\\n                    Explanation: We were popping stack elements to check the range the new found element\\n                    at the index start extends back.\\n\\n                    In the test case 3,1,5,6,4,2\\n                    when we countered 4, we knew the stack had [[1,1],[2,5],[3,6]]\\n                    so since stack.top == 6 > 4, we start popping.\\n\\n                    in the end we are left with [[1,1]]\\n                    Now, if we just insert [4,4] i.e the current index of element 4.\\n                    We would lose the information that 4 was able to extend back since in the\\n                    final for loop(2). we have information about all the stack elements that were able to\\n                    span throughout the array.\\n\\n                    Therefore, to preserve the information of where 4 was able to extend till the back\\n                    we give it a new start which corresponds to the index to which it was able to go back.\\n                \\'\\'\\'\\n                newStart = i\\n            stack.append([newStart, num])\\n            \\n        # loop 2\\n        for start, val in stack:\\n            res = max(res, (prefixSum[len(nums)]-prefixSum[start])*val)\\n\\n        return res%mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumMinProduct(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        # create a prefix sum array\\n        prefixSum = [0]\\n\\n        for n in nums:\\n            prefixSum.append(prefixSum[-1]+n)\\n\\n        res = -1\\n        stack = []\\n\\n        \\'\\'\\'\\n            the idea is to have a monotonically increasing stack\\n            whenver an element greater than or equal to the top of the stack is encountered\\n                => We push the element onto the stack\\n            whenever an element smaller than the top of the stack is encountered.\\n            That means we have encountered the an element which terminates the expansion of the current\\n            minimum element in consideration throughout the array.\\n                => We start popping the elements to the point when stack.top <= current element\\n        \\'\\'\\'\\n\\n        for start, num in enumerate(nums):\\n            newStart = start\\n            while stack and stack[-1][1] > num:\\n                i,val = stack.pop()\\n                res = max(res, (prefixSum[start]-prefixSum[i])*val)\\n                \\'\\'\\'\\n                    Now this new start assignment might be confusing.\\n                    Explanation: We were popping stack elements to check the range the new found element\\n                    at the index start extends back.\\n\\n                    In the test case 3,1,5,6,4,2\\n                    when we countered 4, we knew the stack had [[1,1],[2,5],[3,6]]\\n                    so since stack.top == 6 > 4, we start popping.\\n\\n                    in the end we are left with [[1,1]]\\n                    Now, if we just insert [4,4] i.e the current index of element 4.\\n                    We would lose the information that 4 was able to extend back since in the\\n                    final for loop(2). we have information about all the stack elements that were able to\\n                    span throughout the array.\\n\\n                    Therefore, to preserve the information of where 4 was able to extend till the back\\n                    we give it a new start which corresponds to the index to which it was able to go back.\\n                \\'\\'\\'\\n                newStart = i\\n            stack.append([newStart, num])\\n            \\n        # loop 2\\n        for start, val in stack:\\n            res = max(res, (prefixSum[len(nums)]-prefixSum[start])*val)\\n\\n        return res%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821091,
                "title": "go-use-monotonic-increasing-stack",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nimport \"math\"\\n\\nfunc max(a int, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc maxSumMinProduct(nums []int) int {\\n\\tMOD := int(math.Pow10(9) + 7)\\n\\tst := [][2]int{}\\n\\tpreSum := make([]int, len(nums)+1)\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tpreSum[i+1] = preSum[i] + nums[i]\\n\\t}\\n\\n\\tres := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tnewStart := i\\n\\t\\tfor len(st) > 0 && st[len(st)-1][1] > nums[i] {\\n\\t\\t\\ttopSt := st[len(st)-1]\\n\\t\\t\\tst = st[:len(st)-1]\\n\\n\\t\\t\\tstart, val := topSt[0], topSt[1]\\n\\t\\t\\tsum := preSum[i] - preSum[start]\\n\\t\\t\\tres = max(res, sum*val)\\n\\t\\t\\tnewStart = start\\n\\t\\t}\\n\\t\\tst = append(st, [2]int{newStart, nums[i]})\\n\\t}\\n\\n\\tfor _, t := range st {\\n\\t\\tstart, val := t[0], t[1]\\n\\t\\tsum := preSum[len(nums)] - preSum[start]\\n\\t\\tres = max(res, sum*val)\\n\\t}\\n\\treturn res % MOD\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport \"math\"\\n\\nfunc max(a int, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc maxSumMinProduct(nums []int) int {\\n\\tMOD := int(math.Pow10(9) + 7)\\n\\tst := [][2]int{}\\n\\tpreSum := make([]int, len(nums)+1)\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tpreSum[i+1] = preSum[i] + nums[i]\\n\\t}\\n\\n\\tres := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tnewStart := i\\n\\t\\tfor len(st) > 0 && st[len(st)-1][1] > nums[i] {\\n\\t\\t\\ttopSt := st[len(st)-1]\\n\\t\\t\\tst = st[:len(st)-1]\\n\\n\\t\\t\\tstart, val := topSt[0], topSt[1]\\n\\t\\t\\tsum := preSum[i] - preSum[start]\\n\\t\\t\\tres = max(res, sum*val)\\n\\t\\t\\tnewStart = start\\n\\t\\t}\\n\\t\\tst = append(st, [2]int{newStart, nums[i]})\\n\\t}\\n\\n\\tfor _, t := range st {\\n\\t\\tstart, val := t[0], t[1]\\n\\t\\tsum := preSum[len(nums)] - preSum[start]\\n\\t\\tres = max(res, sum*val)\\n\\t}\\n\\treturn res % MOD\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2799305,
                "title": "not-the-most-most-efficient-but-very-intuitive-approach",
                "content": "# Intuition\\nMin of the subarray effects the product the most, since all the nums are greater >= 1.\\nIf minValue is part of the maximum product subarray. \\nThen that product = minValue*(sum of whole array).\\nOtherwise it\\'s either the left subarray or the right subarray.\\n\\n\\n# Approach\\nDivide and Conquer strategy with Segment Tree for minValue range query in the given subarray.\\n\\nWe store the minValue along with the index in the tree so that we can use it to split the array recursively and compare the two halves with the whole array that includes the minValue.\\n\\nWe return the max of the three products here (the left subarray, the right subarray and the whole array).\\n\\n\\n# Complexity\\n- Time complexity:\\nI don\\'t think I have the time complexity right here.\\nO(nlog(n)) for the divide and conquer. But we are doing O(log(n)) query for the range minimum. \\nTherefore, it should be worse than O(nlog(n)). May be O(nlog(n)*log(n))\\n\\n- Space complexity:\\nO(n) for prefixSum\\nO(4*n) ~ O(n) for segmentTree\\n\\n# Code\\n```\\n#define mod 1000000007\\n\\nclass SegmentTree {\\n    private:\\n    vector<pair<int, int>> tree;\\n    vector<int> lo, hi;\\n    int n;\\n\\n    public:\\n    SegmentTree(int size) {\\n        this->n = size;\\n        tree.resize(n << 2);\\n        lo.resize(n << 2, 0);\\n        hi.resize(n << 2, 0);\\n\\n        init(1, 0, n - 1);\\n    }\\n\\n    void update(int i) {\\n        if(tree[i << 1].first < tree[i << 1 | 1].first)\\n            tree[i] = make_pair(tree[i << 1].first, tree[i << 1].second);\\n        else\\n            tree[i] = make_pair(tree[i << 1 | 1].first, tree[i << 1 | 1].second);\\n    }\\n\\n    void build(vector<int>& nums) {\\n        construct(1, 0, n -1, nums);\\n    }\\n\\n    pair<int, int> construct(int i, int a, int b, vector<int>& nums) {\\n        if(a == b) {\\n            tree[i] = make_pair(nums[a], a);\\n            return tree[i];\\n        }\\n        int m = (a + b) / 2;\\n        pair<int, int> pl = construct(i << 1, a, m, nums);\\n        pair<int, int> pr = construct(i << 1 | 1, m + 1, b, nums);\\n        update(i);\\n        if(pl.first < pr.first)\\n            return pl;\\n        return pr;\\n    }\\n\\n    void init(int i, int a, int b) {\\n        lo[i] = a;\\n        hi[i] = b;\\n\\n        if(a == b)\\n            return;\\n        int m = (a + b) / 2;\\n        init(i << 1, a, m);\\n        init(i << 1 | 1, m + 1, b);\\n    }\\n\\n\\n    pair<int, int> rmq(int i, int a, int b) {\\n        if(b < lo[i] || hi[i] < a)\\n            return make_pair(INT_MAX, -1);\\n        if(a <= lo[i] && hi[i] <= b) {\\n            return tree[i];\\n        }\\n        pair<int, int> pl = rmq(i << 1, a, b); \\n        pair<int, int> pr = rmq(i << 1 | 1, a , b);\\n        update(i);\\n        if(pl.first < pr.first)\\n            return pl;\\n        return pr;\\n    }\\n\\n    pair<int, int> rangeQuery(int l, int r) {\\n        return rmq(1, l, r);\\n    }\\n\\n    void printTree() {\\n        for(int i = 0; i < n << 1; i++) {\\n            cout << tree[i].first << \":\" << tree[i].second <<  \"\\\\t\";\\n        }\\n        cout << endl;\\n    }\\n\\n\\n};\\n\\nclass Solution {\\npublic:\\n\\n    long long divideAndConquer(SegmentTree* tree, vector<int>& nums, vector<long long>& prefixSum, int l, int r) {\\n        if(l > r)\\n            return -1;\\n        if(l == r) {\\n            long long num = nums[l];\\n            return (num *num);\\n        }\\n\\n        pair<int, int> p = tree->rangeQuery(l, r);\\n\\n        long long left = divideAndConquer(tree, nums, prefixSum, l, p.second - 1);\\n        long long right = divideAndConquer(tree, nums, prefixSum, p.second + 1, r);\\n        long long withMin = (prefixSum[r] - prefixSum[l] + (long long)nums[l])*p.first;\\n        return max(withMin, max(left, right));\\n    }\\n\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<long long> prefixSum(n, 0);\\n        prefixSum[0] = nums[0];\\n        SegmentTree* tree = new SegmentTree(nums.size());\\n        tree->build(nums);\\n\\n        for(int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        return divideAndConquer(tree, nums, prefixSum, 0, n - 1) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Segment Tree"
                ],
                "code": "```\\n#define mod 1000000007\\n\\nclass SegmentTree {\\n    private:\\n    vector<pair<int, int>> tree;\\n    vector<int> lo, hi;\\n    int n;\\n\\n    public:\\n    SegmentTree(int size) {\\n        this->n = size;\\n        tree.resize(n << 2);\\n        lo.resize(n << 2, 0);\\n        hi.resize(n << 2, 0);\\n\\n        init(1, 0, n - 1);\\n    }\\n\\n    void update(int i) {\\n        if(tree[i << 1].first < tree[i << 1 | 1].first)\\n            tree[i] = make_pair(tree[i << 1].first, tree[i << 1].second);\\n        else\\n            tree[i] = make_pair(tree[i << 1 | 1].first, tree[i << 1 | 1].second);\\n    }\\n\\n    void build(vector<int>& nums) {\\n        construct(1, 0, n -1, nums);\\n    }\\n\\n    pair<int, int> construct(int i, int a, int b, vector<int>& nums) {\\n        if(a == b) {\\n            tree[i] = make_pair(nums[a], a);\\n            return tree[i];\\n        }\\n        int m = (a + b) / 2;\\n        pair<int, int> pl = construct(i << 1, a, m, nums);\\n        pair<int, int> pr = construct(i << 1 | 1, m + 1, b, nums);\\n        update(i);\\n        if(pl.first < pr.first)\\n            return pl;\\n        return pr;\\n    }\\n\\n    void init(int i, int a, int b) {\\n        lo[i] = a;\\n        hi[i] = b;\\n\\n        if(a == b)\\n            return;\\n        int m = (a + b) / 2;\\n        init(i << 1, a, m);\\n        init(i << 1 | 1, m + 1, b);\\n    }\\n\\n\\n    pair<int, int> rmq(int i, int a, int b) {\\n        if(b < lo[i] || hi[i] < a)\\n            return make_pair(INT_MAX, -1);\\n        if(a <= lo[i] && hi[i] <= b) {\\n            return tree[i];\\n        }\\n        pair<int, int> pl = rmq(i << 1, a, b); \\n        pair<int, int> pr = rmq(i << 1 | 1, a , b);\\n        update(i);\\n        if(pl.first < pr.first)\\n            return pl;\\n        return pr;\\n    }\\n\\n    pair<int, int> rangeQuery(int l, int r) {\\n        return rmq(1, l, r);\\n    }\\n\\n    void printTree() {\\n        for(int i = 0; i < n << 1; i++) {\\n            cout << tree[i].first << \":\" << tree[i].second <<  \"\\\\t\";\\n        }\\n        cout << endl;\\n    }\\n\\n\\n};\\n\\nclass Solution {\\npublic:\\n\\n    long long divideAndConquer(SegmentTree* tree, vector<int>& nums, vector<long long>& prefixSum, int l, int r) {\\n        if(l > r)\\n            return -1;\\n        if(l == r) {\\n            long long num = nums[l];\\n            return (num *num);\\n        }\\n\\n        pair<int, int> p = tree->rangeQuery(l, r);\\n\\n        long long left = divideAndConquer(tree, nums, prefixSum, l, p.second - 1);\\n        long long right = divideAndConquer(tree, nums, prefixSum, p.second + 1, r);\\n        long long withMin = (prefixSum[r] - prefixSum[l] + (long long)nums[l])*p.first;\\n        return max(withMin, max(left, right));\\n    }\\n\\n    int maxSumMinProduct(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        vector<long long> prefixSum(n, 0);\\n        prefixSum[0] = nums[0];\\n        SegmentTree* tree = new SegmentTree(nums.size());\\n        tree->build(nums);\\n\\n        for(int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        return divideAndConquer(tree, nums, prefixSum, 0, n - 1) % mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2773270,
                "title": "o-n-time-and-space-using-monothonic-stack",
                "content": "mainatin a increasing monothonis stack of tuples (x, y) where x is the number and y is the sum of x and all the consecutive numbers to the left of x that are not larger than x. \\n\\nfor example if the given array is 10, 20, 30, 40, 15, .. then \\n- after iterating on 10 the stack will be [(10, 10)]\\n- after iterating on 20 the stack will be [(10, 10), (20,20)]\\n- after iterating on 30 the stack will be [(10, 10), (20,20), (30,30)]\\n- after iterating on 40 the stack will be [(10, 10), (20,20), (30,30), (40, 40)]\\n-  after iterating on 15 the stack will be [(10, 10), (15, 105)]\\n\\nevery time we pop somebody ffrom the stack, we know what what is the sum of consecutive values to the left of him that are not smaller than him, and the same for the right of him (bcs while we pop we mantain summ += popedelem[1]) \\nso this way for each element in the array we know bot for which subrnage he is the minimum and what is the min-product of this subrange.\\n\\n```\\nclass Solution(object):\\n    def maxSumMinProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        st, best = [], 0\\n        nums.append(0)\\n        for num in nums:\\n            summ = 0\\n            while len(st) > 0 and num <= st[-1][0]:\\n                (poppedVal, poppedSum) = st.pop()\\n                best = max(best, poppedVal * (poppedSum + summ))\\n                summ += poppedSum\\n            st.append((num, summ + num))\\n        return best % (10**9 + 7)\\n```\\n\\nI append 0 to nums in the beginning,in order to make sure alll the elements get out from the stack and therefore considered in the calculation of best.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumMinProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        st, best = [], 0\\n        nums.append(0)\\n        for num in nums:\\n            summ = 0\\n            while len(st) > 0 and num <= st[-1][0]:\\n                (poppedVal, poppedSum) = st.pop()\\n                best = max(best, poppedVal * (poppedSum + summ))\\n                summ += poppedSum\\n            st.append((num, summ + num))\\n        return best % (10**9 + 7)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565793,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            },
            {
                "id": 1567139,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            },
            {
                "id": 1567040,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            },
            {
                "id": 1672493,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            },
            {
                "id": 1894880,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            },
            {
                "id": 1671948,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            },
            {
                "id": 1872762,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            },
            {
                "id": 1918141,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            },
            {
                "id": 2023938,
                "content": [
                    {
                        "username": "hkryucr",
                        "content": "I think it\\'s harder than typical medium. anyone agrees?"
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used Monotonic stack and prefix sum. So I do."
                    },
                    {
                        "username": "suhuu",
                        "content": "This can be done same as leetcode 84 https://leetcode.com/problems/largest-rectangle-in-histogram/  and can be done with next smaller element but small change is that instead of lenght of rectange in 84 it has sum of elements"
                    },
                    {
                        "username": "Nightmare9",
                        "content": "This needs to be in Hard category!!"
                    },
                    {
                        "username": "f0nt41n3",
                        "content": "Shoud be hard"
                    },
                    {
                        "username": "layyy",
                        "content": "try \"daily temperatures\" for better understanding of use of stack in this problem\\ntry \"sum of subarray minimums\" for a similar problem"
                    },
                    {
                        "username": "aman_22y",
                        "content": "I don\\'t think this should be labeled medium"
                    },
                    {
                        "username": "anjali2",
                        "content": "In case of example 2: nums = [2,3,3,1,2]\\nIf I take sub array: [2,3,3,2] ->then sum = 10 and min_product = 2*10 = 20.\\nWhy is it showing 18?"
                    },
                    {
                        "username": "richieskoshy",
                        "content": "I know this reply is a bit late, but in case anyone else had the same doubt.\\n\\nIn this question, the subarray has to be a contiguous part of the array. [2, 3, 3, 2] is in invalid subarray as it skips the value 1 in index 3. If you want to include the value 2 at index 4, the valid subarray would be [2, 3, 3, 1, 2], whose min-product would be\\n1*(2+3+3+1+2) = 1*11 = 11.\\n\\nAs for the second question, the contiguous sub-array with greatest min-product is [3, 3].\\nmin-product = 3 * (3+3) = 3*6 = 18."
                    },
                    {
                        "username": "Subh001",
                        "content": "i also have same query"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Don\\'t take modulo while calculating maximum, the question asks you to take it at end. Weird demand but I got like 4 wrong submissions due to it."
                    },
                    {
                        "username": "satendra_04",
                        "content": "How can u say this problem is in Medium category...This should be in hard category"
                    }
                ]
            }
        ]
    }
]