[
    {
        "title": "Check if There is a Valid Partition For The Array",
        "question_content": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\n\tThe subarray consists of exactly 2, equal elements. For example, the subarray [2,2] is good.\n\tThe subarray consists of exactly 3, equal elements. For example, the subarray [4,4,4] is good.\n\tThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.\n&nbsp;\nExample 1:\n\nInput: nums = [4,4,4,5,6]\nOutput: true\nExplanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\nThis partition is valid, so we return true.\n\nExample 2:\n\nInput: nums = [1,1,1,2]\nOutput: false\nExplanation: There is no valid partition for this array.\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 105\n\t1 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 2390532,
                "title": "c-dp-using-recursion-memorization-very-simple-easy-to-understand-solution",
                "content": "<b>Up Vote if you like the solution</b>\\n\\n# Intuition: \\nAs there are rules and same element can be a part of multiple rules => its a optimization problem and that\\'s how i think about to implement dp.\\n\\nThree cases :\\n1. check for 2 consicutive are equal \\n2. check for 3 consicutive are equal\\n3. check for 3 increasing numbers\\n\\nRecursively call for above conditions and use memorisation fo faster execution\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int i, vector<int>& dp){\\n        if(i == nums.size()) return true;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        if(i + 1 < nums.size() && nums[i] == nums[i+1] ) {\\n            if(solve(nums, i + 2, dp)) return true;\\n            if(i + 2 < nums.size() && nums[i] == nums[i+2]){\\n                if(solve(nums, i + 3, dp)) return true;\\n            }\\n        }\\n        if(i + 2 < nums.size() && nums[i] == nums[i+1]-1 && nums[i] == nums[i+2] - 2 ){\\n            if(solve(nums, i + 3, dp)) return true;\\n        }\\n        return dp[i] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n         vector<int> dp(nums.size(), -1);\\n        return solve(nums, 0, dp);\\n    }\\n};\\n```\\n---\\n\\n<b>Here is an article of my interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n\\n---",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int i, vector<int>& dp){\\n        if(i == nums.size()) return true;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        if(i + 1 < nums.size() && nums[i] == nums[i+1] ) {\\n            if(solve(nums, i + 2, dp)) return true;\\n            if(i + 2 < nums.size() && nums[i] == nums[i+2]){\\n                if(solve(nums, i + 3, dp)) return true;\\n            }\\n        }\\n        if(i + 2 < nums.size() && nums[i] == nums[i+1]-1 && nums[i] == nums[i+2] - 2 ){\\n            if(solve(nums, i + 3, dp)) return true;\\n        }\\n        return dp[i] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n         vector<int> dp(nums.size(), -1);\\n        return solve(nums, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901261,
                "title": "100-o-n-dynamic-programming-sliding-window-video-optimal-solution",
                "content": "# Problem Understanding\\n\\nIn the \"Valid Partition\" problem, we are provided with an array of integers. The objective is to determine if it\\'s possible to partition the array into one or more contiguous subarrays that meet specific criteria. A partition is considered valid if each subarray formed satisfies at least one of the following conditions:\\n\\n1. The subarray contains exactly 2 identical elements.\\n2. The subarray contains exactly 3 identical elements.\\n3. The subarray contains exactly 3 consecutive increasing elements.\\n\\nThe solution should return `True` if there\\'s at least one valid partition, and `False` otherwise.\\n\\nFor instance, consider the array `nums = [1, 1, 2, 3, 4]`.\\n\\nA valid partition would be the subarrays `[1, 1]` and `[2, 3, 4]`.\\n\\n# Video Live Coding & Explenation\\n\\nhttps://youtu.be/ESbbmQ9TPqY\\n\\n\\n- [Coding in Python \\uD83D\\uDC0D](https://youtu.be/ESbbmQ9TPqY)\\n- [Coding in Rust \\uD83E\\uDD80](https://youtu.be/MV-Zca7Unxo)\\n\\n---\\n\\n# Approach\\n\\n## Dynamic Programming with Sliding Window\\n\\nThe core idea of this solution is to use a sliding window of size 3 to track the state of the current and the two previous numbers in the list. At each step, we determine the validity of the partition up to the current index.\\n\\n## Key Data Structures:\\n\\n- **`dp` Array**:\\n  The `dp` array is a list of 3 boolean values. The values in this list help track the validity of the partition up to the current index.\\n  - `dp[0]` represents the validity of the partition up to index `i-2`.\\n  - `dp[1]` represents the validity of the partition up to index `i-1`.\\n  - `dp[2]` represents the validity of the partition up to the current index `i`.\\n\\n### Step-by-step Breakdown:\\n\\n1. **Initialization**:\\n   - Check the base case where the list has only one element. In this scenario, we can\\'t create any valid subarray, so we return `False`.\\n   - Initialize the `dp` array with the following values:\\n     - `dp[0]` is `True` because an empty list is always valid.\\n     - `dp[1]` is `False` initially.\\n     - `dp[2]` checks if the first two numbers are identical.\\n\\n2. **Iterate through the List**:\\n   - Start iterating from the third element (`index = 2`).\\n   - For each number:\\n     - Check if it matches the previous one and if `dp[1]` is `True`, indicating a valid partition up to this point.\\n     - Check if it forms a triplet with the two preceding numbers that are identical and if `dp[0]` is `True`, maintaining the validity.\\n     - Check if the current and the two preceding numbers form a sequence of three consecutive increasing numbers, and if `dp[0]` is `True`, keeping the partition valid.\\n   - Slide the window forward by reassigning the values in the `dp` array.\\n\\n3. **Result**:\\n   - After iterating through the entire list, `dp[2]` will reflect whether the list can be partitioned into valid subarrays.\\n\\n## Example:\\n\\nConsider the list `nums = [1, 1, 2, 3, 4]`.\\n\\nHere\\'s the evolution of the `dp` array:\\n\\n**Initial State**:\\n- `dp`: [True, False, True]\\n\\n**After processing index 2 (element = 2)**:\\n- `dp`: [False, True, True]\\n\\n**After processing index 3 (element = 3)**:\\n- `dp`: [True, True, True]\\n\\n**After processing index 4 (element = 4)**:\\n- `dp`: [True, True, True]\\n\\nThe final state of the `dp` array shows that the list can be validly partitioned into subarrays like `[1, 1]` and `[2, 3, 4]`.\\n\\n# Complexity\\n\\n**Time Complexity:** $$O(n)$$\\nEach element in the `nums` array is processed once, resulting in a linear time complexity.\\n\\n**Space Complexity:** $$O(1)$$\\nThe solution only uses a constant amount of space, irrespective of the size of the `nums` array.\\n\\n# Performance\\n\\nThe solution is highly efficient. It quickly determines the validity of a partition by leveraging past computations, ensuring optimal runtime even for larger arrays. The minimal space requirement makes it memory-efficient as well.\\n\\nHere\\'s the performance table sorted by runtime (ms):\\n\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| **Rust**       | 3           | 100%             | 3.7         | 100%            |\\n| **Java**       | 7            | 82.52%           | 56          | 100%            |\\n| **JavaScript** | 85           | 85.71%           | 54.4        | 100%            |\\n| **C++**        | 125          | 91.38%           | 83.6        | 99.69%          |\\n| **Go**         | 126          | 85.71%           | 8.9         | 85.71%          |\\n| **C#**         | 223          | 100%             | 56.2        | 100%            |\\n| **Python3**    | 844          | 93.8%            | 30.3        | 90%             |\\n\\n![perfc.png](https://assets.leetcode.com/users/images/b68aedf3-cf3b-434d-a6e1-13e6dbdb4f25_1691898815.3324234.png)\\n\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n\\n        # If the array has only one element, then not possible to partition into valid subarrays \\n        if n == 1: \\n            return False \\n\\n        # Initialization for the first three values \\n        dp = [True, False, nums[0] == nums[1] if n > 1 else False] \\n\\n        for i in range(2, n): \\n            current_dp = False \\n\\n            # Check for 2 equal elements \\n            if nums[i] == nums[i-1] and dp[1]: \\n                current_dp = True \\n\\n            # Check for 3 equal elements \\n            elif nums[i] == nums[i-1] == nums[i-2] and dp[0]: \\n                current_dp = True \\n\\n            # Check for 3 consecutive increasing elements \\n            elif nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0]: \\n                current_dp = True \\n\\n            # Move the window forward \\n            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp \\n\\n        return dp[2]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool validPartition(std::vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if (n == 1) return false;\\n\\n        std::vector<bool> dp = {true, false, n > 1 && nums[0] == nums[1]};\\n\\n        for (int i = 2; i < n; i++) {\\n            bool current_dp = false;\\n\\n            if (nums[i] == nums[i-1] && dp[1]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]) {\\n                current_dp = true;\\n            }\\n\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n\\n        return dp[2];\\n    }\\n};\\n```\\n``` Go []\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n\\n    if n == 1 {\\n        return false\\n    }\\n\\n    dp := []bool{true, false, n > 1 && nums[0] == nums[1]}\\n\\n    for i := 2; i < n; i++ {\\n        current_dp := false\\n\\n        if nums[i] == nums[i-1] && dp[1] {\\n            current_dp = true\\n        } else if nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0] {\\n            current_dp = true\\n        } else if nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0] {\\n            current_dp = true\\n        }\\n\\n        dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp\\n    }\\n\\n    return dp[2]\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n\\n        if n == 1 {\\n            return false;\\n        }\\n\\n        let mut dp = vec![true, false, if n > 1 { nums[0] == nums[1] } else { false }];\\n\\n        for i in 2..n {\\n            let mut current_dp = false;\\n\\n            if nums[i] == nums[i-1] && dp[1] {\\n                current_dp = true;\\n            }\\n            else if nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0] {\\n                current_dp = true;\\n            }\\n            else if nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0] {\\n                current_dp = true;\\n            }\\n\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n\\n        dp[2]\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n\\n        if (n == 1) return false;\\n\\n        boolean[] dp = new boolean[]{true, false, n > 1 && nums[0] == nums[1]};\\n\\n        for (int i = 2; i < n; i++) {\\n            boolean current_dp = false;\\n\\n            if (nums[i] == nums[i-1] && dp[1]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]) {\\n                current_dp = true;\\n            }\\n\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n\\n        return dp[2];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function(nums) {\\n    let n = nums.length;\\n\\n    if (n === 1) return false;\\n\\n    let dp = [true, false, n > 1 && nums[0] === nums[1]];\\n\\n    for (let i = 2; i < n; i++) {\\n        let current_dp = false;\\n\\n        if (nums[i] === nums[i-1] && dp[1]) {\\n            current_dp = true;\\n        }\\n        else if (nums[i] === nums[i-1] && nums[i] === nums[i-2] && dp[0]) {\\n            current_dp = true;\\n        }\\n        else if (nums[i] - nums[i-1] === 1 && nums[i-1] - nums[i-2] === 1 && dp[0]) {\\n            current_dp = true;\\n        }\\n\\n        [dp[0], dp[1], dp[2]] = [dp[1], dp[2], current_dp];\\n    }\\n\\n    return dp[2];\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        int n = nums.Length;\\n\\n        if (n == 1) return false;\\n\\n        bool[] dp = new bool[]{true, false, n > 1 && nums[0] == nums[1]};\\n\\n        for (int i = 2; i < n; i++) {\\n            bool current_dp = false;\\n\\n            if (nums[i] == nums[i-1] && dp[1]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]) {\\n                current_dp = true;\\n            }\\n\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n\\n        return dp[2];\\n    }\\n}\\n```\\n\\n# Code - Combine True\\n``` Python []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n        if n == 1: \\n            return False \\n        dp = [True, False, nums[0] == nums[1] if n > 1 else False] \\n        for i in range(2, n): \\n            current_dp = (nums[i] == nums[i-1] and dp[1]) or \\\\\\n                         (nums[i] == nums[i-1] == nums[i-2] and dp[0]) or \\\\\\n                         (nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0])\\n            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp \\n        return dp[2]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return false;\\n        vector<bool> dp = {true, false, n > 1 ? nums[0] == nums[1] : false};\\n        for (int i = 2; i < n; i++) {\\n            bool current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                              (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                              (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        return dp[2];\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n        if n == 1 { return false; }\\n        let mut dp = vec![true, false, if n > 1 { nums[0] == nums[1] } else { false }];\\n        for i in 2..n {\\n            let current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                             (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                             (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        dp[2]\\n    }\\n}\\n```\\n``` Go []\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n    if n == 1 { return false }\\n    dp := []bool{true, false, false}\\n    if n > 1 {\\n        dp[2] = nums[0] == nums[1]\\n    }\\n    for i := 2; i < n; i++ {\\n        current_dp := (nums[i] == nums[i-1] && dp[1]) || \\n                      (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                      (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0])\\n        dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp\\n    }\\n    return dp[2]\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return false;\\n        boolean[] dp = {true, false, n > 1 ? nums[0] == nums[1] : false};\\n        for (int i = 2; i < n; i++) {\\n            boolean current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                                 (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                                 (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        return dp[2];\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        int n = nums.Length;\\n        if (n == 1) return false;\\n        bool[] dp = {true, false, n > 1 ? nums[0] == nums[1] : false};\\n        for (int i = 2; i < n; i++) {\\n            bool current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                              (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                              (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        return dp[2];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function(nums) {\\n    let n = nums.length;\\n    if (n === 1) return false;\\n    let dp = [true, false, n > 1 ? nums[0] === nums[1] : false];\\n    for (let i = 2; i < n; i++) {\\n        let current_dp = (nums[i] === nums[i-1] && dp[1]) || \\n                         (nums[i] === nums[i-1] && nums[i] === nums[i-2] && dp[0]) ||\\n                         (nums[i] - nums[i-1] === 1 && nums[i-1] - nums[i-2] === 1 && dp[0]);\\n        dp[0] = dp[1];\\n        dp[1] = dp[2];\\n        dp[2] = current_dp;\\n    }\\n    return dp[2];\\n};\\n```\\nBy using the logical or operator, we\\'re able to combine all the conditions that result in a True value for current_dp. This makes the code more concise.\\n\\n# Live Coding in Rust\\n\\nhttps://youtu.be/MV-Zca7Unxo",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n\\n        # If the array has only one element, then not possible to partition into valid subarrays \\n        if n == 1: \\n            return False \\n\\n        # Initialization for the first three values \\n        dp = [True, False, nums[0] == nums[1] if n > 1 else False] \\n\\n        for i in range(2, n): \\n            current_dp = False \\n\\n            # Check for 2 equal elements \\n            if nums[i] == nums[i-1] and dp[1]: \\n                current_dp = True \\n\\n            # Check for 3 equal elements \\n            elif nums[i] == nums[i-1] == nums[i-2] and dp[0]: \\n                current_dp = True \\n\\n            # Check for 3 consecutive increasing elements \\n            elif nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0]: \\n                current_dp = True \\n\\n            # Move the window forward \\n            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp \\n\\n        return dp[2]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool validPartition(std::vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if (n == 1) return false;\\n\\n        std::vector<bool> dp = {true, false, n > 1 && nums[0] == nums[1]};\\n\\n        for (int i = 2; i < n; i++) {\\n            bool current_dp = false;\\n\\n            if (nums[i] == nums[i-1] && dp[1]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]) {\\n                current_dp = true;\\n            }\\n\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n\\n        return dp[2];\\n    }\\n};\\n```\n``` Go []\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n\\n    if n == 1 {\\n        return false\\n    }\\n\\n    dp := []bool{true, false, n > 1 && nums[0] == nums[1]}\\n\\n    for i := 2; i < n; i++ {\\n        current_dp := false\\n\\n        if nums[i] == nums[i-1] && dp[1] {\\n            current_dp = true\\n        } else if nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0] {\\n            current_dp = true\\n        } else if nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0] {\\n            current_dp = true\\n        }\\n\\n        dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp\\n    }\\n\\n    return dp[2]\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n\\n        if n == 1 {\\n            return false;\\n        }\\n\\n        let mut dp = vec![true, false, if n > 1 { nums[0] == nums[1] } else { false }];\\n\\n        for i in 2..n {\\n            let mut current_dp = false;\\n\\n            if nums[i] == nums[i-1] && dp[1] {\\n                current_dp = true;\\n            }\\n            else if nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0] {\\n                current_dp = true;\\n            }\\n            else if nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0] {\\n                current_dp = true;\\n            }\\n\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n\\n        dp[2]\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n\\n        if (n == 1) return false;\\n\\n        boolean[] dp = new boolean[]{true, false, n > 1 && nums[0] == nums[1]};\\n\\n        for (int i = 2; i < n; i++) {\\n            boolean current_dp = false;\\n\\n            if (nums[i] == nums[i-1] && dp[1]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]) {\\n                current_dp = true;\\n            }\\n\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n\\n        return dp[2];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function(nums) {\\n    let n = nums.length;\\n\\n    if (n === 1) return false;\\n\\n    let dp = [true, false, n > 1 && nums[0] === nums[1]];\\n\\n    for (let i = 2; i < n; i++) {\\n        let current_dp = false;\\n\\n        if (nums[i] === nums[i-1] && dp[1]) {\\n            current_dp = true;\\n        }\\n        else if (nums[i] === nums[i-1] && nums[i] === nums[i-2] && dp[0]) {\\n            current_dp = true;\\n        }\\n        else if (nums[i] - nums[i-1] === 1 && nums[i-1] - nums[i-2] === 1 && dp[0]) {\\n            current_dp = true;\\n        }\\n\\n        [dp[0], dp[1], dp[2]] = [dp[1], dp[2], current_dp];\\n    }\\n\\n    return dp[2];\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        int n = nums.Length;\\n\\n        if (n == 1) return false;\\n\\n        bool[] dp = new bool[]{true, false, n > 1 && nums[0] == nums[1]};\\n\\n        for (int i = 2; i < n; i++) {\\n            bool current_dp = false;\\n\\n            if (nums[i] == nums[i-1] && dp[1]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) {\\n                current_dp = true;\\n            }\\n            else if (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]) {\\n                current_dp = true;\\n            }\\n\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n\\n        return dp[2];\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n        if n == 1: \\n            return False \\n        dp = [True, False, nums[0] == nums[1] if n > 1 else False] \\n        for i in range(2, n): \\n            current_dp = (nums[i] == nums[i-1] and dp[1]) or \\\\\\n                         (nums[i] == nums[i-1] == nums[i-2] and dp[0]) or \\\\\\n                         (nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0])\\n            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp \\n        return dp[2]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return false;\\n        vector<bool> dp = {true, false, n > 1 ? nums[0] == nums[1] : false};\\n        for (int i = 2; i < n; i++) {\\n            bool current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                              (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                              (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        return dp[2];\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n        if n == 1 { return false; }\\n        let mut dp = vec![true, false, if n > 1 { nums[0] == nums[1] } else { false }];\\n        for i in 2..n {\\n            let current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                             (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                             (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        dp[2]\\n    }\\n}\\n```\n``` Go []\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n    if n == 1 { return false }\\n    dp := []bool{true, false, false}\\n    if n > 1 {\\n        dp[2] = nums[0] == nums[1]\\n    }\\n    for i := 2; i < n; i++ {\\n        current_dp := (nums[i] == nums[i-1] && dp[1]) || \\n                      (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                      (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0])\\n        dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp\\n    }\\n    return dp[2]\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return false;\\n        boolean[] dp = {true, false, n > 1 ? nums[0] == nums[1] : false};\\n        for (int i = 2; i < n; i++) {\\n            boolean current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                                 (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                                 (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        return dp[2];\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        int n = nums.Length;\\n        if (n == 1) return false;\\n        bool[] dp = {true, false, n > 1 ? nums[0] == nums[1] : false};\\n        for (int i = 2; i < n; i++) {\\n            bool current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                              (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                              (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        return dp[2];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function(nums) {\\n    let n = nums.length;\\n    if (n === 1) return false;\\n    let dp = [true, false, n > 1 ? nums[0] === nums[1] : false];\\n    for (let i = 2; i < n; i++) {\\n        let current_dp = (nums[i] === nums[i-1] && dp[1]) || \\n                         (nums[i] === nums[i-1] && nums[i] === nums[i-2] && dp[0]) ||\\n                         (nums[i] - nums[i-1] === 1 && nums[i-1] - nums[i-2] === 1 && dp[0]);\\n        dp[0] = dp[1];\\n        dp[1] = dp[2];\\n        dp[2] = current_dp;\\n    }\\n    return dp[2];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390497,
                "title": "dp",
                "content": "For the current element, `dp[i]` indicates if the array can be partitioned up to that element.\\n\\nFor element `dp[i + 1]`, the partition is valid if:\\n- `dp[i - 1] == true` and we have a partition of `two` elements, or,\\n- `dp[i - 2] == true` and we have a partition of `three` elements.\\n\\nSince we only need to look 3 elements back, we can use a rolling `dp` array for constant memory complexity.\\n\\n**C++**\\n```cpp\\nbool validPartition(vector<int>& n) {\\n    bool dp[4] = {true, false, n[0] == n[1], false};\\n    for (int i = 2; i < n.size(); ++i) {\\n        bool two = n[i] == n[i - 1];\\n        bool three = (two && n[i] == n[i - 2]) || (n[i] - 1 == n[i - 1] && n[i] - 2 == n[i - 2]);\\n        dp[(i + 1) % 4] = (dp[(i - 1) % 4] && two) || (dp[(i - 2) % 4] && three);\\n    }\\n    return dp[n.size() % 4];\\n}\\n```\\n**Java**\\n```java\\npublic boolean validPartition(int[] n) {\\n    boolean[] dp = {true, false, n[0] == n[1], false};\\n    for (int i = 2; i < n.length; ++i) {\\n        boolean two = n[i] == n[i - 1];\\n        boolean three = (two && n[i] == n[i - 2]) || (n[i] - 1 == n[i - 1] && n[i] - 2 == n[i - 2]);\\n        dp[(i + 1) % 4] = (two && dp[(i - 1) % 4]) || (three && dp[(i - 2) % 4]);\\n    }\\n    return dp[n.length % 4];\\n}\\n```\\n**Python 3**\\nDop-down DP, just for fun.\\n```python\\nclass Solution:\\n    def validPartition(self, n: List[int]) -> bool:\\n        @cache\\n        def dfs(i: int) -> bool:\\n            if i >= len(n) - 1:\\n                return i == len(n)\\n            two = n[i] == n[i + 1]\\n            three = i < len(n) - 2 and ((two and n[i + 1] == n[i + 2]) or (n[i] + 1 == n[i + 1] and n[i] + 2 == n[i + 2]))\\n            return (two and dfs(i + 2)) or (three and dfs(i + 3))\\n        return dfs(0)\\n```\\n**Complexity Analysis**\\n- Time: O(n); for each element, we check 5 characters.\\n- Memory: O(1); we use a fixed-size `dp` array.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nbool validPartition(vector<int>& n) {\\n    bool dp[4] = {true, false, n[0] == n[1], false};\\n    for (int i = 2; i < n.size(); ++i) {\\n        bool two = n[i] == n[i - 1];\\n        bool three = (two && n[i] == n[i - 2]) || (n[i] - 1 == n[i - 1] && n[i] - 2 == n[i - 2]);\\n        dp[(i + 1) % 4] = (dp[(i - 1) % 4] && two) || (dp[(i - 2) % 4] && three);\\n    }\\n    return dp[n.size() % 4];\\n}\\n```\n```java\\npublic boolean validPartition(int[] n) {\\n    boolean[] dp = {true, false, n[0] == n[1], false};\\n    for (int i = 2; i < n.length; ++i) {\\n        boolean two = n[i] == n[i - 1];\\n        boolean three = (two && n[i] == n[i - 2]) || (n[i] - 1 == n[i - 1] && n[i] - 2 == n[i - 2]);\\n        dp[(i + 1) % 4] = (two && dp[(i - 1) % 4]) || (three && dp[(i - 2) % 4]);\\n    }\\n    return dp[n.length % 4];\\n}\\n```\n```python\\nclass Solution:\\n    def validPartition(self, n: List[int]) -> bool:\\n        @cache\\n        def dfs(i: int) -> bool:\\n            if i >= len(n) - 1:\\n                return i == len(n)\\n            two = n[i] == n[i + 1]\\n            three = i < len(n) - 2 and ((two and n[i + 1] == n[i + 2]) or (n[i] + 1 == n[i + 1] and n[i] + 2 == n[i + 2]))\\n            return (two and dfs(i + 2)) or (three and dfs(i + 3))\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390802,
                "title": "java-c-python-dp-o-1-space",
                "content": "# **Explanation**\\n`dp[i % 4]` means there is a valid partition for `A[0]` to `A[i]`.\\n\\nIterate `i` from `0` to `n - 1`,\\nassign `dp[i]` to false first.\\n\\nCheck if `s[i-1], s[i]` are exactly 2 equal elements,\\nthen `dp[i] |= dp[i - 2]`\\n\\nCheck if `s[i-2],s[i-1], s[i]` are exactly 3 equal elements\\nthen `dp[i] |= dp[i - 3]`\\n\\nCheck if `s[i-2],s[i-1], s[i]` are exactly 3 consecutive increasing elements\\nthen `dp[i] |= dp[i - 3]`\\n\\nFinally return result of `dp[n - 1]`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n\\n**Java**\\n```java\\n    public boolean validPartition(int[] A) {\\n        int n = A.length, dp[] = new int[] {0, 0, 0, 1};\\n        for (int i = 0; i < n; ++i) {\\n            dp[i % 4] = 0;\\n            if (i - 1 >= 0 && A[i] == A[i - 1])\\n                dp[i % 4] |= dp[(i + 2) % 4];\\n            if (i - 2 >= 0 && A[i] == A[i - 1] && A[i - 1] == A[i - 2])\\n                dp[i % 4] |= dp[(i + 1) % 4];\\n            if (i - 2 >= 0 && A[i] - 1 == A[i - 1] && A[i - 1] == A[i - 2] + 1)\\n                dp[i % 4] |= dp[(i + 1) % 4];\\n        }\\n        return dp[(n - 1) % 4] > 0;\\n    }\\n```\\n**C++**\\n```cpp\\n    bool validPartition(vector<int>& A) {\\n        int n = A.size(), dp[4] = {0, 0, 0, 1};\\n        for (int i = 0; i < n; ++i) {\\n            dp[i % 4] = 0;\\n            if (i - 1 >= 0 && A[i] == A[i - 1])\\n                dp[i % 4] |= dp[(i + 2) % 4];\\n            if (i - 2 >= 0 && A[i] == A[i - 1] && A[i - 1] == A[i - 2])\\n                dp[i % 4] |= dp[(i + 1) % 4];\\n            if (i - 2 >= 0 && A[i] - 1 == A[i - 1] && A[i - 1] == A[i - 2] + 1)\\n                dp[i % 4] |= dp[(i + 1) % 4];\\n        }\\n        return dp[(n - 1) % 4];\\n    }\\n```\\n**Python**\\n```py\\n    def validPartition(self, A):\\n        n = len(A)\\n        dp = [False, False, False, True]\\n        for i in range(n):\\n            dp[i % 4] = False\\n            if i - 1 >= 0 and A[i] == A[i-1]:\\n                dp[i % 4] |= dp[(i - 2) % 4]\\n            if i - 2 >= 0 and A[i] == A[i-1] == A[i-2]:\\n                dp[i % 4] |= dp[(i - 3) % 4]\\n            if i - 2 >= 0 and A[i] == A[i-1] + 1 == A[i-2] + 2:\\n                dp[i % 4] |= dp[(i - 3) % 4]\\n        return dp[(n - 1) % 4]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean validPartition(int[] A) {\\n        int n = A.length, dp[] = new int[] {0, 0, 0, 1};\\n        for (int i = 0; i < n; ++i) {\\n            dp[i % 4] = 0;\\n            if (i - 1 >= 0 && A[i] == A[i - 1])\\n                dp[i % 4] |= dp[(i + 2) % 4];\\n            if (i - 2 >= 0 && A[i] == A[i - 1] && A[i - 1] == A[i - 2])\\n                dp[i % 4] |= dp[(i + 1) % 4];\\n            if (i - 2 >= 0 && A[i] - 1 == A[i - 1] && A[i - 1] == A[i - 2] + 1)\\n                dp[i % 4] |= dp[(i + 1) % 4];\\n        }\\n        return dp[(n - 1) % 4] > 0;\\n    }\\n```\n```cpp\\n    bool validPartition(vector<int>& A) {\\n        int n = A.size(), dp[4] = {0, 0, 0, 1};\\n        for (int i = 0; i < n; ++i) {\\n            dp[i % 4] = 0;\\n            if (i - 1 >= 0 && A[i] == A[i - 1])\\n                dp[i % 4] |= dp[(i + 2) % 4];\\n            if (i - 2 >= 0 && A[i] == A[i - 1] && A[i - 1] == A[i - 2])\\n                dp[i % 4] |= dp[(i + 1) % 4];\\n            if (i - 2 >= 0 && A[i] - 1 == A[i - 1] && A[i - 1] == A[i - 2] + 1)\\n                dp[i % 4] |= dp[(i + 1) % 4];\\n        }\\n        return dp[(n - 1) % 4];\\n    }\\n```\n```py\\n    def validPartition(self, A):\\n        n = len(A)\\n        dp = [False, False, False, True]\\n        for i in range(n):\\n            dp[i % 4] = False\\n            if i - 1 >= 0 and A[i] == A[i-1]:\\n                dp[i % 4] |= dp[(i - 2) % 4]\\n            if i - 2 >= 0 and A[i] == A[i-1] == A[i-2]:\\n                dp[i % 4] |= dp[(i - 3) % 4]\\n            if i - 2 >= 0 and A[i] == A[i-1] + 1 == A[i-2] + 2:\\n                dp[i % 4] |= dp[(i - 3) % 4]\\n        return dp[(n - 1) % 4]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3902702,
                "title": "c-apni-bhasha-mein-seedhi-baat-no-bakwaas-dp-1d-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    KARNA KYA HAIN\\u2753\\n   \\t1. \"0-indexed array\" is given we have to \"partition\" the array into \"1 or more\"\\n   \\tcontiguous subarrays.\\n   \\t2. Partition \"valid\" hone ke liye kuch \"rules\" hain:-\\n   \\t- Subarray consists of \"exactly 2 equal\" elems.\\n   \\t- Subarray consists of \"exactly 3 equal\" elems.\\n   \\t- Subarray consists of \"3 elems in increasing order\".\\n   \\t3. Return \"true\" if we find any valid partition.\\n\\n   \\tINTUITION &APPROACH\\n   \\t1. Now question ko dekhke yeh samajh aa raha hain ki valid partitio nikalne ke liye\\n   \\twe have \"many partitioning methods\". Bas above set rules follow hone chahiye.\\n\\n   \\t2. So we have many \"choices\" for partitioning. And when we have choices we use\\n   \\t\"RECURSION\" \\uD83D\\uDCA5.\\n\\n   \\t3. Steps for RECURSION:-\\n   \\t- Visualize everything in terms of indexes.\\n   \\t- Do every stuff on that indexes.\\n   \\t- Find recurrence reation and base cases.\\n\\n   \\t4. Now actually mein ho kya raha hain:-\\n   \\t- Maanlo hame koi array given hain ab usme hame valid partitions nikalne hain.\\n   \\t- So ek chiz jo ham track kar sakte hain vo hain \"index\" in an array.\\n   \\t- We can check if \"ki is index se pehle jo numbers hain wo hamara koi valid\\n   \\tpartition ka rule follow kar rahe hain kya?\".\\n   \\t- Agar our current index is \"i\" then 1st rule follow hone ke liye \"ith == (i-1)th\".\\n   \\t- \"2 nd rule\" follow hone ke liye \"ith == (i-1)th == (i-2)th\".\\n   \\t- \"3 rd rule\" follow hone ke liye \"ith == (i-1)th +1 and (i-1)th == (i-2)th+1\".\\n   \\t- Isse ham \"tukdo\" mein pata kar sakte hain ki we have valid partition or not.\\n   \\t- We are \"divding our big problem into smaller problem\".\\n\\n   \\t5. \"BASE CASE:-\"\\n   \\t- if i < 0 the return 1 Why\\u2753Because it denotes empty subarray and that always have \\n   \\ta valid partition.\\n   \\t6. Now since there will be \"overlapping subproblems\" ,\"multiple options \\n       to choose\", and \"Each decision will affect future decisions\". \\n       So we will use \"DP\"\\uD83D\\uDD25.\\n   \\t7. RECURSION -> MEMOIZATION -> TABULATION -> SPACE-OPTIMISED\\n\\n   \\t8. Memoization Steps:-\\n   \\t- In Memoization we go from Bigger Problem to smaller subproblems and store them\\n   \\tin table.\\n   \\t- See which parameter is changing in this whole game . (\"index\" is changing in\\n   \\tour case.)\\n   \\t- Declare the size of array according to the changing params.(Only 1 param is \\n   \\tchanging so it will be \"1D\" array.).\\n   \\t- Check if the problem is already solved or not.\\n   \\t- Store the result in dp array.\\n\\n    9. Tabulation Steps: -\\n    -In Tabulation we follow a bottom - up approach where we go from solving smaller\\n    problems to solve big problems.\\n    - Declare the size of dp array according to changing parameter.\\n    - Replace the validPrefix() function with dp[].\\n    - For keeping track of index use a for loop. \\n    - Declare the base cases, dp[0] = 1(\"Empty subarray case\").\\n\\n    10. What does dp[index] represents\\u2753It denotes that if \"valid partition are \\n    possible till index position in array or not\".\\n//==========================================================================================================\\n    public:\\n    //MEMOIZATION\\n       \\t    bool validPrefix(int index, vector<int> &nums, vector<int> &dp)\\n       \\t    {\\n       \\t        if (index < 0)\\n       \\t            return 1;//Empty subarray case\\n       \\t        if (dp[index] != -1)\\n       \\t            return dp[index];//Already solved\\n       \\t        bool twoIdentical = 0;\\n       \\t        bool threeIdentical = 0;\\n       \\t        bool increasingSeq = 0;\\n                \\n                //Slef-Explanatory\\n       \\t        if (index > 0 && nums[index] == nums[index - 1])\\n       \\t            twoIdentical = validPrefix(index - 2, nums, dp);\\n                //2 elems mil gaye valid to ab index-2 pe search karenge\\n       \\t        if (index > 1 && nums[index] == nums[index - 1] && nums[index - 1] == nums[index - 2])\\n       \\t            threeIdentical = validPrefix(index - 3, nums, dp);\\n                //3 elems mil gaye valid to ab index-3 pe search karenge.\\n       \\t        if (index > 1 && nums[index] == nums[index - 1] + 1 && nums[index - 1] == nums[index - 2] + 1)\\n       \\t            increasingSeq = validPrefix(index - 3, nums, dp);\\n       \\t        return dp[index] = twoIdentical || threeIdentical || increasingSeq;\\n       \\t    }\\n       \\tbool validPartition(vector<int> &nums)\\n       \\t{\\n       \\t    int n = nums.size();\\n       \\t    vector<int> dp(n, -1);\\n       \\t    return validPrefix(n - 1, nums, dp);\\n       \\t}\\n\\n//=====================================================================================================\\n\\n//TABULATION\\n bool validPartition(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n\\n            vector<int> dp(n + 1, 0);\\n            dp[0] = 1;//Emprt subarray case\\n\\n            for (int index = 0; index < n; index++)\\n            {\\n                int i = index + 1;\\n                bool twoIdentical = false;\\n                bool threeIdentical = false;\\n                bool increasingSeq = false;\\n\\n                if (index > 0 && nums[index] == nums[index - 1])\\n                {\\n                    twoIdentical = dp[i - 2];\\n                }\\n\\n                if (index > 1 && nums[index] == nums[index - 1] && nums[index - 1] == nums[index - 2] && nums[index] == nums[index - 2])\\n                {\\n                    threeIdentical = dp[i - 3];\\n                }\\n\\n                if (index > 1 && nums[index] == nums[index - 1] + 1 && nums[index - 1] == nums[index - 2] + 1)\\n                {\\n                    increasingSeq = dp[i - 3];\\n                }\\n\\n                dp[i] = twoIdentical || threeIdentical || increasingSeq;\\n            }\\n\\n            return dp[n];\\n        }\\n};\\n```\\n# Complexity\\n- Time complexity:$O(N)$\\n\\n- Space complexity:$O(N)$\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    KARNA KYA HAIN\\u2753\\n   \\t1. \"0-indexed array\" is given we have to \"partition\" the array into \"1 or more\"\\n   \\tcontiguous subarrays.\\n   \\t2. Partition \"valid\" hone ke liye kuch \"rules\" hain:-\\n   \\t- Subarray consists of \"exactly 2 equal\" elems.\\n   \\t- Subarray consists of \"exactly 3 equal\" elems.\\n   \\t- Subarray consists of \"3 elems in increasing order\".\\n   \\t3. Return \"true\" if we find any valid partition.\\n\\n   \\tINTUITION &APPROACH\\n   \\t1. Now question ko dekhke yeh samajh aa raha hain ki valid partitio nikalne ke liye\\n   \\twe have \"many partitioning methods\". Bas above set rules follow hone chahiye.\\n\\n   \\t2. So we have many \"choices\" for partitioning. And when we have choices we use\\n   \\t\"RECURSION\" \\uD83D\\uDCA5.\\n\\n   \\t3. Steps for RECURSION:-\\n   \\t- Visualize everything in terms of indexes.\\n   \\t- Do every stuff on that indexes.\\n   \\t- Find recurrence reation and base cases.\\n\\n   \\t4. Now actually mein ho kya raha hain:-\\n   \\t- Maanlo hame koi array given hain ab usme hame valid partitions nikalne hain.\\n   \\t- So ek chiz jo ham track kar sakte hain vo hain \"index\" in an array.\\n   \\t- We can check if \"ki is index se pehle jo numbers hain wo hamara koi valid\\n   \\tpartition ka rule follow kar rahe hain kya?\".\\n   \\t- Agar our current index is \"i\" then 1st rule follow hone ke liye \"ith == (i-1)th\".\\n   \\t- \"2 nd rule\" follow hone ke liye \"ith == (i-1)th == (i-2)th\".\\n   \\t- \"3 rd rule\" follow hone ke liye \"ith == (i-1)th +1 and (i-1)th == (i-2)th+1\".\\n   \\t- Isse ham \"tukdo\" mein pata kar sakte hain ki we have valid partition or not.\\n   \\t- We are \"divding our big problem into smaller problem\".\\n\\n   \\t5. \"BASE CASE:-\"\\n   \\t- if i < 0 the return 1 Why\\u2753Because it denotes empty subarray and that always have \\n   \\ta valid partition.\\n   \\t6. Now since there will be \"overlapping subproblems\" ,\"multiple options \\n       to choose\", and \"Each decision will affect future decisions\". \\n       So we will use \"DP\"\\uD83D\\uDD25.\\n   \\t7. RECURSION -> MEMOIZATION -> TABULATION -> SPACE-OPTIMISED\\n\\n   \\t8. Memoization Steps:-\\n   \\t- In Memoization we go from Bigger Problem to smaller subproblems and store them\\n   \\tin table.\\n   \\t- See which parameter is changing in this whole game . (\"index\" is changing in\\n   \\tour case.)\\n   \\t- Declare the size of array according to the changing params.(Only 1 param is \\n   \\tchanging so it will be \"1D\" array.).\\n   \\t- Check if the problem is already solved or not.\\n   \\t- Store the result in dp array.\\n\\n    9. Tabulation Steps: -\\n    -In Tabulation we follow a bottom - up approach where we go from solving smaller\\n    problems to solve big problems.\\n    - Declare the size of dp array according to changing parameter.\\n    - Replace the validPrefix() function with dp[].\\n    - For keeping track of index use a for loop. \\n    - Declare the base cases, dp[0] = 1(\"Empty subarray case\").\\n\\n    10. What does dp[index] represents\\u2753It denotes that if \"valid partition are \\n    possible till index position in array or not\".\\n//==========================================================================================================\\n    public:\\n    //MEMOIZATION\\n       \\t    bool validPrefix(int index, vector<int> &nums, vector<int> &dp)\\n       \\t    {\\n       \\t        if (index < 0)\\n       \\t            return 1;//Empty subarray case\\n       \\t        if (dp[index] != -1)\\n       \\t            return dp[index];//Already solved\\n       \\t        bool twoIdentical = 0;\\n       \\t        bool threeIdentical = 0;\\n       \\t        bool increasingSeq = 0;\\n                \\n                //Slef-Explanatory\\n       \\t        if (index > 0 && nums[index] == nums[index - 1])\\n       \\t            twoIdentical = validPrefix(index - 2, nums, dp);\\n                //2 elems mil gaye valid to ab index-2 pe search karenge\\n       \\t        if (index > 1 && nums[index] == nums[index - 1] && nums[index - 1] == nums[index - 2])\\n       \\t            threeIdentical = validPrefix(index - 3, nums, dp);\\n                //3 elems mil gaye valid to ab index-3 pe search karenge.\\n       \\t        if (index > 1 && nums[index] == nums[index - 1] + 1 && nums[index - 1] == nums[index - 2] + 1)\\n       \\t            increasingSeq = validPrefix(index - 3, nums, dp);\\n       \\t        return dp[index] = twoIdentical || threeIdentical || increasingSeq;\\n       \\t    }\\n       \\tbool validPartition(vector<int> &nums)\\n       \\t{\\n       \\t    int n = nums.size();\\n       \\t    vector<int> dp(n, -1);\\n       \\t    return validPrefix(n - 1, nums, dp);\\n       \\t}\\n\\n//=====================================================================================================\\n\\n//TABULATION\\n bool validPartition(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n\\n            vector<int> dp(n + 1, 0);\\n            dp[0] = 1;//Emprt subarray case\\n\\n            for (int index = 0; index < n; index++)\\n            {\\n                int i = index + 1;\\n                bool twoIdentical = false;\\n                bool threeIdentical = false;\\n                bool increasingSeq = false;\\n\\n                if (index > 0 && nums[index] == nums[index - 1])\\n                {\\n                    twoIdentical = dp[i - 2];\\n                }\\n\\n                if (index > 1 && nums[index] == nums[index - 1] && nums[index - 1] == nums[index - 2] && nums[index] == nums[index - 2])\\n                {\\n                    threeIdentical = dp[i - 3];\\n                }\\n\\n                if (index > 1 && nums[index] == nums[index - 1] + 1 && nums[index - 1] == nums[index - 2] + 1)\\n                {\\n                    increasingSeq = dp[i - 3];\\n                }\\n\\n                dp[i] = twoIdentical || threeIdentical || increasingSeq;\\n            }\\n\\n            return dp[n];\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390584,
                "title": "java-dp-check-3-conditions",
                "content": "Check all 3 conditions for a given index `i`.\\n\\nHere I use `|=` because we only need 1 of the 3 conditions to be true for `dp[i]` to be true, and \\n`if (cond) dp[i] = true` is equivalent to `dp[i] |= cond`. \\n\\n#### Why do we need to check previous dp values as well?\\nConsider `[1, 1, 2, 3, 4]`. Here `dp[2] = true` because `[1, 1]` satisfies cond 1, and then we get to `dp[5]`, we check that it satisfies cond 3, but that alone isn\\'t enough, we must also check `dp[2]`. Consider the case `[1, 9, 2, 3, 4]`. where `dp[5]` should be false even though `[2, 3, 4]` are consecutive integers, and it is because `dp[2]` is false.\\n#### Java\\n```Java\\n// Time O(n)\\n// Space O(n)\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        boolean[] dp = new boolean[nums.length+1];\\n        dp[0]=true; // base case\\n        for (int i = 2; i <= nums.length; i++){\\n            dp[i]|= nums[i-1]==nums[i-2] && dp[i-2]; // cond 1\\n            dp[i]|= i>2 && nums[i-1] == nums[i-2] && nums[i-2] == nums[i-3] && dp[i-3]; // cond 2\\n            dp[i]|= i>2 && nums[i-1]-nums[i-2]==1 && nums[i-2]-nums[i-3]==1 && dp[i-3]; // cond 3\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```\\n#### Optimization\\nHere is O(1) space solution. Using a circular array.\\n```Java\\n// Time O(n)\\n// Space O(1)\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        boolean[] dp = new boolean[4];\\n        dp[0]=true; // base case\\n        for (int i = 2; i <= nums.length; i++){\\n            dp[i%4]=false; // remember to initiate the current cell to false\\n            dp[i%4]|=nums[i-1]==nums[i-2] && dp[(i+2)%4]; // cond 1\\n            dp[i%4]|= i>2 && nums[i-1] == nums[i-2] && nums[i-2] == nums[i-3] && dp[(i+1)%4]; // cond 2\\n            dp[i%4]|= i>2 && nums[i-1]-nums[i-2]==1 && nums[i-2]-nums[i-3]==1 && dp[(i+1)%4]; // cond 3\\n        }\\n        return dp[nums.length%4];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\n// Time O(n)\\n// Space O(n)\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        boolean[] dp = new boolean[nums.length+1];\\n        dp[0]=true; // base case\\n        for (int i = 2; i <= nums.length; i++){\\n            dp[i]|= nums[i-1]==nums[i-2] && dp[i-2]; // cond 1\\n            dp[i]|= i>2 && nums[i-1] == nums[i-2] && nums[i-2] == nums[i-3] && dp[i-3]; // cond 2\\n            dp[i]|= i>2 && nums[i-1]-nums[i-2]==1 && nums[i-2]-nums[i-3]==1 && dp[i-3]; // cond 3\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```\n```Java\\n// Time O(n)\\n// Space O(1)\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        boolean[] dp = new boolean[4];\\n        dp[0]=true; // base case\\n        for (int i = 2; i <= nums.length; i++){\\n            dp[i%4]=false; // remember to initiate the current cell to false\\n            dp[i%4]|=nums[i-1]==nums[i-2] && dp[(i+2)%4]; // cond 1\\n            dp[i%4]|= i>2 && nums[i-1] == nums[i-2] && nums[i-2] == nums[i-3] && dp[(i+1)%4]; // cond 2\\n            dp[i%4]|= i>2 && nums[i-1]-nums[i-2]==1 && nums[i-2]-nums[i-3]==1 && dp[(i+1)%4]; // cond 3\\n        }\\n        return dp[nums.length%4];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393281,
                "title": "c-memoization-detailed-explanation-in-comments",
                "content": "# Detailed explanation in comments. Happy Reading :)\\n\\nCode looks too exhaustive because of explaination inside comments. **But actual code is not this big.**\\nRemove the commented lines and see actual short size of the code.\\nDon\\'t worry. I did it for you already. Scroll to end to see it.  : )\\n\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // Dp array for memoizing our calculated result. (Nothing to do with name \\'dp\\'. Feel free to give any name.)\\n        vector<int> dp(n,-1);\\n        \\n        // Call our Kind helper function to compute the result and tell if it\\'s possible to get valid partition starting from index 0.\\n        return helper(nums, dp, 0, n);\\n    }\\n    \\n    \\n    \\n    bool helper(vector<int> &arr, vector<int> &dp, int start_indx, int n)\\n    {\\n        // If we reached last index then return a very Happy True :)\\n        if(start_indx >= n)\\n            return true;\\n        \\n        // If we have already calculated the return value of helper function for this start_indx value, then return calculated value happily :)\\n        if(dp[start_indx] != -1)\\n            return dp[start_indx];\\n        \\n        \\n        // If this arr element at index = start_indx and the next element both are same then enter inside this if block.\\n        if(start_indx + 1 < n && arr[start_indx] == arr[start_indx + 1])\\n        {\\n            // Now call helper for remaining elements, 2 step ahead from current start_index.\\n\\t\\t\\t//If helper return true enter this if block.\\n            if(helper(arr, dp, start_indx + 2, n))\\n            {\\n                // Store true i.e 1 inside dp array at this start_indx position for future use (memoizing the result).\\n\\t\\t\\t\\t// This shows that it\\'s possible to get a valid array from this start_indx. \\n                dp[start_indx] = 1;\\n                \\n                // Happily return true :)\\n                return true;\\n            }\\n            \\n            // If we did not returned true from above block then we see if three elements of array are same.\\n\\t\\t\\t// If yes enter this if block.\\n            if(start_indx + 2 < n && arr[start_indx] == arr[start_indx +2])\\n            {\\n                // Call helper again for starting index equal to 3 steps ahead of this current start_indx.\\n\\t\\t\\t\\t// If helper return true enter this if block.\\n                if(helper(arr, dp, start_indx + 3, n))\\n                {\\n                    // As helper returned true, store true i.e 1 inside dp array at this start_indx for future (memoizing  the result).\\n\\t\\t\\t\\t\\t//This shows that it\\'s possible to get a valid array from this start_indx.\\n                    dp[start_indx] = 1;\\n                    \\n                    // Happily return true :)\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        \\n        // If neither 2 elements or 3 elements same then check if 3 consecutive elements of array are in A.P.\\n\\t\\t// If yes then enter this if block.\\n        if(start_indx + 2 < n && arr[start_indx + 1] - arr[start_indx] == 1 && arr[start_indx+2] - arr[start_indx] == 2)\\n        {\\n            // Call helper for starting index equal to 3 steps ahead from current start_indx. If helper returns true enter the block.\\n            if(helper(arr, dp, start_indx+3, n))\\n            {\\n                // As usual memoize the result of helper in dp at start_in\\n                dp[start_indx] = 1;\\n                \\n                // Happily return true :)\\n                return true;\\n            }\\n        }\\n        \\n        \\n        // If your code has arrived here that means none of the conditions were true or none of the calls to helper above has returned true.\\n\\t\\t// Sadly that means from this start_index of array we cannot find any valid partition.   -_-\\n        \\n        // But we still have to store this info inside our dp array so that next time if someone calls helper at this start_index, tell them not to do any calculation.\\n\\t\\t// We already know we cannot find partition from this start_indx of the array. So store 0 i.e false at this index of dp array.\\n        dp[start_indx] = 0;\\n        \\n        \\n        // Sad to return false but return it anyway :(\\n        return false;\\n    }\\n    \\n};\\n```\\n\\n\\n**Hushhh....Above code looks so giant. Well time to see it after removing all the comments**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tvector<int> dp(n,-1);\\n        return helper(nums, dp, 0, n);\\n    }\\n      \\n    bool helper(vector<int> &arr, vector<int> &dp, int start_indx, int n)\\n    {\\n        if(start_indx >= n)\\n            return true;\\n        \\n        if(dp[start_indx] != -1)\\n            return dp[start_indx];\\n      \\n        if(start_indx + 1 < n && arr[start_indx] == arr[start_indx + 1])\\n        {\\n\\t\\t\\tdp[start_indx] = helper(arr, dp, start_indx + 2, n);\\n            if(dp[start_indx])\\n                return true;\\n\\t\\t\\t\\n            if(start_indx + 2 < n && arr[start_indx] == arr[start_indx +2])\\n            {\\n\\t\\t\\t\\tdp[start_indx] = helper(arr, dp, start_indx + 3, n);\\n\\t\\t\\t\\tif(dp[start_indx])\\n\\t\\t\\t\\t\\treturn true;\\n            }\\n        }\\n        \\n \\n        if(start_indx + 2 < n && arr[start_indx + 1] - arr[start_indx] == 1 && arr[start_indx+2] - arr[start_indx] == 2)\\n        {\\n            dp[start_indx] = helper(arr, dp, start_indx+3, n);\\n            if(dp[start_indx])\\n                return true;\\n        }\\n        \\n        dp[start_indx] = 0;\\n        return false;\\n    } \\n};\\n```\\n\\n\\n**Hmmm....This is much better.**\\nI just made very few modifications.\\nThey are so small that they are not even noticable.\\nI just did it to make code look little compact. No change in logic or time complexity.\\n**Well did you noticed ?**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // Dp array for memoizing our calculated result. (Nothing to do with name \\'dp\\'. Feel free to give any name.)\\n        vector<int> dp(n,-1);\\n        \\n        // Call our Kind helper function to compute the result and tell if it\\'s possible to get valid partition starting from index 0.\\n        return helper(nums, dp, 0, n);\\n    }\\n    \\n    \\n    \\n    bool helper(vector<int> &arr, vector<int> &dp, int start_indx, int n)\\n    {\\n        // If we reached last index then return a very Happy True :)\\n        if(start_indx >= n)\\n            return true;\\n        \\n        // If we have already calculated the return value of helper function for this start_indx value, then return calculated value happily :)\\n        if(dp[start_indx] != -1)\\n            return dp[start_indx];\\n        \\n        \\n        // If this arr element at index = start_indx and the next element both are same then enter inside this if block.\\n        if(start_indx + 1 < n && arr[start_indx] == arr[start_indx + 1])\\n        {\\n            // Now call helper for remaining elements, 2 step ahead from current start_index.\\n\\t\\t\\t//If helper return true enter this if block.\\n            if(helper(arr, dp, start_indx + 2, n))\\n            {\\n                // Store true i.e 1 inside dp array at this start_indx position for future use (memoizing the result).\\n\\t\\t\\t\\t// This shows that it\\'s possible to get a valid array from this start_indx. \\n                dp[start_indx] = 1;\\n                \\n                // Happily return true :)\\n                return true;\\n            }\\n            \\n            // If we did not returned true from above block then we see if three elements of array are same.\\n\\t\\t\\t// If yes enter this if block.\\n            if(start_indx + 2 < n && arr[start_indx] == arr[start_indx +2])\\n            {\\n                // Call helper again for starting index equal to 3 steps ahead of this current start_indx.\\n\\t\\t\\t\\t// If helper return true enter this if block.\\n                if(helper(arr, dp, start_indx + 3, n))\\n                {\\n                    // As helper returned true, store true i.e 1 inside dp array at this start_indx for future (memoizing  the result).\\n\\t\\t\\t\\t\\t//This shows that it\\'s possible to get a valid array from this start_indx.\\n                    dp[start_indx] = 1;\\n                    \\n                    // Happily return true :)\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        \\n        // If neither 2 elements or 3 elements same then check if 3 consecutive elements of array are in A.P.\\n\\t\\t// If yes then enter this if block.\\n        if(start_indx + 2 < n && arr[start_indx + 1] - arr[start_indx] == 1 && arr[start_indx+2] - arr[start_indx] == 2)\\n        {\\n            // Call helper for starting index equal to 3 steps ahead from current start_indx. If helper returns true enter the block.\\n            if(helper(arr, dp, start_indx+3, n))\\n            {\\n                // As usual memoize the result of helper in dp at start_in\\n                dp[start_indx] = 1;\\n                \\n                // Happily return true :)\\n                return true;\\n            }\\n        }\\n        \\n        \\n        // If your code has arrived here that means none of the conditions were true or none of the calls to helper above has returned true.\\n\\t\\t// Sadly that means from this start_index of array we cannot find any valid partition.   -_-\\n        \\n        // But we still have to store this info inside our dp array so that next time if someone calls helper at this start_index, tell them not to do any calculation.\\n\\t\\t// We already know we cannot find partition from this start_indx of the array. So store 0 i.e false at this index of dp array.\\n        dp[start_indx] = 0;\\n        \\n        \\n        // Sad to return false but return it anyway :(\\n        return false;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tvector<int> dp(n,-1);\\n        return helper(nums, dp, 0, n);\\n    }\\n      \\n    bool helper(vector<int> &arr, vector<int> &dp, int start_indx, int n)\\n    {\\n        if(start_indx >= n)\\n            return true;\\n        \\n        if(dp[start_indx] != -1)\\n            return dp[start_indx];\\n      \\n        if(start_indx + 1 < n && arr[start_indx] == arr[start_indx + 1])\\n        {\\n\\t\\t\\tdp[start_indx] = helper(arr, dp, start_indx + 2, n);\\n            if(dp[start_indx])\\n                return true;\\n\\t\\t\\t\\n            if(start_indx + 2 < n && arr[start_indx] == arr[start_indx +2])\\n            {\\n\\t\\t\\t\\tdp[start_indx] = helper(arr, dp, start_indx + 3, n);\\n\\t\\t\\t\\tif(dp[start_indx])\\n\\t\\t\\t\\t\\treturn true;\\n            }\\n        }\\n        \\n \\n        if(start_indx + 2 < n && arr[start_indx + 1] - arr[start_indx] == 1 && arr[start_indx+2] - arr[start_indx] == 2)\\n        {\\n            dp[start_indx] = helper(arr, dp, start_indx+3, n);\\n            if(dp[start_indx])\\n                return true;\\n        }\\n        \\n        dp[start_indx] = 0;\\n        return false;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902384,
                "title": "c-dp-recursion-memoization-day-13",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool c(vector<int> &v, vector<int> &dp, int i)\\n    {\\n        int n = v.size();\\n        if (i == v.size())\\n            return true;\\n        if (dp[i] != -1)\\n            return dp[i];\\n\\n        if (i + 1 < n && v[i] == v[i + 1])\\n        {\\n            if (c(v, dp, i + 2))\\n                return dp[i] = true;\\n        }\\n\\n        if (i + 2 < n && v[i] == v[i + 2] and v[i] == v[i + 1])\\n        {\\n            if (c(v, dp, i + 3))\\n                return dp[i] = true;\\n        }\\n        if (i + 2 < n && v[i] + 1 == v[i + 1] && v[i] + 2 == v[i + 2])\\n        {\\n            if (c(v, dp, i + 3))\\n                return dp[i] = true;\\n        }\\n        return dp[i] = false;\\n    }\\n    bool validPartition(vector<int> &v)\\n    {\\n        int n = v.size();\\n        vector<int> dp(n + 1, -1);\\n        return c(v, dp, 0);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c4af5e61-1e62-4649-96e6-4ac4ea6c5d5f_1691906581.3347101.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool c(vector<int> &v, vector<int> &dp, int i)\\n    {\\n        int n = v.size();\\n        if (i == v.size())\\n            return true;\\n        if (dp[i] != -1)\\n            return dp[i];\\n\\n        if (i + 1 < n && v[i] == v[i + 1])\\n        {\\n            if (c(v, dp, i + 2))\\n                return dp[i] = true;\\n        }\\n\\n        if (i + 2 < n && v[i] == v[i + 2] and v[i] == v[i + 1])\\n        {\\n            if (c(v, dp, i + 3))\\n                return dp[i] = true;\\n        }\\n        if (i + 2 < n && v[i] + 1 == v[i + 1] && v[i] + 2 == v[i + 2])\\n        {\\n            if (c(v, dp, i + 3))\\n                return dp[i] = true;\\n        }\\n        return dp[i] = false;\\n    }\\n    bool validPartition(vector<int> &v)\\n    {\\n        int n = v.size();\\n        vector<int> dp(n + 1, -1);\\n        return c(v, dp, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903603,
                "title": "very-easy-code-line-by-line-explained-memoization-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExplore all the options and if any option returns true then answer is true.\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language) \\nhttps://youtu.be/lxpa98WWB-k\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. It initializes an array `dp` to store intermediate results.\\n2. It defines a recursive function `solve` that takes an index `j` and the array `nums` as input and returns whether a valid partition can be formed starting from index `j`.\\n3. The base case of the recursion is when `j` reaches the end of the array. In this case, it returns `1` indicating a valid partition.\\n4. It checks if the result for the current index `j` is already computed and stored in the `dp` array. If yes, it returns the result directly.\\n5. It checks for two conditions:\\n   - If the current element at index `j` is equal to the next element at index `j + 1`, it calls the `solve` function recursively for index `j + 2`.\\n   - If the current element at index `j` is equal to the next two elements at indices `j + 1` and `j + 2`, or if the elements form an incremental sequence (e.g., 1, 2, 3), it also calls the `solve` function recursively for index `j + 3`.\\n6. It returns the result of the recursive calls and stores it in the `dp` array for memoization.\\n7. The `validPartition` function initializes the `dp` array, then calls the `solve` function starting from index `0` of the input `nums` array.\\n8. If the result of the `solve` function is `1`, it indicates a valid partition, so the function returns `true`. Otherwise, it returns `false`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\nint dp[100005];\\nint solve(int j,vector<int>&nums){\\n    if(j==nums.size()){\\n        return 1;\\n    }\\n    if(dp[j]!=-1)\\n    return dp[j];\\n    int c=0;\\n       if(j+1<nums.size()){\\n           if(nums[j]==nums[j+1])\\n             c=c|solve(j+2,nums);\\n       }\\n       if(j+2<nums.size()){\\n           if(nums[j]==nums[j+1]&&nums[j]==nums[j+2]){\\n               c=c|solve(j+3,nums);\\n           }\\n           if(nums[j]+1==nums[j+1]&&nums[j+1]+1==nums[j+2]){\\n                c=c|solve(j+3,nums);\\n           }\\n       }\\n       return dp[j]= c;\\n}\\n    bool validPartition(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }\\n};\\n```\\n```java []\\npublic class Solution {\\n    int[] dp = new int[100005];\\n    \\n    public int solve(int j, int[] nums) {\\n        if (j == nums.length) {\\n            return 1;\\n        }\\n        if (dp[j] != -1) {\\n            return dp[j];\\n        }\\n        int c = 0;\\n        if (j + 1 < nums.length) {\\n            if (nums[j] == nums[j + 1]) {\\n                c |= solve(j + 2, nums);\\n            }\\n        }\\n        if (j + 2 < nums.length) {\\n            if (nums[j] == nums[j + 1] && nums[j] == nums[j + 2]) {\\n                c |= solve(j + 3, nums);\\n            }\\n            if (nums[j] + 1 == nums[j + 1] && nums[j + 1] + 1 == nums[j + 2]) {\\n                c |= solve(j + 3, nums);\\n            }\\n        }\\n        return dp[j] = c;\\n    }\\n    \\n    public boolean validPartition(int[] nums) {\\n        Arrays.fill(dp, -1);\\n        return solve(0, nums) == 1;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = [-1] * 100005\\n    \\n    def solve(self, j, nums):\\n        if j == len(nums):\\n            return 1\\n        if self.dp[j] != -1:\\n            return self.dp[j]\\n        c = 0\\n        if j + 1 < len(nums):\\n            if nums[j] == nums[j + 1]:\\n                c |= self.solve(j + 2, nums)\\n        if j + 2 < len(nums):\\n            if nums[j] == nums[j + 1] and nums[j] == nums[j + 2]:\\n                c |= self.solve(j + 3, nums)\\n            if nums[j] + 1 == nums[j + 1] and nums[j + 1] + 1 == nums[j + 2]:\\n                c |= self.solve(j + 3, nums)\\n        self.dp[j] = c\\n        return c\\n    \\n    def validPartition(self, nums):\\n        self.dp = [-1] * 100005\\n        return self.solve(0, nums) == 1\\n\\n```\\n# upvote if you understood the solution\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\nint dp[100005];\\nint solve(int j,vector<int>&nums){\\n    if(j==nums.size()){\\n        return 1;\\n    }\\n    if(dp[j]!=-1)\\n    return dp[j];\\n    int c=0;\\n       if(j+1<nums.size()){\\n           if(nums[j]==nums[j+1])\\n             c=c|solve(j+2,nums);\\n       }\\n       if(j+2<nums.size()){\\n           if(nums[j]==nums[j+1]&&nums[j]==nums[j+2]){\\n               c=c|solve(j+3,nums);\\n           }\\n           if(nums[j]+1==nums[j+1]&&nums[j+1]+1==nums[j+2]){\\n                c=c|solve(j+3,nums);\\n           }\\n       }\\n       return dp[j]= c;\\n}\\n    bool validPartition(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }\\n};\\n```\n```java []\\npublic class Solution {\\n    int[] dp = new int[100005];\\n    \\n    public int solve(int j, int[] nums) {\\n        if (j == nums.length) {\\n            return 1;\\n        }\\n        if (dp[j] != -1) {\\n            return dp[j];\\n        }\\n        int c = 0;\\n        if (j + 1 < nums.length) {\\n            if (nums[j] == nums[j + 1]) {\\n                c |= solve(j + 2, nums);\\n            }\\n        }\\n        if (j + 2 < nums.length) {\\n            if (nums[j] == nums[j + 1] && nums[j] == nums[j + 2]) {\\n                c |= solve(j + 3, nums);\\n            }\\n            if (nums[j] + 1 == nums[j + 1] && nums[j + 1] + 1 == nums[j + 2]) {\\n                c |= solve(j + 3, nums);\\n            }\\n        }\\n        return dp[j] = c;\\n    }\\n    \\n    public boolean validPartition(int[] nums) {\\n        Arrays.fill(dp, -1);\\n        return solve(0, nums) == 1;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = [-1] * 100005\\n    \\n    def solve(self, j, nums):\\n        if j == len(nums):\\n            return 1\\n        if self.dp[j] != -1:\\n            return self.dp[j]\\n        c = 0\\n        if j + 1 < len(nums):\\n            if nums[j] == nums[j + 1]:\\n                c |= self.solve(j + 2, nums)\\n        if j + 2 < len(nums):\\n            if nums[j] == nums[j + 1] and nums[j] == nums[j + 2]:\\n                c |= self.solve(j + 3, nums)\\n            if nums[j] + 1 == nums[j + 1] and nums[j + 1] + 1 == nums[j + 2]:\\n                c |= self.solve(j + 3, nums)\\n        self.dp[j] = c\\n        return c\\n    \\n    def validPartition(self, nums):\\n        self.dp = [-1] * 100005\\n        return self.solve(0, nums) == 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901531,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing dynamic programming to keep valid partitions.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n# Subscribe to my channel from here. I have 245 videos as of August 13th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n\\nhttps://youtu.be/IV7wD6NQe9M\\n\\nToday, I took a video with putting my kids on my knee. lol there are some points sounding bad. If you don\\'t understand, feel free to ask me in the comments below!\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Calculate the length of the input list and assign it to the variable `n`.\\n\\n2. Initialize a dynamic programming array `dp` of size 3, all set to `False`.\\n\\n3. Set the first element of the `dp` array to `True`.\\n\\n4. Iterate through the indices from `2` to `n` (inclusive).\\n\\n5. For each index `i`:\\n   a. Initialize a variable `ans` to `False`.\\n\\n   b. Check if the index is greater than or equal to `3` and if the last three elements in the `nums` list form an incrementing sequence. If this condition is met, check if the partition ending at index `i-3` in the `dp` array is valid (i.e., `dp[(i - 3) % 3]`). If it\\'s valid, set `ans` to `True`.\\n\\n   c. Store the value of `ans` in the dynamic programming array `dp` at index `i % 3`.\\n\\n6. Return the value at index `n % 3` of the `dp` array, indicating whether a valid partition exists for the entire input list.\\n\\nThe `dp` array is used to store whether a valid partition is possible at each index. It dynamically accumulates this information based on the conditions described in the problem.\\n\\n# Complexity\\n- Time complexity: O(n)\\nThe loop iterates through the entire input array nums, which has n elements. Inside the loop, there are constant time operations for checking and updating the dp array, which are independent of the input size.\\n\\n- Space complexity: O(1)\\nThe primary space usage comes from the dp array of length 3. This array is used to store whether a valid partition is possible at each index and takes constant space.\\n\\n```python []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n        dp = [False] * 3\\n        dp[0] = True  # An empty partition is always valid\\n\\n        for i in range(2, n + 1):\\n            ans = False\\n\\n            if nums[i - 1] == nums[i - 2]:\\n                ans = ans or dp[(i - 2) % 3]\\n            if i >= 3 and nums[i - 1] == nums[i - 2] == nums[i - 3]:\\n                ans = ans or dp[(i - 3) % 3]\\n            if i >= 3 and nums[i - 1] == nums[i - 2] + 1 == nums[i - 3] + 2:\\n                ans = ans or dp[(i - 3) % 3]\\n\\n            dp[i % 3] = ans\\n\\n        return dp[n % 3]\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function(nums) {\\n    const n = nums.length;\\n    \\n    const dp = [false, false, false];\\n    dp[0] = true;  // An empty partition is always valid\\n\\n    for (let i = 2; i <= n; i++) {\\n        let ans = false;\\n\\n        if (nums[i - 1] === nums[i - 2]) {\\n            ans = ans || dp[(i - 2) % 3];\\n        }\\n        if (i >= 3 && nums[i - 1] === nums[i - 2] && nums[i - 1] === nums[i - 3]) {\\n            ans = ans || dp[(i - 3) % 3];\\n        }\\n        if (i >= 3 && nums[i - 1] === nums[i - 2] + 1 && nums[i - 2] + 1 === nums[i - 3] + 2) {\\n            ans = ans || dp[(i - 3) % 3];\\n        }\\n\\n        dp[i % 3] = ans;\\n    }\\n\\n    return dp[n % 3];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        \\n        boolean[] dp = new boolean[3];\\n        dp[0] = true;  // An empty partition is always valid\\n\\n        for (int i = 2; i <= n; i++) {\\n            boolean ans = false;\\n\\n            if (nums[i - 1] == nums[i - 2]) {\\n                ans = ans || dp[(i - 2) % 3];\\n            }\\n            if (i >= 3 && nums[i - 1] == nums[i - 2] && nums[i - 1] == nums[i - 3]) {\\n                ans = ans || dp[(i - 3) % 3];\\n            }\\n            if (i >= 3 && nums[i - 1] == nums[i - 2] + 1 && nums[i - 2] + 1 == nums[i - 3] + 2) {\\n                ans = ans || dp[(i - 3) % 3];\\n            }\\n\\n            dp[i % 3] = ans;\\n        }\\n\\n        return dp[n % 3];\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<bool> dp(3, false);\\n        dp[0] = true;  // An empty partition is always valid\\n\\n        for (int i = 2; i <= n; i++) {\\n            bool ans = false;\\n\\n            if (nums[i - 1] == nums[i - 2]) {\\n                ans = ans || dp[(i - 2) % 3];\\n            }\\n            if (i >= 3 && nums[i - 1] == nums[i - 2] && nums[i - 1] == nums[i - 3]) {\\n                ans = ans || dp[(i - 3) % 3];\\n            }\\n            if (i >= 3 && nums[i - 1] == nums[i - 2] + 1 && nums[i - 2] + 1 == nums[i - 3] + 2) {\\n                ans = ans || dp[(i - 3) % 3];\\n            }\\n\\n            dp[i % 3] = ans;\\n        }\\n\\n        return dp[n % 3];        \\n    }\\n};\\n```\\n\\n## Thank you for reading! Please upvote this aricle and don\\'t forget to subscribe to my channel!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n        dp = [False] * 3\\n        dp[0] = True  # An empty partition is always valid\\n\\n        for i in range(2, n + 1):\\n            ans = False\\n\\n            if nums[i - 1] == nums[i - 2]:\\n                ans = ans or dp[(i - 2) % 3]\\n            if i >= 3 and nums[i - 1] == nums[i - 2] == nums[i - 3]:\\n                ans = ans or dp[(i - 3) % 3]\\n            if i >= 3 and nums[i - 1] == nums[i - 2] + 1 == nums[i - 3] + 2:\\n                ans = ans or dp[(i - 3) % 3]\\n\\n            dp[i % 3] = ans\\n\\n        return dp[n % 3]\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function(nums) {\\n    const n = nums.length;\\n    \\n    const dp = [false, false, false];\\n    dp[0] = true;  // An empty partition is always valid\\n\\n    for (let i = 2; i <= n; i++) {\\n        let ans = false;\\n\\n        if (nums[i - 1] === nums[i - 2]) {\\n            ans = ans || dp[(i - 2) % 3];\\n        }\\n        if (i >= 3 && nums[i - 1] === nums[i - 2] && nums[i - 1] === nums[i - 3]) {\\n            ans = ans || dp[(i - 3) % 3];\\n        }\\n        if (i >= 3 && nums[i - 1] === nums[i - 2] + 1 && nums[i - 2] + 1 === nums[i - 3] + 2) {\\n            ans = ans || dp[(i - 3) % 3];\\n        }\\n\\n        dp[i % 3] = ans;\\n    }\\n\\n    return dp[n % 3];    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        \\n        boolean[] dp = new boolean[3];\\n        dp[0] = true;  // An empty partition is always valid\\n\\n        for (int i = 2; i <= n; i++) {\\n            boolean ans = false;\\n\\n            if (nums[i - 1] == nums[i - 2]) {\\n                ans = ans || dp[(i - 2) % 3];\\n            }\\n            if (i >= 3 && nums[i - 1] == nums[i - 2] && nums[i - 1] == nums[i - 3]) {\\n                ans = ans || dp[(i - 3) % 3];\\n            }\\n            if (i >= 3 && nums[i - 1] == nums[i - 2] + 1 && nums[i - 2] + 1 == nums[i - 3] + 2) {\\n                ans = ans || dp[(i - 3) % 3];\\n            }\\n\\n            dp[i % 3] = ans;\\n        }\\n\\n        return dp[n % 3];\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<bool> dp(3, false);\\n        dp[0] = true;  // An empty partition is always valid\\n\\n        for (int i = 2; i <= n; i++) {\\n            bool ans = false;\\n\\n            if (nums[i - 1] == nums[i - 2]) {\\n                ans = ans || dp[(i - 2) % 3];\\n            }\\n            if (i >= 3 && nums[i - 1] == nums[i - 2] && nums[i - 1] == nums[i - 3]) {\\n                ans = ans || dp[(i - 3) % 3];\\n            }\\n            if (i >= 3 && nums[i - 1] == nums[i - 2] + 1 && nums[i - 2] + 1 == nums[i - 3] + 2) {\\n                ans = ans || dp[(i - 3) % 3];\\n            }\\n\\n            dp[i % 3] = ans;\\n        }\\n\\n        return dp[n % 3];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390820,
                "title": "explanation-dp-tabulation-space-optimisation-c-python",
                "content": "**Why Recursion:**\\nWe use recursion because at every setp we can either take 2 elements or 3 elements, we have 2 possibilities at every index. To exhaust all of them we use recursion.\\n\\n**Steps in Recursion:**\\nIf we are at some index i, we have two options\\n- Take two elements:\\n    only possible if there are two elements and they are equal\\n    ```(i+1 < nums.size() && nums[i] == nums[i+1]```\\n- Take three elements\\n    only possible if we have three elements(```i+2 < nums.size()``` and\\n    (i) they are equal\\n          ```(nums[i] == nums[i+1] && nums[i+1] == nums[i+2])```\\n    (ii) they are consecutive and increasing\\n\\t```(nums[i+1]-nums[i] == 1 && nums[i+2]-nums[i+1] == 1)```\\n\\n**Base case:**\\nif we are able to use all the elements in partitioning, we can return true\\n```i == nums.size()```\\n\\nUsing just recursion(time complexity: exponential) will give us TLE, so we memoize the recursion\\n\\n**Memoization**\\nPython\\n```\\ndef validPartition(self, nums: List[int]) -> bool:\\n    dp = [-1]*(len(nums)+1)\\n    def trav(i=0):\\n        if i == len(nums):\\n            return True\\n        \\n        if dp[i] != -1:\\n            return (False if dp[i] == 0 else True)\\n        \\n        ans = False\\n        if (i+1 < len(nums) and nums[i] == nums[i+1]):\\n            ans = ans or trav(i+2)\\n        if i+2 < len(nums):\\n            if nums[i] == nums[i+1] and nums[i+1] == nums[i+2]:\\n                ans = ans or trav(i+3)\\n            elif(nums[i+1]-nums[i] == 1 and nums[i+2]-nums[i+1] == 1):\\n                ans = ans or trav(i+3)\\n        dp[i] = (0 if ans == False else 1)\\n        return ans\\n\\treturn trav()\\n```\\n\\nC++:\\n```\\nclass Solution {\\n    \\npublic:\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if (i == nums.size()) return 1;\\n        if (dp[i] != -1) return dp[i];\\n        \\n        int ans = 0;\\n        if (i+1 < nums.size() and nums[i] == nums[i+1])\\n            ans = max(ans, solve(i+2, nums, dp));\\n        if (i+2 < nums.size())\\n        {\\n            if (nums[i] == nums[i+1] && nums[i+1] == nums[i+2])\\n                ans = max(ans, solve(i+3, nums, dp));\\n            else if (nums[i+1]-nums[i] == 1 && nums[i+2]-nums[i+1] == 1)\\n                ans = max(ans, solve(i+3, nums, dp));\\n            \\n        }\\n        \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1, -1);\\n        return solve(0, nums, dp);\\n    }\\n};\\n```\\n**TC:** O(N) since we are visiting every index once\\n**SC:** O(N+N) N for dp array and N for recursion stack Space\\n\\n\\nWe can do the same but with loops i.e., tabulation\\n\\n**Tabulation**\\n\\nPython:\\n```\\ndef validPartition(self, nums: List[int]) -> bool:\\n    dp = [False]*(len(nums)+1)\\n    dp[len(nums)] = True\\n    for i in range(len(nums)-1, -1, -1):\\n        if (i+1 < len(nums) and nums[i] == nums[i+1]):\\n            dp[i] = dp[i] or dp[i+2]\\n        if i+2 < len(nums):\\n            if nums[i] == nums[i+1] and nums[i+1] == nums[i+2]:\\n                dp[i] = dp[i] or dp[i+3]\\n            elif (nums[i+1]-nums[i] == 1 and nums[i+2]-nums[i+1] == 1):\\n                dp[i] = dp[i] or dp[i+3]\\n    return dp[0]\\n```\\nC++:\\n```\\nbool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1, 0);\\n        dp[nums.size()] = 1;\\n        for (int i=nums.size()-1; i>=0; i--)\\n        {\\n            if (i+1 < nums.size() and nums[i] == nums[i+1])\\n                dp[i] = max(dp[i], dp[i+2]);\\n            if (i+2 < nums.size())\\n            {\\n                if (nums[i] == nums[i+1] and nums[i+1] == nums[i+2])\\n                    dp[i] = max(dp[i], dp[i+3]);\\n                else if (nums[i+1]-nums[i] == 1 && nums[i+2]-nums[i+1] == 1)\\n                    dp[i] = max(dp[i], dp[i+3]);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n```\\n\\n**TC:** O(N) since we are visiting every index once\\n**SC:** O(N) N for dp array\\n\\n\\nIf we carefully observe, we are just using dp[i+2] and dp[i+3] states while calculating the answer for current state. so we can just the answer for next 3 states and still calculate the answer for current setp\\n\\n**Space Optimisation**\\nPython:\\n```\\ndef validPartition(self, nums: List[int]) -> bool:\\n    #We are setting all of them to be true because if we take any number of steps from last index, the answer is true\\n    dp_1 = True #represents (i+1) state\\n    dp_2 = True #represents (i+2) state\\n    dp_3 = True #represents (i+3) state\\n    \\n    for i in range(len(nums)-1, -1, -1):\\n        cur = False #current dp state\\n        if (i+1 < len(nums) and nums[i] == nums[i+1]):\\n            cur = cur or dp_2\\n        if i+2 < len(nums):\\n            if nums[i] == nums[i+1] and nums[i+1] == nums[i+2]:\\n                cur = cur or dp_3\\n            elif (nums[i+1]-nums[i] == 1 and nums[i+2]-nums[i+1] == 1):\\n                cur = cur or dp_3\\n        dp_1, dp_2, dp_3 = cur, dp_1, dp_2\\n    return dp_1\\n```\\nC++:\\n```\\nbool validPartition(vector<int>& nums)  {\\n    //We are setting all of them to be true because if we take any number of steps from last index, the answer is true\\n    int dp_1 = 1, dp_2 = 1, dp_3 = 1;\\n    for (int i=nums.size()-1; i>=0; i--)\\n    {\\n        int cur=0;\\n        if (i+1 < nums.size() and nums[i] == nums[i+1])\\n            cur = max(cur, dp_2);\\n        if (i+2 < nums.size())\\n        {\\n            if (nums[i] == nums[i+1] and nums[i+1] == nums[i+2])\\n                cur = max(cur, dp_3);\\n            else if (nums[i+1]-nums[i] == 1 && nums[i+2]-nums[i+1] == 1)\\n                cur = max(cur, dp_3);\\n        }\\n        dp_3 = dp_2;\\n        dp_2 = dp_1;\\n        dp_1 = cur;\\n        \\n    }\\n    return dp_1;\\n}\\n```\\n**TC:** O(N) since we are visiting every index once\\n**SC:** O(1) No array is being used\\n\\n\\nI wanted to write more details in how are we converting Memoization to Tabulation and Tabulation to Space Optimisation but it is getting too lengthy, so feel free to comment if you have any doubts.\\n\\nPlease up vote if you find this helpful.",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```(i+1 < nums.size() && nums[i] == nums[i+1]```\n```i+2 < nums.size()```\n```(nums[i] == nums[i+1] && nums[i+1] == nums[i+2])```\n```(nums[i+1]-nums[i] == 1 && nums[i+2]-nums[i+1] == 1)```\n```i == nums.size()```\n```\\ndef validPartition(self, nums: List[int]) -> bool:\\n    dp = [-1]*(len(nums)+1)\\n    def trav(i=0):\\n        if i == len(nums):\\n            return True\\n        \\n        if dp[i] != -1:\\n            return (False if dp[i] == 0 else True)\\n        \\n        ans = False\\n        if (i+1 < len(nums) and nums[i] == nums[i+1]):\\n            ans = ans or trav(i+2)\\n        if i+2 < len(nums):\\n            if nums[i] == nums[i+1] and nums[i+1] == nums[i+2]:\\n                ans = ans or trav(i+3)\\n            elif(nums[i+1]-nums[i] == 1 and nums[i+2]-nums[i+1] == 1):\\n                ans = ans or trav(i+3)\\n        dp[i] = (0 if ans == False else 1)\\n        return ans\\n\\treturn trav()\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if (i == nums.size()) return 1;\\n        if (dp[i] != -1) return dp[i];\\n        \\n        int ans = 0;\\n        if (i+1 < nums.size() and nums[i] == nums[i+1])\\n            ans = max(ans, solve(i+2, nums, dp));\\n        if (i+2 < nums.size())\\n        {\\n            if (nums[i] == nums[i+1] && nums[i+1] == nums[i+2])\\n                ans = max(ans, solve(i+3, nums, dp));\\n            else if (nums[i+1]-nums[i] == 1 && nums[i+2]-nums[i+1] == 1)\\n                ans = max(ans, solve(i+3, nums, dp));\\n            \\n        }\\n        \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1, -1);\\n        return solve(0, nums, dp);\\n    }\\n};\\n```\n```\\ndef validPartition(self, nums: List[int]) -> bool:\\n    dp = [False]*(len(nums)+1)\\n    dp[len(nums)] = True\\n    for i in range(len(nums)-1, -1, -1):\\n        if (i+1 < len(nums) and nums[i] == nums[i+1]):\\n            dp[i] = dp[i] or dp[i+2]\\n        if i+2 < len(nums):\\n            if nums[i] == nums[i+1] and nums[i+1] == nums[i+2]:\\n                dp[i] = dp[i] or dp[i+3]\\n            elif (nums[i+1]-nums[i] == 1 and nums[i+2]-nums[i+1] == 1):\\n                dp[i] = dp[i] or dp[i+3]\\n    return dp[0]\\n```\n```\\nbool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1, 0);\\n        dp[nums.size()] = 1;\\n        for (int i=nums.size()-1; i>=0; i--)\\n        {\\n            if (i+1 < nums.size() and nums[i] == nums[i+1])\\n                dp[i] = max(dp[i], dp[i+2]);\\n            if (i+2 < nums.size())\\n            {\\n                if (nums[i] == nums[i+1] and nums[i+1] == nums[i+2])\\n                    dp[i] = max(dp[i], dp[i+3]);\\n                else if (nums[i+1]-nums[i] == 1 && nums[i+2]-nums[i+1] == 1)\\n                    dp[i] = max(dp[i], dp[i+3]);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n```\n```\\ndef validPartition(self, nums: List[int]) -> bool:\\n    #We are setting all of them to be true because if we take any number of steps from last index, the answer is true\\n    dp_1 = True #represents (i+1) state\\n    dp_2 = True #represents (i+2) state\\n    dp_3 = True #represents (i+3) state\\n    \\n    for i in range(len(nums)-1, -1, -1):\\n        cur = False #current dp state\\n        if (i+1 < len(nums) and nums[i] == nums[i+1]):\\n            cur = cur or dp_2\\n        if i+2 < len(nums):\\n            if nums[i] == nums[i+1] and nums[i+1] == nums[i+2]:\\n                cur = cur or dp_3\\n            elif (nums[i+1]-nums[i] == 1 and nums[i+2]-nums[i+1] == 1):\\n                cur = cur or dp_3\\n        dp_1, dp_2, dp_3 = cur, dp_1, dp_2\\n    return dp_1\\n```\n```\\nbool validPartition(vector<int>& nums)  {\\n    //We are setting all of them to be true because if we take any number of steps from last index, the answer is true\\n    int dp_1 = 1, dp_2 = 1, dp_3 = 1;\\n    for (int i=nums.size()-1; i>=0; i--)\\n    {\\n        int cur=0;\\n        if (i+1 < nums.size() and nums[i] == nums[i+1])\\n            cur = max(cur, dp_2);\\n        if (i+2 < nums.size())\\n        {\\n            if (nums[i] == nums[i+1] and nums[i+1] == nums[i+2])\\n                cur = max(cur, dp_3);\\n            else if (nums[i+1]-nums[i] == 1 && nums[i+2]-nums[i+1] == 1)\\n                cur = max(cur, dp_3);\\n        }\\n        dp_3 = dp_2;\\n        dp_2 = dp_1;\\n        dp_1 = cur;\\n        \\n    }\\n    return dp_1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902603,
                "title": "image-explanation-recursion-memoization",
                "content": "# Why Use Recursion + Memoization?\\nBecause I cannot come up with the iterative DP solution. I prefer solving DP problems using recursion + memoization technique. After we\\'ve come up with the recursion + memoization technique, we can try and further improve the solution to iterative approach.\\n\\n# Problem Explanation:\\nConditions to be concerned of:\\n- Exactly 2 elements will be equal `[4, 4]`, or\\n- Exactly 3 elements will be equal `[4, 4, 4]`, or\\n- Exactly 3 elements will be consecutive increasing. `[3, 4, 5]` is good. But `[1, 3, 4]` is not.\\n\\nNow, if you didn\\'t understand the conditions consider this test case:\\n```\\ninput: [4, 4, 4, 5, 6, 2, 2]\\n```\\nWe need to split that into multiple subarrays.\\nOne way to split them is:\\n```\\n[4, 4] [4, 5, 6] [2, 2]\\n```\\n=> So, we can return **true**.\\n\\nBut for the following test case,\\n```\\ninput: [4, 4, 4, 5, 6, 2]\\n```\\nthere\\'s no way we can split the array into good subarrays. Because we will get either \\n1. `[4, 4] [4, 5, 6] [2]` or,\\n2. `[4, 4, 4] [5, 6, 2]`\\n\\nNotice that in **option 1**, we have a subarray with `[2]`. That clearly doesn\\'t fall under any of the above conditions. Because, the subarray needs to have at least length 2.\\n\\nAnd for **option 2**, we get the second contiguous subarray `[5, 6, 2]` which doesn\\'t fulfill our **3rd** condition of being consecutively increasing.\\n\\n# Intuition:\\nAfter understanding the problem properly our thought will be to use recursion with memoization. Now, let\\'s build the recursion tree.\\n\\n![image.png](https://assets.leetcode.com/users/images/29d5b4ca-b538-4d26-9348-43dc16150888_1691907919.55214.png)\\n\\nLet\\'s show the values returned from the nodes.\\n\\n![image.png](https://assets.leetcode.com/users/images/2dc74e87-a1ed-40d1-bfeb-85365f9c9acd_1691908252.9733953.png)\\n\\nTo validate the elements we have taken in every node, we will need 3 functions.\\n``` python\\nisValid(a, b): returns a==b\\n\\nisValid(a, b, c): returns a==b and b==c\\n\\nisConsecutive(a, b, c): returns b-a==1 and c-b==1\\n```\\nWe will further improve our recursive function by using memoization. \\nUsing `Boolean[] memo = new Boolean[n];` we will track the memoization.\\n\\n# Code\\n``` java []\\nclass Solution {\\n    int n;\\n    public boolean validPartition(int[] nums) {\\n        this.n = nums.length;\\n        Boolean[] memo = new Boolean[n];\\n        return dfs(0, nums, memo);\\n    }\\n    boolean isValid(int a, int b) {\\n        return a == b;\\n    }\\n    boolean isValid(int a, int b, int c) {\\n        return (a == b) && (b == c);\\n    }\\n    boolean isConsecutive(int a, int b, int c) {\\n        return (c-b == 1) && (b-a == 1);\\n    }\\n    boolean dfs(int idx, int[] nums, Boolean[] memo) {\\n        if(idx == n) {\\n            return true;\\n        }\\n        if(n-idx < 2) {\\n            return false;\\n        }\\n        if(memo[idx] != null) {\\n            return memo[idx];\\n        }\\n        // take 2 equal\\n        boolean take2 = isValid(nums[idx], nums[idx+1]) && dfs(idx+2, nums, memo);\\n        if(n-idx < 3) {\\n            // we don\\'t need to consider 3 length subarray.\\n            return memo[idx] = take2;\\n        }\\n        // take 3 equal or consecutive increasing\\n        boolean take3 = (isValid(nums[idx], nums[idx+1], nums[idx+2]) || isConsecutive(nums[idx], nums[idx+1], nums[idx+2])) && dfs(idx+3, nums, memo);\\n        return memo[idx] = (take2 || take3);\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int n;\\n    bool validPartition(vector<int>& nums) {\\n        n = nums.size();\\n        vector<int> memo(n, -1);\\n        return dfs(0, nums, memo) == 1;\\n    }\\n\\n    bool isValid(int a, int b) {\\n        return a == b;\\n    }\\n\\n    bool isValid(int a, int b, int c) {\\n        return (a == b) && (b == c);\\n    }\\n\\n    bool isConsecutive(int a, int b, int c) {\\n        return (c-b == 1) && (b-a == 1);\\n    }\\n\\n    int dfs(int idx, vector<int>& nums, vector<int>& memo) {\\n        if (idx == n) {\\n            return 1;\\n        }\\n        if (n-idx < 2) {\\n            return 0;\\n        }\\n        if (memo[idx] != -1) {\\n            return memo[idx];\\n        }\\n        // take 2 equal\\n        int take2 = isValid(nums[idx], nums[idx+1]) && dfs(idx+2, nums, memo);\\n        if (n-idx < 3) {\\n            // we don\\'t need to consider 3 length subarray.\\n            return memo[idx] = take2;\\n        }\\n        // take 3 equal or consecutive increasing\\n        int take3 = (isValid(nums[idx], nums[idx+1], nums[idx+2]) || isConsecutive(nums[idx], nums[idx+1], nums[idx+2])) && dfs(idx+3, nums, memo);\\n        return memo[idx] = (take2 || take3);\\n    }\\n};\\n```\\n``` Python3 []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        memo = [-1] * len(nums)\\n        return self.dfs(0, nums, memo)\\n\\n    def isValid2(self, a, b) -> bool:\\n        return a == b\\n\\n    def isValid(self, a, b, c) -> bool:\\n        return (a == b) and (b == c)\\n\\n    def isConsecutive(self, a, b, c) -> bool:\\n        return (c-b == 1) and (b-a == 1)\\n\\n    def dfs(self, idx, nums: List[int], memo: List[int]) -> bool:\\n        n = len(nums)\\n        if idx == n:\\n            return 1\\n        if n-idx < 2:\\n            return 0\\n        if memo[idx] != -1:\\n            return memo[idx]\\n        # take 2 equal\\n        take2 = self.isValid2(nums[idx], nums[idx+1]) and self.dfs(idx+2, nums, memo)\\n        if n-idx < 3:\\n            # we don\\'t need to consider 3 length subarray.\\n            memo[idx] = take2\\n            return take2\\n        # take 3 equal or consecutive increasing\\n        take3 = (self.isValid(nums[idx], nums[idx+1], nums[idx+2]) or self.isConsecutive(nums[idx], nums[idx+1], nums[idx+2])) and self.dfs(idx+3, nums, memo)\\n        memo[idx] = (take2 or take3)\\n        return memo[idx]\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/32593f42-b90d-474b-98ae-e2af9af9e413_1691910609.1057935.png)\\n\\n# Complexity Analysis:\\n- Time Complexity: $$O(N^2)$$\\nThe time complexity will be lower than $$O(N^2)$$ (Correct me if I\\'m wrong). Because, we are not incrementing the indices by 1 rather 2 or 3.\\n\\n- Space Complexity: $$O(N)$$\\nFor the memoization array.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ninput: [4, 4, 4, 5, 6, 2, 2]\\n```\n```\\n[4, 4] [4, 5, 6] [2, 2]\\n```\n```\\ninput: [4, 4, 4, 5, 6, 2]\\n```\n``` python\\nisValid(a, b): returns a==b\\n\\nisValid(a, b, c): returns a==b and b==c\\n\\nisConsecutive(a, b, c): returns b-a==1 and c-b==1\\n```\n``` java []\\nclass Solution {\\n    int n;\\n    public boolean validPartition(int[] nums) {\\n        this.n = nums.length;\\n        Boolean[] memo = new Boolean[n];\\n        return dfs(0, nums, memo);\\n    }\\n    boolean isValid(int a, int b) {\\n        return a == b;\\n    }\\n    boolean isValid(int a, int b, int c) {\\n        return (a == b) && (b == c);\\n    }\\n    boolean isConsecutive(int a, int b, int c) {\\n        return (c-b == 1) && (b-a == 1);\\n    }\\n    boolean dfs(int idx, int[] nums, Boolean[] memo) {\\n        if(idx == n) {\\n            return true;\\n        }\\n        if(n-idx < 2) {\\n            return false;\\n        }\\n        if(memo[idx] != null) {\\n            return memo[idx];\\n        }\\n        // take 2 equal\\n        boolean take2 = isValid(nums[idx], nums[idx+1]) && dfs(idx+2, nums, memo);\\n        if(n-idx < 3) {\\n            // we don\\'t need to consider 3 length subarray.\\n            return memo[idx] = take2;\\n        }\\n        // take 3 equal or consecutive increasing\\n        boolean take3 = (isValid(nums[idx], nums[idx+1], nums[idx+2]) || isConsecutive(nums[idx], nums[idx+1], nums[idx+2])) && dfs(idx+3, nums, memo);\\n        return memo[idx] = (take2 || take3);\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int n;\\n    bool validPartition(vector<int>& nums) {\\n        n = nums.size();\\n        vector<int> memo(n, -1);\\n        return dfs(0, nums, memo) == 1;\\n    }\\n\\n    bool isValid(int a, int b) {\\n        return a == b;\\n    }\\n\\n    bool isValid(int a, int b, int c) {\\n        return (a == b) && (b == c);\\n    }\\n\\n    bool isConsecutive(int a, int b, int c) {\\n        return (c-b == 1) && (b-a == 1);\\n    }\\n\\n    int dfs(int idx, vector<int>& nums, vector<int>& memo) {\\n        if (idx == n) {\\n            return 1;\\n        }\\n        if (n-idx < 2) {\\n            return 0;\\n        }\\n        if (memo[idx] != -1) {\\n            return memo[idx];\\n        }\\n        // take 2 equal\\n        int take2 = isValid(nums[idx], nums[idx+1]) && dfs(idx+2, nums, memo);\\n        if (n-idx < 3) {\\n            // we don\\'t need to consider 3 length subarray.\\n            return memo[idx] = take2;\\n        }\\n        // take 3 equal or consecutive increasing\\n        int take3 = (isValid(nums[idx], nums[idx+1], nums[idx+2]) || isConsecutive(nums[idx], nums[idx+1], nums[idx+2])) && dfs(idx+3, nums, memo);\\n        return memo[idx] = (take2 || take3);\\n    }\\n};\\n```\n``` Python3 []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        memo = [-1] * len(nums)\\n        return self.dfs(0, nums, memo)\\n\\n    def isValid2(self, a, b) -> bool:\\n        return a == b\\n\\n    def isValid(self, a, b, c) -> bool:\\n        return (a == b) and (b == c)\\n\\n    def isConsecutive(self, a, b, c) -> bool:\\n        return (c-b == 1) and (b-a == 1)\\n\\n    def dfs(self, idx, nums: List[int], memo: List[int]) -> bool:\\n        n = len(nums)\\n        if idx == n:\\n            return 1\\n        if n-idx < 2:\\n            return 0\\n        if memo[idx] != -1:\\n            return memo[idx]\\n        # take 2 equal\\n        take2 = self.isValid2(nums[idx], nums[idx+1]) and self.dfs(idx+2, nums, memo)\\n        if n-idx < 3:\\n            # we don\\'t need to consider 3 length subarray.\\n            memo[idx] = take2\\n            return take2\\n        # take 3 equal or consecutive increasing\\n        take3 = (self.isValid(nums[idx], nums[idx+1], nums[idx+2]) or self.isConsecutive(nums[idx], nums[idx+1], nums[idx+2])) and self.dfs(idx+3, nums, memo)\\n        memo[idx] = (take2 or take3)\\n        return memo[idx]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390630,
                "title": "o-n-dp-easy-to-understand",
                "content": "valid[i] is true if there are valid partitions in arr[0 ... i].\\n```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        boolean valid[] = new boolean[n];\\n        \\n        if(nums[1]==nums[0]) valid[1] = true;\\n        if(n==2) return valid[1];\\n        \\n        if(nums[2]==nums[1] && nums[1]==nums[0]) valid[2] = true;\\n        if(nums[2]==nums[1]+1 && nums[1]==nums[0]+1) valid[2] = true;\\n        if(n==3) return valid[2];\\n        \\n        for(int i=3; i<n; i++){\\n            if(nums[i]==nums[i-1] && valid[i-2]) valid[i] = true;\\n            if(nums[i]==nums[i-1] && nums[i-1]==nums[i-2] && valid[i-3]) valid[i] = true;\\n            if(nums[i]==nums[i-1]+1 && nums[i-1]==nums[i-2]+1 && valid[i-3]) valid[i] = true;\\n        }\\n        return valid[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        boolean valid[] = new boolean[n];\\n        \\n        if(nums[1]==nums[0]) valid[1] = true;\\n        if(n==2) return valid[1];\\n        \\n        if(nums[2]==nums[1] && nums[1]==nums[0]) valid[2] = true;\\n        if(nums[2]==nums[1]+1 && nums[1]==nums[0]+1) valid[2] = true;\\n        if(n==3) return valid[2];\\n        \\n        for(int i=3; i<n; i++){\\n            if(nums[i]==nums[i-1] && valid[i-2]) valid[i] = true;\\n            if(nums[i]==nums[i-1] && nums[i-1]==nums[i-2] && valid[i-3]) valid[i] = true;\\n            if(nums[i]==nums[i-1]+1 && nums[i-1]==nums[i-2]+1 && valid[i-3]) valid[i] = true;\\n        }\\n        return valid[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901362,
                "title": "easy-explanation-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/37LpfMNzhw8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        if(nums[1] == nums[0]) dp[2] = true;\\n        for (int i = 2; i < n; i++) {\\n\\n            if (nums[i] == nums[i - 1]) dp[i+1] |= dp[i - 1];\\n            \\n            if (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) dp[i+1] |= dp[i - 2];\\n            \\n            if (nums[i] == nums[i - 1] + 1 && nums[i] == nums[i - 2] + 2) dp[i+1] |= dp[i-2];\\n            \\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n\\n        if (nums[1] == nums[0]) dp[2] = true;\\n        for (int i = 2; i < n; i++) {\\n\\n            if (nums[i] == nums[i - 1]) dp[i + 1] = dp[i + 1] || dp[i - 1];\\n\\n            if (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) dp[i + 1] = dp[i + 1] || dp[i - 2];\\n\\n            if (nums[i] == nums[i - 1] + 1 && nums[i] == nums[i - 2] + 2) dp[i + 1] = dp[i + 1] || dp[i - 2];\\n\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        \\n        if nums[1] == nums[0]:\\n            dp[2] = True\\n        \\n        for i in range(2, n):\\n            if nums[i] == nums[i - 1]:\\n                dp[i + 1] = dp[i + 1] or dp[i - 1]\\n            \\n            if nums[i] == nums[i - 1] and nums[i] == nums[i - 2]:\\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\\n            \\n            if nums[i] == nums[i - 1] + 1 and nums[i] == nums[i - 2] + 2:\\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\\n        \\n        return dp[n]\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        if(nums[1] == nums[0]) dp[2] = true;\\n        for (int i = 2; i < n; i++) {\\n\\n            if (nums[i] == nums[i - 1]) dp[i+1] |= dp[i - 1];\\n            \\n            if (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) dp[i+1] |= dp[i - 2];\\n            \\n            if (nums[i] == nums[i - 1] + 1 && nums[i] == nums[i - 2] + 2) dp[i+1] |= dp[i-2];\\n            \\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n\\n        if (nums[1] == nums[0]) dp[2] = true;\\n        for (int i = 2; i < n; i++) {\\n\\n            if (nums[i] == nums[i - 1]) dp[i + 1] = dp[i + 1] || dp[i - 1];\\n\\n            if (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) dp[i + 1] = dp[i + 1] || dp[i - 2];\\n\\n            if (nums[i] == nums[i - 1] + 1 && nums[i] == nums[i - 2] + 2) dp[i + 1] = dp[i + 1] || dp[i - 2];\\n\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        \\n        if nums[1] == nums[0]:\\n            dp[2] = True\\n        \\n        for i in range(2, n):\\n            if nums[i] == nums[i - 1]:\\n                dp[i + 1] = dp[i + 1] or dp[i - 1]\\n            \\n            if nums[i] == nums[i - 1] and nums[i] == nums[i - 2]:\\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\\n            \\n            if nums[i] == nums[i - 1] + 1 and nums[i] == nums[i - 2] + 2:\\n                dp[i + 1] = dp[i + 1] or dp[i - 2]\\n        \\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405370,
                "title": "c-simple-intuitive-memoization",
                "content": "Hello Guys,\\nThis is my first post on leetcode.\\nI hope i will be able to help to some of you.\\n\\nSo, the question is to check whether we can partition the given array into some partitions following certain conditions.\\n1. subarray of two equal elements eg, [2,2]\\n2. subarray of three equal elements eg. [3,3,3]\\n3. subarray of three conscecutive increasing elements. eg. [1,2,3] or [4,5,6]\\n\\nSo, like most of dynamic programming problems one should think whether it is possible to partition elements to some index, based on  that we can check for the whole array.\\n\\nIt is to be noted that at any index any of above three condtions can be applied.\\nWe define an dp array which tell whether it is possible to partition till that index.\\nie. dp[idx] = 1 or 0\\n\\n\\nHere in my solution I am checking from the end of array whether it is possible or not.\\nSo, base condition will be if our index goes to -1, as it is 0 based indexing.\\n\\nBelow is the commented code for your reference.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// checking for cond1 if two adjacent elements are equal\\n    bool cond1(int idx, vector<int> &nums){\\n        return idx >= 1 && (nums[idx] == nums[idx - 1]);\\n    }\\n\\t\\n    // checking for cond2 if three adjacent elements are equal\\n    bool cond2(int idx, vector<int> &nums){\\n        return idx >= 2 && (nums[idx] == nums[idx - 1] && nums[idx - 1] == nums[idx - 2]);\\n    }\\n    \\n\\t// checking for cond3 if three adjacent elements are consecutive increasing\\n    bool cond3(int idx, vector<int> &nums){\\n        return idx >= 2 && ((nums[idx] - nums[idx - 1]) == 1) && ((nums[idx - 1] - nums[idx - 2]) == 1);\\n    }\\n    \\n    bool check(int idx, vector<int> &nums, vector<int> &dp){\\n        \\n\\t\\t// base condition have reached to -1 index than it is possible to partition\\n        if((idx + 1) == 0) return true;\\n        \\n\\t\\t// if we have already find answer of present index just return it\\n        if(dp[idx] != -1) return dp[idx];\\n\\t\\t\\n\\t\\t// this tells whether it is possible to partition or not\\n        bool ok = false;\\n        \\n\\t\\t// check for all three conditions if any of them returns true ok will be true\\n        if(cond1(idx, nums)) ok |= check(idx - 2, nums, dp);\\n        if(cond2(idx, nums)) ok |= check(idx - 3, nums, dp);\\n        if(cond3(idx, nums)) ok |= check(idx - 3, nums, dp);\\n        \\n\\t\\t// memoization step we are storing answer of present index so that we do not calculate again\\n        return dp[idx] = ok;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// dp array is initialised by -1 which denotes answer is not obtained by any of indexes\\n        vector<int> dp(n + 1, -1);\\n\\t\\t\\n\\t\\t// we are checking from the end of array \\n        return check(n - 1, nums, dp);\\n    }\\n};\\n```\\n\\nTime Complexity :- O(n) as we are traversing array only once\\nSpace Complexity :- O(n) we are using extra dp array \\n\\n\\nThanks for giving your time for reading this post.\\nIf there are any doubt please comment, I will try to resolve it.\\nIf there are any suggestion for writing post please comment.\\nThank You\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// checking for cond1 if two adjacent elements are equal\\n    bool cond1(int idx, vector<int> &nums){\\n        return idx >= 1 && (nums[idx] == nums[idx - 1]);\\n    }\\n\\t\\n    // checking for cond2 if three adjacent elements are equal\\n    bool cond2(int idx, vector<int> &nums){\\n        return idx >= 2 && (nums[idx] == nums[idx - 1] && nums[idx - 1] == nums[idx - 2]);\\n    }\\n    \\n\\t// checking for cond3 if three adjacent elements are consecutive increasing\\n    bool cond3(int idx, vector<int> &nums){\\n        return idx >= 2 && ((nums[idx] - nums[idx - 1]) == 1) && ((nums[idx - 1] - nums[idx - 2]) == 1);\\n    }\\n    \\n    bool check(int idx, vector<int> &nums, vector<int> &dp){\\n        \\n\\t\\t// base condition have reached to -1 index than it is possible to partition\\n        if((idx + 1) == 0) return true;\\n        \\n\\t\\t// if we have already find answer of present index just return it\\n        if(dp[idx] != -1) return dp[idx];\\n\\t\\t\\n\\t\\t// this tells whether it is possible to partition or not\\n        bool ok = false;\\n        \\n\\t\\t// check for all three conditions if any of them returns true ok will be true\\n        if(cond1(idx, nums)) ok |= check(idx - 2, nums, dp);\\n        if(cond2(idx, nums)) ok |= check(idx - 3, nums, dp);\\n        if(cond3(idx, nums)) ok |= check(idx - 3, nums, dp);\\n        \\n\\t\\t// memoization step we are storing answer of present index so that we do not calculate again\\n        return dp[idx] = ok;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// dp array is initialised by -1 which denotes answer is not obtained by any of indexes\\n        vector<int> dp(n + 1, -1);\\n\\t\\t\\n\\t\\t// we are checking from the end of array \\n        return check(n - 1, nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390450,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nLet the functions `f` and `g` check to see if there is a valid partition starting at index `i` of size 2 and size 3 correspondingly and let `dp[i]` denote the \"reachability\" of the `i`<sup>th</sup> index non-inclusive.  Return true if-and-only-if we can reach `N` non-inclusive, where `N` is the cardinality of the input array `A`.\\n                             \\n---\\n\\n**<u>Top-Down:</u>**\\n\\n**\\uD83D\\uDED1 Base Case:** when `i == N` return `true`\\n\\n**\\uD83E\\uDD14 Recurrence Relations:** if we can reach the `i`<sup>th</sup> index, then...\\n\\n* **Case 1:** if we can create a partition starting at index `i` of size 2, then return `true` IFF `go(i + 2)` returns `true`\\n* **Case 2:** if we can create a partition starting at index `i` of size 3, then return `true` IFF `go(i + 3)` returns `true`\\n\\n---\\n\\n**<u>Bottom-Up:</u>**\\n\\n**\\uD83D\\uDED1 Base Case:** `dp[0] = true`\\n\\n**\\uD83E\\uDD14 Recurrence Relations:** if we can reach the `i`<sup>th</sup> index, then...\\n\\n* **Case 1:** if we can create a partition starting at index `i` of size 2, then `dp[i + 2] = true`\\n* **Case 2:** if we can create a partition starting at index `i` of size 3, then `dp[i + 3] = true`\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun validPartition(A: IntArray): Boolean {\\n        var N = A.size\\n        var f = { i: Int -> i + 2 <= N && A[i] == A[i + 1] }\\n        var g = { i: Int -> i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)) }\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            var ok = false\\n            if (f(i)) ok = go(i + 2) || ok\\n            if (g(i)) ok = go(i + 3) || ok\\n            return ok\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun validPartition(A: IntArray): Boolean {\\n        var N = A.size\\n        var f = { i: Int -> i + 2 <= N && A[i] == A[i + 1] }\\n        var g = { i: Int -> i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)) }\\n        var m = mutableMapOf<Int, Boolean>()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            if (!m.contains(i)) {\\n                var ok = false\\n                if (f(i)) ok = go(i + 2) || ok\\n                if (g(i)) ok = go(i + 3) || ok\\n                m[i] = ok\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun validPartition(A: IntArray): Boolean {\\n        var N = A.size\\n        var f = { i: Int -> i + 2 <= N && A[i] == A[i + 1] }\\n        var g = { i: Int -> i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)) }\\n        var dp = BooleanArray(N + 1) { false }\\n        dp[0] = true\\n        for (i in 0 until N) {\\n            if (!dp[i])\\n                continue\\n            if (f(i)) dp[i + 2] = true\\n            if (g(i)) dp[i + 3] = true\\n        }\\n        return dp[N]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet validPartition = A => {\\n    let N = A.length;\\n    let f = i => i + 2 <= N && A[i] == A[i + 1];\\n    let g = i => i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2));\\n    let dp = Array(N + 1).fill(0);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        let ok = false;\\n        if (f(i)) ok |= go(i + 2);\\n        if (g(i)) ok |= go(i + 3);\\n        return ok;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet validPartition = (A, m = new Map()) => {\\n    let N = A.length;\\n    let f = i => i + 2 <= N && A[i] == A[i + 1];\\n    let g = i => i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2));\\n    let dp = Array(N + 1).fill(0);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        if (!m.has(i)) {\\n            let ok = false;\\n            if (f(i)) ok |= go(i + 2);\\n            if (g(i)) ok |= go(i + 3);\\n            m.set(i, ok);\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet validPartition = A => {\\n    let N = A.length;\\n    let f = i => i + 2 <= N && A[i] == A[i + 1];\\n    let g = i => i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2));\\n    let dp = Array(N + 1).fill(0);\\n    dp[0] = 1;\\n    for (let i = 0; i < N; ++i) {\\n        if (!dp[i])\\n            continue;\\n        if (f(i)) dp[i + 2] = 1;\\n        if (g(i)) dp[i + 3] = 1;\\n    }\\n    return dp[N];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def validPartition(self, A: List[int]) -> bool:\\n        N = len(A)\\n        f = lambda i: i + 2 <= N and A[i] == A[i + 1]\\n        g = lambda i: i + 3 <= N and (A[i] == A[i + 1] == A[i + 2] or A[i] == A[i + 1] - 1 == A[i + 2] - 2)\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            ok = False\\n            if f(i): ok = go(i + 2) or ok\\n            if g(i): ok = go(i + 3) or ok\\n            return ok\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def validPartition(self, A: List[int]) -> bool:\\n        N = len(A)\\n        f = lambda i: i + 2 <= N and A[i] == A[i + 1]\\n        g = lambda i: i + 3 <= N and (A[i] == A[i + 1] == A[i + 2] or A[i] == A[i + 1] - 1 == A[i + 2] - 2)\\n        @cache\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            ok = False\\n            if f(i): ok = go(i + 2) or ok\\n            if g(i): ok = go(i + 3) or ok\\n            return ok\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def validPartition(self, A: List[int]) -> bool:\\n        N = len(A)\\n        f = lambda i: i + 2 <= N and A[i] == A[i + 1]\\n        g = lambda i: i + 3 <= N and (A[i] == A[i + 1] == A[i + 2] or A[i] == A[i + 1] - 1 == A[i + 2] - 2)\\n        dp = [0] * (N + 1)\\n        dp[0] = 1\\n        for i in range(N):\\n            if not dp[i]:\\n                continue\\n            if f(i): dp[i + 2] = 1\\n            if g(i): dp[i + 3] = 1\\n        return dp[N]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn valid_partition(A: VI) -> bool {\\n        fn go(A: &VI, i: usize) -> bool {\\n            let N = A.len();\\n            let f = (|i| i + 2 <= N && A[i] == A[i + 1]);\\n            let g = (|i| i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)));\\n            if i == N {\\n                return true;\\n            }\\n            let mut ok = false;\\n            if f(i) { ok |= go(A, i + 2); }\\n            if g(i) { ok |= go(A, i + 3); }\\n            return ok;\\n        }\\n        go(&A, 0)\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn valid_partition(A: VI) -> bool {\\n        fn go(A: &VI, i: usize, m: &mut HashMap<usize, bool>) -> bool {\\n            let N = A.len();\\n            let f = (|i| i + 2 <= N && A[i] == A[i + 1]);\\n            let g = (|i| i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)));\\n            if i == N {\\n                return true;\\n            }\\n            if !m.contains_key(&i) {\\n                let mut ok = false;\\n                if f(i) { ok |= go(A, i + 2, m); }\\n                if g(i) { ok |= go(A, i + 3, m); }\\n                m.insert(i, ok);\\n            }\\n            *m.get(&i).unwrap()\\n        }\\n        go(&A, 0, &mut HashMap::new())\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nimpl Solution {\\n    pub fn valid_partition(A: Vec<i32>) -> bool {\\n        let N = A.len();\\n        let f = (|i| i + 2 <= N && A[i] == A[i + 1]);\\n        let g = (|i| i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)));\\n        let mut dp = vec![false; N + 1];\\n        dp[0] = true;\\n        for i in 0..N {\\n            if !dp[i] {\\n                continue;\\n            }\\n            if f(i) { dp[i + 2] = true; }\\n            if g(i) { dp[i + 3] = true; }\\n        }\\n        dp[N]\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int)>;\\n    bool validPartition(VI& A) {\\n        int N = A.size();\\n        auto f = [&](auto i) { return i + 2 <= N && A[i] == A[i + 1]; };\\n        auto g = [&](auto i) { return i + 3 <= N && (A[i] == A[i + 1] && A[i + 1] == A[i + 2] || A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2); };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            auto ok = false;\\n            if (f(i)) ok |= go(i + 2);\\n            if (g(i)) ok |= go(i + 3);\\n            return ok;\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int)>;\\n    using Map = unordered_map<int, bool>;\\n    bool validPartition(VI& A, Map m = {}) {\\n        int N = A.size();\\n        auto f = [&](auto i) { return i + 2 <= N && A[i] == A[i + 1]; };\\n        auto g = [&](auto i) { return i + 3 <= N && (A[i] == A[i + 1] && A[i + 1] == A[i + 2] || A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2); };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            if (m.find(i) == m.end()) {\\n                auto ok = false;\\n                if (f(i)) ok |= go(i + 2);\\n                if (g(i)) ok |= go(i + 3);\\n                m[i] = ok;\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool validPartition(VI& A) {\\n        int N = A.size();\\n        auto f = [&](auto i) { return i + 2 <= N && A[i] == A[i + 1]; };\\n        auto g = [&](auto i) { return i + 3 <= N && (A[i] == A[i + 1] && A[i + 1] == A[i + 2] || A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2); };\\n        VI dp(N + 1);\\n        dp[0] = 1;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            if (!dp[i])\\n                continue;\\n            if (f(i)) dp[i + 2] = 1;\\n            if (g(i)) dp[i + 3] = 1;\\n        }\\n        return dp[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun validPartition(A: IntArray): Boolean {\\n        var N = A.size\\n        var f = { i: Int -> i + 2 <= N && A[i] == A[i + 1] }\\n        var g = { i: Int -> i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)) }\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            var ok = false\\n            if (f(i)) ok = go(i + 2) || ok\\n            if (g(i)) ok = go(i + 3) || ok\\n            return ok\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun validPartition(A: IntArray): Boolean {\\n        var N = A.size\\n        var f = { i: Int -> i + 2 <= N && A[i] == A[i + 1] }\\n        var g = { i: Int -> i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)) }\\n        var m = mutableMapOf<Int, Boolean>()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            if (!m.contains(i)) {\\n                var ok = false\\n                if (f(i)) ok = go(i + 2) || ok\\n                if (g(i)) ok = go(i + 3) || ok\\n                m[i] = ok\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun validPartition(A: IntArray): Boolean {\\n        var N = A.size\\n        var f = { i: Int -> i + 2 <= N && A[i] == A[i + 1] }\\n        var g = { i: Int -> i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)) }\\n        var dp = BooleanArray(N + 1) { false }\\n        dp[0] = true\\n        for (i in 0 until N) {\\n            if (!dp[i])\\n                continue\\n            if (f(i)) dp[i + 2] = true\\n            if (g(i)) dp[i + 3] = true\\n        }\\n        return dp[N]\\n    }\\n}\\n```\n```\\nlet validPartition = A => {\\n    let N = A.length;\\n    let f = i => i + 2 <= N && A[i] == A[i + 1];\\n    let g = i => i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2));\\n    let dp = Array(N + 1).fill(0);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        let ok = false;\\n        if (f(i)) ok |= go(i + 2);\\n        if (g(i)) ok |= go(i + 3);\\n        return ok;\\n    };\\n    return go();\\n};\\n```\n```\\nlet validPartition = (A, m = new Map()) => {\\n    let N = A.length;\\n    let f = i => i + 2 <= N && A[i] == A[i + 1];\\n    let g = i => i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2));\\n    let dp = Array(N + 1).fill(0);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        if (!m.has(i)) {\\n            let ok = false;\\n            if (f(i)) ok |= go(i + 2);\\n            if (g(i)) ok |= go(i + 3);\\n            m.set(i, ok);\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet validPartition = A => {\\n    let N = A.length;\\n    let f = i => i + 2 <= N && A[i] == A[i + 1];\\n    let g = i => i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2));\\n    let dp = Array(N + 1).fill(0);\\n    dp[0] = 1;\\n    for (let i = 0; i < N; ++i) {\\n        if (!dp[i])\\n            continue;\\n        if (f(i)) dp[i + 2] = 1;\\n        if (g(i)) dp[i + 3] = 1;\\n    }\\n    return dp[N];\\n};\\n```\n```\\nclass Solution:\\n    def validPartition(self, A: List[int]) -> bool:\\n        N = len(A)\\n        f = lambda i: i + 2 <= N and A[i] == A[i + 1]\\n        g = lambda i: i + 3 <= N and (A[i] == A[i + 1] == A[i + 2] or A[i] == A[i + 1] - 1 == A[i + 2] - 2)\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            ok = False\\n            if f(i): ok = go(i + 2) or ok\\n            if g(i): ok = go(i + 3) or ok\\n            return ok\\n        return go()\\n```\n```\\nclass Solution:\\n    def validPartition(self, A: List[int]) -> bool:\\n        N = len(A)\\n        f = lambda i: i + 2 <= N and A[i] == A[i + 1]\\n        g = lambda i: i + 3 <= N and (A[i] == A[i + 1] == A[i + 2] or A[i] == A[i + 1] - 1 == A[i + 2] - 2)\\n        @cache\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            ok = False\\n            if f(i): ok = go(i + 2) or ok\\n            if g(i): ok = go(i + 3) or ok\\n            return ok\\n        return go()\\n```\n```\\nclass Solution:\\n    def validPartition(self, A: List[int]) -> bool:\\n        N = len(A)\\n        f = lambda i: i + 2 <= N and A[i] == A[i + 1]\\n        g = lambda i: i + 3 <= N and (A[i] == A[i + 1] == A[i + 2] or A[i] == A[i + 1] - 1 == A[i + 2] - 2)\\n        dp = [0] * (N + 1)\\n        dp[0] = 1\\n        for i in range(N):\\n            if not dp[i]:\\n                continue\\n            if f(i): dp[i + 2] = 1\\n            if g(i): dp[i + 3] = 1\\n        return dp[N]\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn valid_partition(A: VI) -> bool {\\n        fn go(A: &VI, i: usize) -> bool {\\n            let N = A.len();\\n            let f = (|i| i + 2 <= N && A[i] == A[i + 1]);\\n            let g = (|i| i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)));\\n            if i == N {\\n                return true;\\n            }\\n            let mut ok = false;\\n            if f(i) { ok |= go(A, i + 2); }\\n            if g(i) { ok |= go(A, i + 3); }\\n            return ok;\\n        }\\n        go(&A, 0)\\n    }\\n}\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn valid_partition(A: VI) -> bool {\\n        fn go(A: &VI, i: usize, m: &mut HashMap<usize, bool>) -> bool {\\n            let N = A.len();\\n            let f = (|i| i + 2 <= N && A[i] == A[i + 1]);\\n            let g = (|i| i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)));\\n            if i == N {\\n                return true;\\n            }\\n            if !m.contains_key(&i) {\\n                let mut ok = false;\\n                if f(i) { ok |= go(A, i + 2, m); }\\n                if g(i) { ok |= go(A, i + 3, m); }\\n                m.insert(i, ok);\\n            }\\n            *m.get(&i).unwrap()\\n        }\\n        go(&A, 0, &mut HashMap::new())\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn valid_partition(A: Vec<i32>) -> bool {\\n        let N = A.len();\\n        let f = (|i| i + 2 <= N && A[i] == A[i + 1]);\\n        let g = (|i| i + 3 <= N && ((A[i] == A[i + 1] && A[i + 1] == A[i + 2]) || (A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2)));\\n        let mut dp = vec![false; N + 1];\\n        dp[0] = true;\\n        for i in 0..N {\\n            if !dp[i] {\\n                continue;\\n            }\\n            if f(i) { dp[i + 2] = true; }\\n            if g(i) { dp[i + 3] = true; }\\n        }\\n        dp[N]\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int)>;\\n    bool validPartition(VI& A) {\\n        int N = A.size();\\n        auto f = [&](auto i) { return i + 2 <= N && A[i] == A[i + 1]; };\\n        auto g = [&](auto i) { return i + 3 <= N && (A[i] == A[i + 1] && A[i + 1] == A[i + 2] || A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2); };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            auto ok = false;\\n            if (f(i)) ok |= go(i + 2);\\n            if (g(i)) ok |= go(i + 3);\\n            return ok;\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int)>;\\n    using Map = unordered_map<int, bool>;\\n    bool validPartition(VI& A, Map m = {}) {\\n        int N = A.size();\\n        auto f = [&](auto i) { return i + 2 <= N && A[i] == A[i + 1]; };\\n        auto g = [&](auto i) { return i + 3 <= N && (A[i] == A[i + 1] && A[i + 1] == A[i + 2] || A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2); };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            if (m.find(i) == m.end()) {\\n                auto ok = false;\\n                if (f(i)) ok |= go(i + 2);\\n                if (g(i)) ok |= go(i + 3);\\n                m[i] = ok;\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool validPartition(VI& A) {\\n        int N = A.size();\\n        auto f = [&](auto i) { return i + 2 <= N && A[i] == A[i + 1]; };\\n        auto g = [&](auto i) { return i + 3 <= N && (A[i] == A[i + 1] && A[i + 1] == A[i + 2] || A[i] == A[i + 1] - 1 && A[i + 1] - 1 == A[i + 2] - 2); };\\n        VI dp(N + 1);\\n        dp[0] = 1;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            if (!dp[i])\\n                continue;\\n            if (f(i)) dp[i + 2] = 1;\\n            if (g(i)) dp[i + 3] = 1;\\n        }\\n        return dp[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407240,
                "title": "easy-solution-complete-explanation",
                "content": "```\\nDo upvote \\nwhile (learning == true)\\n```\\n# Intution & Basics\\n1. We are given three options to partition, at any given instance and we have to choose one among them. So, we should think of using dp as exploring all options (`brute-force`) will require exponential time.\\n2. Memoization of recursion is as good as Tabular DP (*not completely true but it will get the job done*) when you are learning, so write recursive solution and memoize.\\n3. Suppose you are at an `i` (0 to i-1 have been partitioned correctly w/ a partition b/w i-1 and i), you can partition in one the three choices :\\n\\t\\ta) ``` make a partition after i+1 ``` corresponding to first cond. in the Q.\\n\\t\\tb) ``` make a partition after i+2```  corresponding to second and third cond. in the Q.\\n\\tpartitions will be made only when its possible.\\n4. We repeat the step 3, if we reach i = size(nums) we `return true` else `return false`.\\n# Implementation\\n<iframe src=\"https://leetcode.com/playground/UXoviDLm/shared\" frameBorder=\"0\" width=\"1000\" height=\"750\"></iframe>\\n\\n\\n\\n **Rolling DP is an amazing concept, which can be used here [check this post by Lee.](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/discuss/2390802/JavaC%2B%2BPython-DP-O(1)-Space)**\\n \\n \\n![image](https://assets.leetcode.com/users/images/d80e3b11-c0b5-4fe2-81ae-94c2367f29f9_1660141948.2679107.png)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nDo upvote \\nwhile (learning == true)\\n```\n``` make a partition after i+1 ```\n``` make a partition after i+2```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390500,
                "title": "recursion-memoization-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[100005];\\n\\t\\tint help(int i,vector<int>&nums){\\n\\t\\t\\tif(i>=size(nums)) return 1;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tif(dp[i]!=-1) return dp[i];\\n\\t\\t\\tif(i+2<size(nums) and nums[i+1]==nums[i] and nums[i+1]==nums[i+2]) res|=help(i+3,nums);\\n\\t\\t\\tif(i+2<size(nums) and nums[i+1]-1==nums[i] and nums[i+1]==nums[i+2]-1) res|=help(i+3,nums);\\n\\t\\t\\tif(i+1<size(nums) and nums[i+1]==nums[i]) res|=help(i+2,nums);\\n\\t\\t\\treturn dp[i] = res;\\n\\t\\t}\\n\\n\\t\\tbool validPartition(vector<int>& nums) {\\n\\t\\t\\tmemset(dp,-1,sizeof dp);\\n\\t\\t\\treturn help(0,nums);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[100005];\\n\\t\\tint help(int i,vector<int>&nums){\\n\\t\\t\\tif(i>=size(nums)) return 1;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tif(dp[i]!=-1) return dp[i];\\n\\t\\t\\tif(i+2<size(nums) and nums[i+1]==nums[i] and nums[i+1]==nums[i+2]) res|=help(i+3,nums);\\n\\t\\t\\tif(i+2<size(nums) and nums[i+1]-1==nums[i] and nums[i+1]==nums[i+2]-1) res|=help(i+3,nums);\\n\\t\\t\\tif(i+1<size(nums) and nums[i+1]==nums[i]) res|=help(i+2,nums);\\n\\t\\t\\treturn dp[i] = res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2392960,
                "title": "recursion-memoization-java",
                "content": "```\\nclass Solution {\\n    \\n    Boolean[] dp;\\n    \\n    public boolean Helper(int[] arr, int idx, int n){\\n        \\n        if(idx == n)  return true;\\n        \\n        if(dp[idx] != null)     return dp[idx];\\n        \\n        boolean f1 = false;             \\n        boolean f2 = false;\\n        boolean f3 = false;\\n        \\n\\t\\t// if two consective elements are same\\n        if(idx + 1 < n){\\n            if(arr[idx] == arr[idx + 1]){\\n                f1 = Helper(arr, idx + 2, n);\\n            }\\n        }\\n        \\n        if(idx + 2 < n){\\n\\t\\t\\t// if three consecutive elements are same\\n            if(arr[idx] == arr[idx + 1] && arr[idx + 1] == arr[idx + 2]){\\n                f2 = Helper(arr, idx + 3, n);\\n            }\\n            \\n\\t\\t\\t// if three elements are consecutive (their difference is 1)\\n            if(arr[idx + 2] - arr[idx + 1] == 1 && arr[idx + 1] - arr[idx] == 1){\\n                f3 = Helper(arr, idx + 3, n);\\n            }\\n        }\\n        \\n        return dp[idx] = f1 || f2 || f3;\\n    }\\n    \\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        dp = new Boolean[n];\\n        \\n        return Helper(nums, 0, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Boolean[] dp;\\n    \\n    public boolean Helper(int[] arr, int idx, int n){\\n        \\n        if(idx == n)  return true;\\n        \\n        if(dp[idx] != null)     return dp[idx];\\n        \\n        boolean f1 = false;             \\n        boolean f2 = false;\\n        boolean f3 = false;\\n        \\n\\t\\t// if two consective elements are same\\n        if(idx + 1 < n){\\n            if(arr[idx] == arr[idx + 1]){\\n                f1 = Helper(arr, idx + 2, n);\\n            }\\n        }\\n        \\n        if(idx + 2 < n){\\n\\t\\t\\t// if three consecutive elements are same\\n            if(arr[idx] == arr[idx + 1] && arr[idx + 1] == arr[idx + 2]){\\n                f2 = Helper(arr, idx + 3, n);\\n            }\\n            \\n\\t\\t\\t// if three elements are consecutive (their difference is 1)\\n            if(arr[idx + 2] - arr[idx + 1] == 1 && arr[idx + 1] - arr[idx] == 1){\\n                f3 = Helper(arr, idx + 3, n);\\n            }\\n        }\\n        \\n        return dp[idx] = f1 || f2 || f3;\\n    }\\n    \\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        dp = new Boolean[n];\\n        \\n        return Helper(nums, 0, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391256,
                "title": "python-dp-explained",
                "content": "We have 3 conditions to check for a valid partiton.\\n\\nOnly one of the conditions must hold for a partition to be a valid partition.\\n`[2,2], [2,2,2], [1,2,3]` are all valid partitions\\n\\n`dp[i]` - is a boolean value indicating whether the array **from** index i onwards is a valid partition.\\n\\nSo at any point we check if any one of the 3 given conditions is true, plus if the rest of the array forms a valid partition.\\n\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * (n + 1)\\n        dp[n] = True\\n        \\n        for i in range(n-2, -1, -1):\\n            # we can only check next 2 elements (first valid partition condition)\\n            if i == n-2:\\n                dp[i] = nums[i] == nums[i + 1]\\n                continue\\n                \\n            # we must check all 3 given conditions\\n            \\n            # 1.\\n            dp[i] = nums[i] == nums[i+1] and dp[i+2]\\n            if dp[i]: continue\\n            \\n            # 2.\\n            dp[i] = nums[i] == nums[i+1] == nums[i+2] and dp[i+3]\\n            if dp[i]: continue\\n                \\n\\t\\t\\t#3.\\t\\n            dp[i] = nums[i] + 1 == nums[i+1] and nums[i+1] + 1 == nums[i+2] and dp[i+3]\\n        \\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * (n + 1)\\n        dp[n] = True\\n        \\n        for i in range(n-2, -1, -1):\\n            # we can only check next 2 elements (first valid partition condition)\\n            if i == n-2:\\n                dp[i] = nums[i] == nums[i + 1]\\n                continue\\n                \\n            # we must check all 3 given conditions\\n            \\n            # 1.\\n            dp[i] = nums[i] == nums[i+1] and dp[i+2]\\n            if dp[i]: continue\\n            \\n            # 2.\\n            dp[i] = nums[i] == nums[i+1] == nums[i+2] and dp[i+3]\\n            if dp[i]: continue\\n                \\n\\t\\t\\t#3.\\t\\n            dp[i] = nums[i] + 1 == nums[i+1] and nums[i+1] + 1 == nums[i+2] and dp[i+3]\\n        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901917,
                "title": "memoization-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int s,int &n,vector<int> &v,vector<int> &dp){\\n        if(s>=n){\\n            return true;\\n        }\\n        if(dp[s]!=-1)return dp[s];\\n        bool ans = false;\\n        if(s+1<n&&v[s]==v[s+1]){\\n            ans |= solve(s+2,n,v,dp);\\n        }\\n        if(s+2<n&&v[s]==v[s+1]&&v[s+1]==v[s+2]){\\n            ans |= solve(s+3,n,v,dp);\\n        }\\n        if(s+2<n&&v[s]+1==v[s+1]&&v[s+1]+1==v[s+2]){\\n            ans |= solve(s+3,n,v,dp);\\n        }\\n        return dp[s] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(0,n,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int s,int &n,vector<int> &v,vector<int> &dp){\\n        if(s>=n){\\n            return true;\\n        }\\n        if(dp[s]!=-1)return dp[s];\\n        bool ans = false;\\n        if(s+1<n&&v[s]==v[s+1]){\\n            ans |= solve(s+2,n,v,dp);\\n        }\\n        if(s+2<n&&v[s]==v[s+1]&&v[s+1]==v[s+2]){\\n            ans |= solve(s+3,n,v,dp);\\n        }\\n        if(s+2<n&&v[s]+1==v[s+1]&&v[s+1]+1==v[s+2]){\\n            ans |= solve(s+3,n,v,dp);\\n        }\\n        return dp[s] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(0,n,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390762,
                "title": "easy-dp-solution",
                "content": "```\\n//There will be 3 cases to check if the current element can be a valid partition \\n//We are using 1 based indexing for our dp vector\\nbool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);dp[0]=1;//for 0 elements answer will be 1\\n\\t\\t//Now we will start checking one by one all possible 3 cases as mention in statement\\n\\t\\t//If at any point we found if any one of cases is true we will check if before that point if the array was valid or not.\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==nums[i-1])dp[i+1]=(dp[i+1] || dp[i-1]);//Case 1: For two equal element \\n            if(i>=2 && (nums[i]==nums[i-1]&&nums[i-2]==nums[i-1]))dp[i+1]=(dp[i+1] || dp[i-2]);//Case 2: For three equal element \\n            if(i>=2 && (nums[i]==nums[i-1]+1&&nums[i-2]+1==nums[i-1]))dp[i+1]=(dp[i+1] || dp[i-2]);//Case 3: For three element with diffrerence of one.\\n        }\\n        return dp[n]==1;\\n    }",
                "solutionTags": [],
                "code": "```\\n//There will be 3 cases to check if the current element can be a valid partition \\n//We are using 1 based indexing for our dp vector\\nbool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);dp[0]=1;//for 0 elements answer will be 1\\n\\t\\t//Now we will start checking one by one all possible 3 cases as mention in statement\\n\\t\\t//If at any point we found if any one of cases is true we will check if before that point if the array was valid or not.\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==nums[i-1])dp[i+1]=(dp[i+1] || dp[i-1]);//Case 1: For two equal element \\n            if(i>=2 && (nums[i]==nums[i-1]&&nums[i-2]==nums[i-1]))dp[i+1]=(dp[i+1] || dp[i-2]);//Case 2: For three equal element \\n            if(i>=2 && (nums[i]==nums[i-1]+1&&nums[i-2]+1==nums[i-1]))dp[i+1]=(dp[i+1] || dp[i-2]);//Case 3: For three element with diffrerence of one.\\n        }\\n        return dp[n]==1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3904830,
                "title": "dp-memoization-tc-sc-discussed-easy-solution-clean-code",
                "content": "# Intuition\\nThe intuition is to do exactly what\\'s mentioned in the question.\\n\\n# Approach\\n- First try to find if we have 2 consecutive equal numbers, if we do, then check for the rest of the array, whether further partitions are possible, if yes, return a true.\\n\\n- If not, try checking if we have 3 consecutive equal numbers, if yes, check for the rest of the array, whether we can further partition the array, if yes, return a true.\\n\\n- If not, try checking if we have 3 consecutive increasing numbers, if yes, check for the rest of the array, whether we can further partition the array, if yes, return a true.\\n\\n- If none of the above paths return a true, return a false at last.\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity: O(n) + O(n) for recursion call stack\\n\\n**Please upvote if you like the solution :)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int n;\\n    bool memo(vector<int>&nums,int ind){\\n        if(ind == n)return dp[ind] = true;\\n        if(dp[ind] != -1)return dp[ind];\\n\\n        bool two_same = false, three_same = false, three_consecutive = false;\\n\\n        if(ind+1 < n && nums[ind] == nums[ind+1])\\n            two_same = memo(nums,ind+2);\\n        if(two_same)return dp[ind] = true;\\n\\n\\n        if((ind+1 < n) && (ind + 2 < n) && (nums[ind] == nums[ind+1]) && (nums[ind+1] == nums[ind+2]))\\n            three_same = memo(nums,ind+3);\\n        if(three_same)return dp[ind] = true;\\n\\n\\n        if((ind+1 < n) && (ind + 2 < n) && (nums[ind] + 1 == nums[ind+1]) && (nums[ind+1] + 1 == nums[ind+2]))\\n            three_consecutive = memo(nums,ind+3);\\n        if(three_consecutive)return dp[ind] = true;\\n        \\n        return dp[ind] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        n = nums.size();\\n        dp.resize(n+1,-1);\\n        return memo(nums,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int n;\\n    bool memo(vector<int>&nums,int ind){\\n        if(ind == n)return dp[ind] = true;\\n        if(dp[ind] != -1)return dp[ind];\\n\\n        bool two_same = false, three_same = false, three_consecutive = false;\\n\\n        if(ind+1 < n && nums[ind] == nums[ind+1])\\n            two_same = memo(nums,ind+2);\\n        if(two_same)return dp[ind] = true;\\n\\n\\n        if((ind+1 < n) && (ind + 2 < n) && (nums[ind] == nums[ind+1]) && (nums[ind+1] == nums[ind+2]))\\n            three_same = memo(nums,ind+3);\\n        if(three_same)return dp[ind] = true;\\n\\n\\n        if((ind+1 < n) && (ind + 2 < n) && (nums[ind] + 1 == nums[ind+1]) && (nums[ind+1] + 1 == nums[ind+2]))\\n            three_consecutive = memo(nums,ind+3);\\n        if(three_consecutive)return dp[ind] = true;\\n        \\n        return dp[ind] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        n = nums.size();\\n        dp.resize(n+1,-1);\\n        return memo(nums,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901300,
                "title": "c-recursive-dp-vs-iterative-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis i s a DP problem. Use 1D array DP for storing the states.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn on English subtitles if necessary]\\n[https://youtu.be/WERNnZDK3xU](https://youtu.be/WERNnZDK3xU)\\nUse top-down design. A recursive program with memozation  is implemented.  The initial cases are\\n```\\nif (i<0) return 1;\\nif (i==0) return 0; //if there is only number left\\n```\\nThe second approach uses buttom-up design with optimized space O(1). Since there are only 4 states dp[i-2], dp[i-1], dp[i] & dp[i+1] to be considered in computation. Index number modulo 4 suffices for our implementation.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\\\to O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> dp;\\n    bool f(int i, vector<int>& nums){\\n        if (i<0) return 1;\\n        if (i==0) return 0; //if there is only number left\\n        if (dp[i]!=-1) return dp[i]==1;\\n        bool b0=0, b1=0, b2=0;\\n        if (i > 0 && nums[i] == nums[i-1]) \\n            b0=f(i-2, nums);\\n        if (i > 1 && nums[i] == nums[i-1] && nums[i-1] == nums[i-2])\\n            b1=f(i-3, nums);\\n        if (i > 1 && nums[i] == nums[i-1]+1 && nums[i-1] == nums[i-2]+1)\\n            b2=f(i-3, nums);\\n    //    cout<<i<<\":\"<<b0<<\",\"<<b1<<\",\"<<b2<<endl;\\n        return dp[i]=b0||b1||b2;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        n = nums.size();\\n        dp.assign(n, -1);\\n        return f(n-1, nums);\\n    }\\n};\\n\\n```\\n# iterative Solution with SC O(1)\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();   \\n        vector<bool> dp(4, 0); // 4 states are enough\\n        dp[0]=1;  // Initialize dp[0] to 1\\n        \\n        for (int i = 0; i < n; i++) {\\n            bool b0= i>0 && (nums[i] == nums[i-1]);       \\n            bool b1= i>1 && ((nums[i] == nums[i-1] && nums[i-1] == nums[i-2])\\n            ||( nums[i] == nums[i-1] + 1 && nums[i-1] == nums[i-2] + 1));\\n            \\n            dp[(i+1)%4]= (b0 && dp[(i-1)%4]) || (b1 && dp[(i-2)%4]);\\n        //    cout<<i<<\":\"<<b0<<\",\"<<b1<<\", dp=\"<< dp[(i+1)%4]<<endl;\\n        }\\n        return dp[n%4];\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nif (i<0) return 1;\\nif (i==0) return 0; //if there is only number left\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> dp;\\n    bool f(int i, vector<int>& nums){\\n        if (i<0) return 1;\\n        if (i==0) return 0; //if there is only number left\\n        if (dp[i]!=-1) return dp[i]==1;\\n        bool b0=0, b1=0, b2=0;\\n        if (i > 0 && nums[i] == nums[i-1]) \\n            b0=f(i-2, nums);\\n        if (i > 1 && nums[i] == nums[i-1] && nums[i-1] == nums[i-2])\\n            b1=f(i-3, nums);\\n        if (i > 1 && nums[i] == nums[i-1]+1 && nums[i-1] == nums[i-2]+1)\\n            b2=f(i-3, nums);\\n    //    cout<<i<<\":\"<<b0<<\",\"<<b1<<\",\"<<b2<<endl;\\n        return dp[i]=b0||b1||b2;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        n = nums.size();\\n        dp.assign(n, -1);\\n        return f(n-1, nums);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();   \\n        vector<bool> dp(4, 0); // 4 states are enough\\n        dp[0]=1;  // Initialize dp[0] to 1\\n        \\n        for (int i = 0; i < n; i++) {\\n            bool b0= i>0 && (nums[i] == nums[i-1]);       \\n            bool b1= i>1 && ((nums[i] == nums[i-1] && nums[i-1] == nums[i-2])\\n            ||( nums[i] == nums[i-1] + 1 && nums[i-1] == nums[i-2] + 1));\\n            \\n            dp[(i+1)%4]= (b0 && dp[(i-1)%4]) || (b1 && dp[(i-2)%4]);\\n        //    cout<<i<<\":\"<<b0<<\",\"<<b1<<\", dp=\"<< dp[(i+1)%4]<<endl;\\n        }\\n        return dp[n%4];\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2390651,
                "title": "recursive-memoisaton",
                "content": "```\\nclass Solution {\\n    Boolean dp[];\\n    public boolean solve(int arr[],int i){\\n        if(i>=arr.length)   return true;\\n        // if(i>arr.length)    return false;\\n        if(dp[i]!=null) return dp[i];\\n        if(i<=(arr.length-3) && arr[i]==arr[i+1] && arr[i+1]==arr[i+2]){\\n            return dp[i]= solve(arr,i+2) || solve(arr,i+3);\\n        }\\n        if(i<=(arr.length-2) && arr[i]==arr[i+1]){\\n            return  dp[i]=solve(arr,i+2);\\n        }\\n        if(i<=(arr.length-3)){\\n            if((arr[i+1]-arr[i])==1 && (arr[i+2]-arr[i+1])==1){\\n                return dp[i]=solve(arr,i+3);\\n            }\\n        }\\n        System.out.println(i);\\n        return false;\\n    }\\n    public boolean validPartition(int[] nums) {\\n        dp = new Boolean[nums.length];\\n        return solve(nums,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[];\\n    public boolean solve(int arr[],int i){\\n        if(i>=arr.length)   return true;\\n        // if(i>arr.length)    return false;\\n        if(dp[i]!=null) return dp[i];\\n        if(i<=(arr.length-3) && arr[i]==arr[i+1] && arr[i+1]==arr[i+2]){\\n            return dp[i]= solve(arr,i+2) || solve(arr,i+3);\\n        }\\n        if(i<=(arr.length-2) && arr[i]==arr[i+1]){\\n            return  dp[i]=solve(arr,i+2);\\n        }\\n        if(i<=(arr.length-3)){\\n            if((arr[i+1]-arr[i])==1 && (arr[i+2]-arr[i+1])==1){\\n                return dp[i]=solve(arr,i+3);\\n            }\\n        }\\n        System.out.println(i);\\n        return false;\\n    }\\n    public boolean validPartition(int[] nums) {\\n        dp = new Boolean[nums.length];\\n        return solve(nums,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902453,
                "title": "simple-c-recursive-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int n,vector<int>& nums,vector<int> &dp)\\n    {\\n        if(n<0) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        bool a=0,b=0,c=0;\\n        if(n-1>=0 && nums[n]==nums[n-1]) a=solve(n-2,nums,dp);\\n         if(n-2>=0 && nums[n]==nums[n-1] && nums[n-1]==nums[n-2]) b=solve(n-3,nums,dp);\\n          if(n-2>=0 && nums[n]==nums[n-1]+1 && nums[n-1]==nums[n-2]+1) c=solve(n-3,nums,dp);\\n          return dp[n]=a|b|c;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(n-1,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int n,vector<int>& nums,vector<int> &dp)\\n    {\\n        if(n<0) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        bool a=0,b=0,c=0;\\n        if(n-1>=0 && nums[n]==nums[n-1]) a=solve(n-2,nums,dp);\\n         if(n-2>=0 && nums[n]==nums[n-1] && nums[n-1]==nums[n-2]) b=solve(n-3,nums,dp);\\n          if(n-2>=0 && nums[n]==nums[n-1]+1 && nums[n-1]==nums[n-2]+1) c=solve(n-3,nums,dp);\\n          return dp[n]=a|b|c;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(n-1,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902090,
                "title": "dp-memoization-easy-to-understand-java",
                "content": "# Approach\\n- Recursion + Memoization\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        Boolean[] dp = new Boolean[n];\\n        return f(n-1, nums, dp);\\n    }\\n\\n    private boolean f(int i, int[] nums, Boolean[] dp){\\n        if (i < 0)\\n            return true;\\n        if (dp[i] != null)\\n            return dp[i];\\n        \\n        boolean equal2 = false, equal3 = false, increasing3 = false;\\n        if (i > 0 && nums[i] == nums[i-1])\\n            equal2 = f(i-2, nums, dp);\\n        if (i > 1 && nums[i] == nums[i-1] && nums[i] == nums[i-2])\\n            equal3 = f(i-3, nums, dp);\\n        if (i > 1 && nums[i] == nums[i-1] + 1 && nums[i-1] == nums[i-2] + 1)\\n            increasing3 = f(i-3, nums, dp);\\n        return dp[i] = equal2 || equal3 || increasing3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        Boolean[] dp = new Boolean[n];\\n        return f(n-1, nums, dp);\\n    }\\n\\n    private boolean f(int i, int[] nums, Boolean[] dp){\\n        if (i < 0)\\n            return true;\\n        if (dp[i] != null)\\n            return dp[i];\\n        \\n        boolean equal2 = false, equal3 = false, increasing3 = false;\\n        if (i > 0 && nums[i] == nums[i-1])\\n            equal2 = f(i-2, nums, dp);\\n        if (i > 1 && nums[i] == nums[i-1] && nums[i] == nums[i-2])\\n            equal3 = f(i-3, nums, dp);\\n        if (i > 1 && nums[i] == nums[i-1] + 1 && nums[i-1] == nums[i-2] + 1)\\n            increasing3 = f(i-3, nums, dp);\\n        return dp[i] = equal2 || equal3 || increasing3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901810,
                "title": "rust-go-python-dp",
                "content": "**Intuition** \\uD83E\\uDDE0\\n\\nHey folks! Ever tried to slice an array into special subarrays, where the magic rules are:\\n\\n1. Two identical numbers sitting side by side, chilling.\\n2. Three identical numbers just hanging out together.\\n3. Or, three numbers increasing by one - like they\\'re climbing stairs!\\n\\nOur task today? Simple (or is it? \\uD83D\\uDE09). We need to see if a given array can be split into these magical subarrays. And guess what? I\\'ve got not one, not two, but three programming languages ready to tackle this challenge. \\uD83D\\uDE80 Let\\'s jump in!\\n\\n**Approach** \\uD83E\\uDDD0\\n\\nSo, how do we know if a subarray is magical? Dynamic Programming (DP) to the rescue! We\\'re going to use a window approach to keep track of the validity of our partitions. At every step, we\\'ll just peek at the current number and at most, the two preceding ones. That\\'s all we need!\\n\\n1. If the current number is the same as the previous one and the partition up to the previous number was valid, then... magic!\\n2. If the current number and the two before it are identical and the partition two steps back was valid, then... even more magic!\\n3. If the numbers are like climbing stairs and the partition two steps back was valid, then... you guessed it, magic!\\n\\nWith every step, our window slides, capturing the magic of the array.\\n\\n**Complexity** \\u23F3\\n\\n- **Time complexity:** \\\\(O(n)\\\\) - Just a single loop through the numbers.\\n- **Space complexity:** \\\\(O(1)\\\\) - We only need a fixed-size window.\\n\\n**Code** \\uD83D\\uDDA5\\uFE0F\\n\\n\\uD83E\\uDD80 **Rust**:\\n\\n```\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n        if n == 1 { return false; }\\n\\n        let mut dp = vec![true, false, if n > 1 { nums[0] == nums[1] } else { false }];\\n\\n        for i in 2..n {\\n            let current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                             (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                             (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        dp[2]\\n    }\\n}\\n```\\n\\n\\uD83D\\uDC0D **Python**:\\n\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n        if n == 1: \\n            return False \\n        dp = [True, False, nums[0] == nums[1] if n > 1 else False] \\n        for i in range(2, n): \\n            current_dp = (nums[i] == nums[i-1] and dp[1]) or \\\\\\n                         (nums[i] == nums[i-1] == nums[i-2] and dp[0]) or \\\\\\n                         (nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0])\\n            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp \\n        return dp[2]\\n```\\n\\n\\uD83D\\uDE80 **Go**:\\n\\n```\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n    if n == 1 { return false }\\n\\n    dp := []bool{true, false, false}\\n    if n > 1 {\\n        dp[2] = nums[0] == nums[1]\\n    }\\n\\n    for i := 2; i < n; i++ {\\n        current_dp := (nums[i] == nums[i-1] && dp[1]) || \\n                      (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                      (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0])\\n        dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp\\n    }\\n    return dp[2]\\n}\\n```\\n\\nHang tight, put on your coding hats, and let\\'s make some magic happen! And if you\\'re feeling the vibes, don\\'t forget to like, share, and subscribe for more coding adventures! \\u270C\\uFE0F\\uD83C\\uDF0C\\uD83C\\uDFA9",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n        if n == 1 { return false; }\\n\\n        let mut dp = vec![true, false, if n > 1 { nums[0] == nums[1] } else { false }];\\n\\n        for i in 2..n {\\n            let current_dp = (nums[i] == nums[i-1] && dp[1]) || \\n                             (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                             (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0]);\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = current_dp;\\n        }\\n        dp[2]\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n        if n == 1: \\n            return False \\n        dp = [True, False, nums[0] == nums[1] if n > 1 else False] \\n        for i in range(2, n): \\n            current_dp = (nums[i] == nums[i-1] and dp[1]) or \\\\\\n                         (nums[i] == nums[i-1] == nums[i-2] and dp[0]) or \\\\\\n                         (nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0])\\n            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp \\n        return dp[2]\\n```\n```\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n    if n == 1 { return false }\\n\\n    dp := []bool{true, false, false}\\n    if n > 1 {\\n        dp[2] = nums[0] == nums[1]\\n    }\\n\\n    for i := 2; i < n; i++ {\\n        current_dp := (nums[i] == nums[i-1] && dp[1]) || \\n                      (nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[0]) ||\\n                      (nums[i] - nums[i-1] == 1 && nums[i-1] - nums[i-2] == 1 && dp[0])\\n        dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp\\n    }\\n    return dp[2]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944955,
                "title": "python3-solution-dp",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def validPartition(self, A):\\n        a = True\\n        b = False\\n        c = A[0] == A[1]\\n        for i in range(2, len(A)):\\n            a, b, c = b, c, b and A[i] == A[i - 1] or a and (A[i] == A[i - 1] == A[i - 2] or A[i] == A[i - 1] + 1 == A[i - 2] + 2)\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, A):\\n        a = True\\n        b = False\\n        c = A[0] == A[1]\\n        for i in range(2, len(A)):\\n            a, b, c = b, c, b and A[i] == A[i - 1] or a and (A[i] == A[i - 1] == A[i - 2] or A[i] == A[i - 1] + 1 == A[i - 2] + 2)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425635,
                "title": "c-recursion-to-memoization-with-explantion",
                "content": "\\t// Recursion gives TLE\\n\\t// class Solution {\\n\\t// public:\\n\\t//     int solve(int i,vector<int>&nums)\\n\\t//     {\\n\\t//         if(i==nums.size()) return 1;\\n\\t//         int ans=0;\\n\\n\\t//         if(i+1<nums.size() && nums[i]==nums[i+1]){\\n\\t//             ans=max(ans,solve(i+2,nums));\\n\\t//         }\\n\\t//         if(i+2<nums.size())\\n\\t//         {\\n\\t//             if(nums[i]==nums[i+1] && nums[i+1]==nums[i+2])\\n\\t//                 ans=max(ans,solve(i+3,nums));\\n\\t//             else if(nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1)\\n\\t//                 ans=max(ans,solve(i+3,nums));\\n\\t//         }\\n\\t//         return ans;\\n\\t//     }\\n\\t//     bool validPartition(vector<int>& nums) {\\n\\t//         int ans=solve(0,nums);\\n\\t//         return ans;\\n\\t//     }\\n\\t// };\\n\\n\\n\\t// Memoize \\n\\t// since only i is changing make dp of size n+1\\n\\t// check in each step if d[i]!=-1 return dp[i]\\n\\t// else store the ans in dp vector then return \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint solve(int i,vector<int>&nums,vector<int>&dp)\\n\\t\\t{\\n\\t\\t\\tif(i==nums.size()) return 1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tif(dp[i]!=-1) return dp[i];\\n\\n\\t\\t\\tif(i+1<nums.size() && nums[i]==nums[i+1]) // two number pick \\n\\t\\t\\t{\\n\\t\\t\\t\\tans=max(ans,solve(i+2,nums,dp));\\n\\t\\t\\t}\\n\\t\\t\\tif(i+2<nums.size()) // three number pick\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]==nums[i+1] && nums[i+1]==nums[i+2])\\n\\t\\t\\t\\t\\tdp[i]=ans=max(ans,solve(i+3,nums,dp));\\n\\t\\t\\t\\telse if(nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1)\\n\\t\\t\\t\\t\\tdp[i]=ans=max(ans,solve(i+3,nums,dp));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tbool validPartition(vector<int>& nums) {\\n\\t\\t\\tvector<int>dp(nums.size()+1,-1);\\n\\t\\t\\tint ans=solve(0,nums,dp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t// public:\\n\\t//     int solve(int i,vector<int>&nums)\\n\\t//     {\\n\\t//         if(i==nums.size()) return 1;\\n\\t//         int ans=0;\\n\\n\\t//         if(i+1<nums.size() && nums[i]==nums[i+1]){\\n\\t//             ans=max(ans,solve(i+2,nums));\\n\\t//         }",
                "codeTag": "Java"
            },
            {
                "id": 2392744,
                "title": "easy-python-solution",
                "content": "```\\nn=len(nums)\\n        @cache\\n        def valid(i):\\n            if i==n:\\n                return True\\n            if i+1<n and nums[i]==nums[i+1] and valid(i+2):\\n                return True\\n            if i+2<n and nums[i]==nums[i+1]==nums[i+2] and valid(i+3):\\n                return True\\n            if i+2<n and nums[i]==nums[i+1]-1 and nums[i+1]==nums[i+2]-1 and valid(i+3):\\n                return True\\n        return valid(0)\\n```\\n***Please Upvote if you liked it.***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nn=len(nums)\\n        @cache\\n        def valid(i):\\n            if i==n:\\n                return True\\n            if i+1<n and nums[i]==nums[i+1] and valid(i+2):\\n                return True\\n            if i+2<n and nums[i]==nums[i+1]==nums[i+2] and valid(i+3):\\n                return True\\n            if i+2<n and nums[i]==nums[i+1]-1 and nums[i+1]==nums[i+2]-1 and valid(i+3):\\n                return True\\n        return valid(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2391782,
                "title": "c-dp-using-memorization-very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,vector<int>&dp,vector<int>&nums)\\n    {\\n          if(i > nums.size()) return false;\\n        if(i==nums.size())\\n        {\\n            return true;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        bool res=false;\\n        if(i+1<nums.size() &&  nums[i]==nums[i+1]) //check two equal element\\n        {\\n            res=res||solve(i+2,dp,nums);\\n        }\\n         if(i+2<nums.size() &&  nums[i]==nums[i+1]&&nums[i+1]==nums[i+2]) //check three equal element\\n        {\\n            res=res||solve(i+3,dp,nums);\\n        }\\n       \\n\\t   //check three consecutive element\\n       \\n        if(i+2<nums.size() &&  nums[i]+1==nums[i+1] && nums[i+1]+1==nums[i+2])\\n        {\\n          //  cout<<nums[i]<<\" \"<<nums[i+1];\\n            res=res||solve(i+3,dp,nums);\\n        }\\n        return dp[i]=res;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        \\n        if(nums.size()==2)\\n        {\\n            return nums[0]==nums[1];\\n        }\\n        vector<int>dp(nums.size(),-1);\\n        return solve(0,dp,nums);\\n    \\n    }\\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,vector<int>&dp,vector<int>&nums)\\n    {\\n          if(i > nums.size()) return false;\\n        if(i==nums.size())\\n        {\\n            return true;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        bool res=false;\\n        if(i+1<nums.size() &&  nums[i]==nums[i+1]) //check two equal element\\n        {\\n            res=res||solve(i+2,dp,nums);\\n        }\\n         if(i+2<nums.size() &&  nums[i]==nums[i+1]&&nums[i+1]==nums[i+2]) //check three equal element\\n        {\\n            res=res||solve(i+3,dp,nums);\\n        }\\n       \\n\\t   //check three consecutive element\\n       \\n        if(i+2<nums.size() &&  nums[i]+1==nums[i+1] && nums[i+1]+1==nums[i+2])\\n        {\\n          //  cout<<nums[i]<<\" \"<<nums[i+1];\\n            res=res||solve(i+3,dp,nums);\\n        }\\n        return dp[i]=res;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        \\n        if(nums.size()==2)\\n        {\\n            return nums[0]==nums[1];\\n        }\\n        vector<int>dp(nums.size(),-1);\\n        return solve(0,dp,nums);\\n    \\n    }\\n    \\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2390726,
                "title": "easy-to-understand-dp-code-o-n",
                "content": "```\\n//we doesn\\'t need to find partition array\\'s\\n//we only have to return whether the array can be partitioned\\n\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n=nums.length;\\n        boolean dp[]=new boolean[n+1];\\n        dp[n]=true;\\n        for(int i=n-1;i>=0;i--){\\n            if(i+1<n){\\n\\t\\t\\t\\t//cond.1 for 2 same ele\\n                if(nums[i]==nums[i+1] && dp[i+2]){\\n                    dp[i]=true;\\n                }\\n                if(i+2<n){\\n\\t\\t\\t\\t\\t//cond. 2 for 3 same ele\\n\\t\\t\\t\\t\\t//cond. 3 for difference between adjacent elements is 1.\\n                    if( ( (nums[i]==nums[i+1] && nums[i+1]==nums[i+2]) || (nums[i]+1==nums[i+1] && nums[i+1]+1==nums[i+2]) ) && dp[i+3] ){\\n                        dp[i]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n//we doesn\\'t need to find partition array\\'s\\n//we only have to return whether the array can be partitioned\\n\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n=nums.length;\\n        boolean dp[]=new boolean[n+1];\\n        dp[n]=true;\\n        for(int i=n-1;i>=0;i--){\\n            if(i+1<n){\\n\\t\\t\\t\\t//cond.1 for 2 same ele\\n                if(nums[i]==nums[i+1] && dp[i+2]){\\n                    dp[i]=true;\\n                }\\n                if(i+2<n){\\n\\t\\t\\t\\t\\t//cond. 2 for 3 same ele\\n\\t\\t\\t\\t\\t//cond. 3 for difference between adjacent elements is 1.\\n                    if( ( (nums[i]==nums[i+1] && nums[i+1]==nums[i+2]) || (nums[i]+1==nums[i+1] && nums[i+1]+1==nums[i+2]) ) && dp[i+3] ){\\n                        dp[i]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390668,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<bool>dp(n+1,false);\\n        dp[0]=true;\\n        dp[1]=false;\\n        \\n        \\n        for(int i=2;i<=n;i++){\\n            if(i==2){\\n                if(nums[i-1]==nums[i-2] and dp[i-2]){\\n                    dp[i]=true;\\n                    \\n                }\\n                \\n            }\\n            else{\\n                if(nums[i-1]==nums[i-2] and dp[i-2]){\\n                    dp[i]=true;\\n                    \\n                }\\n                \\n                \\n                if(nums[i-1]==nums[i-2] and nums[i-1]==nums[i-3] and dp[i-3]){\\n                    dp[i]=true;\\n                }\\n                \\n                \\n                if(nums[i-1]-nums[i-2]==1 and nums[i-1]-nums[i-3]==2 and dp[i-3]){\\n                    dp[i]=true;\\n                }\\n                \\n                \\n                \\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<bool>dp(n+1,false);\\n        dp[0]=true;\\n        dp[1]=false;\\n        \\n        \\n        for(int i=2;i<=n;i++){\\n            if(i==2){\\n                if(nums[i-1]==nums[i-2] and dp[i-2]){\\n                    dp[i]=true;\\n                    \\n                }\\n                \\n            }\\n            else{\\n                if(nums[i-1]==nums[i-2] and dp[i-2]){\\n                    dp[i]=true;\\n                    \\n                }\\n                \\n                \\n                if(nums[i-1]==nums[i-2] and nums[i-1]==nums[i-3] and dp[i-3]){\\n                    dp[i]=true;\\n                }\\n                \\n                \\n                if(nums[i-1]-nums[i-2]==1 and nums[i-1]-nums[i-3]==2 and dp[i-3]){\\n                    dp[i]=true;\\n                }\\n                \\n                \\n                \\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905114,
                "title": "python-3-4-lines-fixed-window-t-m-99-99",
                "content": "We use a sliding window of fixed length 3, checking element by element, whether any one of the three conditions is satisfied.\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```\\n[https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020355801/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902960,
                "title": "dp-memoization-solution",
                "content": "\\n# Approach\\nThe solve function is a recursive helper function that checks whether a valid partitioning can be achieved starting from index i of the nums array. It takes three parameters: nums (the input array), i (the current index), and dp (a memoization array to store intermediate results).\\n\\nThe base case of the recursion is when i reaches the end of the array (i == n). In this case, the function returns true indicating that a valid partition has been found.\\n\\nBefore proceeding with the recursive steps, the function checks if the result for the current index i is already stored in the memoization array dp. If it is, the function directly returns that result.\\n\\nThe variable res is used to store the final result for the current index i. It is initially set to false.\\n\\nThe first part of the code handles cases where consecutive elements in the array are equal. If the current element (nums[i]) is equal to the next element (nums[i+1]), the function explores two possibilities:\\na. It tries skipping the next element and calls solve recursively for index i+2.\\nb. If the element after the next element is also equal to nums[i], it skips two elements and calls solve recursively for index i+3.\\n\\nThe second part of the code handles cases where three consecutive elements form an increasing sequence (e.g., 1, 2, 3). If the differences between adjacent elements are both 1, the function calls solve recursively for index i+3.\\n\\nThe value of res is updated based on the results obtained from the above steps.\\n\\nFinally, the value of res is stored in the dp array for the current index i and returned.\\n\\nThe validPartition function initializes the memoization array dp with -1 values and then calls the solve function with initial parameters nums, i=0, and dp.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool solve(vector<int>& nums,int i , vector<int>&dp)\\n{\\n    int n = nums.size();\\n    if(i==n)\\n    {\\n        return true;\\n    }\\n    if(dp[i]!=-1)\\n    {\\n        return dp[i];\\n    }\\n    bool res= false;\\n    if(i+1 < n && nums[i] == nums[i+1])\\n    {\\n        res= res || solve(nums,i+2,dp);\\n        if(i+2 < n && nums[i]==nums[i+2])\\n        {\\n            res= res || solve(nums,i+3,dp);\\n        }\\n    }\\n    if(i+2 < n && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1)\\n    {\\n        res = res || solve(nums,i+3,dp);\\n    }\\n    return dp[i] = res;\\n}\\n\\n    bool validPartition(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return solve(nums, 0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool solve(vector<int>& nums,int i , vector<int>&dp)\\n{\\n    int n = nums.size();\\n    if(i==n)\\n    {\\n        return true;\\n    }\\n    if(dp[i]!=-1)\\n    {\\n        return dp[i];\\n    }\\n    bool res= false;\\n    if(i+1 < n && nums[i] == nums[i+1])\\n    {\\n        res= res || solve(nums,i+2,dp);\\n        if(i+2 < n && nums[i]==nums[i+2])\\n        {\\n            res= res || solve(nums,i+3,dp);\\n        }\\n    }\\n    if(i+2 < n && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1)\\n    {\\n        res = res || solve(nums,i+3,dp);\\n    }\\n    return dp[i] = res;\\n}\\n\\n    bool validPartition(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return solve(nums, 0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902351,
                "title": "step-by-step-simple-java-solution-by-recursion-memoization-and-tabulation-method",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPairEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1];\\n    }\\n    public boolean isTripleEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1] && nums[index] == nums[index+2];\\n    }\\n    public boolean isTripleConsecutive(int index,int []nums) {\\n        return nums[index] + 1 == nums[index+1] && nums[index+1] + 1 == nums[index+2];\\n    }\\n    public boolean recSol(int index,int []nums) {\\n        //if traversing of array is completed then return true\\n        if(index == nums.length) return true;\\n        //if we are at last element of array then we can not create partition as there are no condition for subarray of size one\\n        if(index == nums.length - 1) return false;\\n        //if we have only two elements remaining then we have to check whether that two are equal or not\\n        if(index == nums.length - 2) return isPairEqual(index,nums);\\n        //otherwise check all 3 conditions and move to new index accordingly\\n        boolean isTwo = isPairEqual(index,nums) && recSol(index+2,nums);\\n        boolean isThree = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && recSol(index+3,nums);\\n        return isTwo || isThree;\\n    }\\n    public boolean memoSol(int index,int []nums,int []dp) {\\n        if(index == nums.length) return true;\\n        if(dp[index] != -1) return dp[index] == 1 ? true : false;\\n        if(index == nums.length - 1) return false;\\n        if(index == nums.length - 2) return isPairEqual(index,nums);\\n        boolean isTwo = isPairEqual(index,nums) && memoSol(index+2,nums,dp);\\n        boolean isThree = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && memoSol(index+3,nums,dp);\\n        dp[index] = isTwo || isThree ? 1 : 0;\\n        return isTwo || isThree;\\n    }\\n    public boolean dpSol(int []nums) {\\n        int []dp = new int[nums.length+1];\\n        dp[nums.length] = 1; // if(index == nums.length) return true;\\n        dp[nums.length-1] = 0; // if(index == nums.length - 1) return false;\\n        dp[nums.length-2] = isPairEqual(nums.length-2,nums) ? 1 : 0; //if(index == nums.length - 2) return isPairEqual(index,nums);\\n        for(int index=nums.length-3;index>=0;index--) {\\n            dp[index] = isPairEqual(index,nums) && dp[index+2] == 1 ? 1 : 0; // isPairEqual(index,nums) && memoSol(index+2,nums,dp);\\n            if(dp[index] == 0) {\\n                dp[index] = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && dp[index+3] == 1 ? 1 : 0; //(isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && memoSol(index+3,nums,dp);\\n            }\\n        }\\n        return dp[0] == 1;\\n\\n    }\\n    public boolean validPartition(int[] nums) {\\n        // return recSol(0,nums);\\n        // int []dp = new int[nums.length];\\n        // Arrays.fill(dp,-1);\\n        // return memoSol(0,nums,dp);\\n        return dpSol(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPairEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1];\\n    }\\n    public boolean isTripleEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1] && nums[index] == nums[index+2];\\n    }\\n    public boolean isTripleConsecutive(int index,int []nums) {\\n        return nums[index] + 1 == nums[index+1] && nums[index+1] + 1 == nums[index+2];\\n    }\\n    public boolean recSol(int index,int []nums) {\\n        //if traversing of array is completed then return true\\n        if(index == nums.length) return true;\\n        //if we are at last element of array then we can not create partition as there are no condition for subarray of size one\\n        if(index == nums.length - 1) return false;\\n        //if we have only two elements remaining then we have to check whether that two are equal or not\\n        if(index == nums.length - 2) return isPairEqual(index,nums);\\n        //otherwise check all 3 conditions and move to new index accordingly\\n        boolean isTwo = isPairEqual(index,nums) && recSol(index+2,nums);\\n        boolean isThree = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && recSol(index+3,nums);\\n        return isTwo || isThree;\\n    }\\n    public boolean memoSol(int index,int []nums,int []dp) {\\n        if(index == nums.length) return true;\\n        if(dp[index] != -1) return dp[index] == 1 ? true : false;\\n        if(index == nums.length - 1) return false;\\n        if(index == nums.length - 2) return isPairEqual(index,nums);\\n        boolean isTwo = isPairEqual(index,nums) && memoSol(index+2,nums,dp);\\n        boolean isThree = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && memoSol(index+3,nums,dp);\\n        dp[index] = isTwo || isThree ? 1 : 0;\\n        return isTwo || isThree;\\n    }\\n    public boolean dpSol(int []nums) {\\n        int []dp = new int[nums.length+1];\\n        dp[nums.length] = 1; // if(index == nums.length) return true;\\n        dp[nums.length-1] = 0; // if(index == nums.length - 1) return false;\\n        dp[nums.length-2] = isPairEqual(nums.length-2,nums) ? 1 : 0; //if(index == nums.length - 2) return isPairEqual(index,nums);\\n        for(int index=nums.length-3;index>=0;index--) {\\n            dp[index] = isPairEqual(index,nums) && dp[index+2] == 1 ? 1 : 0; // isPairEqual(index,nums) && memoSol(index+2,nums,dp);\\n            if(dp[index] == 0) {\\n                dp[index] = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && dp[index+3] == 1 ? 1 : 0; //(isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && memoSol(index+3,nums,dp);\\n            }\\n        }\\n        return dp[0] == 1;\\n\\n    }\\n    public boolean validPartition(int[] nums) {\\n        // return recSol(0,nums);\\n        // int []dp = new int[nums.length];\\n        // Arrays.fill(dp,-1);\\n        // return memoSol(0,nums,dp);\\n        return dpSol(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901812,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        vector<int> Dp(n + 1);\\n        Dp[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (!Dp[i]) {\\n                continue;\\n            }\\n            if (i + 2 <= n) {\\n                if (nums[i] == nums[i + 1]) {\\n                    Dp[i + 2] = 1;\\n                }\\n            }\\n            if (i + 3 <= n) {\\n                if (nums[i] == nums[i + 1] and nums[i + 1] == nums[i + 2]) {\\n                    Dp[i + 3] = 1;\\n                }\\n                else if (nums[i] + 1 == nums[i + 1] and nums[i + 1] + 1 == nums[i + 2]) {\\n                    Dp[i + 3] = 1;\\n                }\\n            }\\n        }\\n        return Dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        vector<int> Dp(n + 1);\\n        Dp[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (!Dp[i]) {\\n                continue;\\n            }\\n            if (i + 2 <= n) {\\n                if (nums[i] == nums[i + 1]) {\\n                    Dp[i + 2] = 1;\\n                }\\n            }\\n            if (i + 3 <= n) {\\n                if (nums[i] == nums[i + 1] and nums[i + 1] == nums[i + 2]) {\\n                    Dp[i + 3] = 1;\\n                }\\n                else if (nums[i] + 1 == nums[i + 1] and nums[i + 1] + 1 == nums[i + 2]) {\\n                    Dp[i + 3] = 1;\\n                }\\n            }\\n        }\\n        return Dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901264,
                "title": "ruby-solution-with-memoization-explained-100-100",
                "content": "# Intuition\\nStart at the beginning of the array.  If the first two  or first threee elements form a valid subarray, see if the rest of the array can be partitioned.  (Return true if you get to the end.)  Memoize for efficiency.\\n\\n# Approach\\n1. Create a memo that will take in the index and say if the subarray starting at that point can be partitioned.\\n2. Make nums a class variable to it\\'s accessible in the helper function.\\n3. Call the helper function for index 0.\\n\\nHelper function:\\n1. Return true if you reached the end of the array.\\n2. Return a stored value in memo if there is one.  (Note that we can\\'t do ```return @memo[i] if @memo[i]``` because ```@memo[i]``` could exist but be false, which is falsey.  Check if it exists by seeing if ```@memo[i]``` is nil.)\\n3. Create an options array.\\n    - Option 1: the first two numbers match, so we partition off a subarray of 2 from the beginning.\\n    - Option 2: the first three numbers match, so we parition off three.\\n    - Option 3: the first three elements are increasing by 1, so we patition off three.\\n4. Check if options cantains true, memoize, and return.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef valid_partition(nums)\\n    @memo = {}\\n    @nums = nums\\n\\n    valid?(0)\\nend\\n\\ndef valid?(i)\\n    return true if i == @nums.length\\n    return @memo[i] if @memo[i] != nil\\n\\n    options = []\\n    options << valid?(i+2) if @nums[i] == @nums[i+1]\\n    options << valid?(i+3) if @nums[i] == @nums[i+1] && @nums[i] == @nums[i+2]\\n    options << valid?(i+3) if @nums[i+2] &&\\n                              @nums[i+1] == @nums[i] + 1 &&\\n                              @nums[i+2] == @nums[i] + 2\\n\\n    @memo[i] = options.any? { |option| option }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```return @memo[i] if @memo[i]```\n```@memo[i]```\n```@memo[i]```\n```\\ndef valid_partition(nums)\\n    @memo = {}\\n    @nums = nums\\n\\n    valid?(0)\\nend\\n\\ndef valid?(i)\\n    return true if i == @nums.length\\n    return @memo[i] if @memo[i] != nil\\n\\n    options = []\\n    options << valid?(i+2) if @nums[i] == @nums[i+1]\\n    options << valid?(i+3) if @nums[i] == @nums[i+1] && @nums[i] == @nums[i+2]\\n    options << valid?(i+3) if @nums[i+2] &&\\n                              @nums[i+1] == @nums[i] + 1 &&\\n                              @nums[i+2] == @nums[i] + 2\\n\\n    @memo[i] = options.any? { |option| option }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2394158,
                "title": "java-dp-tabulation-solution-with-o-n-time-complexity",
                "content": "**Few Pointers :**\\nMake a dp array of n+1 length.\\nIndividually check for both conditions , **if the numbers are equal then check back the 2nd last and 3rd last answer if it is possible to make a partiton.**\\nAnd **if the numbers are greater then check the 3rd last answer in dp array. Otherwise assign false value ,** as no partition is possible then and move on with the dp array.\\n```\\nclass Solution {\\n    \\n    public boolean validPartition(int[] nums) {\\n        \\n        int n = nums.length;\\n        boolean []dp = new boolean[n+1];\\n\\t\\t// assigning base cases values \\n        dp[0] = true;\\n        dp[1] = false;\\n        \\n        for( int i=2; i<=n; i++ ){\\n            if( nums[i-1]==nums[i-2] ){\\n                if( i>=3 && nums[i-2]==nums[i-3] ) dp[i] = dp[i-2]||dp[i-3];\\n                else dp[i] = dp[i-2];\\n            }\\n            else if( i>=3 && nums[i-1]==nums[i-2]+1 && nums[i-2]==nums[i-3]+1 ){\\n                dp[i] = dp[i-3];\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean validPartition(int[] nums) {\\n        \\n        int n = nums.length;\\n        boolean []dp = new boolean[n+1];\\n\\t\\t// assigning base cases values \\n        dp[0] = true;\\n        dp[1] = false;\\n        \\n        for( int i=2; i<=n; i++ ){\\n            if( nums[i-1]==nums[i-2] ){\\n                if( i>=3 && nums[i-2]==nums[i-3] ) dp[i] = dp[i-2]||dp[i-3];\\n                else dp[i] = dp[i-2];\\n            }\\n            else if( i>=3 && nums[i-1]==nums[i-2]+1 && nums[i-2]==nums[i-3]+1 ){\\n                dp[i] = dp[i-3];\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392967,
                "title": "easy-c-solution-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dp=vector<int>(100005,-1);\\n    bool rec(vector<int> &nums,int i){\\n        int n=nums.size();\\n        if(i==n)\\n            return true;\\n        if(i>n)\\n            return false;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        bool res=false;\\n        \\n        if(i+2<=n && nums[i]==nums[i+1]){\\n            res = rec(nums,i+2);\\n            if(i+3<=n && nums[i]==nums[i+2]){\\n                res = res || rec(nums,i+3);\\n            }\\n        }\\n        if(i+3<=n && (nums[i+1]-nums[i]==1) && (nums[i+2]-nums[i+1]==1)){\\n            res = res || rec(nums,i+3);\\n        }\\n        dp[i]=res;\\n        return dp[i];\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return false;\\n        if(n==2)\\n            return nums[0]==nums[1];\\n        return rec(nums,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp=vector<int>(100005,-1);\\n    bool rec(vector<int> &nums,int i){\\n        int n=nums.size();\\n        if(i==n)\\n            return true;\\n        if(i>n)\\n            return false;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        bool res=false;\\n        \\n        if(i+2<=n && nums[i]==nums[i+1]){\\n            res = rec(nums,i+2);\\n            if(i+3<=n && nums[i]==nums[i+2]){\\n                res = res || rec(nums,i+3);\\n            }\\n        }\\n        if(i+3<=n && (nums[i+1]-nums[i]==1) && (nums[i+2]-nums[i+1]==1)){\\n            res = res || rec(nums,i+3);\\n        }\\n        dp[i]=res;\\n        return dp[i];\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return false;\\n        if(n==2)\\n            return nums[0]==nums[1];\\n        return rec(nums,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392003,
                "title": "c-bottom-up-dp",
                "content": "**State** = dp[i] = is the partition possible from 0 to ith index?\\nif(nums[i] == nums[i-1]) -> means there can be a sequence possible from i-1 to i\\nEx -> 1 1 2 2 3 4 => a sequence from index 2 to 3 is possible (2,2)\\nso for this sequence or partition to be possible there must be a Partition which should be valid at index 0 to 1\\nEX -> 1,1,2,2,3,3\\nfor sequence 2 to 3 to be possible sequence 0 to i-2 must be true (here i=3, 0th based indexing)\\nThis can be taken from Dp[i-2] since it tells whether some partions possible from 0 to j (here j = i-2)\\n\\n**Transition** \\nthere are three cases possible , so there are 3 transitions\\nif(nums[i] == nums[i-1]) dp[i] |= dp[i-2];\\nif(nums[i]==nums[i-1] && nums[i]==nums[i-2]) dp[i] |= dp[i-3];\\nif((nums[i]-nums[i-1]) == 1 && (nums[i-1]-nums[i-2]) == 1) dp[i] |= dp[i-3];\\n\\nNow simply code with 0 based indexing\\n\\n```\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp(n+1, 0);\\n        dp[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            if(i>1 && nums[i-1] == nums[i-2]){\\n                dp[i] |= dp[i-2];\\n            }\\n            if(i>2 && nums[i-1]==nums[i-2] && nums[i-1]==nums[i-3]){\\n                dp[i] |= dp[i-3];\\n            }\\n            if(i>2 && (nums[i-1]-nums[i-2]) == 1 && (nums[i-2]-nums[i-3]) == 1){\\n                dp[i] |= dp[i-3];\\n            }\\n        }\\n        return dp[n];\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "**State** = dp[i] = is the partition possible from 0 to ith index?\\nif(nums[i] == nums[i-1]) -> means there can be a sequence possible from i-1 to i\\nEx -> 1 1 2 2 3 4 => a sequence from index 2 to 3 is possible (2,2)\\nso for this sequence or partition to be possible there must be a Partition which should be valid at index 0 to 1\\nEX -> 1,1,2,2,3,3\\nfor sequence 2 to 3 to be possible sequence 0 to i-2 must be true (here i=3, 0th based indexing)\\nThis can be taken from Dp[i-2] since it tells whether some partions possible from 0 to j (here j = i-2)\\n\\n**Transition** \\nthere are three cases possible , so there are 3 transitions\\nif(nums[i] == nums[i-1]) dp[i] |= dp[i-2];\\nif(nums[i]==nums[i-1] && nums[i]==nums[i-2]) dp[i] |= dp[i-3];\\nif((nums[i]-nums[i-1]) == 1 && (nums[i-1]-nums[i-2]) == 1) dp[i] |= dp[i-3];\\n\\nNow simply code with 0 based indexing\\n\\n```\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp(n+1, 0);\\n        dp[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            if(i>1 && nums[i-1] == nums[i-2]){\\n                dp[i] |= dp[i-2];\\n            }\\n            if(i>2 && nums[i-1]==nums[i-2] && nums[i-1]==nums[i-3]){\\n                dp[i] |= dp[i-3];\\n            }\\n            if(i>2 && (nums[i-1]-nums[i-2]) == 1 && (nums[i-2]-nums[i-3]) == 1){\\n                dp[i] |= dp[i-3];\\n            }\\n        }\\n        return dp[n];\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2391166,
                "title": "c-dp-with-pruning",
                "content": "* If Either of the three condition are not satisfied we `break` at the end of for loop, This is required to avoid **TLE**.\\n```\\nclass Solution {\\npublic:\\n    int dp[100001] ;\\n    //dp with pruning \\n    bool solve(int pos , vector<int> &nums){\\n        if(pos >= size(nums)) return true ;\\n        if(dp[pos] !=  -1) return dp[pos] ;\\n        \\n        bool op1 = false , op2 = false ;\\n        for(int i = pos ; i < size(nums) ; ++i ){\\n            if(pos + 1 >= size(nums)) break ;\\n            if(nums[pos] == nums[pos + 1]) op1 = solve(pos + 2, nums) ;\\n            \\n            if(pos + 2 >= size(nums)) break ;\\n            if(nums[pos] == nums[pos + 1] and nums[pos] == nums[pos + 2]\\n              || nums[pos + 1] == nums[pos] + 1 and nums[pos + 2] == nums[pos] + 2)\\n                op2 = solve(pos + 3,nums) ;\\n            break ;\\n        }\\n        \\n        return dp[pos] = op1 or op2 ;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,nums) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001] ;\\n    //dp with pruning \\n    bool solve(int pos , vector<int> &nums){\\n        if(pos >= size(nums)) return true ;\\n        if(dp[pos] !=  -1) return dp[pos] ;\\n        \\n        bool op1 = false , op2 = false ;\\n        for(int i = pos ; i < size(nums) ; ++i ){\\n            if(pos + 1 >= size(nums)) break ;\\n            if(nums[pos] == nums[pos + 1]) op1 = solve(pos + 2, nums) ;\\n            \\n            if(pos + 2 >= size(nums)) break ;\\n            if(nums[pos] == nums[pos + 1] and nums[pos] == nums[pos + 2]\\n              || nums[pos + 1] == nums[pos] + 1 and nums[pos + 2] == nums[pos] + 2)\\n                op2 = solve(pos + 3,nums) ;\\n            break ;\\n        }\\n        \\n        return dp[pos] = op1 or op2 ;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,nums) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390873,
                "title": "c-dp-memorization-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& nums,vector<int>& dp,int n)\\n    {\\n        if(n<2)\\n            return 0l;\\n        if(n==2)\\n            return nums[n-1]==nums[n-2];\\n        if(n==3)\\n        {\\n            if(nums[n-1]==nums[n-2] && nums[n-2]==nums[n-3])\\n                return 1;\\n            if(nums[n-1]==nums[n-2]+1 && nums[n-2]==nums[n-3]+1)\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[n]!=-1)\\n            return dp[n];\\n        \\n        int t=0;\\n        if(nums[n-1]==nums[n-2])\\n            t=fun(nums,dp,n-2);\\n        if(nums[n-1]==nums[n-2] && nums[n-2]==nums[n-3])\\n            t=max(t,fun(nums,dp,n-3));\\n        if(nums[n-1]==nums[n-2]+1 && nums[n-2]==nums[n-3]+1)\\n            t=max(t,fun(nums,dp,n-3));\\n        \\n        return dp[n]=t;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return fun(nums,dp,nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& nums,vector<int>& dp,int n)\\n    {\\n        if(n<2)\\n            return 0l;\\n        if(n==2)\\n            return nums[n-1]==nums[n-2];\\n        if(n==3)\\n        {\\n            if(nums[n-1]==nums[n-2] && nums[n-2]==nums[n-3])\\n                return 1;\\n            if(nums[n-1]==nums[n-2]+1 && nums[n-2]==nums[n-3]+1)\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[n]!=-1)\\n            return dp[n];\\n        \\n        int t=0;\\n        if(nums[n-1]==nums[n-2])\\n            t=fun(nums,dp,n-2);\\n        if(nums[n-1]==nums[n-2] && nums[n-2]==nums[n-3])\\n            t=max(t,fun(nums,dp,n-3));\\n        if(nums[n-1]==nums[n-2]+1 && nums[n-2]==nums[n-3]+1)\\n            t=max(t,fun(nums,dp,n-3));\\n        \\n        return dp[n]=t;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return fun(nums,dp,nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390550,
                "title": "recursion-memoization",
                "content": "We check all the possible three condition and call further if any of the condition is true we return true;\\n\\nAnd to store the ans i have used 1 for true and -1 for false\\n\\n\\n`\\nclass Solution {\\n\\n    int[] memo;\\n    public boolean validPartition(int[] nums) {\\n        memo = new int[nums.length];\\n        return solve(nums ,0);\\n    }\\n    private boolean solve(int[] nums , int i){\\n        if(i >= nums.length)return true;\\n        if(memo[i] != 0){\\n            return memo[i] == 1 ? true:false;\\n        }\\n        boolean ans1 = false , ans2 = false ,ans3 = false;\\n        if(i+1 < nums.length && nums[i+1] == nums[i]){\\n            ans1 = solve(nums ,i+2);\\n        }\\n        if(i+2 < nums.length && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]){\\n            ans2 = solve(nums , i+3);\\n        }\\n        if(i+2 < nums.length && nums[i] == nums[i+1] - 1 && nums[i+1] == nums[i+2] -1){\\n            ans3 = solve(nums,i+3);\\n        }\\n         if(ans1 || (ans2||ans3)){\\n             memo[i] = 1;\\n         }else{\\n             memo[i] = -1;\\n         }\\n        return memo[i] == 1?true : false;\\n    }\\n}\\n`",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int[] memo;\\n    public boolean validPartition(int[] nums) {\\n        memo = new int[nums.length];\\n        return solve(nums ,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4022024,
                "title": "check-if-there-is-a-valid-partition-for-the-array-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int VP(int i,vector<int>& dp,vector<int>& nums){\\n        if(i==nums.size()) return 1;\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int f1,f2,f3;\\n        f1=f2=f3=0;\\n        if((i+1)<nums.size()&&nums[i+1]==nums[i]){\\n            f1=VP(i+2,dp,nums);\\n        }\\n        if(i+2<nums.size()&&(nums[i+1]==nums[i]&&nums[i]==nums[i+2])){\\n            f2=VP(i+3,dp,nums);\\n        }\\n        if(i+2<nums.size()&&(nums[i+2]-nums[i+1]==1&&nums[i+1]-nums[i]==1)){\\n            f3=VP(i+3,dp,nums);\\n        }\\n        if(f1==false&&f2==false&&f3==false) return dp[i]=false;\\n        return dp[i]=f1||f2||f3;\\n\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return 1==VP(0,dp,nums);\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int VP(int i,vector<int>& dp,vector<int>& nums){\\n        if(i==nums.size()) return 1;\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int f1,f2,f3;\\n        f1=f2=f3=0;\\n        if((i+1)<nums.size()&&nums[i+1]==nums[i]){\\n            f1=VP(i+2,dp,nums);\\n        }\\n        if(i+2<nums.size()&&(nums[i+1]==nums[i]&&nums[i]==nums[i+2])){\\n            f2=VP(i+3,dp,nums);\\n        }\\n        if(i+2<nums.size()&&(nums[i+2]-nums[i+1]==1&&nums[i+1]-nums[i]==1)){\\n            f3=VP(i+3,dp,nums);\\n        }\\n        if(f1==false&&f2==false&&f3==false) return dp[i]=false;\\n        return dp[i]=f1||f2||f3;\\n\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return 1==VP(0,dp,nums);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905058,
                "title": "c-memoization-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool solve(vector<int>&v,vector<int>&dp,int i){\\n       if(i==v.size())return true;\\n        int n=v.size();\\n       if(dp[i]!=-1)return dp[i];\\n\\n       if(i+1<n && v[i]==v[i+1]){\\n           if(solve(v,dp,i+2))return dp[i]=true;\\n       }\\n\\n       if(i+2<n && v[i]==v[i+1] && v[i]==v[i+2]){\\n            if(solve(v,dp,i+3))return dp[i]=true;\\n       }\\n\\n       if(i+2<n && v[i]==v[i+1]-1 && v[i+1]+1==v[i+2]){\\n           if(solve(v,dp,i+3))return dp[i]=true;\\n       }\\n\\n       return dp[i]=false;\\n\\n   }\\n\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n+1,-1);\\n\\n        return solve(nums,dp,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool solve(vector<int>&v,vector<int>&dp,int i){\\n       if(i==v.size())return true;\\n        int n=v.size();\\n       if(dp[i]!=-1)return dp[i];\\n\\n       if(i+1<n && v[i]==v[i+1]){\\n           if(solve(v,dp,i+2))return dp[i]=true;\\n       }\\n\\n       if(i+2<n && v[i]==v[i+1] && v[i]==v[i+2]){\\n            if(solve(v,dp,i+3))return dp[i]=true;\\n       }\\n\\n       if(i+2<n && v[i]==v[i+1]-1 && v[i+1]+1==v[i+2]){\\n           if(solve(v,dp,i+3))return dp[i]=true;\\n       }\\n\\n       return dp[i]=false;\\n\\n   }\\n\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n+1,-1);\\n\\n        return solve(nums,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904782,
                "title": "100-beats-time-and-space-o-1-space-o-n-time-4-different-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***As we have to partition the array into one or more sub-arrays using the given conditions, there are 3 choices at each index, and choices means recursion and recursion makes us think of dynamic programming.***\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n***If we make it till the end return true, otherwise false.\\nApply the three given conditions, and you are good to go.***\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Recursion ( TLE )\\n```\\nclass Solution {\\npublic:\\nint sz;\\n    bool recursion(int i, vector<int>& nums){\\n        if(i>=sz)    return 1;\\n        if(i+1<sz && nums[i]==nums[i+1]){\\n            if(recursion(i+2,nums))    return 1;\\n        }\\n        if(i+2<sz && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n            if(recursion(i+3,nums))    return 1;\\n        }\\n        if(i+2<sz && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n            if(recursion(i+3,nums))    return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sz=nums.size();\\n        return recursion(0,nums);\\n    }\\n};\\n```\\n# Memoization\\n```\\nclass Solution {\\npublic:\\nint sz;\\n    bool memoization(int i, vector<int>& nums, vector<int>& dp){\\n        if(i>=sz)    return 1;\\n        if(dp[i]!=-1)   return dp[i];\\n        if(i+1<sz && nums[i]==nums[i+1]){\\n            if(memoization(i+2,nums,dp))    return dp[i]=1;\\n        }\\n        if(i+2<sz && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n            if(memoization(i+3,nums,dp))    return dp[i]=1;\\n        }\\n        if(i+2<sz && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n            if(memoization(i+3,nums,dp))    return dp[i]=1;\\n        }\\n        return dp[i]=0;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sz=nums.size();\\n        vector<int>dp(sz,-1);\\n        return memoization(0,nums,dp);\\n    }\\n};\\n```\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\nint sz;\\n    bool tabulation(vector<int>& nums){\\n        vector<int>dp(sz+1,0);\\n        dp[sz]=1;\\n        for(int i=sz-1;i>=0;i--){\\n            if(i+1<sz && nums[i]==nums[i+1]){\\n                if(dp[i+2])    dp[i]=1;\\n            }\\n            if(i+2<sz && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n                if(dp[i+3])    dp[i]=1;\\n            }\\n            if(i+2<sz && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n                if(dp[i+3])    dp[i]=1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sz=nums.size();\\n        return tabulation(nums);\\n    }\\n};\\n```\\n# Tabulation + Space Optimization\\n```\\nclass Solution {\\npublic:\\nint sz;\\n    bool spaceOptimization(vector<int>& nums){\\n        int plus1=1,plus2=0,plus3=0;\\n        for(int i=sz-1;i>=0;i--){\\n            int curr=0;\\n            if(i+1<sz && nums[i]==nums[i+1]){\\n                if(plus2)    curr=1;\\n            }\\n            if(i+2<sz && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n                if(plus3)    curr=1;\\n            }\\n            if(i+2<sz && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n                if(plus3)    curr=1;\\n            }\\n            plus3=plus2;\\n            plus2=plus1;\\n            plus1=curr;\\n        }\\n        return plus1;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sz=nums.size();\\n        return spaceOptimization(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint sz;\\n    bool recursion(int i, vector<int>& nums){\\n        if(i>=sz)    return 1;\\n        if(i+1<sz && nums[i]==nums[i+1]){\\n            if(recursion(i+2,nums))    return 1;\\n        }\\n        if(i+2<sz && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n            if(recursion(i+3,nums))    return 1;\\n        }\\n        if(i+2<sz && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n            if(recursion(i+3,nums))    return 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sz=nums.size();\\n        return recursion(0,nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint sz;\\n    bool memoization(int i, vector<int>& nums, vector<int>& dp){\\n        if(i>=sz)    return 1;\\n        if(dp[i]!=-1)   return dp[i];\\n        if(i+1<sz && nums[i]==nums[i+1]){\\n            if(memoization(i+2,nums,dp))    return dp[i]=1;\\n        }\\n        if(i+2<sz && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n            if(memoization(i+3,nums,dp))    return dp[i]=1;\\n        }\\n        if(i+2<sz && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n            if(memoization(i+3,nums,dp))    return dp[i]=1;\\n        }\\n        return dp[i]=0;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sz=nums.size();\\n        vector<int>dp(sz,-1);\\n        return memoization(0,nums,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint sz;\\n    bool tabulation(vector<int>& nums){\\n        vector<int>dp(sz+1,0);\\n        dp[sz]=1;\\n        for(int i=sz-1;i>=0;i--){\\n            if(i+1<sz && nums[i]==nums[i+1]){\\n                if(dp[i+2])    dp[i]=1;\\n            }\\n            if(i+2<sz && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n                if(dp[i+3])    dp[i]=1;\\n            }\\n            if(i+2<sz && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n                if(dp[i+3])    dp[i]=1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sz=nums.size();\\n        return tabulation(nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint sz;\\n    bool spaceOptimization(vector<int>& nums){\\n        int plus1=1,plus2=0,plus3=0;\\n        for(int i=sz-1;i>=0;i--){\\n            int curr=0;\\n            if(i+1<sz && nums[i]==nums[i+1]){\\n                if(plus2)    curr=1;\\n            }\\n            if(i+2<sz && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n                if(plus3)    curr=1;\\n            }\\n            if(i+2<sz && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n                if(plus3)    curr=1;\\n            }\\n            plus3=plus2;\\n            plus2=plus1;\\n            plus1=curr;\\n        }\\n        return plus1;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sz=nums.size();\\n        return spaceOptimization(nums);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3904640,
                "title": "javascript-memoization-recursion-clean-solution",
                "content": "```\\nvar validPartition = function(nums, memo = {}, start = 0) {\\n    if (start >= nums.length) return true;\\n    if (start in memo) return memo[start];\\n\\n    let isTwoEqual = nums[start] === nums[start + 1];\\n\\n    let isThreeEqual = nums[start] === nums[start + 1] && \\n                       nums[start] === nums[start + 2];\\n    \\n    let isIncreasing = nums[start] + 1 === nums[start + 1] && \\n                       nums[start + 1] + 1 === nums[start + 2];\\n\\n\\n\\n    let isValid = false;\\n\\n    if (isIncreasing) {\\n        isValid =  validPartition(nums, memo, start + 3);\\n    } else if (isThreeEqual) {\\n        isValid =  validPartition(nums, memo, start + 2) || \\n                   validPartition(nums, memo, start + 3);\\n    } else if (isTwoEqual)\\n        isValid =  validPartition(nums, memo, start + 2)\\n    \\n       \\n    memo[start] = isValid;\\n    return isValid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar validPartition = function(nums, memo = {}, start = 0) {\\n    if (start >= nums.length) return true;\\n    if (start in memo) return memo[start];\\n\\n    let isTwoEqual = nums[start] === nums[start + 1];\\n\\n    let isThreeEqual = nums[start] === nums[start + 1] && \\n                       nums[start] === nums[start + 2];\\n    \\n    let isIncreasing = nums[start] + 1 === nums[start + 1] && \\n                       nums[start + 1] + 1 === nums[start + 2];\\n\\n\\n\\n    let isValid = false;\\n\\n    if (isIncreasing) {\\n        isValid =  validPartition(nums, memo, start + 3);\\n    } else if (isThreeEqual) {\\n        isValid =  validPartition(nums, memo, start + 2) || \\n                   validPartition(nums, memo, start + 3);\\n    } else if (isTwoEqual)\\n        isValid =  validPartition(nums, memo, start + 2)\\n    \\n       \\n    memo[start] = isValid;\\n    return isValid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3904084,
                "title": "c-solution-for-check-if-there-is-a-valid-partition-for-the-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem requires us to partition the array into valid subarrays that satisfy certain conditions. We are given three conditions for a subarray to be considered valid. The goal is to determine if there exists at least one valid partition for the given array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe provided solution uses dynamic programming to solve the problem. It maintains a boolean array dp, where dp[i] represents whether the prefix array nums[0 ~ i] can be partitioned into valid subarrays. The approach iterates through the array, checking the three possibilities for creating valid subarrays as mentioned in the problem statement. For each element, it updates the dp array based on the previous elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe solution iterates through the input array once. For each element, it performs constant-time operations to update the dp array. Therefore, the time complexity of this solution is O(n), where n is the length of the input array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses an additional boolean array dp of size n + 1 to store the results of subproblems. Therefore, the space complexity of this solution is O(n), where n is the length of the input array.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        int n = nums.Length;\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n\\n        // Determine if the prefix array nums[0 ~ i] has a valid partition\\n        for (int i = 0; i < n; i++) {\\n            int dpIndex = i + 1;\\n\\n            // Check 3 possibilities\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                dp[dpIndex] |= dp[dpIndex - 2];\\n            }\\n            if (i > 1 && nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) {\\n                dp[dpIndex] |= dp[dpIndex - 3];\\n            }\\n            if (i > 1 && nums[i] == nums[i - 1] + 1 && nums[i] == nums[i - 2] + 2) {\\n                dp[dpIndex] |= dp[dpIndex - 3];\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        int n = nums.Length;\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n\\n        // Determine if the prefix array nums[0 ~ i] has a valid partition\\n        for (int i = 0; i < n; i++) {\\n            int dpIndex = i + 1;\\n\\n            // Check 3 possibilities\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                dp[dpIndex] |= dp[dpIndex - 2];\\n            }\\n            if (i > 1 && nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) {\\n                dp[dpIndex] |= dp[dpIndex - 3];\\n            }\\n            if (i > 1 && nums[i] == nums[i - 1] + 1 && nums[i] == nums[i - 2] + 2) {\\n                dp[dpIndex] |= dp[dpIndex - 3];\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903906,
                "title": "recursion-memoization-technique",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n\\nThis is top down approach recursion.\\nThis will be accepted, here I used a Boolean array, whose default value is null.\\n\\nIt\\'s the memozation technique Memoization\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        Boolean[] dp = new Boolean[n];\\n        return validPartition(n-1, nums, dp);\\n    }\\n\\n    private boolean validPartition(int i, int[] nums, Boolean[] dp){\\n        if (i < 0)\\n            return true;\\n        if (dp[i] != null)\\n            return dp[i];\\n        \\n        boolean equal2 = false, equal3 = false, increasing3 = false;\\n        if (i > 0 && nums[i] == nums[i-1])\\n            equal2 = validPartition(i-2, nums, dp);\\n        if (i > 1 && nums[i] == nums[i-1] && nums[i] == nums[i-2])\\n            equal3 = validPartition(i-3, nums, dp);\\n        if (i > 1 && nums[i] == nums[i-1] + 1 && nums[i-1] == nums[i-2] + 1)\\n            increasing3 = validPartition(i-3, nums, dp);\\n        return dp[i] = equal2 || equal3 || increasing3;\\n    }\\n}\\n```\\n\\n\\n\\n# Recursion Technique\\nThis is bottom up approach recursion.\\nThis solution will not be accepted because it give TLE. \\n```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        if(n==2)\\n            return nums[0]==nums[1];\\n        return check(nums,0);\\n    }\\n    boolean check(int[] nums, int i){\\n        if(i==nums.length){\\n            return true;\\n        }\\n        if(i+1 < nums.length && nums[i]==nums[i+1]){\\n            if(check(nums,i+2)) return true;\\n            \\n            if(i+2 < nums.length && nums[i+1]==nums[i+2]){\\n                    if(check(nums,i+3)) return true;\\n            }\\n        }\\n        if(i+1 < nums.length &&  i+2 < nums.length && nums[i]+1==nums[i+1] && nums[i+1]+1 == nums[i+2]){\\n            if(check(nums,i+3)) return true;\\n        }\\n    \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        Boolean[] dp = new Boolean[n];\\n        return validPartition(n-1, nums, dp);\\n    }\\n\\n    private boolean validPartition(int i, int[] nums, Boolean[] dp){\\n        if (i < 0)\\n            return true;\\n        if (dp[i] != null)\\n            return dp[i];\\n        \\n        boolean equal2 = false, equal3 = false, increasing3 = false;\\n        if (i > 0 && nums[i] == nums[i-1])\\n            equal2 = validPartition(i-2, nums, dp);\\n        if (i > 1 && nums[i] == nums[i-1] && nums[i] == nums[i-2])\\n            equal3 = validPartition(i-3, nums, dp);\\n        if (i > 1 && nums[i] == nums[i-1] + 1 && nums[i-1] == nums[i-2] + 1)\\n            increasing3 = validPartition(i-3, nums, dp);\\n        return dp[i] = equal2 || equal3 || increasing3;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        if(n==2)\\n            return nums[0]==nums[1];\\n        return check(nums,0);\\n    }\\n    boolean check(int[] nums, int i){\\n        if(i==nums.length){\\n            return true;\\n        }\\n        if(i+1 < nums.length && nums[i]==nums[i+1]){\\n            if(check(nums,i+2)) return true;\\n            \\n            if(i+2 < nums.length && nums[i+1]==nums[i+2]){\\n                    if(check(nums,i+3)) return true;\\n            }\\n        }\\n        if(i+1 < nums.length &&  i+2 < nums.length && nums[i]+1==nums[i+1] && nums[i+1]+1 == nums[i+2]){\\n            if(check(nums,i+3)) return true;\\n        }\\n    \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903855,
                "title": "typescript-dynamic-programming-solution-with-memory-optimization-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: $\\\\mathcal{O(n)}$\\n- Space complexity: $\\\\mathcal{O(1)}$\\n\\n# Code\\n```\\nfunction validPartition(nums: number[]): boolean {\\n    const N = nums.length, dp = [ true, false, nums[ 0 ] === nums[ 1 ] ];\\n    for ( let i = 2; i < N; i++ ) {\\n        const cur = nums[ i ] === nums[ i - 1 ] && dp[ 1 ] ||\\n            nums[ i ] === nums[ i - 1 ] && nums[ i ] === nums[ i - 2 ] && dp[ 0 ] ||\\n            nums[ i ] - nums[ i - 1 ] === 1 && nums[ i ] - nums[ i - 2 ] === 2 && dp[ 0 ];\\n        dp[ 0 ] = dp[ 1 ]; dp[ 1 ] = dp[ 2 ]; dp[ 2 ] = cur;\\n    }\\n    return dp[ 2 ];\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction validPartition(nums: number[]): boolean {\\n    const N = nums.length, dp = [ true, false, nums[ 0 ] === nums[ 1 ] ];\\n    for ( let i = 2; i < N; i++ ) {\\n        const cur = nums[ i ] === nums[ i - 1 ] && dp[ 1 ] ||\\n            nums[ i ] === nums[ i - 1 ] && nums[ i ] === nums[ i - 2 ] && dp[ 0 ] ||\\n            nums[ i ] - nums[ i - 1 ] === 1 && nums[ i ] - nums[ i - 2 ] === 2 && dp[ 0 ];\\n        dp[ 0 ] = dp[ 1 ]; dp[ 1 ] = dp[ 2 ]; dp[ 2 ] = cur;\\n    }\\n    return dp[ 2 ];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903003,
                "title": "java-easy-solution-dynamic-programing-memoization-beats-83",
                "content": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        Boolean [] dp = new Boolean[nums.length];\\n        dp[0]= false;\\n        return solve(nums, dp, nums.length-1);\\n    }\\n    private boolean solve(int [] nums, Boolean [] dp, int index){\\n        if(index<0)return true;\\n        if(index == 1){\\n            if(nums[1]==nums[0]){\\n                dp[1] = true;\\n            }\\n            else dp[1] = false;\\n            return dp[1];\\n        }\\n        if(dp[index]!=null) return dp[index];\\n        dp[index] = (nums[index]==nums[index-1] && solve(nums,dp,index-2)) ||\\n                    (nums[index]==nums[index-1] && nums[index] == nums[index-2] && solve(nums,dp,index-3)) ||\\n                    (nums[index]==nums[index-1]+1 && nums[index] == nums[index-2]+2 && solve(nums,dp,index-3));\\n        return dp[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        Boolean [] dp = new Boolean[nums.length];\\n        dp[0]= false;\\n        return solve(nums, dp, nums.length-1);\\n    }\\n    private boolean solve(int [] nums, Boolean [] dp, int index){\\n        if(index<0)return true;\\n        if(index == 1){\\n            if(nums[1]==nums[0]){\\n                dp[1] = true;\\n            }\\n            else dp[1] = false;\\n            return dp[1];\\n        }\\n        if(dp[index]!=null) return dp[index];\\n        dp[index] = (nums[index]==nums[index-1] && solve(nums,dp,index-2)) ||\\n                    (nums[index]==nums[index-1] && nums[index] == nums[index-2] && solve(nums,dp,index-3)) ||\\n                    (nums[index]==nums[index-1]+1 && nums[index] == nums[index-2]+2 && solve(nums,dp,index-3));\\n        return dp[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902922,
                "title": "c-beginner-friendly-front-partition-dp",
                "content": "# Intuition\\n```\\nThe Question states that the array can be Partitioned of only \\nsize 2 or 3.\\n\\nTherefore we need to check for the subarrays of size 2 or 3 and \\nnot more than that.\\n\\nBut there are three conditions that need to be followed in order\\nto make every subarray of size 2 and 3 to be valid.\\n\\n```\\n\\n# Approach\\n```\\nCondition 1:\\n    The subarray consists of exactly 2 equal elements.\\n    For example, the subarray [2,2] is good.\\n\\nCondition 2:\\n    The subarray consists of exactly 3 equal elements.\\n    For example, the subarray [4,4,4] is good.\\n\\nTherefore we can notice that for subarray of size 2 and 3 it \\nbecomes a good subarray if all the elements in it are equal.\\n\\nSo we can write our first function to check whether our elements\\nare all equal in the subarray.\\n\\nbool isEqual(vector<int>& nums,int i,int j)\\n{\\n    for(int x = i;x <= j-1;x++)\\n    {\\n        if(nums[x] != nums[x+1]) return false;\\n    }\\n    return true;\\n}\\n\\nThe above function to check whether all the elements in the range \\nof i -> j are equal or not else it returns false.\\n```\\n\\n```\\nCondition 3:\\n    The subarray consists of exactly 3 consecutive increasing\\n    elements, that is, the difference between adjacent \\n    elements is 1. For example, the subarray [3,4,5] is good, \\n    but the subarray [1,3,5] is not.\\n\\nTherefore we can notice that for subarray of size 3 it \\nbecomes a good subarray if all the elements in it are increasing \\nand have a difference of 1.\\n\\nSo we can write our second function to check whether our elements\\nare increasing with a difference of 1.\\n\\nNote: This subarray should be of size 3 inorder to make it valid.\\n\\nbool isConti(vector<int>& nums,int i,int j)\\n{\\n    if(j-i+1 != 3) return false;\\n    for(int x = i+1;x <= j;x++)\\n    {\\n        if(nums[x] - nums[x-1] != 1) return false;\\n    }\\n    return true;\\n}\\n\\n\\nThe above function to check whether all the elements in the range \\nof i -> j are increasing with difference of 1.\\n```\\n\\n```\\nLast Step:\\n    Finally our recursive function which helps in finding whether\\n    we can partition our array with the above conditions or not.\\n\\nLets see the code and then breakdown the code.\\n\\nbool solve(vector<int>& nums,int ind,int n,vector<int> &dp)\\n{\\n    if(ind == n) return true;\\n    if(dp[ind] != -1) return dp[ind];\\n    for(int i = ind+1;i <= min(n-1,ind+2);i++)\\n    {\\n        if((isEqual(nums,ind,i) || isConti(nums,ind,i)) && solve(nums,i+1,n,dp))\\n        {\\n            return dp[ind] = true;\\n        }\\n    }\\n    return dp[ind] = false;\\n}\\n\\nThe function accepts four parameters :\\n1. nums array.\\n2. current index from where partition begins.\\n3. size of array.\\n4. memoized dp vector.\\n\\nBase condition:\\n    if(ind == n) return true;\\n\\n    it states that if we have reached the end of array then we have\\n    successfully partitioned the array with the conditions.\\n\\nMemoization:\\n    if(dp[ind] != -1) return dp[ind];\\n\\n    it states that if the value at the current index is already been\\n    computed then return it without re-calculating it again.\\n\\nMain Loop:\\n    for(int i = ind+1;i <= min(n-1,ind+2);i++)\\n    {\\n        if((isEqual(nums,ind,i) || isConti(nums,ind,i)) && solve(nums,i+1,n,dp))\\n        {\\n            return dp[ind] = true;\\n        }\\n    }\\n\\n    Suppose if we are at index ind then our subarray should be atleast\\n    of size 2 and maximum of 3.\\n    Therefore our loop starts from ind+1 to ensure a minimum size\\n    of subarray 2 and can go until subarray of size 3.\\n\\n    The min(n-1,ind+2) ensures that the loop doesnt go out of the \\n    bounds if ind+2 exceeds the size of the array.\\n\\n    Lastly in the if condition our partition becomes valid only if\\n    any of the (isEqual or isConti) returns true and the next \\n    recursive partition is also true.\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isEqual(vector<int>& nums,int i,int j)\\n    {\\n        for(int x = i;x <= j-1;x++)\\n        {\\n            if(nums[x] != nums[x+1]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isConti(vector<int>& nums,int i,int j)\\n    {\\n        if(j-i+1 != 3) return false;\\n        for(int x = i+1;x <= j;x++)\\n        {\\n            if(nums[x] - nums[x-1] != 1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool solve(vector<int>& nums,int ind,int n,vector<int> &dp)\\n    {\\n        if(ind == n) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        for(int i = ind+1;i <= min(n-1,ind+2);i++)\\n        {\\n            if((isEqual(nums,ind,i) || isConti(nums,ind,i)) && solve(nums,i+1,n,dp))\\n            {\\n                return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        return solve(nums,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nThe Question states that the array can be Partitioned of only \\nsize 2 or 3.\\n\\nTherefore we need to check for the subarrays of size 2 or 3 and \\nnot more than that.\\n\\nBut there are three conditions that need to be followed in order\\nto make every subarray of size 2 and 3 to be valid.\\n\\n```\n```\\nCondition 1:\\n    The subarray consists of exactly 2 equal elements.\\n    For example, the subarray [2,2] is good.\\n\\nCondition 2:\\n    The subarray consists of exactly 3 equal elements.\\n    For example, the subarray [4,4,4] is good.\\n\\nTherefore we can notice that for subarray of size 2 and 3 it \\nbecomes a good subarray if all the elements in it are equal.\\n\\nSo we can write our first function to check whether our elements\\nare all equal in the subarray.\\n\\nbool isEqual(vector<int>& nums,int i,int j)\\n{\\n    for(int x = i;x <= j-1;x++)\\n    {\\n        if(nums[x] != nums[x+1]) return false;\\n    }\\n    return true;\\n}\\n\\nThe above function to check whether all the elements in the range \\nof i -> j are equal or not else it returns false.\\n```\n```\\nCondition 3:\\n    The subarray consists of exactly 3 consecutive increasing\\n    elements, that is, the difference between adjacent \\n    elements is 1. For example, the subarray [3,4,5] is good, \\n    but the subarray [1,3,5] is not.\\n\\nTherefore we can notice that for subarray of size 3 it \\nbecomes a good subarray if all the elements in it are increasing \\nand have a difference of 1.\\n\\nSo we can write our second function to check whether our elements\\nare increasing with a difference of 1.\\n\\nNote: This subarray should be of size 3 inorder to make it valid.\\n\\nbool isConti(vector<int>& nums,int i,int j)\\n{\\n    if(j-i+1 != 3) return false;\\n    for(int x = i+1;x <= j;x++)\\n    {\\n        if(nums[x] - nums[x-1] != 1) return false;\\n    }\\n    return true;\\n}\\n\\n\\nThe above function to check whether all the elements in the range \\nof i -> j are increasing with difference of 1.\\n```\n```\\nLast Step:\\n    Finally our recursive function which helps in finding whether\\n    we can partition our array with the above conditions or not.\\n\\nLets see the code and then breakdown the code.\\n\\nbool solve(vector<int>& nums,int ind,int n,vector<int> &dp)\\n{\\n    if(ind == n) return true;\\n    if(dp[ind] != -1) return dp[ind];\\n    for(int i = ind+1;i <= min(n-1,ind+2);i++)\\n    {\\n        if((isEqual(nums,ind,i) || isConti(nums,ind,i)) && solve(nums,i+1,n,dp))\\n        {\\n            return dp[ind] = true;\\n        }\\n    }\\n    return dp[ind] = false;\\n}\\n\\nThe function accepts four parameters :\\n1. nums array.\\n2. current index from where partition begins.\\n3. size of array.\\n4. memoized dp vector.\\n\\nBase condition:\\n    if(ind == n) return true;\\n\\n    it states that if we have reached the end of array then we have\\n    successfully partitioned the array with the conditions.\\n\\nMemoization:\\n    if(dp[ind] != -1) return dp[ind];\\n\\n    it states that if the value at the current index is already been\\n    computed then return it without re-calculating it again.\\n\\nMain Loop:\\n    for(int i = ind+1;i <= min(n-1,ind+2);i++)\\n    {\\n        if((isEqual(nums,ind,i) || isConti(nums,ind,i)) && solve(nums,i+1,n,dp))\\n        {\\n            return dp[ind] = true;\\n        }\\n    }\\n\\n    Suppose if we are at index ind then our subarray should be atleast\\n    of size 2 and maximum of 3.\\n    Therefore our loop starts from ind+1 to ensure a minimum size\\n    of subarray 2 and can go until subarray of size 3.\\n\\n    The min(n-1,ind+2) ensures that the loop doesnt go out of the \\n    bounds if ind+2 exceeds the size of the array.\\n\\n    Lastly in the if condition our partition becomes valid only if\\n    any of the (isEqual or isConti) returns true and the next \\n    recursive partition is also true.\\n```\n```\\nclass Solution {\\npublic:\\n    bool isEqual(vector<int>& nums,int i,int j)\\n    {\\n        for(int x = i;x <= j-1;x++)\\n        {\\n            if(nums[x] != nums[x+1]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isConti(vector<int>& nums,int i,int j)\\n    {\\n        if(j-i+1 != 3) return false;\\n        for(int x = i+1;x <= j;x++)\\n        {\\n            if(nums[x] - nums[x-1] != 1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool solve(vector<int>& nums,int ind,int n,vector<int> &dp)\\n    {\\n        if(ind == n) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        for(int i = ind+1;i <= min(n-1,ind+2);i++)\\n        {\\n            if((isEqual(nums,ind,i) || isConti(nums,ind,i)) && solve(nums,i+1,n,dp))\\n            {\\n                return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        return solve(nums,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902719,
                "title": "memo-beats-97",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int i, vector<int>& nums, vector<int>& dp){\\n        if(dp[i]!=-1) return dp[i];\\n        if(i>nums.size()-2) return dp[i] = false;\\n        //Base case 1\\n        if(i==nums.size()-2){\\n            if(nums[i]==nums[i+1]) return dp[i] = true;\\n            return false;\\n        }\\n        // Base case 2 and 3.\\n        else if(i==nums.size()-3){\\n            if(nums[i]==nums[i+1] && nums[i+1]==nums[i+2]) return dp[i] = true;\\n            if(nums[i]==nums[i+1]-1 && nums[i+1]==nums[i+2]-1) return dp[i] = true;\\n            return dp[i] = false;\\n        }\\n        else{\\n            bool two = false, three = false;\\n            if(nums[i]==nums[i+1]){\\n                two = f(i+2, nums, dp);\\n            }\\n            if(nums[i]==nums[i+1]-1 && nums[i+1]==nums[i+2]-1){\\n                three = f(i+3, nums, dp);\\n            }\\n            if(nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n                three = f(i+3, nums, dp);\\n            }\\n            return dp[i] = two || three;\\n        }\\n        \\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+2, -1);\\n        return f(0, nums, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i, vector<int>& nums, vector<int>& dp){\\n        if(dp[i]!=-1) return dp[i];\\n        if(i>nums.size()-2) return dp[i] = false;\\n        //Base case 1\\n        if(i==nums.size()-2){\\n            if(nums[i]==nums[i+1]) return dp[i] = true;\\n            return false;\\n        }\\n        // Base case 2 and 3.\\n        else if(i==nums.size()-3){\\n            if(nums[i]==nums[i+1] && nums[i+1]==nums[i+2]) return dp[i] = true;\\n            if(nums[i]==nums[i+1]-1 && nums[i+1]==nums[i+2]-1) return dp[i] = true;\\n            return dp[i] = false;\\n        }\\n        else{\\n            bool two = false, three = false;\\n            if(nums[i]==nums[i+1]){\\n                two = f(i+2, nums, dp);\\n            }\\n            if(nums[i]==nums[i+1]-1 && nums[i+1]==nums[i+2]-1){\\n                three = f(i+3, nums, dp);\\n            }\\n            if(nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n                three = f(i+3, nums, dp);\\n            }\\n            return dp[i] = two || three;\\n        }\\n        \\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+2, -1);\\n        return f(0, nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902391,
                "title": "c-solution-1d-dp-supereasy-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. `bool solveMem(vector<int>& nums, vector<int>& dp, int i)`: Recursive function with memoization to determine if the array can be partitioned.\\n- Get the size ``n`` of the input array `nums`.\\n- Base Case:\\n If `i` is greater than or equal to `n`, return `true` as the entire array has been successfully partitioned.\\n- Check Memoization:\\nIf the result for the current index i is already computed and stored in dp, return it.\\n- For Equal Elements:\\nCheck if the current element `nums[i]` is equal to the next element `nums[i+1]`.\\nIf true, set dp[i] to the result of recursing with a step of 2 (`i+2`).\\nIf `dp[i]` is true, return `true`.\\nAlso, if the element after `nums[i+1]` is equal to `nums[i]`, set dp[i] to the result of recursing with a step of 3 (i+3).\\nIf `dp[i]` is true, return `true`.\\n- For 3 Consecutive Increasing Elements:\\nCheck if the elements at indices i, i+1, and i+2 form a consecutive increasing sequence.\\nIf true, set `dp[i]` to the result of recursing with a step of 3 (`i+3`).\\nIf `dp[i]` is true, return `true`.\\n- Return `false` if none of the conditions match.\\n\\n\\n2. `bool validPartition(vector<int>& nums)`: It is the main function to set up memoization and solve the problem.\\nGet the size `n`of the input array` nums`.\\nInitialize a memoization array `dp` with size n+1, filled with -1.\\nReturn the result of the `solveMem` function by passing nums, dp, and the starting index 0.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solveMem(vector<int>&nums,vector<int>&dp,int i){\\n        int n=nums.size(); \\n\\n        //base case\\n        if(i>=n) return true;\\n\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        //For equal elements\\n        if(i+1<n && nums[i]==nums[i+1]){\\n            dp[i]=solveMem(nums,dp,i+2);\\n            if(dp[i]) return true;\\n\\n            if(i+2<n && nums[i]==nums[i+2]){\\n                dp[i]=solveMem(nums,dp,i+3);\\n                if(dp[i]) return true;\\n            }\\n        }\\n        //For 3 consecutive increasing elements\\n        if(i+2<n && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n            dp[i]=solveMem(nums,dp,i+3);\\n            if(dp[i]) return true;\\n        }\\n\\n        return false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n         \\n         vector<int>dp(n+1,-1);\\n\\n\\n\\n         return solveMem(nums,dp,0);\\n\\n\\n    }\\n};\\n```\\n![upvote lc.jpeg](https://assets.leetcode.com/users/images/d8cf9422-4d0f-4aa4-8d31-0518f9ec4b17_1691906838.6030326.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solveMem(vector<int>&nums,vector<int>&dp,int i){\\n        int n=nums.size(); \\n\\n        //base case\\n        if(i>=n) return true;\\n\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        //For equal elements\\n        if(i+1<n && nums[i]==nums[i+1]){\\n            dp[i]=solveMem(nums,dp,i+2);\\n            if(dp[i]) return true;\\n\\n            if(i+2<n && nums[i]==nums[i+2]){\\n                dp[i]=solveMem(nums,dp,i+3);\\n                if(dp[i]) return true;\\n            }\\n        }\\n        //For 3 consecutive increasing elements\\n        if(i+2<n && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n            dp[i]=solveMem(nums,dp,i+3);\\n            if(dp[i]) return true;\\n        }\\n\\n        return false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n         \\n         vector<int>dp(n+1,-1);\\n\\n\\n\\n         return solveMem(nums,dp,0);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902209,
                "title": "python-optimized-dp-with-circular-buffer-4-lines",
                "content": "# DP\\nGiven a valid sub partition with length `i`\\n* The sub partition with length `i + 2` is valid iff `nums[i+1] == nums[i+2]`\\n* The sub partition with length `i + 3` is valid iff `nums[i+1] == nums[i+2] == nums[i+3]` or `nums[i+1]+2 == nums[i+2]+1 == nums[i+3]`\\n\\nThe initial partition is an empty array which is valid.\\n\\n# Circular Buffer\\nSince we only look for the last three states, we can optimize the memory usage with a circular buffer.\\n\\n# Code\\n```\\nclass Solution:\\n    def validPartition(self, A: List[int]) -> bool:\\n        dp = [True, False, A[0] == A[1]]\\n        for i in range(2, len(A)):\\n            dp[(i+1)%3] = (A[i-2] == A[i-1] == A[i] or A[i-2]+2 == A[i-1]+1 == A[i]) and dp[(i-2)%3] or A[i-1] == A[i] and dp[(i-1)%3]\\n        return dp[len(A)%3]    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, A: List[int]) -> bool:\\n        dp = [True, False, A[0] == A[1]]\\n        for i in range(2, len(A)):\\n            dp[(i+1)%3] = (A[i-2] == A[i-1] == A[i] or A[i-2]+2 == A[i-1]+1 == A[i]) and dp[(i-2)%3] or A[i-1] == A[i] and dp[(i-1)%3]\\n        return dp[len(A)%3]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902100,
                "title": "daily-coding-challenge-video-explanation-easy-approach-dp",
                "content": "# Video Explanation\\n\\nhttps://youtu.be/qhlpX1OdF2k\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n    int n=nums.length;\\n    boolean dp[]=new boolean[n+1];\\n    dp[n]=true;\\n\\n    for(int i=n-1;i>=0;i--){\\n        if(i+1 <n){\\n            if(nums[i]==nums[i+1] && dp[i+2]){\\n                dp[i]=true;\\n            }\\n       if(i+2 <n){\\n            if(((nums[i]==nums[i+1] && nums[i+1]==nums[i+2])|| (nums[i]+1==nums[i+1]&& nums[i+1]+1 == nums[i+2]))&& dp[i+3]){\\n                dp[i]=true;\\n            }\\n       }\\n        }\\n\\n       \\n    }\\n    return dp[0];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n    int n=nums.length;\\n    boolean dp[]=new boolean[n+1];\\n    dp[n]=true;\\n\\n    for(int i=n-1;i>=0;i--){\\n        if(i+1 <n){\\n            if(nums[i]==nums[i+1] && dp[i+2]){\\n                dp[i]=true;\\n            }\\n       if(i+2 <n){\\n            if(((nums[i]==nums[i+1] && nums[i+1]==nums[i+2])|| (nums[i]+1==nums[i+1]&& nums[i+1]+1 == nums[i+2]))&& dp[i+3]){\\n                dp[i]=true;\\n            }\\n       }\\n        }\\n\\n       \\n    }\\n    return dp[0];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901985,
                "title": "dp-memoized-solution-with-simple-approach",
                "content": "## Upvote if you like the solution\\n# Approach\\nIdea is simple first create a function to check the validity of the subarray.\\nNow we must have minimum 2 elements in partition, so create a for loop which will run for next 2 consecutive elements (including current element), now check for the validity of subarray, if it is valid then call recursive function for remaining subarray.\\n\\nNow for base case if index goes beyond nums.size() mens last subarray is checked so return true.\\n\\n# Complexity\\n- Time complexity: nearly exponential\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isValid(int i, int j, vector<int> &nums){\\n    if(i>=nums.size() || j>=nums.size()) return false;\\n\\n    if(j-i == 1){\\n        if(nums[i] == nums[j])\\n            return true;\\n    }else if(j-i == 2){\\n        if(nums[i] == nums[i+1] && nums[i+1] == nums[j])\\n            return true;\\n        else if(nums[i+1]-nums[i] == 1 && nums[j]-nums[i+1] == 1)\\n            return true;\\n    }\\n    return false;\\n}\\nbool getPartitions(int idx, int n, vector<int> &nums, vector<int> &dp){\\n    if(idx>=n) return true;\\n    if(dp[idx] != -1) return dp[idx];\\n\\n    for(int i = idx+1; i<idx+3; i++){\\n        if(isValid(idx, i, nums))\\n            if(getPartitions(i+1, n, nums, dp))\\n                return dp[idx] = true;\\n    }\\n\\n    return dp[idx] = false;\\n}\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return getPartitions(0, n, nums, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isValid(int i, int j, vector<int> &nums){\\n    if(i>=nums.size() || j>=nums.size()) return false;\\n\\n    if(j-i == 1){\\n        if(nums[i] == nums[j])\\n            return true;\\n    }else if(j-i == 2){\\n        if(nums[i] == nums[i+1] && nums[i+1] == nums[j])\\n            return true;\\n        else if(nums[i+1]-nums[i] == 1 && nums[j]-nums[i+1] == 1)\\n            return true;\\n    }\\n    return false;\\n}\\nbool getPartitions(int idx, int n, vector<int> &nums, vector<int> &dp){\\n    if(idx>=n) return true;\\n    if(dp[idx] != -1) return dp[idx];\\n\\n    for(int i = idx+1; i<idx+3; i++){\\n        if(isValid(idx, i, nums))\\n            if(getPartitions(i+1, n, nums, dp))\\n                return dp[idx] = true;\\n    }\\n\\n    return dp[idx] = false;\\n}\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return getPartitions(0, n, nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901826,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& nums, int ind, vector<int>& dp){\\n        if(ind == nums.size()) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        if(ind + 1 < nums.size() && nums[ind] == nums[ind+1] ) {\\n            //check for 2 consecutive same element\\n            if(helper(nums, ind + 2, dp)) return true;\\n            //check for 3 consecutive same element\\n            if(ind + 2 < nums.size() && nums[ind] == nums[ind+2]){\\n                if(helper(nums, ind + 3, dp)) return true;\\n            }\\n        }\\n        //check for exact 3 consecutive increasing sequence\\n        if(ind + 2 < nums.size() && nums[ind] == nums[ind+1]-1 && nums[ind] == nums[ind+2] - 2 ){\\n            if(helper(nums, ind + 3, dp)) return true;\\n        }\\n        return dp[ind] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& nums, int ind, vector<int>& dp){\\n        if(ind == nums.size()) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        if(ind + 1 < nums.size() && nums[ind] == nums[ind+1] ) {\\n            //check for 2 consecutive same element\\n            if(helper(nums, ind + 2, dp)) return true;\\n            //check for 3 consecutive same element\\n            if(ind + 2 < nums.size() && nums[ind] == nums[ind+2]){\\n                if(helper(nums, ind + 3, dp)) return true;\\n            }\\n        }\\n        //check for exact 3 consecutive increasing sequence\\n        if(ind + 2 < nums.size() && nums[ind] == nums[ind+1]-1 && nums[ind] == nums[ind+2] - 2 ){\\n            if(helper(nums, ind + 3, dp)) return true;\\n        }\\n        return dp[ind] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901510,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        @cache\\n        def fn(index):\\n            if index==n:\\n                return True\\n\\n            if index+1<n and nums[index]==nums[index+1] and fn(index+2):\\n                return True\\n\\n            if index+2<n and nums[index]==nums[index+1]==nums[index+2] and fn(index+3):\\n                return True\\n\\n            if index+2<n and nums[index]==nums[index+1]-1 and nums[index+1]==nums[index+2]-1 and fn(index+3):\\n                return True\\n\\n            return False\\n\\n        return fn(0)                                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        @cache\\n        def fn(index):\\n            if index==n:\\n                return True\\n\\n            if index+1<n and nums[index]==nums[index+1] and fn(index+2):\\n                return True\\n\\n            if index+2<n and nums[index]==nums[index+1]==nums[index+2] and fn(index+3):\\n                return True\\n\\n            if index+2<n and nums[index]==nums[index+1]-1 and nums[index+1]==nums[index+2]-1 and fn(index+3):\\n                return True\\n\\n            return False\\n\\n        return fn(0)                                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901484,
                "title": "o-1-space-in-place-solution-that-isn-t-in-editorial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse dynamic programming to solve this one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNegate a number to mark a cell.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n* You could find some other extraordinary solutions in my [profile](https://leetcode.com/almostmonday/) on the Solutions tab (I don\\'t post obvious or not interesting solutions at all.)\\n* If this was helpful, please upvote so that others can see this solution too.\\n---\\n\\n# Code\\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        nums[0] *= -1\\n        for i in range(len(nums) - 2):\\n            if nums[i] > -1: continue\\n            \\n            if abs(nums[i]) == abs(nums[i + 1]): nums[i + 2] = -abs(nums[i + 2])\\n\\n            if (abs(nums[i]) == abs(nums[i + 1]) == abs(nums[i + 2]) or \\n                abs(nums[i]) + 1 == abs(nums[i + 1]) == abs(nums[i + 2]) - 1):\\n                    if i + 3 == len(nums): return True\\n                    else: nums[i + 3] = -abs(nums[i + 3])\\n        \\n        return nums[-2] < 0 and abs(nums[-2]) == abs(nums[-1])\\n```\\n\\nYou could optimise it:\\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        nums[0] *= -1\\n        for i in range(len(nums) - 2):\\n            if nums[i] > -1: continue\\n            \\n            if abs(nums[i]) == abs(nums[i + 1]): \\n                nums[i + 2] = -abs(nums[i + 2])\\n                if abs(nums[i]) == abs(nums[i + 2]):\\n                    if i + 3 == len(nums): return True\\n                    else: nums[i + 3] = -abs(nums[i + 3])\\n\\n            elif abs(nums[i]) + 1 == abs(nums[i + 1]) == abs(nums[i + 2]) - 1:\\n                    if i + 3 == len(nums): return True\\n                    else: nums[i + 3] = -abs(nums[i + 3])\\n        \\n        return nums[-2] < 0 and abs(nums[-2]) == abs(nums[-1])\\n```\\n\\nif it\\'s necessary, recover the values:\\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        nums[0] *= -1\\n        for i in range(len(nums) - 2):\\n            if nums[i] > -1: continue\\n            nums[i] *= -1\\n            \\n            if abs(nums[i]) == abs(nums[i + 1]): nums[i + 2] = -abs(nums[i + 2])\\n\\n            if (abs(nums[i]) == abs(nums[i + 1]) == abs(nums[i + 2]) or \\n                abs(nums[i]) + 1 == abs(nums[i + 1]) == abs(nums[i + 2]) - 1):\\n                    if i + 3 == len(nums): return True\\n                    else: nums[i + 3] = -abs(nums[i + 3])\\n        \\n        res = nums[-2] < 0 and abs(nums[-2]) == abs(nums[-1])\\n        nums[-1], nums[-2] = abs(nums[-1]), abs(nums[-2])\\n\\n        return res\\n```\\n\\nYou could collect next steps, the number of which is limited:\\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        steps = {0}\\n        while steps:\\n            stepsNext = set()\\n            for i in steps:\\n                if i == len(nums): return True\\n                \\n                if (i + 1 < len(nums) and \\n                    nums[i] == nums[i + 1] and \\n                    (i + 2) not in steps): stepsNext.add(i + 2)\\n                \\n                if (i + 2 < len(nums) and \\n                    (nums[i] == nums[i + 1] == nums[i + 2] or\\n                    nums[i] + 1 == nums[i + 1] == nums[i + 2] - 1) and \\n                    (i + 3) not in steps): stepsNext.add(i + 3)\\n            \\n            steps = stepsNext\\n        \\n        return False\\n```\\n\\n---\\n\\nIf it\\'s difficult to understand, you could start with this one:\\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        dp = [1] + [0] * len(nums)\\n        for i in range(len(nums) - 2):\\n            if not dp[i]: continue\\n            if nums[i] == nums[i + 1]: dp[i + 2] = 1\\n            if ((nums[i] == nums[i + 1] == nums[i + 2]) or\\n                (nums[i] + 1 == nums[i + 1] == nums[i + 2] - 1)): dp[i + 3] = 1\\n            \\n        return dp[-1] or (dp[-3] and nums[-1] == nums[-2])\\n```\\n\\nAlso, you could check if there are any steps left:\\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        dp = [1] + [0] * len(nums)\\n        last = 0\\n        for i in range(len(nums) - 2):\\n            if i > last: return False\\n            if not dp[i]: continue\\n            if nums[i] == nums[i + 1]: dp[i + 2], last = 1, i + 2\\n            if ((nums[i] == nums[i + 1] == nums[i + 2]) or\\n                (nums[i] + 1 == nums[i + 1] == nums[i + 2] - 1)): dp[i + 3], last = 1, i + 3\\n            \\n        return dp[-1] or (dp[-3] and nums[-1] == nums[-2])\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        nums[0] *= -1\\n        for i in range(len(nums) - 2):\\n            if nums[i] > -1: continue\\n            \\n            if abs(nums[i]) == abs(nums[i + 1]): nums[i + 2] = -abs(nums[i + 2])\\n\\n            if (abs(nums[i]) == abs(nums[i + 1]) == abs(nums[i + 2]) or \\n                abs(nums[i]) + 1 == abs(nums[i + 1]) == abs(nums[i + 2]) - 1):\\n                    if i + 3 == len(nums): return True\\n                    else: nums[i + 3] = -abs(nums[i + 3])\\n        \\n        return nums[-2] < 0 and abs(nums[-2]) == abs(nums[-1])\\n```\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        nums[0] *= -1\\n        for i in range(len(nums) - 2):\\n            if nums[i] > -1: continue\\n            \\n            if abs(nums[i]) == abs(nums[i + 1]): \\n                nums[i + 2] = -abs(nums[i + 2])\\n                if abs(nums[i]) == abs(nums[i + 2]):\\n                    if i + 3 == len(nums): return True\\n                    else: nums[i + 3] = -abs(nums[i + 3])\\n\\n            elif abs(nums[i]) + 1 == abs(nums[i + 1]) == abs(nums[i + 2]) - 1:\\n                    if i + 3 == len(nums): return True\\n                    else: nums[i + 3] = -abs(nums[i + 3])\\n        \\n        return nums[-2] < 0 and abs(nums[-2]) == abs(nums[-1])\\n```\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        nums[0] *= -1\\n        for i in range(len(nums) - 2):\\n            if nums[i] > -1: continue\\n            nums[i] *= -1\\n            \\n            if abs(nums[i]) == abs(nums[i + 1]): nums[i + 2] = -abs(nums[i + 2])\\n\\n            if (abs(nums[i]) == abs(nums[i + 1]) == abs(nums[i + 2]) or \\n                abs(nums[i]) + 1 == abs(nums[i + 1]) == abs(nums[i + 2]) - 1):\\n                    if i + 3 == len(nums): return True\\n                    else: nums[i + 3] = -abs(nums[i + 3])\\n        \\n        res = nums[-2] < 0 and abs(nums[-2]) == abs(nums[-1])\\n        nums[-1], nums[-2] = abs(nums[-1]), abs(nums[-2])\\n\\n        return res\\n```\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        steps = {0}\\n        while steps:\\n            stepsNext = set()\\n            for i in steps:\\n                if i == len(nums): return True\\n                \\n                if (i + 1 < len(nums) and \\n                    nums[i] == nums[i + 1] and \\n                    (i + 2) not in steps): stepsNext.add(i + 2)\\n                \\n                if (i + 2 < len(nums) and \\n                    (nums[i] == nums[i + 1] == nums[i + 2] or\\n                    nums[i] + 1 == nums[i + 1] == nums[i + 2] - 1) and \\n                    (i + 3) not in steps): stepsNext.add(i + 3)\\n            \\n            steps = stepsNext\\n        \\n        return False\\n```\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        dp = [1] + [0] * len(nums)\\n        for i in range(len(nums) - 2):\\n            if not dp[i]: continue\\n            if nums[i] == nums[i + 1]: dp[i + 2] = 1\\n            if ((nums[i] == nums[i + 1] == nums[i + 2]) or\\n                (nums[i] + 1 == nums[i + 1] == nums[i + 2] - 1)): dp[i + 3] = 1\\n            \\n        return dp[-1] or (dp[-3] and nums[-1] == nums[-2])\\n```\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        dp = [1] + [0] * len(nums)\\n        last = 0\\n        for i in range(len(nums) - 2):\\n            if i > last: return False\\n            if not dp[i]: continue\\n            if nums[i] == nums[i + 1]: dp[i + 2], last = 1, i + 2\\n            if ((nums[i] == nums[i + 1] == nums[i + 2]) or\\n                (nums[i] + 1 == nums[i + 1] == nums[i + 2] - 1)): dp[i + 3], last = 1, i + 3\\n            \\n        return dp[-1] or (dp[-3] and nums[-1] == nums[-2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741216,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool solve(vector<int>& nums, int i, vector<int>& dp){\\n        if(i == nums.size()) return true;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        if(i + 1 < nums.size() && nums[i] == nums[i+1] ) {\\n            if(solve(nums, i + 2, dp)) return true;\\n            if(i + 2 < nums.size() && nums[i] == nums[i+2]){\\n                if(solve(nums, i + 3, dp)) return true;\\n            }\\n        }\\n        if(i + 2 < nums.size() && nums[i] == nums[i+1]-1 && nums[i] == nums[i+2] - 2 ){\\n            if(solve(nums, i + 3, dp)) return true;\\n        }\\n        return dp[i] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n         vector<int> dp(nums.size(), -1);\\n        return solve(nums, 0, dp);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool solve(vector<int>& nums, int i, vector<int>& dp){\\n        if(i == nums.size()) return true;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        if(i + 1 < nums.size() && nums[i] == nums[i+1] ) {\\n            if(solve(nums, i + 2, dp)) return true;\\n            if(i + 2 < nums.size() && nums[i] == nums[i+2]){\\n                if(solve(nums, i + 3, dp)) return true;\\n            }\\n        }\\n        if(i + 2 < nums.size() && nums[i] == nums[i+1]-1 && nums[i] == nums[i+2] - 2 ){\\n            if(solve(nums, i + 3, dp)) return true;\\n        }\\n        return dp[i] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n         vector<int> dp(nums.size(), -1);\\n        return solve(nums, 0, dp);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411355,
                "title": "c-memoization-recursion-with-explaination",
                "content": "class Solution {\\npublic:\\n    \\n    bool checkPartition(vector<int>& nums, int i, int n, vector<int> &dp)\\n    {\\n        //If we reach the end of the array\\n        if(i == n) return dp[i] = true;\\n        \\n        //return memoized answer  if it exists\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        //We have 2 cases \\n        //Case 1 is we have two equal consequtive numbers \\n        //Case 2 is we have three equal consequtive numbers\\n        //We need to check if a valid partition is formed if we take case1 and solve for the remaining array or \\n        //if we take case2 and solve for the remaining array\\n        // example1:  [4,4,4,5,6] Case1 = [4,4 | 4,5,6] OR Case2 = [4,4,4 | 5,6] --> Case 1 gives us our valid partition\\n        // example2:  [4,4,4,1,1] Case1 = [4,4 | 4,1,1] OR Case2 = [4,4,4 | 1,1] --> Case 2 gives us our valid partition\\n        \\n        //Here check1 => Case1 ; check2 => Case2\\n        int check1 =false, check2=false;\\n        \\n        \\n        //This is the 3rd given case\\n        // in this case we check for consequtive numbers with difference of 1 and if so we solve for the remaining array\\n        \\n        if(i+1 < n && i + 2 < n && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) \\n            return dp[i] = checkPartition(nums,i+3,n,dp);\\n        \\n        if(i+1 < n && nums[i] == nums[i+1])\\n        {\\n            check1 = checkPartition(nums,i+2,n,dp);\\n        \\n            if(i+2 < n && nums[i] == nums[i+2])\\n                check2 = checkPartition(nums,i+3,n,dp);\\n        }\\n            \\n        return dp[i] = (check1 or check2);\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n    \\n        int n = nums.size();\\n        vector<int> dp(n+1,-1);\\n        return checkPartition(nums,0,n,dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool checkPartition(vector<int>& nums, int i, int n, vector<int> &dp)\\n    {\\n        //If we reach the end of the array\\n        if(i == n) return dp[i] = true;\\n        \\n        //return memoized answer  if it exists\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        //We have 2 cases \\n        //Case 1 is we have two equal consequtive numbers \\n        //Case 2 is we have three equal consequtive numbers\\n        //We need to check if a valid partition is formed if we take case1 and solve for the remaining array or \\n        //if we take case2 and solve for the remaining array\\n        // example1:  [4,4,4,5,6] Case1 = [4,4 | 4,5,6] OR Case2 = [4,4,4 | 5,6] --> Case 1 gives us our valid partition\\n        // example2:  [4,4,4,1,1] Case1 = [4,4 | 4,1,1] OR Case2 = [4,4,4 | 1,1] --> Case 2 gives us our valid partition\\n        \\n        //Here check1 => Case1 ; check2 => Case2\\n        int check1 =false, check2=false;\\n        \\n        \\n        //This is the 3rd given case\\n        // in this case we check for consequtive numbers with difference of 1 and if so we solve for the remaining array\\n        \\n        if(i+1 < n && i + 2 < n && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) \\n            return dp[i] = checkPartition(nums,i+3,n,dp);\\n        \\n        if(i+1 < n && nums[i] == nums[i+1])\\n        {\\n            check1 = checkPartition(nums,i+2,n,dp);\\n        \\n            if(i+2 < n && nums[i] == nums[i+2])\\n                check2 = checkPartition(nums,i+3,n,dp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2403935,
                "title": "python3-state-machine-accepted-and-regular-expression-tle",
                "content": "First idea: convert input to string and let the re module do the work.\\nElement that is equal to previous one, gets \\'a\\'. If it\\'s larger by one, it gets \\'b\\'. Other elements get \\'c\\'.\\nSo, type one subarray is matched by \".a\", type two - by \".aa\", type three - by \".bb\".\\n```\\nimport re\\n\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        s = [\"c\"]\\n        for a,b in zip(nums,nums[1:]):\\n            if a==b:\\n                s.append(\"a\")\\n            elif a+1==b:\\n                s.append(\"b\")\\n            else:\\n                s.append(\"c\")\\n        s = \"\".join(s)\\n        return bool(re.fullmatch(\"(.a|.aa|.bb)+\", s))\\n```\\n\\nApparently, python\\'s re implementation doesn\\'t optimize its state machines good enough, this solution got TLE. So, let\\'s do it by hand.\\n\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        f3,f2,f1 = False,False,True\\n        for i,v in enumerate(nums):\\n            f = f2 and (v==nums[i-1])\\n            f = f or f3 and (v==nums[i-1]==nums[i-2])\\n            f = f or f3 and (v==nums[i-1]+1==nums[i-2]+2)\\n            f3,f2,f1 = f2,f1,f\\n        return f1\\n```\\nSo here we scan from left to right and keep track of possible subarray boundaries.\\nThere is a valid partition iff there may be a boundary after the last element.\\nO(1) space, O(n) time one-pass.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        s = [\"c\"]\\n        for a,b in zip(nums,nums[1:]):\\n            if a==b:\\n                s.append(\"a\")\\n            elif a+1==b:\\n                s.append(\"b\")\\n            else:\\n                s.append(\"c\")\\n        s = \"\".join(s)\\n        return bool(re.fullmatch(\"(.a|.aa|.bb)+\", s))\\n```\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        f3,f2,f1 = False,False,True\\n        for i,v in enumerate(nums):\\n            f = f2 and (v==nums[i-1])\\n            f = f or f3 and (v==nums[i-1]==nums[i-2])\\n            f = f or f3 and (v==nums[i-1]+1==nums[i-2]+2)\\n            f3,f2,f1 = f2,f1,f\\n        return f1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400531,
                "title": "simple-c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int ind,vector<int> &nums,vector<int> &memo){\\n        int n = nums.size();\\n        if(ind >= n) return true;\\n        if(memo[ind] != -1) return memo[ind];\\n         \\n        bool ans = false;\\n        if(ind+1 < n && nums[ind+1] == nums[ind]) {\\n            ans = ans | solve(ind+2,nums,memo);\\n        }\\n        \\n        if(ind+2 < n && nums[ind+2] == nums[ind+1] && nums[ind+1] == nums[ind]){\\n            ans = ans | solve(ind+3,nums,memo);\\n        }\\n        \\n        if(ind+2 < n && nums[ind+2] - nums[ind+1] == 1 && nums[ind+1] - nums[ind] == 1){\\n            ans = ans | solve(ind+3,nums,memo);\\n        }\\n       \\n        return memo[ind] = ans;\\n        \\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        vector<int> memo(nums.size()+1,-1);\\n        return solve(0,nums,memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int ind,vector<int> &nums,vector<int> &memo){\\n        int n = nums.size();\\n        if(ind >= n) return true;\\n        if(memo[ind] != -1) return memo[ind];\\n         \\n        bool ans = false;\\n        if(ind+1 < n && nums[ind+1] == nums[ind]) {\\n            ans = ans | solve(ind+2,nums,memo);\\n        }\\n        \\n        if(ind+2 < n && nums[ind+2] == nums[ind+1] && nums[ind+1] == nums[ind]){\\n            ans = ans | solve(ind+3,nums,memo);\\n        }\\n        \\n        if(ind+2 < n && nums[ind+2] - nums[ind+1] == 1 && nums[ind+1] - nums[ind] == 1){\\n            ans = ans | solve(ind+3,nums,memo);\\n        }\\n       \\n        return memo[ind] = ans;\\n        \\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        vector<int> memo(nums.size()+1,-1);\\n        return solve(0,nums,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396490,
                "title": "easy-recursion-in-java-memo",
                "content": "class Solution {\\n    public boolean validPartition(int[] nums) {\\n        Boolean [] dp = new Boolean[nums.length];\\n        return is(0,nums,dp);\\n    }\\n    public boolean is(int i,int[] nums,Boolean[] dp){\\n        if(i==nums.length){\\n            return true;\\n        }\\n        if(dp[i]!=null){\\n            return dp[i];\\n        }\\n         boolean a=false;\\n          boolean   b=false;\\n          boolean   c=false;\\n         if(nums.length-i>=3 && nums[i]==nums[i+1]&& nums[i+1]==nums[i+2]){\\n            a =  is(i+3,nums,dp);\\n         }\\n         if(nums.length -i>=2 && nums[i]==nums[i+1]){\\n             b =  is(i+2,nums,dp);\\n         }\\n         if(nums.length-i>=3 &&nums[i]-nums[i+1] == -1 && nums[i+1]-nums[i+2]==-1){\\n             c =  is(i+3,nums,dp);\\n         }\\n        dp[i]=a || b || c;\\n        return a || b || c;\\n    }\\n}",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public boolean validPartition(int[] nums) {\\n        Boolean [] dp = new Boolean[nums.length];\\n        return is(0,nums,dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2393100,
                "title": "c-simple-dp-logic-explained-o-n",
                "content": "It is very clear from the problem statement that we can make two type of cuts at any particular position,\\n\\n\\t- It can be of size two if nums[i] == nums[i+1]\\n\\t- It can be of size three if\\n\\t\\t- nums[i] == nums[i+1] == nums[i+2]\\n\\t\\t- or, abs(nums[i] - nums[i+1]) == 1 && abs(nums[i+1] - nums[i+2]) == 1\\n\\nHence when standing at any poistion i when when we are making a cut of either size 2 or 3, all we need to check is\\n\\n\\t- If this is a valid cut, and\\n\\t- If the (i+2)th cut if (cut is of size 2) or (i+3)th cut if (cut is of size 3) is also valid\\n\\nHence dp can pe defined as\\n\\n\\t- For a cut of size two\\n\\t\\t- dp[i] = (nums[i] == nums[i+1]) && dp[i+2]\\n\\t- for a cut of size three\\n\\t\\t- dp[i] = (nums[i] == nums[i+1] == nums[i+2]) or (abs(nums[i] - nums[i+1]) == 1 && abs(nums[i+1] - nums[i+2]) == 1) && dp[i+3]\\n\\n\\n```\\nbool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool> dp(n+1, 0);\\n        dp[n]=1;\\n        dp[n-1]=0;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i]==nums[i+1] && dp[i+2]){\\n                dp[i]=1;\\n            }\\n            if((i+2)<n && (nums[i]==nums[i+1]) && (nums[i+1]==nums[i+2]) && dp[i+3]){\\n                dp[i]=1;\\n            }\\n            if((i+2)<n && (abs(nums[i]-nums[i+1])==1) && (abs(nums[i+1]-nums[i+2])==1) && dp[i+3]){\\n                dp[i]=1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool> dp(n+1, 0);\\n        dp[n]=1;\\n        dp[n-1]=0;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i]==nums[i+1] && dp[i+2]){\\n                dp[i]=1;\\n            }\\n            if((i+2)<n && (nums[i]==nums[i+1]) && (nums[i+1]==nums[i+2]) && dp[i+3]){\\n                dp[i]=1;\\n            }\\n            if((i+2)<n && (abs(nums[i]-nums[i+1])==1) && (abs(nums[i+1]-nums[i+2])==1) && dp[i+3]){\\n                dp[i]=1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2392223,
                "title": "recursion-to-memoization-dp-solution-c",
                "content": "Three cases for validation:\\n\\n1. Check for 2 consecutive are equal\\n1. Check for 3 consecutive are equal\\n1. Check for 3 increasing numbers\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<int>& nums, int id, int len, vector<int>& dp)\\n    {\\n\\t\\tint n = nums.size();\\n\\t\\t//Base case if length of subarray less than 2 then invalid\\n        if(len < 2)\\n            return 0;\\n        \\n\\t\\t//If subproblem calculated previously then return value\\n        if(dp[id] != -1)\\n            return dp[id];\\n        \\n\\t\\t//Subarray of length 2\\n        if(len == 2)\\n        {\\n\\t\\t\\t//Check for 2 consecutive are equal\\n            return nums[id] == nums[id+1];\\n        }\\n\\t\\t//Subarray of length 3\\n        else if(len == 3)\\n        {\\n\\t\\t\\t//Check for 3 consecutive are equal\\n            if(nums[id] == nums[id+1] && nums[id+1] == nums[id+2])\\n                return 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t//Check for 3 increasing numbers\\n            else if(nums[id+1] - nums[id] == 1 && nums[id+2] - nums[id+1] == 1)\\n                return 1;\\n            else \\n                return 0;\\n        }\\n\\t\\t//Recursively call for length of 2 & next remaining subarray OR call for length of 3 & next remaining subarray\\n        return dp[id] = (checkValid(nums, id, 2, dp) && checkValid(nums, id+2, n-(id+2), dp)) ||     \\n\\t\\t                (checkValid(nums, id, 3, dp) && checkValid(nums, id+3, n-(id+3), dp));\\n    } \\n    \\n    bool validPartition(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n + 1, -1);\\n\\t\\t\\n        return checkValid(nums, 0, n, dp);\\n    }\\n};\\n```\\n**Complexity Analysis :**\\n\\tTime Complexity   : O(N)\\n\\tSpace Complexity : O(N)",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<int>& nums, int id, int len, vector<int>& dp)\\n    {\\n\\t\\tint n = nums.size();\\n\\t\\t//Base case if length of subarray less than 2 then invalid\\n        if(len < 2)\\n            return 0;\\n        \\n\\t\\t//If subproblem calculated previously then return value\\n        if(dp[id] != -1)\\n            return dp[id];\\n        \\n\\t\\t//Subarray of length 2\\n        if(len == 2)\\n        {\\n\\t\\t\\t//Check for 2 consecutive are equal\\n            return nums[id] == nums[id+1];\\n        }\\n\\t\\t//Subarray of length 3\\n        else if(len == 3)\\n        {\\n\\t\\t\\t//Check for 3 consecutive are equal\\n            if(nums[id] == nums[id+1] && nums[id+1] == nums[id+2])\\n                return 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t//Check for 3 increasing numbers\\n            else if(nums[id+1] - nums[id] == 1 && nums[id+2] - nums[id+1] == 1)\\n                return 1;\\n            else \\n                return 0;\\n        }\\n\\t\\t//Recursively call for length of 2 & next remaining subarray OR call for length of 3 & next remaining subarray\\n        return dp[id] = (checkValid(nums, id, 2, dp) && checkValid(nums, id+2, n-(id+2), dp)) ||     \\n\\t\\t                (checkValid(nums, id, 3, dp) && checkValid(nums, id+3, n-(id+3), dp));\\n    } \\n    \\n    bool validPartition(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n + 1, -1);\\n\\t\\t\\n        return checkValid(nums, 0, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391429,
                "title": "explanation-dp-tabulation-recursion-easy",
                "content": "**Why Recursion:**\\nLets first try to solve this using recursion and we use recursion because at every setp we can either take 2 elements or 3 elements, we have 2 possibilities at every index. To exhaust all of them we use recursion.\\n\\n**Steps in Recursion:**\\nIf we are at some index i, we have two options\\n\\nTake two elements:\\nonly possible if there are two elements and they are equal\\n(i+1 < nums.size() && nums[i] == nums[i+1]\\nTake three elements\\nonly possible if we have three elements(i+2 < nums.size() and\\n(i) they are equal\\n(nums[i] == nums[i+1] && nums[i+1] == nums[i+2])\\n(ii) they are consecutive\\n(abs(nums[i]-nums[i+1]) == 1 && abs(nums[i+1]-nums[i+2]) == 1)\\n**Base case:**\\nif we are able to use all the elements in partitioning, we can return true\\ni == nums.size()\\n\\nUsing just recursion(time complexity: exponential) will give us TLE, so we memoize the recursion\\n\\n\\n**Memoization**\\n\\nclass Solution {\\n    \\npublic:\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if (i == nums.size()) return 1;\\n        if (dp[i] != -1) return dp[i];\\n        \\n        int ans = 0;\\n        if (i+1 < nums.size() and nums[i] == nums[i+1])\\n            ans = max(ans, solve(i+2, nums, dp));\\n        if (i+2 < nums.size())\\n        {\\n            if (nums[i] == nums[i+1] && nums[i+1] == nums[i+2])\\n                ans = max(ans, solve(i+3, nums, dp));\\n            else if (abs(nums[i]-nums[i+1]) == 1 and abs(nums[i+1]-nums[i+2]) == 1)\\n                ans = max(ans, solve(i+3, nums, dp));\\n            \\n        }\\n        \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1, -1);\\n        return solve(0, nums, dp);\\n    }\\n};\\n\\n\\nTC: O(N) since we are visiting every index once\\nSC: O(N+N) N for dp array and N for recursion stack Space\\n\\nWe can do the same but with loops i.e., tabulation\\n\\n\\n**Tabulation**:\\n\\n```\\n\\nbool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1, 0);\\n        dp[nums.size()] = 1;\\n        for (int i=nums.size()-1; i>=0; i--)\\n        {\\n            if (i+1 < nums.size() and nums[i] == nums[i+1])\\n                dp[i] = max(dp[i], dp[i+2]);\\n            if (i+2 < nums.size())\\n            {\\n                if (nums[i] == nums[i+1] and nums[i+1] == nums[i+2])\\n                    dp[i] = max(dp[i], dp[i+3]);\\n                else if (abs(nums[i]-nums[i+1]) == 1 and abs(nums[i+1]-nums[i+2]) == 1)\\n                    dp[i] = max(dp[i], dp[i+3]);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n```\\n\\t\\n\\t\\nTC: O(N) since we are visiting every index once\\nSC: O(N) N for dp array\\n\\n\\nIF U LIKE **UPVOTE** IT\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nbool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1, 0);\\n        dp[nums.size()] = 1;\\n        for (int i=nums.size()-1; i>=0; i--)\\n        {\\n            if (i+1 < nums.size() and nums[i] == nums[i+1])\\n                dp[i] = max(dp[i], dp[i+2]);\\n            if (i+2 < nums.size())\\n            {\\n                if (nums[i] == nums[i+1] and nums[i+1] == nums[i+2])\\n                    dp[i] = max(dp[i], dp[i+3]);\\n                else if (abs(nums[i]-nums[i+1]) == 1 and abs(nums[i+1]-nums[i+2]) == 1)\\n                    dp[i] = max(dp[i], dp[i+3]);\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391124,
                "title": "c-o-n-dp-approach-using-example",
                "content": "**In this question you can divide the array in multiple contigous subarrays of size either 2 or 3  based on which of the 3 conditions they follow.\\n1->Subarray of size 2 having both Element same i.e [3,3]\\n2->Subarray of size 3 having all 3 Elements same i.e [4,4,4]\\n3->Subarray of size 3 having 3 consecutive number in sequence i.e [1,2,3] or [4,5,6].\\n\\tSo basically if you are at index 0 and you can try to make 1st subarray of size 2 or 3 based on which condition they satisfy of the above 3. \\n\\tIf the Current Subarray satisfy the 1st condition i.e (nums[i]==nums[i+1]) then in that case our index will move on to the (i+2)th position and we try same for the remaining array.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tOR\\n\\tIf the Current Subarray satisfy the 2nd condition i.e (nums[i]==nums[i+1]==nums[i+2]) then in that case our index will move on to the (i+3)th position and we try same for the remaining array. [2,2,2,3,4]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tOR\\n\\tIf the Current subarray satisfy the 3rd condition i.e (nums[i]+1==nums[i+1] && nums[i+1]+1==nums[i+2]) then in that case also our index will move on to the (i+3)th position and we try same for the remaining array.\\n\\tExample->\\n\\tSuppose  array given to us is [2,2,2,3,4] and initially our idx was at 0.\\n\\tSince (nums[0]==nums[1]) that means our 1st condtion is satisfied so we can apply it due to which out idx will move to idx+2 i.e our idx will be at pos 2.\\n\\tBut if you see when we were at idx 0 we can also apply condition 2 so if we apply condition 2 in it then our idx will move to (i+3)rd idx i.e idx=3.\\n\\tSo after you have generated first Subarray you can similarly try to generate other subarrays using same approach.\\n\\tLike this we can check for every possible partition of array and while doing this if our index points to the end of array that means that we were able to partition the array following the given conditions.\\n\\tSo while trying all the possible partition their will be Overlapping Subproblems this we can Optimise using Dynamic programming. \\n\\tCode for the above appraoch: **\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    bool dfs(vector<int> &nums,int n,int i,vector<int>& dp){\\n        if(i>=n)return true;\\n        bool ans1=false,ans2=false;\\n        if(dp[i]!=-1)return dp[i];\\n        if(i+2<n){\\n            if(nums[i]==nums[i+1] && nums[i]==nums[i+2]){\\n                ans1= dfs(nums,n,i+3,dp);\\n            }\\n            else if(nums[i]+1==nums[i+1] && nums[i+1]+1==nums[i+2]){\\n                ans1= dfs(nums,n,i+3,dp);\\n            }\\n        }\\n        if(i+1<n){\\n            if(nums[i]==nums[i+1]){\\n                ans2= dfs(nums,n,i+2,dp);\\n            }   \\n        }\\n        return dp[i]=ans1||ans2;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int idx=0,n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        return dfs(nums,n,idx,dp);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool dfs(vector<int> &nums,int n,int i,vector<int>& dp){\\n        if(i>=n)return true;\\n        bool ans1=false,ans2=false;\\n        if(dp[i]!=-1)return dp[i];\\n        if(i+2<n){\\n            if(nums[i]==nums[i+1] && nums[i]==nums[i+2]){\\n                ans1= dfs(nums,n,i+3,dp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2391005,
                "title": "go-python-dp-simple-explanation",
                "content": "**Complexity**\\n\\tTime   :  O(n)\\n\\tSpace  : O(n)\\n\\t\\n**Description**\\nCreate boolean DP array of length `len(nums)+1` with dummy value True at index 0.\\nIn order to create a subarray for current position, it must meet either 3 conditions stated in question, AND it must be connecting from previous valid subarray. The position for previous connecting subarray is `current position - window size`.\\n`nums` is considered as can be partitioned if the final value/subarray is true.\\n\\n**Take these examples**\\n`nums: [4,4,4,5,6]`\\n`DP: [T,F,T,T,F,T]`\\nPartition: `[4,4]` and `[4,5,6]`. In order to use `[4,5,6]`, it must chain from dp[2]/nums[1]\\'s subarray.\\n\\n`nums:  [4,5,4,5,6]`\\n`DP: [T,F,F,F,F,F]`\\nPartition: only `[4,5,6]`. `[4,5,6]` cannot chain from dp[2]/nums[1] because there is no subarray at that position.\\n\\n**Code**\\n**Go**\\n```\\nfunc validPartition(nums []int) bool {\\n    dp := make([]bool, len(nums)+1)\\n    dp[0] = true\\n    if nums[0] == nums[1] {\\n        dp[2] = true\\n    }\\n    for i := 3; i < len(nums)+1; i++ {\\n        // Condition 1\\n        if nums[i-1] == nums[i-2] {\\n            dp[i] = dp[i] || dp[i-2] \\n        }\\n        // Condition 2\\n        if nums[i-1] == nums[i-2] && nums[i-2] == nums[i-3] {\\n            dp[i] = dp[i] || dp[i-3] \\n        }\\n        // Condition 3\\n        if nums[i-1]-2 == nums[i-2]-1 && nums[i-1]-2 == nums[i-3] {\\n            dp[i] = dp[i] || dp[i-3]\\n        }\\n    }\\n    return dp[len(dp)-1]\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [False for _ in range(len(nums)+1)]\\n        dp[0] = True\\n        if nums[0] == nums[1]:\\n            dp[2] = True\\n        for i in range(3, len(nums)+1):\\n            if nums[i-1] == nums[i-2]:\\n                dp[i] = dp[i] or dp[i-2]\\n            if nums[i-1] == nums[i-2] == nums[i-3]:\\n                dp[i] = dp[i] or dp[i-3]\\n            if nums[i-1]-2 == nums[i-2]-1 == nums[i-3]:\\n                dp[i] = dp[i] or dp[i-3]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc validPartition(nums []int) bool {\\n    dp := make([]bool, len(nums)+1)\\n    dp[0] = true\\n    if nums[0] == nums[1] {\\n        dp[2] = true\\n    }\\n    for i := 3; i < len(nums)+1; i++ {\\n        // Condition 1\\n        if nums[i-1] == nums[i-2] {\\n            dp[i] = dp[i] || dp[i-2] \\n        }\\n        // Condition 2\\n        if nums[i-1] == nums[i-2] && nums[i-2] == nums[i-3] {\\n            dp[i] = dp[i] || dp[i-3] \\n        }\\n        // Condition 3\\n        if nums[i-1]-2 == nums[i-2]-1 && nums[i-1]-2 == nums[i-3] {\\n            dp[i] = dp[i] || dp[i-3]\\n        }\\n    }\\n    return dp[len(dp)-1]\\n}\\n```\n```\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [False for _ in range(len(nums)+1)]\\n        dp[0] = True\\n        if nums[0] == nums[1]:\\n            dp[2] = True\\n        for i in range(3, len(nums)+1):\\n            if nums[i-1] == nums[i-2]:\\n                dp[i] = dp[i] or dp[i-2]\\n            if nums[i-1] == nums[i-2] == nums[i-3]:\\n                dp[i] = dp[i] or dp[i-3]\\n            if nums[i-1]-2 == nums[i-2]-1 == nums[i-3]:\\n                dp[i] = dp[i] or dp[i-3]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390982,
                "title": "javascript-dp-136ms",
                "content": "```\\nconst validPartition = (a) => {\\n    let n = a.length, dp = Array(n + 1).fill(false); // dp[i]: till i, if the array can be partition\\n    dp[0] = true;\\n    for (let i = 2; i <= n; i++) {\\n\\t    // check dp[i-2] = true dp[i-3] = true for previous array can be partion\\n        if (dp[i - 2] && a[i - 2] == a[i - 1]) dp[i] = true; // condition 1\\n        if (i - 3 >= 0 && dp[i - 3] && a[i - 1] == a[i - 2] && a[i - 2] == a[i - 3]) dp[i] = true; // condition 2\\n        if (i - 3 >= 0 && dp[i - 3] && a[i - 1] - a[i - 2] == 1 && a[i - 2] - a[i - 3] == 1) dp[i] = true; // condition 3\\n    }\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst validPartition = (a) => {\\n    let n = a.length, dp = Array(n + 1).fill(false); // dp[i]: till i, if the array can be partition\\n    dp[0] = true;\\n    for (let i = 2; i <= n; i++) {\\n\\t    // check dp[i-2] = true dp[i-3] = true for previous array can be partion\\n        if (dp[i - 2] && a[i - 2] == a[i - 1]) dp[i] = true; // condition 1\\n        if (i - 3 >= 0 && dp[i - 3] && a[i - 1] == a[i - 2] && a[i - 2] == a[i - 3]) dp[i] = true; // condition 2\\n        if (i - 3 >= 0 && dp[i - 3] && a[i - 1] - a[i - 2] == 1 && a[i - 2] - a[i - 3] == 1) dp[i] = true; // condition 3\\n    }\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390683,
                "title": "partition-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&dp,vector<int>&nums,int start){\\n        if(start==nums.size()) return true;\\n        if(dp[start]!=-1) return dp[start];\\n        bool ans=false;\\n        if(start!=nums.size()-1){\\n            if(nums[start]==nums[start+1]) ans=ans||helper(dp,nums,start+2);\\n        }\\n        int i=start;\\n        if(start<nums.size()-2){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if((nums[start]==nums[start+1] && nums[start+1]==nums[start+2]) || (nums[start]+1==nums[start+1] && nums[start+1]+1==nums[start+2]) ) ans=ans||helper(dp,nums,start+3);\\n        }\\n        return dp[start]=ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n+1,-1);\\n        return helper(dp,nums,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&dp,vector<int>&nums,int start){\\n        if(start==nums.size()) return true;\\n        if(dp[start]!=-1) return dp[start];\\n        bool ans=false;\\n        if(start!=nums.size()-1){\\n            if(nums[start]==nums[start+1]) ans=ans||helper(dp,nums,start+2);\\n        }\\n        int i=start;\\n        if(start<nums.size()-2){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if((nums[start]==nums[start+1] && nums[start+1]==nums[start+2]) || (nums[start]+1==nums[start+1] && nums[start+1]+1==nums[start+2]) ) ans=ans||helper(dp,nums,start+3);\\n        }\\n        return dp[start]=ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n+1,-1);\\n        return helper(dp,nums,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390552,
                "title": "python3-iterative-dfs",
                "content": "**Weekly Contest 305 Submission**\\n\\n**Iterative DFS**\\n1. Find all partitions that meet each of the three requirements. Save the starting index and the next index after it occurs in a dictionary (creating a graph).\\n2. DFS through the graph, if we find the length of the array as a node we know we are able to create a partition. \\n\\n**Code**\\n```Python3 []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        idxs = defaultdict(list)\\n        n = len(nums)\\n        \\n        #Find all doubles\\n        for idx in range(1, n):\\n            if nums[idx] == nums[idx - 1]:\\n                idxs[idx - 1].append(idx + 1)\\n                \\n        #Find all triples\\n        for idx in range(2, n):\\n            if nums[idx] == nums[idx - 1] == nums[idx - 2]:\\n                idxs[idx - 2].append(idx + 1)\\n                \\n        #Find all triple increments\\n        for idx in range(2, n):\\n            if nums[idx] == nums[idx - 1] + 1 == nums[idx - 2] + 2:\\n                idxs[idx - 2].append(idx + 1)\\n        \\n        #DFS \\n        seen = set()\\n        stack = [0]\\n\\n        while stack:\\n            node = stack.pop()\\n\\n            if node not in seen:\\n                if node == n:\\n                    return True\\n                seen.add(node)\\n\\n            for adj in idxs[node]:\\n                if adj not in seen:\\n                    stack.append(adj)\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        idxs = defaultdict(list)\\n        n = len(nums)\\n        \\n        #Find all doubles\\n        for idx in range(1, n):\\n            if nums[idx] == nums[idx - 1]:\\n                idxs[idx - 1].append(idx + 1)\\n                \\n        #Find all triples\\n        for idx in range(2, n):\\n            if nums[idx] == nums[idx - 1] == nums[idx - 2]:\\n                idxs[idx - 2].append(idx + 1)\\n                \\n        #Find all triple increments\\n        for idx in range(2, n):\\n            if nums[idx] == nums[idx - 1] + 1 == nums[idx - 2] + 2:\\n                idxs[idx - 2].append(idx + 1)\\n        \\n        #DFS \\n        seen = set()\\n        stack = [0]\\n\\n        while stack:\\n            node = stack.pop()\\n\\n            if node not in seen:\\n                if node == n:\\n                    return True\\n                seen.add(node)\\n\\n            for adj in idxs[node]:\\n                if adj not in seen:\\n                    stack.append(adj)\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390541,
                "title": "python-bfs-or-dfs",
                "content": "- Breadth-First Search\\n```python\\n    def validPartition(self, nums: List[int]) -> bool:\\n        q, seen, n = deque([0]), set([0]), len(nums)\\n        \\n        while q:\\n            i = q.popleft()\\n            \\n            if i == n:\\n                return True\\n            \\n            if (i + 2) <= n and (i + 2) not in seen and nums[i + 1] == nums[i]:\\n                    seen.add(i + 2)\\n                    q.append(i + 2)\\n                   \\n            if (i + 3) <= n and (i + 3) not in seen:\\n                if nums[i + 2] == nums[i + 1] and nums[i + 1] == nums[i]:\\n                    seen.add(i + 3)\\n                    q.append(i + 3)\\n                elif nums[i + 2] - nums[i + 1] == 1 and nums[i + 1] - nums[i] == 1:\\n                    seen.add(i + 3)\\n                    q.append(i + 3)\\n\\n        return False\\n```\\n\\n- Depth-First Search\\n\\n```python\\n    def validPartition(self, nums: List[int]) -> bool:\\n        def dfs(i = 0) -> bool:\\n            if i == n:\\n                return True\\n            \\n            if table[i] != -1:\\n                return table[i]\\n            \\n            res = False\\n                \\n            if (i + 2) <= n and nums[i + 1] == nums[i]:\\n                    res |= dfs(i + 2)\\n                    \\n            if (i + 3) <= n:\\n                if nums[i + 2] == nums[i + 1] and nums[i + 1] == nums[i]:\\n                    res |= dfs(i + 3)\\n                elif nums[i + 2] - nums[i + 1] == 1 and nums[i + 1] - nums[i] == 1:\\n                    res |= dfs(i + 3)\\n                    \\n            table[i] = res\\n            return res\\n        \\n        n = len(nums)\\n        table = [-1] * n\\n        \\n        return dfs()\\n```",
                "solutionTags": [],
                "code": "```python\\n    def validPartition(self, nums: List[int]) -> bool:\\n        q, seen, n = deque([0]), set([0]), len(nums)\\n        \\n        while q:\\n            i = q.popleft()\\n            \\n            if i == n:\\n                return True\\n            \\n            if (i + 2) <= n and (i + 2) not in seen and nums[i + 1] == nums[i]:\\n                    seen.add(i + 2)\\n                    q.append(i + 2)\\n                   \\n            if (i + 3) <= n and (i + 3) not in seen:\\n                if nums[i + 2] == nums[i + 1] and nums[i + 1] == nums[i]:\\n                    seen.add(i + 3)\\n                    q.append(i + 3)\\n                elif nums[i + 2] - nums[i + 1] == 1 and nums[i + 1] - nums[i] == 1:\\n                    seen.add(i + 3)\\n                    q.append(i + 3)\\n\\n        return False\\n```\n```python\\n    def validPartition(self, nums: List[int]) -> bool:\\n        def dfs(i = 0) -> bool:\\n            if i == n:\\n                return True\\n            \\n            if table[i] != -1:\\n                return table[i]\\n            \\n            res = False\\n                \\n            if (i + 2) <= n and nums[i + 1] == nums[i]:\\n                    res |= dfs(i + 2)\\n                    \\n            if (i + 3) <= n:\\n                if nums[i + 2] == nums[i + 1] and nums[i + 1] == nums[i]:\\n                    res |= dfs(i + 3)\\n                elif nums[i + 2] - nums[i + 1] == 1 and nums[i + 1] - nums[i] == 1:\\n                    res |= dfs(i + 3)\\n                    \\n            table[i] = res\\n            return res\\n        \\n        n = len(nums)\\n        table = [-1] * n\\n        \\n        return dfs()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3909877,
                "title": "dp-top-down-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int VP(int i,vector<int>& dp,vector<int>& nums){\\n        if(i==nums.size()) return 1;\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int f1,f2,f3;\\n        f1=f2=f3=0;\\n        if((i+1)<nums.size()&&nums[i+1]==nums[i]){\\n            f1=VP(i+2,dp,nums);\\n        }\\n        if(i+2<nums.size()&&(nums[i+1]==nums[i]&&nums[i]==nums[i+2])){\\n            f2=VP(i+3,dp,nums);\\n        }\\n        if(i+2<nums.size()&&(nums[i+2]-nums[i+1]==1&&nums[i+1]-nums[i]==1)){\\n            f3=VP(i+3,dp,nums);\\n        }\\n        if(f1==false&&f2==false&&f3==false) return dp[i]=false;\\n        return dp[i]=f1||f2||f3;\\n\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return 1==VP(0,dp,nums);\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int VP(int i,vector<int>& dp,vector<int>& nums){\\n        if(i==nums.size()) return 1;\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int f1,f2,f3;\\n        f1=f2=f3=0;\\n        if((i+1)<nums.size()&&nums[i+1]==nums[i]){\\n            f1=VP(i+2,dp,nums);\\n        }\\n        if(i+2<nums.size()&&(nums[i+1]==nums[i]&&nums[i]==nums[i+2])){\\n            f2=VP(i+3,dp,nums);\\n        }\\n        if(i+2<nums.size()&&(nums[i+2]-nums[i+1]==1&&nums[i+1]-nums[i]==1)){\\n            f3=VP(i+3,dp,nums);\\n        }\\n        if(f1==false&&f2==false&&f3==false) return dp[i]=false;\\n        return dp[i]=f1||f2||f3;\\n\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return 1==VP(0,dp,nums);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908738,
                "title": "c-4-methods-recursion-memoization-tabulation-space-optimization",
                "content": "# Space Optimization\\n\\n# Code\\n```\\nclass Solution {\\n    // method-3 : space optimization\\n    public:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n\\n        // fropm base case\\n        bool plus1, plus2, plus3;\\n        plus1 = true;\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            bool ans1 = false, ans2 = false, ans3 = false;\\n            // case 1\\n            if(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n                ans1 = plus2;\\n            }\\n            // case 2\\n            if(i+2 < nums.size() && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]) {\\n                ans2 = plus3;\\n            }\\n            // case 3\\n            if(i+2 < nums.size() && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) {\\n                ans3 = plus3;\\n            }\\n\\n            bool curr = ans1 || ans2 || ans3;\\n\\n            plus3 = plus2;\\n            plus2 = plus1;\\n            plus1 = curr;\\n        }\\n\\n        return plus1;\\n    }\\n};\\n```\\n\\n\\n# Tabulation\\n\\n# Code\\n```\\nclass Solution {\\n    // method-2 : tabulation\\n    public:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n\\n        // fropm base case\\n        dp[n] = true;\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            bool ans1 = false, ans2 = false, ans3 = false;\\n            // case 1\\n            if(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n                ans1 = dp[i+2];\\n            }\\n            // case 2\\n            if(i+2 < nums.size() && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]) {\\n                ans2 = dp[i+3];\\n            }\\n            // case 3\\n            if(i+2 < nums.size() && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) {\\n                ans3 = dp[i+3];\\n            }\\n\\n            dp[i] = ans1 || ans2 || ans3;\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n\\n\\n# Recursion + Memoization\\n\\n# Code\\n```\\nclass Solution {\\n    // method-1 : recursion + memoization\\n    bool f(int i, vector<int>& nums, vector<int>& dp) {\\n        if(i == nums.size())\\n            return true;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        bool ans1 = false, ans2 = false, ans3 = false;\\n        // case 1\\n        if(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n            ans1 = f(i+2, nums, dp);\\n        }\\n        // case 2\\n        if(i+2 < nums.size() && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]) {\\n            ans2 = f(i+3, nums, dp);\\n        }\\n        // case 3\\n        if(i+2 < nums.size() && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) {\\n            ans3 = f(i+3, nums, dp);\\n        }\\n\\n        return dp[i] = ans1 || ans2 || ans3;\\n    }\\n\\n    public:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, nums, dp);\\n    }\\n};\\n```\\n\\n    \\n\\n# Recursion\\n\\n# Code\\n```\\nclass Solution {\\n    // method-0 : recursion --> will give TLE\\n    bool f(int i, vector<int>& nums) {\\n        if(i == nums.size())\\n            return true;\\n        \\n        bool ans1 = false, ans2 = false, ans3 = false;\\n        // case 1\\n        if(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n            ans1 = f(i+2, nums);\\n        }\\n        // case 2\\n        if(i+2 < nums.size() && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]) {\\n            ans2 = f(i+3, nums);\\n        }\\n        // case 3\\n        if(i+2 < nums.size() && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) {\\n            ans3 = f(i+3, nums);\\n        }\\n\\n        return ans1 || ans2 || ans3;\\n    }\\n\\n    public:\\n    bool validPartition(vector<int>& nums) {\\n        return f(0, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // method-3 : space optimization\\n    public:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n\\n        // fropm base case\\n        bool plus1, plus2, plus3;\\n        plus1 = true;\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            bool ans1 = false, ans2 = false, ans3 = false;\\n            // case 1\\n            if(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n                ans1 = plus2;\\n            }\\n            // case 2\\n            if(i+2 < nums.size() && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]) {\\n                ans2 = plus3;\\n            }\\n            // case 3\\n            if(i+2 < nums.size() && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) {\\n                ans3 = plus3;\\n            }\\n\\n            bool curr = ans1 || ans2 || ans3;\\n\\n            plus3 = plus2;\\n            plus2 = plus1;\\n            plus1 = curr;\\n        }\\n\\n        return plus1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    // method-2 : tabulation\\n    public:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n\\n        // fropm base case\\n        dp[n] = true;\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            bool ans1 = false, ans2 = false, ans3 = false;\\n            // case 1\\n            if(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n                ans1 = dp[i+2];\\n            }\\n            // case 2\\n            if(i+2 < nums.size() && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]) {\\n                ans2 = dp[i+3];\\n            }\\n            // case 3\\n            if(i+2 < nums.size() && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) {\\n                ans3 = dp[i+3];\\n            }\\n\\n            dp[i] = ans1 || ans2 || ans3;\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    // method-1 : recursion + memoization\\n    bool f(int i, vector<int>& nums, vector<int>& dp) {\\n        if(i == nums.size())\\n            return true;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        bool ans1 = false, ans2 = false, ans3 = false;\\n        // case 1\\n        if(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n            ans1 = f(i+2, nums, dp);\\n        }\\n        // case 2\\n        if(i+2 < nums.size() && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]) {\\n            ans2 = f(i+3, nums, dp);\\n        }\\n        // case 3\\n        if(i+2 < nums.size() && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) {\\n            ans3 = f(i+3, nums, dp);\\n        }\\n\\n        return dp[i] = ans1 || ans2 || ans3;\\n    }\\n\\n    public:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    // method-0 : recursion --> will give TLE\\n    bool f(int i, vector<int>& nums) {\\n        if(i == nums.size())\\n            return true;\\n        \\n        bool ans1 = false, ans2 = false, ans3 = false;\\n        // case 1\\n        if(i+1 < nums.size() && nums[i] == nums[i+1]) {\\n            ans1 = f(i+2, nums);\\n        }\\n        // case 2\\n        if(i+2 < nums.size() && nums[i] == nums[i+1] && nums[i+1] == nums[i+2]) {\\n            ans2 = f(i+3, nums);\\n        }\\n        // case 3\\n        if(i+2 < nums.size() && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1) {\\n            ans3 = f(i+3, nums);\\n        }\\n\\n        return ans1 || ans2 || ans3;\\n    }\\n\\n    public:\\n    bool validPartition(vector<int>& nums) {\\n        return f(0, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906801,
                "title": "dp-memo-tc-o-n-c",
                "content": "# Complexity\\n```\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n```\\n\\n# Code\\n## Please Upvote if u found it useful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    bool helper(int ind, vector<int>& nums, int n){\\n        if(ind == n)\\n            return true;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        if(ind < n - 1 && nums[ind] == nums[ind + 1]){\\n            if(helper(ind + 2, nums, n))\\n                return dp[ind] = true;\\n            if(ind < n - 2 && nums[ind] == nums[ind + 2]){\\n                if(helper(ind + 3, nums, n))\\n                    return dp[ind] = true;\\n            }\\n        }\\n        if(ind < n - 2 && nums[ind + 1] - nums[ind] == 1 && nums[ind + 2] - nums[ind + 1] == 1){\\n            if(helper(ind + 3, nums, n))\\n                return dp[ind] = true;\\n        }\\n        return dp[ind] = false;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return helper(0, nums, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    bool helper(int ind, vector<int>& nums, int n){\\n        if(ind == n)\\n            return true;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        if(ind < n - 1 && nums[ind] == nums[ind + 1]){\\n            if(helper(ind + 2, nums, n))\\n                return dp[ind] = true;\\n            if(ind < n - 2 && nums[ind] == nums[ind + 2]){\\n                if(helper(ind + 3, nums, n))\\n                    return dp[ind] = true;\\n            }\\n        }\\n        if(ind < n - 2 && nums[ind + 1] - nums[ind] == 1 && nums[ind + 2] - nums[ind + 1] == 1){\\n            if(helper(ind + 3, nums, n))\\n                return dp[ind] = true;\\n        }\\n        return dp[ind] = false;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return helper(0, nums, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905763,
                "title": "easy-java-solution-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n       return isValid(nums,0,new Boolean[nums.length]);\\n    }\\n    boolean isValid(int arr[],int i,Boolean dp[]){\\n        if(i>=arr.length) return true;\\n        boolean c=false;\\n        if(dp[i]!=null) return dp[i];\\n        if(i+1<arr.length && arr[i]==arr[i+1]) {\\n            c=isValid(arr,i+2,dp);\\n        }\\n        if(c) return dp[i]= true;\\n        if(i+2<arr.length && arr[i]==arr[i+1] && arr[i+1]==arr[i+2]) {\\n            c=isValid(arr,i+3,dp);\\n        }\\n        if(c) return dp[i]= true;\\n        if(i+2<arr.length && arr[i]+1==arr[i+1] && arr[i+1]+1==arr[i+2]  ) {\\n            c=isValid(arr,i+3,dp);\\n        }\\n        return dp[i]= c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n       return isValid(nums,0,new Boolean[nums.length]);\\n    }\\n    boolean isValid(int arr[],int i,Boolean dp[]){\\n        if(i>=arr.length) return true;\\n        boolean c=false;\\n        if(dp[i]!=null) return dp[i];\\n        if(i+1<arr.length && arr[i]==arr[i+1]) {\\n            c=isValid(arr,i+2,dp);\\n        }\\n        if(c) return dp[i]= true;\\n        if(i+2<arr.length && arr[i]==arr[i+1] && arr[i+1]==arr[i+2]) {\\n            c=isValid(arr,i+3,dp);\\n        }\\n        if(c) return dp[i]= true;\\n        if(i+2<arr.length && arr[i]+1==arr[i+1] && arr[i+1]+1==arr[i+2]  ) {\\n            c=isValid(arr,i+3,dp);\\n        }\\n        return dp[i]= c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905746,
                "title": "python-solution-dp",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        def func(i) :\\n            if i<0 :\\n                return True  \\n\\n            if dp[i]!=-1:\\n                return dp[i]\\n\\n            res = False\\n            if i>=1 and nums[i] == nums[i-1]:\\n                res = res or func(i-2)\\n            if i>=2 and nums[i]==nums[i-1]==nums[i-2] :\\n                res = res or func(i-3)\\n            if i>=2 and nums[i]-nums[i-1] == 1 and nums[i-1]-nums[i-2]==1 :\\n                res = res or func(i-3)\\n\\n            dp[i] = res \\n            return res \\n            \\n        dp = [-1 for i in range(len(nums))]\\n        a = func(len(nums)-1)\\n        return a  \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        def func(i) :\\n            if i<0 :\\n                return True  \\n\\n            if dp[i]!=-1:\\n                return dp[i]\\n\\n            res = False\\n            if i>=1 and nums[i] == nums[i-1]:\\n                res = res or func(i-2)\\n            if i>=2 and nums[i]==nums[i-1]==nums[i-2] :\\n                res = res or func(i-3)\\n            if i>=2 and nums[i]-nums[i-1] == 1 and nums[i-1]-nums[i-2]==1 :\\n                res = res or func(i-3)\\n\\n            dp[i] = res \\n            return res \\n            \\n        dp = [-1 for i in range(len(nums))]\\n        a = func(len(nums)-1)\\n        return a  \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905630,
                "title": "easy-java-solution-recursion-memoization-dp",
                "content": "\\n# Approach\\nDynamic Programming with memoization\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)+recursion stack\\n\\n# Code\\n```\\nclass Solution {\\n    boolean check(int nums[], int dp[], int i,int n){\\n        if(i==n) return true;\\n        if(dp[i]!=0) return dp[i]==1;\\n        if(i<n-1 && nums[i]==nums[i+1]) {\\n            if(check(nums,dp,i+2,n)) {\\n                dp[i] = 1;\\n                return true;\\n            }\\n        } \\n        if(i<n-2 && nums[i]==nums[i+1] && nums[i]==nums[i+2]){\\n            if(check(nums,dp,i+3,n)) {\\n                dp[i] = 1;\\n                return true;\\n            }\\n        }\\n        if(i<n-2 && nums[i]+1==nums[i+1] && nums[i]+2==nums[i+2]) {\\n            if(check(nums,dp,i+3,n)) {\\n                dp[i] = 1;\\n                return true;\\n            }\\n        }\\n        dp[i] = -1;\\n        return false;\\n\\n    }\\n    public boolean validPartition(int[] nums) {\\n        int arr[] = new int[nums.length];\\n        return check(nums,arr,0,nums.length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    boolean check(int nums[], int dp[], int i,int n){\\n        if(i==n) return true;\\n        if(dp[i]!=0) return dp[i]==1;\\n        if(i<n-1 && nums[i]==nums[i+1]) {\\n            if(check(nums,dp,i+2,n)) {\\n                dp[i] = 1;\\n                return true;\\n            }\\n        } \\n        if(i<n-2 && nums[i]==nums[i+1] && nums[i]==nums[i+2]){\\n            if(check(nums,dp,i+3,n)) {\\n                dp[i] = 1;\\n                return true;\\n            }\\n        }\\n        if(i<n-2 && nums[i]+1==nums[i+1] && nums[i]+2==nums[i+2]) {\\n            if(check(nums,dp,i+3,n)) {\\n                dp[i] = 1;\\n                return true;\\n            }\\n        }\\n        dp[i] = -1;\\n        return false;\\n\\n    }\\n    public boolean validPartition(int[] nums) {\\n        int arr[] = new int[nums.length];\\n        return check(nums,arr,0,nums.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905618,
                "title": "noob-guy-s-code-don-t-click",
                "content": "Hello there, Stranger \\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F\\nThanks for stopping by \\uD83E\\uDEE1\\nHope you find what you\\'re looking for \\uD83D\\uDE0C\\nHave a great day \\uD83C\\uDF89\\uD83D\\uDE07\\nThank you \\uD83D\\uDC4D\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function(nums) {\\n    const n = nums.length;\\n    const isValidTypeA = (i) => nums[i] === nums[i + 1];\\n    const isValidTypeB = (i) => nums[i] === nums[i + 1] && nums[i] === nums[i + 2];\\n    const isValidTypeC = (i) => nums[i] + 1 === nums[i + 1] && nums[i] + 2 === nums[i + 2];\\n    let isSecondLastValid = isValidTypeA(n - 2);\\n    if (n === 2) return isSecondLastValid;\\n    let isThirdLastValid =  isValidTypeB(n - 3) || isValidTypeC(n - 3);\\n    if (n === 3) return isThirdLastValid;\\n    let memo = [isThirdLastValid, isSecondLastValid, false];\\n    for (let i = n - 4; i >= 0 ; i--) {\\n        let res = isValidTypeA(i) && memo[1];\\n        res = res || (isValidTypeB(i) || isValidTypeC(i)) && memo[2];\\n        memo = [res, memo[0], memo[1]];\\n    }\\n    return memo[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function(nums) {\\n    const n = nums.length;\\n    const isValidTypeA = (i) => nums[i] === nums[i + 1];\\n    const isValidTypeB = (i) => nums[i] === nums[i + 1] && nums[i] === nums[i + 2];\\n    const isValidTypeC = (i) => nums[i] + 1 === nums[i + 1] && nums[i] + 2 === nums[i + 2];\\n    let isSecondLastValid = isValidTypeA(n - 2);\\n    if (n === 2) return isSecondLastValid;\\n    let isThirdLastValid =  isValidTypeB(n - 3) || isValidTypeC(n - 3);\\n    if (n === 3) return isThirdLastValid;\\n    let memo = [isThirdLastValid, isSecondLastValid, false];\\n    for (let i = n - 4; i >= 0 ; i--) {\\n        let res = isValidTypeA(i) && memo[1];\\n        res = res || (isValidTypeB(i) || isValidTypeC(i)) && memo[2];\\n        memo = [res, memo[0], memo[1]];\\n    }\\n    return memo[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905487,
                "title": "easy-recursion-only-c",
                "content": "# Intuition\\nsimply what was asked i just did that in code in recursive way i wrote it \\n\\n# Approach\\ni started from the last perosn and checked whether it is possible to get ans true using last 2 elemenrs and then i tried the same using last 3 elements which ever can make ans as true will make it and at the end if no makes it true it will remain false and will return it \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool solve(vector<int> &nums,int ind){\\n      int n=nums.size();\\n      if(ind==-1){\\n          return true;\\n      }\\n      bool ans=false;\\n      if(ind-1>=0){\\n        if(nums[ind]==nums[ind-1]){\\n            ans=(ans || solve(nums,ind-2));\\n        }\\n      }\\n      if(ind-2>=0){\\n         if(nums[ind]==nums[ind-1] && nums[ind-1]==nums[ind-2]){\\n             ans=(ans  || solve(nums,ind-3));\\n         }\\n         if(nums[ind]==nums[ind-1]+1 && nums[ind-1]==nums[ind-2]+1){\\n             ans=(ans || solve(nums,ind-3));\\n         }\\n      }\\n      return ans;\\n   }\\n\\n    bool validPartition(vector<int>& nums) {\\n       int n=nums.size();\\n       return solve(nums,n-1); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool solve(vector<int> &nums,int ind){\\n      int n=nums.size();\\n      if(ind==-1){\\n          return true;\\n      }\\n      bool ans=false;\\n      if(ind-1>=0){\\n        if(nums[ind]==nums[ind-1]){\\n            ans=(ans || solve(nums,ind-2));\\n        }\\n      }\\n      if(ind-2>=0){\\n         if(nums[ind]==nums[ind-1] && nums[ind-1]==nums[ind-2]){\\n             ans=(ans  || solve(nums,ind-3));\\n         }\\n         if(nums[ind]==nums[ind-1]+1 && nums[ind-1]==nums[ind-2]+1){\\n             ans=(ans || solve(nums,ind-3));\\n         }\\n      }\\n      return ans;\\n   }\\n\\n    bool validPartition(vector<int>& nums) {\\n       int n=nums.size();\\n       return solve(nums,n-1); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905133,
                "title": "python-1-liner-multiple-solutions-functional-programming",
                "content": "# Approach 1: Top-Down DP\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        @cache\\n        def partable(i: int) -> bool:\\n            return (\\n                (i < 0) or\\n                (i > 0 and nums[i] == nums[i - 1] and partable(i - 2)) or\\n                (i > 1 and nums[i] == nums[i - 1] == nums[i - 2] and partable(i - 3)) or\\n                (i > 1 and nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and partable(i - 3))\\n            )\\n        \\n        return partable(len(nums) - 1)\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: Bottom-Up DP\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        n = len(nums)\\n        partable = [False] * (n + 1)\\n        partable[0] = True\\n\\n        for i in range(n):\\n            k = i + 1\\n            partable[k] = (\\n                (i > 0 and nums[i] == nums[i - 1] and partable[k - 2]) or\\n                (i > 1 and nums[i] == nums[i - 1] == nums[i - 2] and partable[k - 3]) or\\n                (i > 1 and nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and partable[k - 3])\\n            )\\n        \\n        return partable[-1]\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: Bottom-Up Space optimized DP\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        n = len(nums)\\n        partable = deque([True, False, nums[0] == nums[1]], 3)\\n        for i in range(2, n):\\n            partable.append(\\n                (nums[i] == nums[i - 1] and partable[-2]) or\\n                (nums[i] == nums[i - 1] == nums[i - 2] and partable[-3]) or\\n                (nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and partable[-3])\\n            )\\n        return partable[-1]\\n\\n\\n```\\n\\n---\\n\\n# Approach 4: 1-liner Bottom-Up DP\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\nFunctional and Declarative 1-liner:\\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        return reduce(\\n            lambda p, i: p.append(\\n                (nums[i] == nums[i - 1] and p[-2]) or\\n                (nums[i] == nums[i - 1] == nums[i - 2] and p[-3]) or\\n                (nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and p[-3])\\n            ) or p,\\n            range(2, len(nums)),\\n            deque([True, False, nums[0] == nums[1]], 3),\\n        )[-1]\\n\\n\\n```\\n\\nSplit into multi-liner for readability:\\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        partable = deque([True, False, nums[0] == nums[1]], 3)\\n        next_part = lambda p, i: p.append(\\n            (nums[i] == nums[i - 1] and p[-2]) or\\n            (nums[i] == nums[i - 1] == nums[i - 2] and p[-3]) or\\n            (nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and p[-3])\\n        ) or p\\n        return reduce(next_part, range(2, len(nums)), partable)[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        @cache\\n        def partable(i: int) -> bool:\\n            return (\\n                (i < 0) or\\n                (i > 0 and nums[i] == nums[i - 1] and partable(i - 2)) or\\n                (i > 1 and nums[i] == nums[i - 1] == nums[i - 2] and partable(i - 3)) or\\n                (i > 1 and nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and partable(i - 3))\\n            )\\n        \\n        return partable(len(nums) - 1)\\n\\n\\n```\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        n = len(nums)\\n        partable = [False] * (n + 1)\\n        partable[0] = True\\n\\n        for i in range(n):\\n            k = i + 1\\n            partable[k] = (\\n                (i > 0 and nums[i] == nums[i - 1] and partable[k - 2]) or\\n                (i > 1 and nums[i] == nums[i - 1] == nums[i - 2] and partable[k - 3]) or\\n                (i > 1 and nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and partable[k - 3])\\n            )\\n        \\n        return partable[-1]\\n\\n\\n```\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        n = len(nums)\\n        partable = deque([True, False, nums[0] == nums[1]], 3)\\n        for i in range(2, n):\\n            partable.append(\\n                (nums[i] == nums[i - 1] and partable[-2]) or\\n                (nums[i] == nums[i - 1] == nums[i - 2] and partable[-3]) or\\n                (nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and partable[-3])\\n            )\\n        return partable[-1]\\n\\n\\n```\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        return reduce(\\n            lambda p, i: p.append(\\n                (nums[i] == nums[i - 1] and p[-2]) or\\n                (nums[i] == nums[i - 1] == nums[i - 2] and p[-3]) or\\n                (nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and p[-3])\\n            ) or p,\\n            range(2, len(nums)),\\n            deque([True, False, nums[0] == nums[1]], 3),\\n        )[-1]\\n\\n\\n```\n```python\\nclass Solution:\\n    def validPartition(self, nums: list[int]) -> bool:\\n        partable = deque([True, False, nums[0] == nums[1]], 3)\\n        next_part = lambda p, i: p.append(\\n            (nums[i] == nums[i - 1] and p[-2]) or\\n            (nums[i] == nums[i - 1] == nums[i - 2] and p[-3]) or\\n            (nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2 and p[-3])\\n        ) or p\\n        return reduce(next_part, range(2, len(nums)), partable)[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905077,
                "title": "swift-space-optimized-dp-solution",
                "content": "# Approach\\nFor each index $i$ in `nums` determine whether `nums[i]` can be the final element of a subarray by checking if any of the conditions holds:\\n1. `nums[i-2]` can be the subarray end, and `nums[i-1]` equals `nums[i]`\\n2. `nums[i-3]` can be the subarray end, and `nums[i-2], nums[i-1], nums[i]` are equal or increasing by 1\\n\\nIf there happens to be 3 or more consecutive indexes that cannot be subarray end, the partition in that place is impossible, so  return `false`.\\n\\nOtherwise, return found value for last index in `nums`.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $\\\\Theta(1)$\\n\\n# Code\\n```\\nclass Solution {\\n    func validPartition(_ nums: [Int]) -> Bool\\n    {\\n        var canBeSubarrayEnd = [false, false, true]\\n        for (i, num) in nums.enumerated()\\n        {\\n            canBeSubarrayEnd[i % 3] = (canBeSubarrayEnd[(i+1) % 3] && nums[i-1] == num) ||\\n                ( canBeSubarrayEnd[i % 3] &&\\n                  ((nums[i-2] == nums[i-1] && nums[i-1] == num) ||\\n                  (nums[i-2] + 1 == nums[i-1] && nums[i-1] + 1 == num)) )\\n            if canBeSubarrayEnd == [false, false, false] { return false }\\n        }\\n        return canBeSubarrayEnd[(nums.count-1) % 3]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func validPartition(_ nums: [Int]) -> Bool\\n    {\\n        var canBeSubarrayEnd = [false, false, true]\\n        for (i, num) in nums.enumerated()\\n        {\\n            canBeSubarrayEnd[i % 3] = (canBeSubarrayEnd[(i+1) % 3] && nums[i-1] == num) ||\\n                ( canBeSubarrayEnd[i % 3] &&\\n                  ((nums[i-2] == nums[i-1] && nums[i-1] == num) ||\\n                  (nums[i-2] + 1 == nums[i-1] && nums[i-1] + 1 == num)) )\\n            if canBeSubarrayEnd == [false, false, false] { return false }\\n        }\\n        return canBeSubarrayEnd[(nums.count-1) % 3]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905049,
                "title": "smallest-code-but-easy-just-read-the-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nso , there are 3 cases, out oh which when we pass two , we call for further recursion, first we have init the dp, then our first case check its i is in range in all the checks to stop memory overflow\\n- now for the first check after adress check m, we check of the first two numbers are eq if yes, then we allow it to send the rest of array for check , since we checked till i+1  we move index to i+2\\n- next we check for 3 eq elements and move the index by i+3\\n- next we check for 3 consecutive increasing elements, if yes we call for solve\\n\\n\\nnext up its simple memoization \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int k;\\n    bool solve(vector<int> &nums, int i ) {\\n        if(i == nums.size()) return true;\\n        if(dp[i] != -1) return dp[i];\\n        if(i+1 < k &&  nums[i+1] == nums[i] && solve(nums,i+2)) return dp[i] =true;\\n        if(i+1 < k && nums[i] == nums[i+1] && i+2 < k &&  nums[i+1] == nums[i+2] && solve(nums,i+3) ) return dp[i] = true;\\n        if(i+1 < k && (nums[i]+1) == nums[i+1] && i+2 < k && (nums[i+1]+1) == nums[i+2] && solve(nums,i+3)) return dp[i]= true; \\n        return dp[i] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n         k = nums.size();\\n         dp.resize(nums.size()+1,-1);\\n         return solve(nums,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int k;\\n    bool solve(vector<int> &nums, int i ) {\\n        if(i == nums.size()) return true;\\n        if(dp[i] != -1) return dp[i];\\n        if(i+1 < k &&  nums[i+1] == nums[i] && solve(nums,i+2)) return dp[i] =true;\\n        if(i+1 < k && nums[i] == nums[i+1] && i+2 < k &&  nums[i+1] == nums[i+2] && solve(nums,i+3) ) return dp[i] = true;\\n        if(i+1 < k && (nums[i]+1) == nums[i+1] && i+2 < k && (nums[i+1]+1) == nums[i+2] && solve(nums,i+3)) return dp[i]= true; \\n        return dp[i] = false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n         k = nums.size();\\n         dp.resize(nums.size()+1,-1);\\n         return solve(nums,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904818,
                "title": "dynamic-programming-solution-for-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool validPartition(int* nums, int numsSize){\\n    int dp[numsSize+1];\\n    dp[0]=1;\\n    for(int j=1;j<=numsSize;j++)\\n        dp[j]=0;\\n    for(int i=1;i<=numsSize;i++)\\n    {\\n        if(i==1)dp[i]=0;\\n        if(i>1)\\n        {\\n            if(nums[i-2]==nums[i-1])\\n                dp[i]=dp[i-2]||dp[i];\\n        }\\n        if(i>2)\\n        {\\n            if((nums[i-2]==nums[i-1])&&(nums[i-3]==nums[i-2]))\\n                dp[i]=dp[i-3]||dp[i];\\n            if((nums[i-2]+1==nums[i-1])&&(nums[i-3]+1==nums[i-2]))\\n                dp[i]=dp[i-3]||dp[i];\\n        }\\n    }\\n    if(dp[numsSize]==1)return true;\\n    else return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool validPartition(int* nums, int numsSize){\\n    int dp[numsSize+1];\\n    dp[0]=1;\\n    for(int j=1;j<=numsSize;j++)\\n        dp[j]=0;\\n    for(int i=1;i<=numsSize;i++)\\n    {\\n        if(i==1)dp[i]=0;\\n        if(i>1)\\n        {\\n            if(nums[i-2]==nums[i-1])\\n                dp[i]=dp[i-2]||dp[i];\\n        }\\n        if(i>2)\\n        {\\n            if((nums[i-2]==nums[i-1])&&(nums[i-3]==nums[i-2]))\\n                dp[i]=dp[i-3]||dp[i];\\n            if((nums[i-2]+1==nums[i-1])&&(nums[i-3]+1==nums[i-2]))\\n                dp[i]=dp[i-3]||dp[i];\\n        }\\n    }\\n    if(dp[numsSize]==1)return true;\\n    else return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3904724,
                "title": "best-c-memorization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we craeate the first recursive method then we have convert it into memorization.The answer is very sime hope you will find the useful in the answer.Please upvote for more solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust read craefully what the question says.And do that accordingly to get the desired output.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n int n;\\nclass Solution {\\npublic:\\n int mem[100000];\\n bool valid(vector<int>& nums,int start,int end){\\n    if(end-start<2){\\n        return false;\\n    }\\n    if(mem[start]!=-1){\\n        return mem[start];\\n    }\\n    if(end-start==2){\\n        if(nums[start]==nums[start+1]){\\n            return mem[start]=true;\\n        }\\n        return mem[start]=false;\\n    }\\n    if(end-start==3){\\n        if(nums[start]==nums[start+1] && nums[start+1]==nums[start+2]){\\n            return mem[start]=true;\\n        }\\n        if(nums[start+1]-nums[start]==1 && nums[start+2]-nums[start+1]==1){\\n            return mem[start]=true;\\n        }\\n        return mem[start]=false;\\n    }\\n    if((nums[start]==nums[start+1] && valid(nums,start+2,end)) || (nums[start]==nums[start+1] &  nums[start+1]==nums[start+2] & valid(nums,start+3,end)) || (nums[start+1]-nums[start]==1 && nums[start+2]-nums[start+1]==1 && valid(nums,start+3,end)) ){\\n        return mem[start]=true;\\n    }\\n    return mem[start]=false;\\n}\\n    bool validPartition(vector<int>& nums) {\\n        n=nums.size();\\n       memset(mem,-1,sizeof(mem));\\n       return valid(nums,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n int n;\\nclass Solution {\\npublic:\\n int mem[100000];\\n bool valid(vector<int>& nums,int start,int end){\\n    if(end-start<2){\\n        return false;\\n    }\\n    if(mem[start]!=-1){\\n        return mem[start];\\n    }\\n    if(end-start==2){\\n        if(nums[start]==nums[start+1]){\\n            return mem[start]=true;\\n        }\\n        return mem[start]=false;\\n    }\\n    if(end-start==3){\\n        if(nums[start]==nums[start+1] && nums[start+1]==nums[start+2]){\\n            return mem[start]=true;\\n        }\\n        if(nums[start+1]-nums[start]==1 && nums[start+2]-nums[start+1]==1){\\n            return mem[start]=true;\\n        }\\n        return mem[start]=false;\\n    }\\n    if((nums[start]==nums[start+1] && valid(nums,start+2,end)) || (nums[start]==nums[start+1] &  nums[start+1]==nums[start+2] & valid(nums,start+3,end)) || (nums[start+1]-nums[start]==1 && nums[start+2]-nums[start+1]==1 && valid(nums,start+3,end)) ){\\n        return mem[start]=true;\\n    }\\n    return mem[start]=false;\\n}\\n    bool validPartition(vector<int>& nums) {\\n        n=nums.size();\\n       memset(mem,-1,sizeof(mem));\\n       return valid(nums,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904415,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPairEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1];\\n    }\\n    public boolean isTripleEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1] && nums[index] == nums[index+2];\\n    }\\n    public boolean isTripleConsecutive(int index,int []nums) {\\n        return nums[index] + 1 == nums[index+1] && nums[index+1] + 1 == nums[index+2];\\n    }\\n    public boolean recSol(int index,int []nums) {\\n        //if traversing of array is completed then return true\\n        if(index == nums.length) return true;\\n        //if we are at last element of array then we can not create partition as there are no condition for subarray of size one\\n        if(index == nums.length - 1) return false;\\n        //if we have only two elements remaining then we have to check whether that two are equal or not\\n        if(index == nums.length - 2) return isPairEqual(index,nums);\\n        //otherwise check all 3 conditions and move to new index accordingly\\n        boolean isTwo = isPairEqual(index,nums) && recSol(index+2,nums);\\n        boolean isThree = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && recSol(index+3,nums);\\n        return isTwo || isThree;\\n    }\\n    public boolean memoSol(int index,int []nums,int []dp) {\\n        if(index == nums.length) return true;\\n        if(dp[index] != -1) return dp[index] == 1 ? true : false;\\n        if(index == nums.length - 1) return false;\\n        if(index == nums.length - 2) return isPairEqual(index,nums);\\n        boolean isTwo = isPairEqual(index,nums) && memoSol(index+2,nums,dp);\\n        boolean isThree = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && memoSol(index+3,nums,dp);\\n        dp[index] = isTwo || isThree ? 1 : 0;\\n        return isTwo || isThree;\\n    }\\n    public boolean dpSol(int []nums) {\\n        int []dp = new int[nums.length+1];\\n        dp[nums.length] = 1; // if(index == nums.length) return true;\\n        dp[nums.length-1] = 0; // if(index == nums.length - 1) return false;\\n        dp[nums.length-2] = isPairEqual(nums.length-2,nums) ? 1 : 0; //if(index == nums.length - 2) return isPairEqual(index,nums);\\n        for(int index=nums.length-3;index>=0;index--) {\\n            dp[index] = isPairEqual(index,nums) && dp[index+2] == 1 ? 1 : 0; // isPairEqual(index,nums) && memoSol(index+2,nums,dp);\\n            if(dp[index] == 0) {\\n                dp[index] = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && dp[index+3] == 1 ? 1 : 0; //(isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && memoSol(index+3,nums,dp);\\n            }\\n        }\\n        return dp[0] == 1;\\n\\n    }\\n    public boolean validPartition(int[] nums) {\\n        // return recSol(0,nums);\\n        // int []dp = new int[nums.length];\\n        // Arrays.fill(dp,-1);\\n        // return memoSol(0,nums,dp);\\n        return dpSol(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPairEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1];\\n    }\\n    public boolean isTripleEqual(int index,int []nums) {\\n        return nums[index] == nums[index+1] && nums[index] == nums[index+2];\\n    }\\n    public boolean isTripleConsecutive(int index,int []nums) {\\n        return nums[index] + 1 == nums[index+1] && nums[index+1] + 1 == nums[index+2];\\n    }\\n    public boolean recSol(int index,int []nums) {\\n        //if traversing of array is completed then return true\\n        if(index == nums.length) return true;\\n        //if we are at last element of array then we can not create partition as there are no condition for subarray of size one\\n        if(index == nums.length - 1) return false;\\n        //if we have only two elements remaining then we have to check whether that two are equal or not\\n        if(index == nums.length - 2) return isPairEqual(index,nums);\\n        //otherwise check all 3 conditions and move to new index accordingly\\n        boolean isTwo = isPairEqual(index,nums) && recSol(index+2,nums);\\n        boolean isThree = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && recSol(index+3,nums);\\n        return isTwo || isThree;\\n    }\\n    public boolean memoSol(int index,int []nums,int []dp) {\\n        if(index == nums.length) return true;\\n        if(dp[index] != -1) return dp[index] == 1 ? true : false;\\n        if(index == nums.length - 1) return false;\\n        if(index == nums.length - 2) return isPairEqual(index,nums);\\n        boolean isTwo = isPairEqual(index,nums) && memoSol(index+2,nums,dp);\\n        boolean isThree = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && memoSol(index+3,nums,dp);\\n        dp[index] = isTwo || isThree ? 1 : 0;\\n        return isTwo || isThree;\\n    }\\n    public boolean dpSol(int []nums) {\\n        int []dp = new int[nums.length+1];\\n        dp[nums.length] = 1; // if(index == nums.length) return true;\\n        dp[nums.length-1] = 0; // if(index == nums.length - 1) return false;\\n        dp[nums.length-2] = isPairEqual(nums.length-2,nums) ? 1 : 0; //if(index == nums.length - 2) return isPairEqual(index,nums);\\n        for(int index=nums.length-3;index>=0;index--) {\\n            dp[index] = isPairEqual(index,nums) && dp[index+2] == 1 ? 1 : 0; // isPairEqual(index,nums) && memoSol(index+2,nums,dp);\\n            if(dp[index] == 0) {\\n                dp[index] = (isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && dp[index+3] == 1 ? 1 : 0; //(isTripleEqual(index,nums) || isTripleConsecutive(index,nums)) && memoSol(index+3,nums,dp);\\n            }\\n        }\\n        return dp[0] == 1;\\n\\n    }\\n    public boolean validPartition(int[] nums) {\\n        // return recSol(0,nums);\\n        // int []dp = new int[nums.length];\\n        // Arrays.fill(dp,-1);\\n        // return memoSol(0,nums,dp);\\n        return dpSol(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904262,
                "title": "easy-dp-memo-solution-beats-95",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        found=False\\n        from functools import cache\\n\\n        @cache\\n        def solve(i):\\n            nonlocal n,nums,found\\n            if i<0:\\n                return True\\n            if not found:\\n                res=False\\n                if i-1>=0 and nums[i]==nums[i-1]:\\n                    res=res or solve(i-2)\\n                if i-2>=0 and (nums[i-2]==nums[i-1]==nums[i] or nums[i-2]+2==nums[i-1]+1==nums[i]):\\n                    res=res or solve(i-3)\\n                found=found or res\\n                return res\\n        \\n        return solve(n-1)\\n\\n        # Recursive solution\\n        # f(i): \\n        # if f(i-1)==f(i): return f(i-2)\\n        # if f(i-2)==f(i-1)==f(i): return f(i-3)\\n        # if f(i-2)==f(i-1)+1==f(i)+2: return f(i-3)\\n        # if i<0: return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        found=False\\n        from functools import cache\\n\\n        @cache\\n        def solve(i):\\n            nonlocal n,nums,found\\n            if i<0:\\n                return True\\n            if not found:\\n                res=False\\n                if i-1>=0 and nums[i]==nums[i-1]:\\n                    res=res or solve(i-2)\\n                if i-2>=0 and (nums[i-2]==nums[i-1]==nums[i] or nums[i-2]+2==nums[i-1]+1==nums[i]):\\n                    res=res or solve(i-3)\\n                found=found or res\\n                return res\\n        \\n        return solve(n-1)\\n\\n        # Recursive solution\\n        # f(i): \\n        # if f(i-1)==f(i): return f(i-2)\\n        # if f(i-2)==f(i-1)==f(i): return f(i-3)\\n        # if f(i-2)==f(i-1)+1==f(i)+2: return f(i-3)\\n        # if i<0: return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904174,
                "title": "easy-to-understand",
                "content": "#\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool>dp(n+1,false);\\n        dp[0]=false;\\n        if(nums[1]==nums[0]){\\n           dp[1] = true;\\n        }\\n        if(n<=2){\\n           return dp[1];\\n        }\\n        if(nums[2] == nums[1] && nums[2] == nums[0]){\\n            dp[2] = true;\\n        }\\n        if((nums[2] -nums[1]==1 )&& (nums[1] - nums[0]==1 )){\\n            dp[2] = true;\\n        }\\n\\n        for(int i=3;i<n;i++){\\n           if(nums[i-1]== nums[i] && dp[i-2] == true){\\n               dp[i]=true;\\n           }\\n           if(nums[i-1]== nums[i] &&  nums[i-2]== nums[i]  && dp[i-3] == true){\\n                 dp[i]=true;\\n           }\\n           if((nums[i] - nums[i-1] == 1 ) && (nums[i-1] - nums[i-2] == 1 ) && dp[i-3]==true){\\n               dp[i]=true;\\n           }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n    // 0.   1.   2.   3.   4\\n//  4.   4.   4.   5.   6\\n//  F    T.   T.   F.   T\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool>dp(n+1,false);\\n        dp[0]=false;\\n        if(nums[1]==nums[0]){\\n           dp[1] = true;\\n        }\\n        if(n<=2){\\n           return dp[1];\\n        }\\n        if(nums[2] == nums[1] && nums[2] == nums[0]){\\n            dp[2] = true;\\n        }\\n        if((nums[2] -nums[1]==1 )&& (nums[1] - nums[0]==1 )){\\n            dp[2] = true;\\n        }\\n\\n        for(int i=3;i<n;i++){\\n           if(nums[i-1]== nums[i] && dp[i-2] == true){\\n               dp[i]=true;\\n           }\\n           if(nums[i-1]== nums[i] &&  nums[i-2]== nums[i]  && dp[i-3] == true){\\n                 dp[i]=true;\\n           }\\n           if((nums[i] - nums[i-1] == 1 ) && (nums[i-1] - nums[i-2] == 1 ) && dp[i-3]==true){\\n               dp[i]=true;\\n           }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n    // 0.   1.   2.   3.   4\\n//  4.   4.   4.   5.   6\\n//  F    T.   T.   F.   T\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904098,
                "title": "simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& a,int s, int n, vector<int> &dp)\\n    {\\n        if(s >= n)\\n            return true;\\n        \\n        if(dp[s]!=-1)\\n            return dp[s];\\n        \\n        if(s+1<n && a[s] == a[s+1])\\n        {\\n            bool v1 = solve(a,s+2,n,dp);\\n            bool v2 = false;\\n            if(s+2<n && a[s] == a[s+2])\\n            {\\n                v2 = solve(a,s+3,n,dp);\\n            }\\n            \\n            return dp[s] = (v1 || v2);\\n        }\\n        \\n        if(s+1<n && s+2<n && a[s]+1==a[s+1] && a[s]+2 == a[s+2])\\n        {\\n            \\n            return dp[s] = solve(a,s+3,n,dp);\\n            \\n        }\\n        \\n        return dp[s] = false;\\n    }\\n    \\n    \\n    bool validPartition(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        \\n        vector<int> dp(n+1 ,-1);\\n        \\n        return solve(a,0,n,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& a,int s, int n, vector<int> &dp)\\n    {\\n        if(s >= n)\\n            return true;\\n        \\n        if(dp[s]!=-1)\\n            return dp[s];\\n        \\n        if(s+1<n && a[s] == a[s+1])\\n        {\\n            bool v1 = solve(a,s+2,n,dp);\\n            bool v2 = false;\\n            if(s+2<n && a[s] == a[s+2])\\n            {\\n                v2 = solve(a,s+3,n,dp);\\n            }\\n            \\n            return dp[s] = (v1 || v2);\\n        }\\n        \\n        if(s+1<n && s+2<n && a[s]+1==a[s+1] && a[s]+2 == a[s+2])\\n        {\\n            \\n            return dp[s] = solve(a,s+3,n,dp);\\n            \\n        }\\n        \\n        return dp[s] = false;\\n    }\\n    \\n    \\n    bool validPartition(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        \\n        vector<int> dp(n+1 ,-1);\\n        \\n        return solve(a,0,n,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903943,
                "title": "simple-rust-solution",
                "content": "# Code\\n\\n```rust\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n        let mut ok = vec![false; nums.len() + 1];\\n        ok[0] = true;\\n\\n        for i in 0..n {\\n            if i + 1 < n && nums[i] == nums[i + 1] {\\n                ok[i + 1 + 1] |= ok[i];\\n            }\\n            if i + 2 < n && nums[i] == nums[i + 1] && nums[i] == nums[i + 2] {\\n                ok[i + 2 + 1] |= ok[i];\\n            }\\n            if i + 2 < n && nums[i] == nums[i + 1] - 1 && nums[i] == nums[i + 2] - 2 {\\n                ok[i + 2 + 1] |= ok[i];\\n            }\\n        }\\n\\n        ok[n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Design"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n        let mut ok = vec![false; nums.len() + 1];\\n        ok[0] = true;\\n\\n        for i in 0..n {\\n            if i + 1 < n && nums[i] == nums[i + 1] {\\n                ok[i + 1 + 1] |= ok[i];\\n            }\\n            if i + 2 < n && nums[i] == nums[i + 1] && nums[i] == nums[i + 2] {\\n                ok[i + 2 + 1] |= ok[i];\\n            }\\n            if i + 2 < n && nums[i] == nums[i + 1] - 1 && nums[i] == nums[i + 2] - 2 {\\n                ok[i + 2 + 1] |= ok[i];\\n            }\\n        }\\n\\n        ok[n]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903846,
                "title": "c-recursive-iterative-clean-code",
                "content": "**Recusrive** \\n\\nRuntime: 393 ms\\n```c++\\nbool validPartition(vector<int>& nums) {\\n    auto len = nums.size();\\n    unordered_map<int, bool> dp;\\n    \\n    auto two = [&](int i) {\\n        return i + 1 < len && nums[i] == nums[i+1];\\n    };\\n    \\n    auto three = [&](int i) {\\n        if (i + 2 >= len) return false;\\n        auto eq = two(i) && nums[i+1] == nums[i+2];\\n        auto incr = (nums[i] + 1) == nums[i+1] && (nums[i+1] + 1) == nums[i+2];\\n        return eq || incr;\\n    };\\n    \\n    function<bool(int)> go = [&](auto i) {\\n        if (i == len) return true;\\n        if (dp.count(i)) return dp[i];\\n        \\n        bool can = false;\\n        if (two(i)) can |= go(i + 2);\\n        if (three(i)) can |= go(i + 3);\\n        return dp[i] = can;\\n    };\\n    \\n    return go(0);\\n}\\n```\\n\\n\\n\\n**Iterative** \\n\\nRuntime: 192 ms\\t\\n```c++\\nbool validPartition(vector<int>& nums) {\\n    int len = nums.size();\\n    auto two = [&](int i) {\\n        return i + 1 < len && nums[i] == nums[i+1];\\n    };\\n    auto three = [&](int i) {\\n        if (i + 2 >= len) return false;\\n        auto eq = two(i) && nums[i+1] == nums[i+2];\\n        auto incr = (nums[i] + 1) == nums[i+1] && (nums[i+1] + 1) == nums[i+2];\\n        return eq || incr;\\n    };\\n    \\n    vector<int> dp(len + 1); dp[0] = 1;\\n    for (auto i = 0; i < len; ++i) {\\n        if (!dp[i]) continue;\\n        if (two(i)) dp[i + 2] = 1;\\n        if (three(i)) dp[i + 3] = 1;\\n    }\\n    return dp[len];\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nbool validPartition(vector<int>& nums) {\\n    auto len = nums.size();\\n    unordered_map<int, bool> dp;\\n    \\n    auto two = [&](int i) {\\n        return i + 1 < len && nums[i] == nums[i+1];\\n    };\\n    \\n    auto three = [&](int i) {\\n        if (i + 2 >= len) return false;\\n        auto eq = two(i) && nums[i+1] == nums[i+2];\\n        auto incr = (nums[i] + 1) == nums[i+1] && (nums[i+1] + 1) == nums[i+2];\\n        return eq || incr;\\n    };\\n    \\n    function<bool(int)> go = [&](auto i) {\\n        if (i == len) return true;\\n        if (dp.count(i)) return dp[i];\\n        \\n        bool can = false;\\n        if (two(i)) can |= go(i + 2);\\n        if (three(i)) can |= go(i + 3);\\n        return dp[i] = can;\\n    };\\n    \\n    return go(0);\\n}\\n```\n```c++\\nbool validPartition(vector<int>& nums) {\\n    int len = nums.size();\\n    auto two = [&](int i) {\\n        return i + 1 < len && nums[i] == nums[i+1];\\n    };\\n    auto three = [&](int i) {\\n        if (i + 2 >= len) return false;\\n        auto eq = two(i) && nums[i+1] == nums[i+2];\\n        auto incr = (nums[i] + 1) == nums[i+1] && (nums[i+1] + 1) == nums[i+2];\\n        return eq || incr;\\n    };\\n    \\n    vector<int> dp(len + 1); dp[0] = 1;\\n    for (auto i = 0; i < len; ++i) {\\n        if (!dp[i]) continue;\\n        if (two(i)) dp[i + 2] = 1;\\n        if (three(i)) dp[i + 3] = 1;\\n    }\\n    return dp[len];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903831,
                "title": "memoization",
                "content": "arr\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool f(int index, int n, vector<int>&nums,vector<int>&dp){\\n        if(index==n) return true;\\n        // if(index==n-1) return false;\\n        \\n        int first=false;\\n        int second = false;\\n        int third =false;\\n        if(dp[index]!=-1) return dp[index];\\n        if(index+1<n && nums[index]==nums[index+1]){\\n            first =f(index+2,n,nums,dp) ;\\n            \\n        }\\n         if(index+2<n && nums[index]==nums[index+1] && nums[index+1]==nums[index+2]){\\n             second=f(index+3,n,nums,dp) ;\\n        }\\n         if(index+2<n && nums[index]==nums[index+1]-1 && nums[index]==nums[index+2]-2){\\n             third=f(index+3,n,nums,dp) ;\\n        }\\n       return dp[index]= first |third|second;\\n\\n\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<int>dp(n,-1);\\n        return f(0,n,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    bool f(int index, int n, vector<int>&nums,vector<int>&dp){\\n        if(index==n) return true;\\n        // if(index==n-1) return false;\\n        \\n        int first=false;\\n        int second = false;\\n        int third =false;\\n        if(dp[index]!=-1) return dp[index];\\n        if(index+1<n && nums[index]==nums[index+1]){\\n            first =f(index+2,n,nums,dp) ;\\n            \\n        }\\n         if(index+2<n && nums[index]==nums[index+1] && nums[index+1]==nums[index+2]){\\n             second=f(index+3,n,nums,dp) ;\\n        }\\n         if(index+2<n && nums[index]==nums[index+1]-1 && nums[index]==nums[index+2]-2){\\n             third=f(index+3,n,nums,dp) ;\\n        }\\n       return dp[index]= first |third|second;\\n\\n\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n =nums.size();\\n        vector<int>dp(n,-1);\\n        return f(0,n,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903640,
                "title": "very-easy-solution-with-dp",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func validPartition(_ nums: [Int]) -> Bool {\\n        \\n        var dp =  [Bool](repeating: false, count: nums.count)\\n\\n        dp[1] = nums[0] == nums[1]\\n\\n        if nums.count >= 3 {\\n            dp[2] = (nums[1] == nums[2] && dp[1]) || (nums[2] == nums[1]+1 && nums[1] == nums[0]+1)\\n\\n            if nums.count > 3 {\\n                for i in 3...nums.count-1 {\\n                    if nums[i] == nums[i-1] && dp[i-2] {\\n                        dp[i] = true\\n                        continue\\n                    } else if  nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[i-3] {\\n                        dp[i] = true\\n                        continue\\n                    } else if( nums[i-1] == nums[i-2]+1 && nums[i] == nums[i-1]+1) && dp[i-3] {\\n                        dp[i] = true\\n                        continue\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[nums.count-1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func validPartition(_ nums: [Int]) -> Bool {\\n        \\n        var dp =  [Bool](repeating: false, count: nums.count)\\n\\n        dp[1] = nums[0] == nums[1]\\n\\n        if nums.count >= 3 {\\n            dp[2] = (nums[1] == nums[2] && dp[1]) || (nums[2] == nums[1]+1 && nums[1] == nums[0]+1)\\n\\n            if nums.count > 3 {\\n                for i in 3...nums.count-1 {\\n                    if nums[i] == nums[i-1] && dp[i-2] {\\n                        dp[i] = true\\n                        continue\\n                    } else if  nums[i] == nums[i-1] && nums[i] == nums[i-2] && dp[i-3] {\\n                        dp[i] = true\\n                        continue\\n                    } else if( nums[i-1] == nums[i-2]+1 && nums[i] == nums[i-1]+1) && dp[i-3] {\\n                        dp[i] = true\\n                        continue\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[nums.count-1]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903634,
                "title": "recursion-memoization-check-3-conditions",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConditions to check : \\n1. Subarray of size 2 with all equal elements.\\n2. Subarray of size 3 with all equal elements.\\n2. Subaarray of size 3 having difference of 1 between `nums[i]-nums[i-1]`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int start,int end,int diff,vector<int>& nums)\\n    {\\n        if(end>nums.size())return false;\\n        for(int i=start+1;i<end;i++){\\n            if(nums[i]-nums[i-1]!=diff)return false;\\n        }\\n        return true;\\n    }\\n    bool solve(int i,vector<int>& nums,vector<int>& dp)\\n    {\\n        if(i==nums.size())return true;\\n        if(dp[i]!=-1)return dp[i];\\n        if(check(i,i+2,0,nums))if(solve(i+2,nums,dp))return dp[i] = true;\\n        if(check(i,i+3,0,nums))if(solve(i+3,nums,dp))return dp[i] = true;\\n        if(check(i,i+3,1,nums))if(solve(i+3,nums,dp))return dp[i] = true;\\n        return dp[i] = false; \\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return solve(0,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int start,int end,int diff,vector<int>& nums)\\n    {\\n        if(end>nums.size())return false;\\n        for(int i=start+1;i<end;i++){\\n            if(nums[i]-nums[i-1]!=diff)return false;\\n        }\\n        return true;\\n    }\\n    bool solve(int i,vector<int>& nums,vector<int>& dp)\\n    {\\n        if(i==nums.size())return true;\\n        if(dp[i]!=-1)return dp[i];\\n        if(check(i,i+2,0,nums))if(solve(i+2,nums,dp))return dp[i] = true;\\n        if(check(i,i+3,0,nums))if(solve(i+3,nums,dp))return dp[i] = true;\\n        if(check(i,i+3,1,nums))if(solve(i+3,nums,dp))return dp[i] = true;\\n        return dp[i] = false; \\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return solve(0,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903595,
                "title": "c-simple-tabulation-approach-small-simple-code-o-n",
                "content": "# Intuition\\nWe can split if and only if the previous substring satisfies the given conditions.\\nSo, we make a split at every possible index which satisfies the given conditions and return true if we can make a split after last index.\\n\\n# Approach\\nwe have 3 conditions \\n1. if there was a split after i-2 (i.e., dp[i-1]==1) and nums[i-1] == nums[i] then u can make a split after i.\\n2. if there was a split after i-3 (i.e., dp[i-2]==1) and nums[i-2] == nums[i-1] == nums[i] are equal then u can make a split after i.\\n3. if there was a split after i-3 (i.e., dp[i-2]==1) and nums[i-2],nums[i-1] and nums[i] are consecutive then u can make a split after i.\\n\\nFinally if u can make a split at the end (i.e., at nums.size()) then return \"true\" \\notherwise return \"false\"\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;\\n        if(n==1)return 0;\\n        for(int i=1;i<n;i++){\\n            if((nums[i-1]==nums[i] && dp[i-1]) || (i>1 && nums[i-2]==nums[i] && nums[i-1]==nums[i] && dp[i-2]))\\n            dp[i+1]=1;\\n            else if(i>1 && nums[i]==nums[i-1]+1 && nums[i-1]==nums[i-2]+1 && dp[i-2])dp[i+1]=1;}\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;\\n        if(n==1)return 0;\\n        for(int i=1;i<n;i++){\\n            if((nums[i-1]==nums[i] && dp[i-1]) || (i>1 && nums[i-2]==nums[i] && nums[i-1]==nums[i] && dp[i-2]))\\n            dp[i+1]=1;\\n            else if(i>1 && nums[i]==nums[i-1]+1 && nums[i-1]==nums[i-2]+1 && dp[i-2])dp[i+1]=1;}\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903575,
                "title": "faster-than-100-constant-space-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a partition to be true in this question a array index ending with n should follow the rules and array ending with index n-2 or n-3 should be true, then only the original will have valid partition .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare three variables which will store bool if the index with distance (1 or 2 or 3) from the array ending has valid partition of not.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int dis3=1; \\n        int dis2=0;\\n        int dis1=0;\\n        if(nums[1] == nums[0]) dis1=1;\\n        for(int i=2;i<n;i++){\\n            // this index has 0 distance from itself\\n            int dis0=0;\\n\\n            // here we check if the array\\'s last two element from this index are equal\\n            // or not and we check the index with distance two from this array has \\n            // possible partition or not.\\n            if(nums[i] == nums[i-1] && dis2==1) \\n                dis0 = 1;\\n\\n            //here we check if the array\\'s last three element from this index are\\n            //equal or not and we check the index with distance three from this array\\n            //has possible partition or not.\\n            if(i>1 && nums[i-1] == nums[i-2] && nums[i] == nums[i-1] && dis3==1)\\n                dis0 = 1;\\n\\n            //here we check if the array\\'s last three element from this index are\\n            //continuous like 3 4 5 or not and we check the index with distance three\\n            //from this array has possible partition or not.\\n            if(i>1 && nums[i-1]-nums[i-2]==1 && nums[i]-nums[i-1]==1 && dis3==1)\\n                dis0 = 1;\\n\\n            // here we are moving forward in the array\\n            dis3 = dis2;\\n            dis2 = dis1;\\n            dis1 = dis0;\\n        }\\n\\n        return dis1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int dis3=1; \\n        int dis2=0;\\n        int dis1=0;\\n        if(nums[1] == nums[0]) dis1=1;\\n        for(int i=2;i<n;i++){\\n            // this index has 0 distance from itself\\n            int dis0=0;\\n\\n            // here we check if the array\\'s last two element from this index are equal\\n            // or not and we check the index with distance two from this array has \\n            // possible partition or not.\\n            if(nums[i] == nums[i-1] && dis2==1) \\n                dis0 = 1;\\n\\n            //here we check if the array\\'s last three element from this index are\\n            //equal or not and we check the index with distance three from this array\\n            //has possible partition or not.\\n            if(i>1 && nums[i-1] == nums[i-2] && nums[i] == nums[i-1] && dis3==1)\\n                dis0 = 1;\\n\\n            //here we check if the array\\'s last three element from this index are\\n            //continuous like 3 4 5 or not and we check the index with distance three\\n            //from this array has possible partition or not.\\n            if(i>1 && nums[i-1]-nums[i-2]==1 && nums[i]-nums[i-1]==1 && dis3==1)\\n                dis0 = 1;\\n\\n            // here we are moving forward in the array\\n            dis3 = dis2;\\n            dis2 = dis1;\\n            dis1 = dis0;\\n        }\\n\\n        return dis1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903345,
                "title": "c-super-easy-clean-code-1d-dp-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint n;\\nclass Solution {\\nprivate:\\n    bool isValid(int i, vector<int>& nums, int dp[]){\\n        if(i >= n) return true;\\n        if(dp[i] != -1) return dp[i];\\n\\n        if(i+1 < n && nums[i] == nums[i+1]){\\n            if(isValid(i+2,nums,dp)) return dp[i] = true;\\n\\n            if(i+2 < n && nums[i+1] == nums[i+2] && isValid(i+3,nums,dp)) return dp[i] = true;\\n        }\\n\\n        if(i+2<n&&nums[i+1]-nums[i]==1&&nums[i+2]-nums[i+1] == 1 && isValid(i+3,nums,dp)) return dp[i] = true;\\n\\n        return dp[i] = false; \\n\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        \\n        n = nums.size();\\n\\n        int dp[100001];\\n        memset(dp,-1,sizeof(dp));      \\n\\n        return isValid(0,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nint n;\\nclass Solution {\\nprivate:\\n    bool isValid(int i, vector<int>& nums, int dp[]){\\n        if(i >= n) return true;\\n        if(dp[i] != -1) return dp[i];\\n\\n        if(i+1 < n && nums[i] == nums[i+1]){\\n            if(isValid(i+2,nums,dp)) return dp[i] = true;\\n\\n            if(i+2 < n && nums[i+1] == nums[i+2] && isValid(i+3,nums,dp)) return dp[i] = true;\\n        }\\n\\n        if(i+2<n&&nums[i+1]-nums[i]==1&&nums[i+2]-nums[i+1] == 1 && isValid(i+3,nums,dp)) return dp[i] = true;\\n\\n        return dp[i] = false; \\n\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        \\n        n = nums.size();\\n\\n        int dp[100001];\\n        memset(dp,-1,sizeof(dp));      \\n\\n        return isValid(0,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903215,
                "title": "c-partition-dp",
                "content": "class Solution {\\nprivate:\\n\\n\\n    int find(int i, vector<int>& a, vector<int>& dp)\\n    {\\n        int n= a.size();\\n        if(i==n) return true;\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        // 2 equal elements...\\n        \\n        if(i+1<n && a[i]==a[i+1])\\n        {\\n            if(find(i+2,a,dp)) return dp[i]=true;\\n        }\\n        \\n        // 3 equal elements ...\\n        \\n        if(i+2<n && a[i]==a[i+1] && a[i]==a[i+2])\\n        {\\n            if(find(i+3,a,dp)) return dp[i]=true;\\n        }\\n        \\n        // 3 consecutive elements ...\\n        \\n        if(i+2<n && a[i]+1 == a[i+1] && a[i]+2 == a[i+2])\\n        {\\n            if( find(i+3,a,dp) ) return dp[i]=true;\\n        }\\n        \\n        \\n        return dp[i]=false;\\n    }\\n\\t\\n\\t\\npublic:\\n\\n\\n    bool validPartition(vector<int>& a) {\\n        \\n        int n= a.size();\\n        vector<int> dp(n+1,-1);\\n        \\n        return find(0,a,dp);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\nprivate:\\n\\n\\n    int find(int i, vector<int>& a, vector<int>& dp)\\n    {\\n        int n= a.size();\\n        if(i==n) return true;\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        // 2 equal elements...\\n        \\n        if(i+1<n && a[i]==a[i+1])\\n        {\\n            if(find(i+2,a,dp)) return dp[i]=true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3903162,
                "title": "golang-dp-topdown-and-bottomup-approach",
                "content": "# Code\\n```\\n// DP TopDown Approach \\n\\nfunc validPartition(nums []int) bool {\\n    cache := make(map[int]bool)\\n    return isValid(0, nums, cache)\\n}\\n\\nfunc isValid(idx int, nums []int, cache map[int]bool) bool {\\n    if idx == len(nums) {\\n        return true\\n    }\\n\\n    if value, ok := cache[idx]; ok {\\n        return value\\n    }\\n\\n    isValidSeq := false\\n    if idx+1 < len(nums) && nums[idx] == nums[idx+1] {\\n        isValidSeq = isValid(idx+2, nums, cache)\\n    }\\n    if !isValidSeq && idx+2 < len(nums) && nums[idx] == nums[idx+1] && nums[idx] == nums[idx+2] {\\n        isValidSeq = isValid(idx+3, nums, cache)\\n    }\\n    if !isValidSeq && idx+2 < len(nums) && nums[idx]+1 == nums[idx+1] && nums[idx+1]+1  == nums[idx+2] {\\n        isValidSeq = isValid(idx+3, nums, cache)\\n    }\\n\\n    cache[idx] = isValidSeq\\n    return isValidSeq  \\n}\\n\\n// DP BottomUp Approach \\n\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n    dp := make([]bool, n+1)\\n    \\n    dp[n] = true\\n    for i := n-2; i >= 0; i-- {\\n        if dp[i+2] && nums[i] == nums[i+1] {\\n            dp[i] = true\\n        }\\n        if i < n-2 && dp[i+3] {\\n            if nums[i] == nums[i+1] && nums[i+1] == nums[i+2] {\\n                dp[i] = true\\n            } else if nums[i]+1 == nums[i+1] && nums[i+1]+1 == nums[i+2] {\\n                dp[i] = true\\n            }\\n        }\\n    }\\n\\n    return dp[0]\\n}\\n\\n// DP BottomUp Approach, space optimized\\n\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n    dp := make([]bool, 3)\\n    \\n    dp[0] = true\\n    for i := 0; i < n; i++ {\\n        res := false\\n        if i > 0 && dp[(i-1) % 3] && nums[i] == nums[i-1] {\\n            res = true\\n        }\\n        if i > 1 && dp[(i-2) % 3] {\\n            if nums[i] == nums[i-1] && nums[i-1] == nums[i-2] {\\n                res = true\\n            } else if nums[i]-1 == nums[i-1] && nums[i-1]-1 == nums[i-2] {\\n                res = true\\n            }\\n        }\\n        dp[(i+1) % 3] = res\\n    }\\n\\n    return dp[n % 3]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// DP TopDown Approach \\n\\nfunc validPartition(nums []int) bool {\\n    cache := make(map[int]bool)\\n    return isValid(0, nums, cache)\\n}\\n\\nfunc isValid(idx int, nums []int, cache map[int]bool) bool {\\n    if idx == len(nums) {\\n        return true\\n    }\\n\\n    if value, ok := cache[idx]; ok {\\n        return value\\n    }\\n\\n    isValidSeq := false\\n    if idx+1 < len(nums) && nums[idx] == nums[idx+1] {\\n        isValidSeq = isValid(idx+2, nums, cache)\\n    }\\n    if !isValidSeq && idx+2 < len(nums) && nums[idx] == nums[idx+1] && nums[idx] == nums[idx+2] {\\n        isValidSeq = isValid(idx+3, nums, cache)\\n    }\\n    if !isValidSeq && idx+2 < len(nums) && nums[idx]+1 == nums[idx+1] && nums[idx+1]+1  == nums[idx+2] {\\n        isValidSeq = isValid(idx+3, nums, cache)\\n    }\\n\\n    cache[idx] = isValidSeq\\n    return isValidSeq  \\n}\\n\\n// DP BottomUp Approach \\n\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n    dp := make([]bool, n+1)\\n    \\n    dp[n] = true\\n    for i := n-2; i >= 0; i-- {\\n        if dp[i+2] && nums[i] == nums[i+1] {\\n            dp[i] = true\\n        }\\n        if i < n-2 && dp[i+3] {\\n            if nums[i] == nums[i+1] && nums[i+1] == nums[i+2] {\\n                dp[i] = true\\n            } else if nums[i]+1 == nums[i+1] && nums[i+1]+1 == nums[i+2] {\\n                dp[i] = true\\n            }\\n        }\\n    }\\n\\n    return dp[0]\\n}\\n\\n// DP BottomUp Approach, space optimized\\n\\nfunc validPartition(nums []int) bool {\\n    n := len(nums)\\n    dp := make([]bool, 3)\\n    \\n    dp[0] = true\\n    for i := 0; i < n; i++ {\\n        res := false\\n        if i > 0 && dp[(i-1) % 3] && nums[i] == nums[i-1] {\\n            res = true\\n        }\\n        if i > 1 && dp[(i-2) % 3] {\\n            if nums[i] == nums[i-1] && nums[i-1] == nums[i-2] {\\n                res = true\\n            } else if nums[i]-1 == nums[i-1] && nums[i-1]-1 == nums[i-2] {\\n                res = true\\n            }\\n        }\\n        dp[(i+1) % 3] = res\\n    }\\n\\n    return dp[n % 3]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903023,
                "title": "c-solution-recursive-memoized-solution-faster-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&nums,int i,vector<int>&dp){\\n        int n = nums.size();\\n        if(i == n) return true;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        bool res = false;\\n        if(i+1 < n && nums[i] == nums[i+1]){\\n            res = res || helper(nums,i+2,dp);\\n            if(i+2 < n && nums[i] == nums[i+2]){\\n                res = res || helper(nums,i+3,dp);\\n            }\\n        }\\n\\n        if(i+2 < n && nums[i+1] == nums[i] + 1 && nums[i+2] == nums[i+1] + 1){\\n            res = res || helper(nums,i+3,dp);\\n        }\\n\\n        return dp[i] = res;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        int ans = 0;\\n        return helper(nums,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&nums,int i,vector<int>&dp){\\n        int n = nums.size();\\n        if(i == n) return true;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        bool res = false;\\n        if(i+1 < n && nums[i] == nums[i+1]){\\n            res = res || helper(nums,i+2,dp);\\n            if(i+2 < n && nums[i] == nums[i+2]){\\n                res = res || helper(nums,i+3,dp);\\n            }\\n        }\\n\\n        if(i+2 < n && nums[i+1] == nums[i] + 1 && nums[i+2] == nums[i+1] + 1){\\n            res = res || helper(nums,i+3,dp);\\n        }\\n\\n        return dp[i] = res;\\n    }\\n\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        int ans = 0;\\n        return helper(nums,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902971,
                "title": "recursion-memoization-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nThere are two Conditions:-\\n1st :- if(Arr[i]==Arr[i+1]) move to i+2 index\\n2nd:-  if(Arr[i]==Arr[i+1]==Arr[i+2] || Arr[i]+1==Arr[i+1]==Arr[i+2]-1) move to i+3 index\\nif any of them reach at the final index then Result will be True otherwise False.\\n```\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i, vector<int>&arr, int n,vector<int> &dp){\\n        if(i>=arr.size()) return true;\\n        if(dp[i]!=-1) return dp[i];\\n        bool ans = false;\\n        if(i+1<n && arr[i] == arr[i+1]){\\n            ans |= solve(i+2,arr,n,dp);\\n        }\\n        if(i+2<n && ((arr[i] == arr[i+1] && arr[i+1] == arr[i+2]) || (arr[i]+1 == arr[i+1] && arr[i+1]+1 == arr[i+2])) ){\\n            ans |= solve(i+3,arr,n,dp);\\n        }\\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& arr) { \\n        int n = arr.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(0,arr,n,dp);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ca452bc8-9bd9-4c44-99fe-d892b4678904_1691913496.0595458.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nThere are two Conditions:-\\n1st :- if(Arr[i]==Arr[i+1]) move to i+2 index\\n2nd:-  if(Arr[i]==Arr[i+1]==Arr[i+2] || Arr[i]+1==Arr[i+1]==Arr[i+2]-1) move to i+3 index\\nif any of them reach at the final index then Result will be True otherwise False.\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(int i, vector<int>&arr, int n,vector<int> &dp){\\n        if(i>=arr.size()) return true;\\n        if(dp[i]!=-1) return dp[i];\\n        bool ans = false;\\n        if(i+1<n && arr[i] == arr[i+1]){\\n            ans |= solve(i+2,arr,n,dp);\\n        }\\n        if(i+2<n && ((arr[i] == arr[i+1] && arr[i+1] == arr[i+2]) || (arr[i]+1 == arr[i+1] && arr[i+1]+1 == arr[i+2])) ){\\n            ans |= solve(i+3,arr,n,dp);\\n        }\\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& arr) { \\n        int n = arr.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(0,arr,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902899,
                "title": "very-easy-approach-i-bet-you-will-understand-with-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;\\n\\n        for(int i=0;i<n;i++){\\n            int idx=i+1;\\n            if(i>0 && nums[i]==nums[i-1])  //FOR FIRST CONDITION \\n            dp[idx]|=dp[idx-2];\\n            \\n            if(i>1 && nums[i]==nums[i-1] && nums[i]==nums[i-2])   //FOR SECOND CONDITION\\n            dp[idx]|=dp[idx-3];\\n\\n            if(i>1 && nums[i]==nums[i-1]+1 && nums[i]==nums[i-2]+2) //FOR THIRD CONDITION\\n            dp[idx]|=dp[idx-3];\\n        }\\n        return dp[n];\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION IS HELPFUL FOR YOU*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;\\n\\n        for(int i=0;i<n;i++){\\n            int idx=i+1;\\n            if(i>0 && nums[i]==nums[i-1])  //FOR FIRST CONDITION \\n            dp[idx]|=dp[idx-2];\\n            \\n            if(i>1 && nums[i]==nums[i-1] && nums[i]==nums[i-2])   //FOR SECOND CONDITION\\n            dp[idx]|=dp[idx-3];\\n\\n            if(i>1 && nums[i]==nums[i-1]+1 && nums[i]==nums[i-2]+2) //FOR THIRD CONDITION\\n            dp[idx]|=dp[idx-3];\\n        }\\n        return dp[n];\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION IS HELPFUL FOR YOU*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902860,
                "title": "dynamic-programming-solution-easy-to-understand-c",
                "content": "Simply Check all the three conditions that has been asked in the question.\\n\\n```\\nclass Solution {\\n    bool solve(vector<int> &nums, int i, vector<int> &dp){\\n        int n = nums.size();\\n        if(i == n) return true;\\n        \\n        if(dp[i] != -1) return dp[i];\\n        \\n        // check for first condition\\n        if(i + 1 < n && nums[i] == nums[i + 1]){\\n            if(solve(nums, i + 2, dp)) return dp[i] = true;\\n        }\\n        \\n        // check for second condition\\n        if(i + 2 < n && nums[i] == nums[i + 1] && nums[i] == nums[i + 2]){\\n            if(solve(nums, i + 3, dp)) return dp[i] = true;\\n        }\\n        \\n        // check for third condition\\n        if(i + 2 < n && nums[i] == nums[i + 1] - 1 && nums[i] == nums[i + 2] - 2){\\n            if(solve(nums, i + 3, dp)) return dp[i] = true;\\n        }\\n        \\n        return dp[i] = false;\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size() + 1, -1);\\n        return solve(nums, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(vector<int> &nums, int i, vector<int> &dp){\\n        int n = nums.size();\\n        if(i == n) return true;\\n        \\n        if(dp[i] != -1) return dp[i];\\n        \\n        // check for first condition\\n        if(i + 1 < n && nums[i] == nums[i + 1]){\\n            if(solve(nums, i + 2, dp)) return dp[i] = true;\\n        }\\n        \\n        // check for second condition\\n        if(i + 2 < n && nums[i] == nums[i + 1] && nums[i] == nums[i + 2]){\\n            if(solve(nums, i + 3, dp)) return dp[i] = true;\\n        }\\n        \\n        // check for third condition\\n        if(i + 2 < n && nums[i] == nums[i + 1] - 1 && nums[i] == nums[i + 2] - 2){\\n            if(solve(nums, i + 3, dp)) return dp[i] = true;\\n        }\\n        \\n        return dp[i] = false;\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size() + 1, -1);\\n        return solve(nums, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902830,
                "title": "c-solution-without-memoization-unsure-about-efficiency",
                "content": "# Approach\\nI originally included a memo to keep track of results for solved subarrays, but I found it was never returning the cached entries because I was checking for the \"three identical elements\" or \"three consecutive increasing elements\" at the same time in one method. Therefore, I was only calling the recursive function for the remainder of elements on the left once vs. how the solution in the editorial does it. Leetcode says runtime beats 100%, but I\\'m unsure if that\\'s just an inconsistency on their end or not enough C# solutions. \\n\\nPlease let me know why this would be incorrect/inefficient for certain scenarios vs. the top-down memoization solution in the editorial, because I can\\'t figure it out, and I\\'m still a newbie to these problems.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        return Partition(nums.Length-1, nums);\\n    }\\n\\n    public bool Partition(int end, int[] nums)\\n    {\\n        if(CheckValid(0,end,nums)) return true; // check if current partition is already a valid partition\\n        if(CheckValid(end-2,end,nums) && Partition(end-3, nums)) return true; // check three rightmost elements as partition and recurse remainder on the left\\n        if(CheckValid(end-1,end,nums) && Partition(end-2, nums)) return true; // check two rightmost elements as partition and recurse remainder on the left\\n        return false;\\n    }\\n\\n    public bool CheckValid(int start, int end, int[] nums)\\n    {\\n        if(start < 0 || end >= nums.Length || end - start > 2 || end - start == 0) return false;\\n        // two elements equal partition\\n        if(end - start == 1) return nums[start] == nums[end];\\n        // check three equal elements or three elements incrementing by one\\n        return (nums[start] == nums[start+1] && nums[start] == nums[start+2]) || (nums[start+1] - nums[start] == 1 && nums[end] - nums[start] == 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        return Partition(nums.Length-1, nums);\\n    }\\n\\n    public bool Partition(int end, int[] nums)\\n    {\\n        if(CheckValid(0,end,nums)) return true; // check if current partition is already a valid partition\\n        if(CheckValid(end-2,end,nums) && Partition(end-3, nums)) return true; // check three rightmost elements as partition and recurse remainder on the left\\n        if(CheckValid(end-1,end,nums) && Partition(end-2, nums)) return true; // check two rightmost elements as partition and recurse remainder on the left\\n        return false;\\n    }\\n\\n    public bool CheckValid(int start, int end, int[] nums)\\n    {\\n        if(start < 0 || end >= nums.Length || end - start > 2 || end - start == 0) return false;\\n        // two elements equal partition\\n        if(end - start == 1) return nums[start] == nums[end];\\n        // check three equal elements or three elements incrementing by one\\n        return (nums[start] == nums[start+1] && nums[start] == nums[start+2]) || (nums[start+1] - nums[start] == 1 && nums[end] - nums[start] == 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902821,
                "title": "simple-c-video-solution-beats-100-recursion-memoization",
                "content": "# Video Solution\\nhttps://youtu.be/Ig5PWQI-dHM\\n# Intuition\\nWe can solve this question using recursion and memoization. We will go on each index and we will have following three cases for each index:\\n1. It obeys 1st condition\\n2. It obeys 2nd condition\\n3. It obeys 3rd condition\\n\\nAnd in order to reduce time complexity we will use DP vector for memoization.\\n\\n![image.png](https://assets.leetcode.com/users/images/ac8fe9b1-0227-4307-b6d7-8a238aa91609_1691912025.0429177.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n**Please upvote if you liked !!!**\\n\\n# Code\\n```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n    bool solve(int curr,vector<int>&nums,vector<int>&dp){\\n        if(curr>=nums.size()){\\n            return true; // as we are done with all indices...\\n        }\\n        if(dp[curr]!=-1){\\n            return dp[curr]; // by doing this we are avoiding repeated cases....\\n        }\\n        if(curr+1<nums.size()&&nums[curr]==nums[curr+1]){\\n            if(solve(curr+2,nums,dp)){\\n                return dp[curr]=true;\\n            }\\n        }\\n        if(curr+2<nums.size()&&nums[curr]==nums[curr+1]&&nums[curr+1]==nums[curr+2]){\\n            if(solve(curr+3,nums,dp)){\\n                return dp[curr]=true;\\n            }\\n        }\\n        if(curr+2<nums.size()&&nums[curr]+1==nums[curr+1]&&nums[curr+1]+1==nums[curr+2]){\\n            if(solve(curr+3,nums,dp)){\\n                return dp[curr]=true;\\n            }\\n        }\\n        return dp[curr]=false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        // for memoization we will have a dp vector..\\n        vector<int>dp(n,-1);\\n        return solve(0,nums,dp);\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n    bool solve(int curr,vector<int>&nums,vector<int>&dp){\\n        if(curr>=nums.size()){\\n            return true; // as we are done with all indices...\\n        }\\n        if(dp[curr]!=-1){\\n            return dp[curr]; // by doing this we are avoiding repeated cases....\\n        }\\n        if(curr+1<nums.size()&&nums[curr]==nums[curr+1]){\\n            if(solve(curr+2,nums,dp)){\\n                return dp[curr]=true;\\n            }\\n        }\\n        if(curr+2<nums.size()&&nums[curr]==nums[curr+1]&&nums[curr+1]==nums[curr+2]){\\n            if(solve(curr+3,nums,dp)){\\n                return dp[curr]=true;\\n            }\\n        }\\n        if(curr+2<nums.size()&&nums[curr]+1==nums[curr+1]&&nums[curr+1]+1==nums[curr+2]){\\n            if(solve(curr+3,nums,dp)){\\n                return dp[curr]=true;\\n            }\\n        }\\n        return dp[curr]=false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        // for memoization we will have a dp vector..\\n        vector<int>dp(n,-1);\\n        return solve(0,nums,dp);\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902790,
                "title": "tabulated-dp-c-beats-95",
                "content": "# Intuition\\ndp[i] signifies whether array till i\\'th index is valid.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDeclare a boolean dp array and initialize zero indexed array with dp[0] = false since 1 length array is not valid for any case. \\n1. put values in dp uptill n==3 since this will help to easily gather previous dp values with checking for out of bound condition.\\n2. now check all the three condition for validity where 2 size or 3 size subarray were given and then check for the index previous to them like in 2 size subarray dp[i-2] && dp[i-3] in 3 length subarray\\n3. return the value stored in dp[n-1].\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        bool dp[n+1];\\n        memset(dp, false, sizeof dp);\\n        if(nums[0] == nums[1])dp[1]=true;\\n        if(n>2){\\n            if(nums[2]==nums[1] && nums[1]==nums[0])dp[2]=true;\\n            if(nums[2]-nums[1]==1 && nums[1]-nums[0]==1)dp[2]=true;\\n        }\\n        \\n        for(int i=3;i<n;i++){\\n            if(nums[i]==nums[i-1] && dp[i-2]==true)dp[i]=true;\\n            if(nums[i]==nums[i-1] && nums[i-1]==nums[i-2] && dp[i-3]==true)dp[i]=true;\\n            if(nums[i]-nums[i-1]==1 && nums[i-1]-nums[i-2]==1 && dp[i-3]==true)dp[i]=true;\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        bool dp[n+1];\\n        memset(dp, false, sizeof dp);\\n        if(nums[0] == nums[1])dp[1]=true;\\n        if(n>2){\\n            if(nums[2]==nums[1] && nums[1]==nums[0])dp[2]=true;\\n            if(nums[2]-nums[1]==1 && nums[1]-nums[0]==1)dp[2]=true;\\n        }\\n        \\n        for(int i=3;i<n;i++){\\n            if(nums[i]==nums[i-1] && dp[i-2]==true)dp[i]=true;\\n            if(nums[i]==nums[i-1] && nums[i-1]==nums[i-2] && dp[i-3]==true)dp[i]=true;\\n            if(nums[i]-nums[i-1]==1 && nums[i-1]-nums[i-2]==1 && dp[i-3]==true)dp[i]=true;\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902662,
                "title": "memoized-dp-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n       \\n\\n    bool f(vector<int>& nums,int ind,vector<int> &dp){\\n        // base case\\n        if (ind>=nums.size()){\\n            return true;\\n        }\\n      \\n\\n\\n        bool f1=0;\\n        bool f2=0;\\n        bool f3=0;\\n        if (dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n\\n        if (ind+1<nums.size()&&nums[ind]==nums[ind+1]){\\n            f1=  f(nums,ind+2,dp);\\n        }\\n        if ((ind+2<nums.size())&&(nums[ind]==nums[ind+1]&&nums[ind+1]==nums[ind+2])){\\n         f2=  f(nums,ind+3,dp);\\n        }\\n        if ((ind+2<nums.size())&&(nums[ind+1]-nums[ind]==1&&nums[ind+2]-nums[ind+1]==1)){\\n            f3=f(nums,ind+3,dp);\\n        }\\n        return dp[ind]=f1|f2|f3;\\n\\n\\n\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        return f(nums,0,dp);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       \\n\\n    bool f(vector<int>& nums,int ind,vector<int> &dp){\\n        // base case\\n        if (ind>=nums.size()){\\n            return true;\\n        }\\n      \\n\\n\\n        bool f1=0;\\n        bool f2=0;\\n        bool f3=0;\\n        if (dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n\\n        if (ind+1<nums.size()&&nums[ind]==nums[ind+1]){\\n            f1=  f(nums,ind+2,dp);\\n        }\\n        if ((ind+2<nums.size())&&(nums[ind]==nums[ind+1]&&nums[ind+1]==nums[ind+2])){\\n         f2=  f(nums,ind+3,dp);\\n        }\\n        if ((ind+2<nums.size())&&(nums[ind+1]-nums[ind]==1&&nums[ind+2]-nums[ind+1]==1)){\\n            f3=f(nums,ind+3,dp);\\n        }\\n        return dp[ind]=f1|f2|f3;\\n\\n\\n\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        return f(nums,0,dp);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902612,
                "title": "recursion-memoization-88-faster-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int ind, vector<int> &nums, vector<int> &dp){\\n        if(ind >= nums.size()) return false;\\n        if(nums.size() - ind == 2){\\n            return nums[ind] == nums[ind+1];\\n        }\\n        if(nums.size() - ind == 3){\\n            return (nums[ind] == nums[ind+1] && nums[ind] == nums[ind+2] ||\\n                    nums[ind] == nums[ind+1]-1 && nums[ind] == nums[ind+2] - 2);\\n        }\\n        if(dp[ind] != -1) return dp[ind];\\n        int left = nums.size() - ind;\\n        return dp[ind] = (left >= 2 && nums[ind] == nums[ind+1] && f(ind+2, nums, dp) ||\\n                left >= 3 && nums[ind] == nums[ind+1] && nums[ind] == nums[ind+2] && f(ind+3, nums, dp) || left >= 3 && nums[ind] == nums[ind+1]-1 && nums[ind] == nums[ind+2]-2 && f(ind+3, nums, dp));\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size() + 1, -1);\\n        return f(0, nums, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int ind, vector<int> &nums, vector<int> &dp){\\n        if(ind >= nums.size()) return false;\\n        if(nums.size() - ind == 2){\\n            return nums[ind] == nums[ind+1];\\n        }\\n        if(nums.size() - ind == 3){\\n            return (nums[ind] == nums[ind+1] && nums[ind] == nums[ind+2] ||\\n                    nums[ind] == nums[ind+1]-1 && nums[ind] == nums[ind+2] - 2);\\n        }\\n        if(dp[ind] != -1) return dp[ind];\\n        int left = nums.size() - ind;\\n        return dp[ind] = (left >= 2 && nums[ind] == nums[ind+1] && f(ind+2, nums, dp) ||\\n                left >= 3 && nums[ind] == nums[ind+1] && nums[ind] == nums[ind+2] && f(ind+3, nums, dp) || left >= 3 && nums[ind] == nums[ind+1]-1 && nums[ind] == nums[ind+2]-2 && f(ind+3, nums, dp));\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size() + 1, -1);\\n        return f(0, nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902538,
                "title": "memoization-dp",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &nums, vector<int> &dp) {\\n        if(i == n) return 1;\\n        if(dp[i] != - 1) return dp[i];\\n\\n        if(i + 1 < n && nums[i] == nums[i + 1]) {\\n            if(dfs(i + 2, n, nums, dp)) return dp[i] = 1;\\n        }\\n        if(i + 1 < n && i + 2 < n && nums[i] == nums[i + 1] && nums[i] == nums[i + 2]) {\\n            if(dfs(i + 3, n, nums, dp)) return dp[i] = 1;\\n        }\\n        if(i + 1 < n && i + 2 < n && nums[i] + 1 == nums[i + 1] && nums[i] + 2 == nums[i + 2]) {\\n            if(dfs(i + 3, n, nums, dp)) return dp[i] = 1;\\n        }\\n        return dp[i] = 0;\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return dfs(0, n, nums, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &nums, vector<int> &dp) {\\n        if(i == n) return 1;\\n        if(dp[i] != - 1) return dp[i];\\n\\n        if(i + 1 < n && nums[i] == nums[i + 1]) {\\n            if(dfs(i + 2, n, nums, dp)) return dp[i] = 1;\\n        }\\n        if(i + 1 < n && i + 2 < n && nums[i] == nums[i + 1] && nums[i] == nums[i + 2]) {\\n            if(dfs(i + 3, n, nums, dp)) return dp[i] = 1;\\n        }\\n        if(i + 1 < n && i + 2 < n && nums[i] + 1 == nums[i + 1] && nums[i] + 2 == nums[i + 2]) {\\n            if(dfs(i + 3, n, nums, dp)) return dp[i] = 1;\\n        }\\n        return dp[i] = 0;\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return dfs(0, n, nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902374,
                "title": "java-13",
                "content": "# Code\\n```\\nclass Solution {\\n    Map<Integer, Boolean> memo = new HashMap<>();\\n\\n    // Determine if the prefix array nums[0 ~ i] has a valid partition\\n    boolean prefixIsValid(int[] nums, int i) {\\n        if (memo.containsKey(i)) {\\n            return memo.get(i);\\n        }\\n        boolean ans = false;\\n\\n        // Check 3 possibilities\\n        if (i > 0 && nums[i] == nums[i - 1]) {\\n            ans |= prefixIsValid(nums, i - 2);\\n        }\\n        if (i > 1 && nums[i] == nums[i - 1] && nums[i - 1] == nums[i - 2]) {\\n            ans |= prefixIsValid(nums, i - 3);\\n        }\\n        if (i > 1 && nums[i] == nums[i - 1] + 1 && nums[i - 1] == nums[i - 2] + 1) {\\n            ans |= prefixIsValid(nums, i - 3);\\n        }\\n        memo.put(i, ans);\\n        return ans;\\n    }\\n\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        memo.put(-1, true);\\n\\n        return prefixIsValid(nums, n - 1);\\n    }\\n}//TC:O(n),SC:O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Boolean> memo = new HashMap<>();\\n\\n    // Determine if the prefix array nums[0 ~ i] has a valid partition\\n    boolean prefixIsValid(int[] nums, int i) {\\n        if (memo.containsKey(i)) {\\n            return memo.get(i);\\n        }\\n        boolean ans = false;\\n\\n        // Check 3 possibilities\\n        if (i > 0 && nums[i] == nums[i - 1]) {\\n            ans |= prefixIsValid(nums, i - 2);\\n        }\\n        if (i > 1 && nums[i] == nums[i - 1] && nums[i - 1] == nums[i - 2]) {\\n            ans |= prefixIsValid(nums, i - 3);\\n        }\\n        if (i > 1 && nums[i] == nums[i - 1] + 1 && nums[i - 1] == nums[i - 2] + 1) {\\n            ans |= prefixIsValid(nums, i - 3);\\n        }\\n        memo.put(i, ans);\\n        return ans;\\n    }\\n\\n    public boolean validPartition(int[] nums) {\\n        int n = nums.length;\\n        memo.put(-1, true);\\n\\n        return prefixIsValid(nums, n - 1);\\n    }\\n}//TC:O(n),SC:O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902251,
                "title": "java-dynamic-programming-memoization",
                "content": "```\\nclass Solution {\\n    boolean[] dp = new boolean[100005];\\n    \\n    public boolean equal(int i, int j , int[] nums){\\n        int ii = i;\\n        if(nums.length < j)\\n            return false;\\n        \\n        while(i < j  ){\\n            if(nums[ii] != nums[i])\\n                return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public boolean increasing(int i, int j, int[] nums){\\n        int pre = nums[i];\\n        \\n        if(nums.length < j)\\n            return false;\\n        \\n        i++;\\n        while(i < j ){\\n            if(nums[i] != pre+1)\\n                return false;\\n            pre = nums[i];\\n            i++;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    Map<Integer, Boolean> memo = new HashMap<>();\\n    public boolean solve(int i, int[] nums){\\n        int n = nums.length;\\n        if( i >= n )\\n            return true;\\n        if(memo.containsKey(i) )\\n            return memo.get(i);\\n        \\n        memo.put(i,true);\\n        boolean two = equal(i,i+2, nums) && solve(i+2,nums) ; \\n        // System.out.println(i+ \" two \"+two);\\n        if(two)\\n            return two;\\n        boolean three = equal(i,i+3,nums) && solve(i+3, nums) ;\\n        // System.out.println(i+\" three 1 \"+ three);\\n        if(three)\\n            return true;\\n        three = increasing(i,i+3, nums) && solve(i+3,nums);\\n        // System.out.println(i+\" three 2 \"+ three);\\n        if(three) return true;\\n        memo.put(i,false);\\n        return false;\\n    }\\n    \\n    public boolean validPartition(int[] nums) {\\n        boolean ans = solve(0,nums);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] dp = new boolean[100005];\\n    \\n    public boolean equal(int i, int j , int[] nums){\\n        int ii = i;\\n        if(nums.length < j)\\n            return false;\\n        \\n        while(i < j  ){\\n            if(nums[ii] != nums[i])\\n                return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public boolean increasing(int i, int j, int[] nums){\\n        int pre = nums[i];\\n        \\n        if(nums.length < j)\\n            return false;\\n        \\n        i++;\\n        while(i < j ){\\n            if(nums[i] != pre+1)\\n                return false;\\n            pre = nums[i];\\n            i++;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    Map<Integer, Boolean> memo = new HashMap<>();\\n    public boolean solve(int i, int[] nums){\\n        int n = nums.length;\\n        if( i >= n )\\n            return true;\\n        if(memo.containsKey(i) )\\n            return memo.get(i);\\n        \\n        memo.put(i,true);\\n        boolean two = equal(i,i+2, nums) && solve(i+2,nums) ; \\n        // System.out.println(i+ \" two \"+two);\\n        if(two)\\n            return two;\\n        boolean three = equal(i,i+3,nums) && solve(i+3, nums) ;\\n        // System.out.println(i+\" three 1 \"+ three);\\n        if(three)\\n            return true;\\n        three = increasing(i,i+3, nums) && solve(i+3,nums);\\n        // System.out.println(i+\" three 2 \"+ three);\\n        if(three) return true;\\n        memo.put(i,false);\\n        return false;\\n    }\\n    \\n    public boolean validPartition(int[] nums) {\\n        boolean ans = solve(0,nums);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902236,
                "title": "dp-memoization",
                "content": "# Intuition\\nSimple take and not take approach and checking each time.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\nNot sure about the complexity of time, please comment it out.\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool check(vector<int> &arr, int a, int b, int thing){\\n        if(thing == 1 || thing == 2){\\n            for(int i = a; i<b; i++){\\n                if(arr[i]!=arr[i+1])return false;\\n            }\\n            return true;\\n        }\\n\\n        if(thing == 3){\\n            for(int i=a; i<b; i++){\\n                if(arr[i+1] != (arr[i]+1))return false;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool f(vector<int>& arr, int ind, int n, vector<int> &dp){\\n        if(ind == n){\\n            return true;\\n        }\\n\\n        if(dp[ind]!=-1)return dp[ind];\\n\\n        bool one = false, two = false, three = false;\\n        if(ind+1<n and check(arr, ind, ind+1, 1)){\\n            one = f(arr, ind+2, n, dp);\\n        }\\n        if(ind+2<n and check(arr, ind, ind+2, 2)){\\n            two = f(arr, ind+3, n, dp);\\n        }\\n        if(ind+2<n and check(arr, ind, ind+2, 3)){\\n            two = f(arr, ind+3, n, dp);\\n        }\\n\\n        return dp[ind] = (one || two || three) ;\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+1, -1);\\n        return f(nums, 0, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool check(vector<int> &arr, int a, int b, int thing){\\n        if(thing == 1 || thing == 2){\\n            for(int i = a; i<b; i++){\\n                if(arr[i]!=arr[i+1])return false;\\n            }\\n            return true;\\n        }\\n\\n        if(thing == 3){\\n            for(int i=a; i<b; i++){\\n                if(arr[i+1] != (arr[i]+1))return false;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool f(vector<int>& arr, int ind, int n, vector<int> &dp){\\n        if(ind == n){\\n            return true;\\n        }\\n\\n        if(dp[ind]!=-1)return dp[ind];\\n\\n        bool one = false, two = false, three = false;\\n        if(ind+1<n and check(arr, ind, ind+1, 1)){\\n            one = f(arr, ind+2, n, dp);\\n        }\\n        if(ind+2<n and check(arr, ind, ind+2, 2)){\\n            two = f(arr, ind+3, n, dp);\\n        }\\n        if(ind+2<n and check(arr, ind, ind+2, 3)){\\n            two = f(arr, ind+3, n, dp);\\n        }\\n\\n        return dp[ind] = (one || two || three) ;\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+1, -1);\\n        return f(nums, 0, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902084,
                "title": "c-easy-to-understand-fastest",
                "content": "# C++ | Easy to Understand | Fastest\\n```\\nclass Solution {\\npublic:\\n   bool validPartition(vector<int>& n) {\\n    bool dp[4] = {true, false, n[0] == n[1], false};\\n    for (int i = 2; i < n.size(); ++i) {\\n        bool two = n[i] == n[i - 1];\\n        bool three = (two && n[i] == n[i - 2]) || (n[i] - 1 == n[i - 1] && n[i] - 2 == n[i - 2]);\\n        dp[(i + 1) % 4] = (dp[(i - 1) % 4] && two) || (dp[(i - 2) % 4] && three);\\n    }\\n    return dp[n.size() % 4];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool validPartition(vector<int>& n) {\\n    bool dp[4] = {true, false, n[0] == n[1], false};\\n    for (int i = 2; i < n.size(); ++i) {\\n        bool two = n[i] == n[i - 1];\\n        bool three = (two && n[i] == n[i - 2]) || (n[i] - 1 == n[i - 1] && n[i] - 2 == n[i - 2]);\\n        dp[(i + 1) % 4] = (dp[(i - 1) % 4] && two) || (dp[(i - 2) % 4] && three);\\n    }\\n    return dp[n.size() % 4];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902045,
                "title": "python-dp-easy-to-understand-optimal-solution-medium-problem",
                "content": "# Python | DP | Easy to Understand | Optimal Solution | Medium Problem\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n        if n == 1: \\n            return False \\n        dp = [True, False, nums[0] == nums[1] if n > 1 else False] \\n        for i in range(2, n): \\n            current_dp = False\\n            if nums[i] == nums[i-1] and dp[1]: \\n                current_dp = True\\n            elif nums[i] == nums[i-1] == nums[i-2] and dp[0]: \\n                current_dp = True \\n            elif nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0]: \\n                current_dp = True \\n            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp \\n        return dp[2]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums) \\n        if n == 1: \\n            return False \\n        dp = [True, False, nums[0] == nums[1] if n > 1 else False] \\n        for i in range(2, n): \\n            current_dp = False\\n            if nums[i] == nums[i-1] and dp[1]: \\n                current_dp = True\\n            elif nums[i] == nums[i-1] == nums[i-2] and dp[0]: \\n                current_dp = True \\n            elif nums[i] - nums[i-1] == 1 and nums[i-1] - nums[i-2] == 1 and dp[0]: \\n                current_dp = True \\n            dp[0], dp[1], dp[2] = dp[1], dp[2], current_dp \\n        return dp[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902029,
                "title": "rust-elixir-bottom-top-dp",
                "content": "Need to initialize the 3-boolean DP tuple to:\\n- 1st value: `nums[1] == nums[0]`: To determine whether nums[..2] is valid.\\n- 2nd value: `false`: Array is never valid when it has only 1 element.\\n- 3rd value: `true`: Assume empty arrays are valid.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let mut dp = (nums[1] == nums[0], false, true);\\n        for i in 2..nums.len() {\\n            let valid = match (dp.1, dp.2, nums[i] - nums[i - 1], nums[i - 1] - nums[i - 2]) {\\n                (true, _, 0, _) |\\n                (_, true, 0, 0) |\\n                (_, true, 1, 1) => true,\\n                _ => false,\\n            };\\n            dp = (valid, dp.0, dp.1);\\n        }\\n        dp.0\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec valid_partition(nums :: [integer]) :: boolean\\n  def valid_partition(nums = [a, b | _]) do\\n    Enum.chunk_every(nums, 3, 1, :discard)\\n    |> Enum.reduce({a == b, false, true}, fn [a, b, c], {dp1, dp2, dp3} ->\\n      cond do\\n        dp2 and b == c -> true\\n        dp3 and a == b and b == c -> true\\n        dp3 and a + 1 == b and b + 1 == c -> true\\n        true -> false\\n      end\\n      |> then(&{&1, dp1, dp2})\\n    end)\\n    |> elem(0)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Dynamic Programming"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        let mut dp = (nums[1] == nums[0], false, true);\\n        for i in 2..nums.len() {\\n            let valid = match (dp.1, dp.2, nums[i] - nums[i - 1], nums[i - 1] - nums[i - 2]) {\\n                (true, _, 0, _) |\\n                (_, true, 0, 0) |\\n                (_, true, 1, 1) => true,\\n                _ => false,\\n            };\\n            dp = (valid, dp.0, dp.1);\\n        }\\n        dp.0\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec valid_partition(nums :: [integer]) :: boolean\\n  def valid_partition(nums = [a, b | _]) do\\n    Enum.chunk_every(nums, 3, 1, :discard)\\n    |> Enum.reduce({a == b, false, true}, fn [a, b, c], {dp1, dp2, dp3} ->\\n      cond do\\n        dp2 and b == c -> true\\n        dp3 and a == b and b == c -> true\\n        dp3 and a + 1 == b and b + 1 == c -> true\\n        true -> false\\n      end\\n      |> then(&{&1, dp1, dp2})\\n    end)\\n    |> elem(0)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3901803,
                "title": "short-simple-solution-with-js-beats-100-00",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function (nums) {\\n    let n = nums.length, dp = new Array(n + 1).fill(0);\\n    for (let i = 1; i < n; i++) {\\n        const a = nums[i] == nums[i - 1];\\n        const b = a && i - 2 >= 0 && nums[i] == nums[i - 2];\\n        const c = i - 2 >= 0 && (nums[i - 1] - nums[i - 2]) === 1 && (nums[i] - nums[i - 1]) === 1;\\n\\n        dp[i] = (a && (i - 2 >= 0 ? dp[i - 2] : 1)) || ((b || c) && (i - 3 >= 0 ? dp[i - 3] : 1));\\n    }\\n    return dp[n - 1];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar validPartition = function (nums) {\\n    let n = nums.length, dp = new Array(n + 1).fill(0);\\n    for (let i = 1; i < n; i++) {\\n        const a = nums[i] == nums[i - 1];\\n        const b = a && i - 2 >= 0 && nums[i] == nums[i - 2];\\n        const c = i - 2 >= 0 && (nums[i - 1] - nums[i - 2]) === 1 && (nums[i] - nums[i - 1]) === 1;\\n\\n        dp[i] = (a && (i - 2 >= 0 ? dp[i - 2] : 1)) || ((b || c) && (i - 3 >= 0 ? dp[i - 3] : 1));\\n    }\\n    return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901525,
                "title": "beats-85-clean-code-dp-memoization-c-rust-go-java-python-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUltra Instinct \\u26A1\\uFE0F\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExplore all possibilities and memoize explored! \\uD83D\\uDDFA\\uFE0F\\uD83C\\uDF0D\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool chk(int i, int j, vector<int> &a) {\\n        if (j - i == 1) {\\n            return a[i] == a[j];\\n        }\\n        else {\\n            if (a[i] == a[i + 1] && a[i + 1] == a[i + 2]) return 1;\\n            return a[i + 1] - a[i] == 1 && a[i + 2] - a[i + 1] == 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool f(int i, vector<int> &a, vector<int> &dp) {\\n        if (i > a.size()) return 0;\\n        if (i == a.size()) return 1;\\n\\n        if (dp[i] != -1) return dp[idx];\\n        bool two = 0, three = 0;\\n        if(i < a.size() - 1 && chk(i, i + 1, a)) two = f(i + 2, a, dp);\\n        if(i < a.size() - 2 && chk(i, i + 2, a)) three = f(i + 3, a, dp);\\n\\n        return dp[i] = aa || b;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return f(0, nums, dp);\\n    }\\n};\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        fn chk(i: usize, j: usize, a: &Vec<i32>) -> bool {\\n            if j - i == 1 { return a[i] == a[j]; } \\n            else {\\n                if a[i] == a[i + 1] && a[i + 1] == a[i + 2] { return true; }\\n                return a[i + 1] - a[i] == 1 && a[i + 2] - a[i + 1] == 1;\\n            }\\n            return false;\\n        }\\n\\n        fn f(i: usize, a: &Vec<i32>, dp: &mut Vec<i32>) -> bool {\\n            if i > a.len() { return false; }\\n            if i == a.len() { return true; }\\n\\n            if dp[i] != -1 { return dp[i] != 0; }\\n\\n            let mut two = false;\\n            let mut three = false;\\n            if i < a.len() - 1 && chk(i, i + 1, a) { two = f(i + 2, a, dp); }\\n            if i < a.len() - 2 && chk(i, i + 2, a) { three = f(i + 3, a, dp); }\\n\\n            dp[i] = (two || three) as i32;\\n            dp[i] != 0\\n        }\\n\\n        let mut dp = vec![-1; nums.len()];\\n        f(0, &nums, &mut dp)\\n    }\\n}\\n\\n```\\n```Go []\\nfunc validPartition(nums []int) bool {\\n    chk := func(i, j int, a []int) bool {\\n        if j-i == 1 {\\n            return a[i] == a[j]\\n        } else {\\n            if a[i] == a[i+1] && a[i+1] == a[i+2] {\\n                return true\\n            }\\n            return a[i+1]-a[i] == 1 && a[i+2]-a[i+1] == 1\\n        }\\n    }\\n\\n    var f func(i int, a []int, dp []int) bool\\n    f = func(i int, a []int, dp []int) bool {\\n        if i > len(a) {\\n            return false\\n        }\\n        if i == len(a) {\\n            return true\\n        }\\n\\n        if dp[i] != -1 {\\n            return dp[i] != 0\\n        }\\n\\n        var two, three bool\\n        if i < len(a)-1 && chk(i, i+1, a) {\\n            two = f(i+2, a, dp)\\n        }\\n        if i < len(a)-2 && chk(i, i+2, a) {\\n            three = f(i+3, a, dp)\\n        }\\n\\n        dp[i] = 0\\n        if two || three {\\n            dp[i] = 1\\n        }\\n        return dp[i] != 0\\n    }\\n\\n    dp := make([]int, len(nums))\\n    for i := range dp {\\n        dp[i] = -1\\n    }\\n\\n    return f(0, nums, dp)\\n}\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean chk(int i, int j, int[] a) {\\n        if (j - i == 1) return a[i] == a[j];\\n        else {\\n            if (a[i] == a[i + 1] && a[i + 1] == a[i + 2]) return true;\\n            return a[i + 1] - a[i] == 1 && a[i + 2] - a[i + 1] == 1;\\n        }\\n    }\\n\\n    public boolean f(int i, int[] a, int[] dp) {\\n        if (i > a.length) return false;\\n        if (i == a.length) return true;\\n\\n        if (dp[i] != -1) return dp[i] == 1 ? true : false;\\n\\n        boolean two = false, three = false;\\n        if (i < a.length - 1 && chk(i, i + 1, a)) two = f(i + 2, a, dp);\\n        if (i < a.length - 2 && chk(i, i + 2, a)) three = f(i + 3, a, dp);\\n\\n        if (two || three) dp[i] = 1;\\n        else dp[i] = 0;\\n\\n        return two || three;\\n    }\\n    \\n    public boolean validPartition(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return f(0, nums, dp);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def chk(self, i, j, a):\\n        if j - i == 1:return a[i] == a[j]\\n\\n        else:\\n            if a[i] == a[i + 1] and a[i + 1] == a[i + 2]: return True\\n            return a[i + 1] - a[i] == 1 and a[i + 2] - a[i + 1] == 1\\n\\n        return False\\n    \\n    def f(self, i, a, dp):\\n        if i > len(a): return False\\n        if i == len(a): return True\\n        \\n        if dp[i] != -1: return dp[i]\\n        \\n        two, three = False, False\\n        if i < len(a) - 1 and self.chk(i, i + 1, a): two = self.f(i + 2, a, dp)\\n        if i < len(a) - 2 and self.chk(i, i + 2, a): three = self.f(i + 3, a, dp)\\n        \\n        dp[i] = two or three\\n        return dp[i]\\n    \\n    def validPartition(self, nums: List[int]) -> bool:\\n        dp = [-1] * len(nums)\\n        return self.f(0, nums, dp)\\n```\\n```Javascript []\\nconst validPartition = (nums) => {\\n    const chk = (i, j, a) => {\\n        if (j - i === 1)  return a[i] === a[j];\\n        else {\\n            if (a[i] === a[i + 1] && a[i + 1] === a[i + 2]) return true;\\n            return a[i + 1] - a[i] === 1 && a[i + 2] - a[i + 1] === 1;\\n        }\\n    };\\n\\n    const f = (i, a, dp) => {\\n        if (i > a.length)  return false;\\n        if (i === a.length) return true;\\n\\n        if (dp[i] !== -1) return dp[i];\\n\\n        let two = false, three = false;\\n        if (i < a.length - 1 && chk(i, i + 1, a)) two = f(i + 2, a, dp);\\n        if (i < a.length - 2 && chk(i, i + 2, a)) three = f(i + 3, a, dp);\\n\\n        return dp[i] = two || three;\\n    };\\n\\n    const dp = new Array(nums.length).fill(-1);\\n    return f(0, nums, dp);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool chk(int i, int j, vector<int> &a) {\\n        if (j - i == 1) {\\n            return a[i] == a[j];\\n        }\\n        else {\\n            if (a[i] == a[i + 1] && a[i + 1] == a[i + 2]) return 1;\\n            return a[i + 1] - a[i] == 1 && a[i + 2] - a[i + 1] == 1;\\n        }\\n        return 0;\\n    }\\n\\n    bool f(int i, vector<int> &a, vector<int> &dp) {\\n        if (i > a.size()) return 0;\\n        if (i == a.size()) return 1;\\n\\n        if (dp[i] != -1) return dp[idx];\\n        bool two = 0, three = 0;\\n        if(i < a.size() - 1 && chk(i, i + 1, a)) two = f(i + 2, a, dp);\\n        if(i < a.size() - 2 && chk(i, i + 2, a)) three = f(i + 3, a, dp);\\n\\n        return dp[i] = aa || b;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return f(0, nums, dp);\\n    }\\n};\\n```\n```Rust []\\nimpl Solution {\\n    pub fn valid_partition(nums: Vec<i32>) -> bool {\\n        fn chk(i: usize, j: usize, a: &Vec<i32>) -> bool {\\n            if j - i == 1 { return a[i] == a[j]; } \\n            else {\\n                if a[i] == a[i + 1] && a[i + 1] == a[i + 2] { return true; }\\n                return a[i + 1] - a[i] == 1 && a[i + 2] - a[i + 1] == 1;\\n            }\\n            return false;\\n        }\\n\\n        fn f(i: usize, a: &Vec<i32>, dp: &mut Vec<i32>) -> bool {\\n            if i > a.len() { return false; }\\n            if i == a.len() { return true; }\\n\\n            if dp[i] != -1 { return dp[i] != 0; }\\n\\n            let mut two = false;\\n            let mut three = false;\\n            if i < a.len() - 1 && chk(i, i + 1, a) { two = f(i + 2, a, dp); }\\n            if i < a.len() - 2 && chk(i, i + 2, a) { three = f(i + 3, a, dp); }\\n\\n            dp[i] = (two || three) as i32;\\n            dp[i] != 0\\n        }\\n\\n        let mut dp = vec![-1; nums.len()];\\n        f(0, &nums, &mut dp)\\n    }\\n}\\n\\n```\n```Go []\\nfunc validPartition(nums []int) bool {\\n    chk := func(i, j int, a []int) bool {\\n        if j-i == 1 {\\n            return a[i] == a[j]\\n        } else {\\n            if a[i] == a[i+1] && a[i+1] == a[i+2] {\\n                return true\\n            }\\n            return a[i+1]-a[i] == 1 && a[i+2]-a[i+1] == 1\\n        }\\n    }\\n\\n    var f func(i int, a []int, dp []int) bool\\n    f = func(i int, a []int, dp []int) bool {\\n        if i > len(a) {\\n            return false\\n        }\\n        if i == len(a) {\\n            return true\\n        }\\n\\n        if dp[i] != -1 {\\n            return dp[i] != 0\\n        }\\n\\n        var two, three bool\\n        if i < len(a)-1 && chk(i, i+1, a) {\\n            two = f(i+2, a, dp)\\n        }\\n        if i < len(a)-2 && chk(i, i+2, a) {\\n            three = f(i+3, a, dp)\\n        }\\n\\n        dp[i] = 0\\n        if two || three {\\n            dp[i] = 1\\n        }\\n        return dp[i] != 0\\n    }\\n\\n    dp := make([]int, len(nums))\\n    for i := range dp {\\n        dp[i] = -1\\n    }\\n\\n    return f(0, nums, dp)\\n}\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean chk(int i, int j, int[] a) {\\n        if (j - i == 1) return a[i] == a[j];\\n        else {\\n            if (a[i] == a[i + 1] && a[i + 1] == a[i + 2]) return true;\\n            return a[i + 1] - a[i] == 1 && a[i + 2] - a[i + 1] == 1;\\n        }\\n    }\\n\\n    public boolean f(int i, int[] a, int[] dp) {\\n        if (i > a.length) return false;\\n        if (i == a.length) return true;\\n\\n        if (dp[i] != -1) return dp[i] == 1 ? true : false;\\n\\n        boolean two = false, three = false;\\n        if (i < a.length - 1 && chk(i, i + 1, a)) two = f(i + 2, a, dp);\\n        if (i < a.length - 2 && chk(i, i + 2, a)) three = f(i + 3, a, dp);\\n\\n        if (two || three) dp[i] = 1;\\n        else dp[i] = 0;\\n\\n        return two || three;\\n    }\\n    \\n    public boolean validPartition(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return f(0, nums, dp);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def chk(self, i, j, a):\\n        if j - i == 1:return a[i] == a[j]\\n\\n        else:\\n            if a[i] == a[i + 1] and a[i + 1] == a[i + 2]: return True\\n            return a[i + 1] - a[i] == 1 and a[i + 2] - a[i + 1] == 1\\n\\n        return False\\n    \\n    def f(self, i, a, dp):\\n        if i > len(a): return False\\n        if i == len(a): return True\\n        \\n        if dp[i] != -1: return dp[i]\\n        \\n        two, three = False, False\\n        if i < len(a) - 1 and self.chk(i, i + 1, a): two = self.f(i + 2, a, dp)\\n        if i < len(a) - 2 and self.chk(i, i + 2, a): three = self.f(i + 3, a, dp)\\n        \\n        dp[i] = two or three\\n        return dp[i]\\n    \\n    def validPartition(self, nums: List[int]) -> bool:\\n        dp = [-1] * len(nums)\\n        return self.f(0, nums, dp)\\n```\n```Javascript []\\nconst validPartition = (nums) => {\\n    const chk = (i, j, a) => {\\n        if (j - i === 1)  return a[i] === a[j];\\n        else {\\n            if (a[i] === a[i + 1] && a[i + 1] === a[i + 2]) return true;\\n            return a[i + 1] - a[i] === 1 && a[i + 2] - a[i + 1] === 1;\\n        }\\n    };\\n\\n    const f = (i, a, dp) => {\\n        if (i > a.length)  return false;\\n        if (i === a.length) return true;\\n\\n        if (dp[i] !== -1) return dp[i];\\n\\n        let two = false, three = false;\\n        if (i < a.length - 1 && chk(i, i + 1, a)) two = f(i + 2, a, dp);\\n        if (i < a.length - 2 && chk(i, i + 2, a)) three = f(i + 3, a, dp);\\n\\n        return dp[i] = two || three;\\n    };\\n\\n    const dp = new Array(nums.length).fill(-1);\\n    return f(0, nums, dp);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901508,
                "title": "python-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn general, problems where you need to try different combinations of things (especially where there\\'s an array involved) tend to be DP problems.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDescribed in Code \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        # base cases: \\n        # 1 - exactly 2 equal elements\\n        # 2 - exactly 3 equal elements\\n        # 3 - exactly 3 consecutive increasing elements (with at most 1 difference)\\n\\n        # from a first glance this definitely looks like a dp problem\\n        # this is obvious because we are checking for different combinations\\n        # of subpartitions until we find a combination that works\\n\\n        # so the gist is: \\n        # so we try to build a valid subpartition\\n        # and if it works, then we can move on and try to build the next valid subpartition\\n        \\n        # we can create an array called DP \\n        # DP[i] will represent the sub problem for array from nums[0] to nums[i]\\n\\n        # at index i for the dp, we have 3 conditions we can check\\n        # if any of con 1 2 or 3 are true, then dp[i] is true \\n        # it doesn\\'t matter if 2 of them are false as long as one condition is true.\\n        # dp[i] only ever is false if all 3 conditions are false \\n\\n\\n        dp = [False for _ in range(len(nums))]\\n        if nums[0] == nums[1]: dp[1] = True\\n        if len(nums) == 2: return dp[1]\\n        if nums[0] == nums[1] == nums[2] or (nums[0] + 1 == nums[1] and nums[1] + 1 == nums[2]): dp[2] = True\\n        if len(nums) == 3: return dp[2]\\n\\n\\n\\n\\n        for i in range(3, len(nums)):\\n            # case 1\\n            if i >= 1 and nums[i-1] == nums[i]:\\n                dp[i] |= dp[i-2]\\n            # case 2\\n            if i >= 2 and nums[i-2] == nums[i-1] == nums[i]:\\n                dp[i] |= dp[i - 3]\\n            # case 3\\n            if i >= 2 and nums[i-2] + 1 == nums[i-1] and nums[i-1] + 1 == nums[i]: \\n                dp[i] |= dp[i-3]\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        # base cases: \\n        # 1 - exactly 2 equal elements\\n        # 2 - exactly 3 equal elements\\n        # 3 - exactly 3 consecutive increasing elements (with at most 1 difference)\\n\\n        # from a first glance this definitely looks like a dp problem\\n        # this is obvious because we are checking for different combinations\\n        # of subpartitions until we find a combination that works\\n\\n        # so the gist is: \\n        # so we try to build a valid subpartition\\n        # and if it works, then we can move on and try to build the next valid subpartition\\n        \\n        # we can create an array called DP \\n        # DP[i] will represent the sub problem for array from nums[0] to nums[i]\\n\\n        # at index i for the dp, we have 3 conditions we can check\\n        # if any of con 1 2 or 3 are true, then dp[i] is true \\n        # it doesn\\'t matter if 2 of them are false as long as one condition is true.\\n        # dp[i] only ever is false if all 3 conditions are false \\n\\n\\n        dp = [False for _ in range(len(nums))]\\n        if nums[0] == nums[1]: dp[1] = True\\n        if len(nums) == 2: return dp[1]\\n        if nums[0] == nums[1] == nums[2] or (nums[0] + 1 == nums[1] and nums[1] + 1 == nums[2]): dp[2] = True\\n        if len(nums) == 3: return dp[2]\\n\\n\\n\\n\\n        for i in range(3, len(nums)):\\n            # case 1\\n            if i >= 1 and nums[i-1] == nums[i]:\\n                dp[i] |= dp[i-2]\\n            # case 2\\n            if i >= 2 and nums[i-2] == nums[i-1] == nums[i]:\\n                dp[i] |= dp[i - 3]\\n            # case 3\\n            if i >= 2 and nums[i-2] + 1 == nums[i-1] and nums[i-1] + 1 == nums[i]: \\n                dp[i] |= dp[i-3]\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901486,
                "title": "beats-95-recursion-memoization-intuition-approach",
                "content": "# Intuition\\nThe key idea behind this solution is to explore the possible valid partitions in the given array nums using a recursive approach. At each step, we examine the current element and determine whether it fits the criteria to be part of a valid partition. We employ memoization to reduce unnecessary recalculations.\\n\\n# Approach\\nWe design a recursive function named `checkPartition(i, nums, dp)` that takes the current index i, the array nums, and a memoization array dp as parameters.\\n\\nDuring each recursive call, we evaluate the potential subarrays starting from index i and assess whether they satisfy the given conditions.\\n\\nWe consider three primary cases:\\na. If the next two elements are equal to the element at nums[i], a valid subarray of **length 3 with identical elements** is formed.\\nb. If the next element is equal to nums[i], a valid subarray of **length 2 with identical elements** is formed.\\nc. If the next two elements are consecutive and increasing, a valid subarray of **length 3 with consecutive increasing elements** is formed.\\n\\nThe memoization technique is employed to store whether a particular index i leads to a valid partition. This reduces redundant computations and significantly enhances the efficiency of the algorithm.\\n# Code\\n```\\nclass Solution {\\npublic: \\n    bool solve(int i, vector<int>& nums, vector<int>& dp) {\\n        int n = nums.size();\\n        \\n        if (i >= n) return true; \\n        \\n        if (dp[i] != -1) return dp[i];\\n        \\n        if (i + 1 < n) {\\n            if (nums[i + 1] == nums[i]) {\\n                if (i + 2 < n) {\\n                    if (nums[i + 2] == nums[i]) {\\n                        return dp[i] = solve(i + 2, nums, dp) || solve(i + 3, nums, dp);\\n                    }\\n                    return dp[i] = solve(i + 2, nums, dp);\\n                }\\n                return dp[i] = true;\\n            }\\n            \\n            if (nums[i + 1] == nums[i] + 1) {\\n                if (i + 2 >= n) return dp[i] = false;\\n                if (nums[i + 2] == nums[i] + 2) \\n                    return dp[i] = solve(i + 3, nums, dp);\\n                \\n                return dp[i] = false;\\n            }\\n            return dp[i] = false;\\n        }\\n        return dp[i] =  false;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return solve(0, nums, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool solve(int i, vector<int>& nums, vector<int>& dp) {\\n        int n = nums.size();\\n        \\n        if (i >= n) return true; \\n        \\n        if (dp[i] != -1) return dp[i];\\n        \\n        if (i + 1 < n) {\\n            if (nums[i + 1] == nums[i]) {\\n                if (i + 2 < n) {\\n                    if (nums[i + 2] == nums[i]) {\\n                        return dp[i] = solve(i + 2, nums, dp) || solve(i + 3, nums, dp);\\n                    }\\n                    return dp[i] = solve(i + 2, nums, dp);\\n                }\\n                return dp[i] = true;\\n            }\\n            \\n            if (nums[i + 1] == nums[i] + 1) {\\n                if (i + 2 >= n) return dp[i] = false;\\n                if (nums[i + 2] == nums[i] + 2) \\n                    return dp[i] = solve(i + 3, nums, dp);\\n                \\n                return dp[i] = false;\\n            }\\n            return dp[i] = false;\\n        }\\n        return dp[i] =  false;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return solve(0, nums, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901389,
                "title": "recursion-dp-c",
                "content": "# Intuition\\nChecking all the possibilty mentioned in the question.<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int index,vector<int>&nums,vector<int>&dp){\\n        if(index==nums.size()){\\n            return 1;\\n        }\\n        if(index>=nums.size()-1){\\n            return 0;\\n        }\\n        if(dp[index]!=-1)return dp[index];\\n        bool a=0;\\n        if(nums[index]==nums[index+1]){\\n            a=a|f(index+2,nums,dp);\\n        }\\n        if(nums.size()-index>=3){\\n            if(nums[index]==nums[index+1] && nums[index+1]==nums[index+2] || (((nums[index]+1)==nums[index+1] )&& ( (nums[index]+2)==nums[index+2]))){\\n                a=a|f(index+3,nums,dp);\\n            }\\n         \\n        }\\n     return dp[index]=a;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return f(0,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int index,vector<int>&nums,vector<int>&dp){\\n        if(index==nums.size()){\\n            return 1;\\n        }\\n        if(index>=nums.size()-1){\\n            return 0;\\n        }\\n        if(dp[index]!=-1)return dp[index];\\n        bool a=0;\\n        if(nums[index]==nums[index+1]){\\n            a=a|f(index+2,nums,dp);\\n        }\\n        if(nums.size()-index>=3){\\n            if(nums[index]==nums[index+1] && nums[index+1]==nums[index+2] || (((nums[index]+1)==nums[index+1] )&& ( (nums[index]+2)==nums[index+2]))){\\n                a=a|f(index+3,nums,dp);\\n            }\\n         \\n        }\\n     return dp[index]=a;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return f(0,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901250,
                "title": "easy-c-dp-with-memoization-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool fun(vector<int>&nums,int i, vector<int>&dp)\\n    {\\n        int n = nums.size();\\n        //base case - if index clears all index it means all it is valid subarray so return true.\\n        if(i >= nums.size())\\n        {\\n            return true;\\n        }\\n        //if index is at last position it is sure that none of the given condition will be true so return false.\\n        if(i == nums.size()-1) return false;\\n        if(dp[i] != -1) return dp[i];\\n        bool ans = false;\\n        //if condition 1 is true\\n        if(nums[i+1] == nums[i])\\n        {\\n            ans |= fun(nums,i+2,dp);\\n\\n        }\\n        //if condition 2 is true\\n        if(i <= n-3 && nums[i+1] == nums[i] && nums[i+1] == nums[i+2])\\n        {\\n            ans |= fun(nums,i+3,dp);\\n        }\\n        //if condition 3 is true\\n        if(i <= n-3 && nums[i+1]- nums[i] == 1 && nums[i+2]-nums[i+1] == 1)\\n        {\\n            ans |= fun(nums,i+3,dp);\\n\\n        }   \\n        //storing ans in dp array.\\n        if(ans == true) dp[i] = 1;\\n        else dp[i] = 0;\\n        return ans;\\n    }\\n    bool validPartition(vector<int>& nums) \\n    {\\n        vector<int>dp(nums.size(),-1);\\n        return fun(nums,0,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool fun(vector<int>&nums,int i, vector<int>&dp)\\n    {\\n        int n = nums.size();\\n        //base case - if index clears all index it means all it is valid subarray so return true.\\n        if(i >= nums.size())\\n        {\\n            return true;\\n        }\\n        //if index is at last position it is sure that none of the given condition will be true so return false.\\n        if(i == nums.size()-1) return false;\\n        if(dp[i] != -1) return dp[i];\\n        bool ans = false;\\n        //if condition 1 is true\\n        if(nums[i+1] == nums[i])\\n        {\\n            ans |= fun(nums,i+2,dp);\\n\\n        }\\n        //if condition 2 is true\\n        if(i <= n-3 && nums[i+1] == nums[i] && nums[i+1] == nums[i+2])\\n        {\\n            ans |= fun(nums,i+3,dp);\\n        }\\n        //if condition 3 is true\\n        if(i <= n-3 && nums[i+1]- nums[i] == 1 && nums[i+2]-nums[i+1] == 1)\\n        {\\n            ans |= fun(nums,i+3,dp);\\n\\n        }   \\n        //storing ans in dp array.\\n        if(ans == true) dp[i] = 1;\\n        else dp[i] = 0;\\n        return ans;\\n    }\\n    bool validPartition(vector<int>& nums) \\n    {\\n        vector<int>dp(nums.size(),-1);\\n        return fun(nums,0,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901228,
                "title": "daily-leetcoding-challenge-august-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming \n\n  \n**Approach 3:** Space Optimized Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3282141,
                "title": "c",
                "content": "```\\nbool validPartition(int* nums, int numsSize){\\n    int n = numsSize ;\\n    bool* dp = calloc(n+1, sizeof(bool)) ;\\n    dp[0] = true ;\\n    if(nums[0] == nums[1])\\n        dp[2] = true ;\\n    \\n    int consecutiveFalse = 0 ;\\n    for(int i = 3; i <= n; i++){\\n        if(nums[i-1] == nums[i-2]){\\n            dp[i] |= dp[i-2] ;\\n            if(dp[i]){\\n                consecutiveFalse = 0 ;\\n                continue ;\\n            }\\n            if(nums[i-2] == nums[i-3])\\n                dp[i] |= dp[i-3] ;\\n                if(dp[i]){\\n                    consecutiveFalse = 0;\\n                    continue ; \\n                }\\n        }\\n        else\\n        {\\n            if((nums[i-1] == nums[i-2] + 1) && (nums[i-2] == nums[i-3] + 1)){\\n                dp[i] |= dp[i-3] ;\\n                if(dp[i]){\\n                    consecutiveFalse = 0 ;\\n                    continue ;\\n                }\\n            }\\n        }\\n        consecutiveFalse++ ;\\n        if(consecutiveFalse == 3)\\n            break ;\\n    }\\n    return dp[n] ;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nbool validPartition(int* nums, int numsSize){\\n    int n = numsSize ;\\n    bool* dp = calloc(n+1, sizeof(bool)) ;\\n    dp[0] = true ;\\n    if(nums[0] == nums[1])\\n        dp[2] = true ;\\n    \\n    int consecutiveFalse = 0 ;\\n    for(int i = 3; i <= n; i++){\\n        if(nums[i-1] == nums[i-2]){\\n            dp[i] |= dp[i-2] ;\\n            if(dp[i]){\\n                consecutiveFalse = 0 ;\\n                continue ;\\n            }\\n            if(nums[i-2] == nums[i-3])\\n                dp[i] |= dp[i-3] ;\\n                if(dp[i]){\\n                    consecutiveFalse = 0;\\n                    continue ; \\n                }\\n        }\\n        else\\n        {\\n            if((nums[i-1] == nums[i-2] + 1) && (nums[i-2] == nums[i-3] + 1)){\\n                dp[i] |= dp[i-3] ;\\n                if(dp[i]){\\n                    consecutiveFalse = 0 ;\\n                    continue ;\\n                }\\n            }\\n        }\\n        consecutiveFalse++ ;\\n        if(consecutiveFalse == 3)\\n            break ;\\n    }\\n    return dp[n] ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2476576,
                "title": "intuitive-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validateChunks(vector <int> &nums, int idx, vector <int> &cache) {\\n        if(idx >= nums.size()) {\\n            return true;\\n        }    \\n        if(cache[idx] != -1) {\\n            return cache[idx];\\n        }\\n        \\n        // create 2 sized chunk\\n        bool res1 = true;\\n        if(idx + 1 < nums.size()) {\\n            int e1 = nums[idx], e2 = nums[idx + 1];\\n            \\n            res1 = (e1 == e2) and validateChunks(nums, idx + 2, cache);\\n        }\\n        else {\\n            res1 = false;\\n        }\\n        \\n        \\n        // create 3 sized chunk\\n        bool res2 = true;\\n        if(idx + 2 < nums.size()) {\\n            int e1 = nums[idx], e2 = nums[idx + 1], e3 = nums[idx + 2];\\n            \\n            bool condition1 = (e1 == e2) and (e2 == e3);\\n            bool condition2 = (e2 == (e1 + 1)) and (e3 == (e2 + 1));\\n                           \\n            res2 = (condition1 or condition2) and validateChunks(nums, idx + 3, cache);\\n        }\\n        else {\\n            res2 = false;\\n        }\\n        \\n        return cache[idx] = res1 or res2;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        vector <int> cache(nums.size(), -1);\\n        \\n        return validateChunks(nums, 0, cache); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validateChunks(vector <int> &nums, int idx, vector <int> &cache) {\\n        if(idx >= nums.size()) {\\n            return true;\\n        }    \\n        if(cache[idx] != -1) {\\n            return cache[idx];\\n        }\\n        \\n        // create 2 sized chunk\\n        bool res1 = true;\\n        if(idx + 1 < nums.size()) {\\n            int e1 = nums[idx], e2 = nums[idx + 1];\\n            \\n            res1 = (e1 == e2) and validateChunks(nums, idx + 2, cache);\\n        }\\n        else {\\n            res1 = false;\\n        }\\n        \\n        \\n        // create 3 sized chunk\\n        bool res2 = true;\\n        if(idx + 2 < nums.size()) {\\n            int e1 = nums[idx], e2 = nums[idx + 1], e3 = nums[idx + 2];\\n            \\n            bool condition1 = (e1 == e2) and (e2 == e3);\\n            bool condition2 = (e2 == (e1 + 1)) and (e3 == (e2 + 1));\\n                           \\n            res2 = (condition1 or condition2) and validateChunks(nums, idx + 3, cache);\\n        }\\n        else {\\n            res2 = false;\\n        }\\n        \\n        return cache[idx] = res1 or res2;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        vector <int> cache(nums.size(), -1);\\n        \\n        return validateChunks(nums, 0, cache); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421404,
                "title": "c-solution",
                "content": "```\\n bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        return func(nums,0,dp);\\n    }\\n    \\n    bool func(vector<int> &nums,int i,vector<int> &dp){\\n        int n=nums.size();\\n        if(i==nums.size()){\\n            return true;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n            \\n         if(i+1<n && nums[i+1]==nums[i]){\\n             if(func(nums,i+2,dp))\\n             return dp[i]=true;\\n             \\n             if(i+2<n && nums[i+2]==nums[i]){\\n                if(func(nums,i+3,dp))\\n                 return dp[i]=true;\\n             }\\n         }\\n        if(i+2<n && nums[i+1]==nums[i]+1 && nums[i+2]==nums[i]+2){\\n            if(func(nums,i+3,dp))\\n            return dp[i]=true;\\n        }\\n        return dp[i]=false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n+1,-1);\\n        return func(nums,0,dp);\\n    }\\n    \\n    bool func(vector<int> &nums,int i,vector<int> &dp){\\n        int n=nums.size();\\n        if(i==nums.size()){\\n            return true;\\n        }\\n        if(dp[i]!=-1) return dp[i];\\n            \\n         if(i+1<n && nums[i+1]==nums[i]){\\n             if(func(nums,i+2,dp))\\n             return dp[i]=true;\\n             \\n             if(i+2<n && nums[i+2]==nums[i]){\\n                if(func(nums,i+3,dp))\\n                 return dp[i]=true;\\n             }\\n         }\\n        if(i+2<n && nums[i+1]==nums[i]+1 && nums[i+2]==nums[i]+2){\\n            if(func(nums,i+3,dp))\\n            return dp[i]=true;\\n        }\\n        return dp[i]=false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2413470,
                "title": "swift-fastest-dp-with-short-circuit",
                "content": "**DP with Short-Circuit and O(1) storage (accepted answer)**\\n```\\nclass Solution {\\n    func validPartition(_ nums: [Int]) -> Bool {\\n        var dp = [false, nums[0] == nums[1], false, true]\\n        var lastPartitionIndex = 0\\n        \\n        for i in nums.indices.dropFirst(2) {\\n            let doubleFound = nums[i] == nums[i-1]\\n            let tripleFound = doubleFound && nums[i] == nums[i-2]\\n            let seqFound = nums[i] == nums[i-1] + 1 && nums[i] == nums[i-2] + 2\\n            dp[i & 3] = (dp[(i-3) & 3] && (seqFound || tripleFound)) || (dp[(i-2) & 3] && doubleFound)\\n            if dp[i & 3] {\\n                lastPartitionIndex = i\\n            } else if i - lastPartitionIndex > 3 { \\n                // more than three elements have passed w/o partition\\n                // array cannot be partitioned, so short-circuit\\n                return false \\n            }          \\n        }\\n        \\n        return dp[(nums.count-1) & 3]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func validPartition(_ nums: [Int]) -> Bool {\\n        var dp = [false, nums[0] == nums[1], false, true]\\n        var lastPartitionIndex = 0\\n        \\n        for i in nums.indices.dropFirst(2) {\\n            let doubleFound = nums[i] == nums[i-1]\\n            let tripleFound = doubleFound && nums[i] == nums[i-2]\\n            let seqFound = nums[i] == nums[i-1] + 1 && nums[i] == nums[i-2] + 2\\n            dp[i & 3] = (dp[(i-3) & 3] && (seqFound || tripleFound)) || (dp[(i-2) & 3] && doubleFound)\\n            if dp[i & 3] {\\n                lastPartitionIndex = i\\n            } else if i - lastPartitionIndex > 3 { \\n                // more than three elements have passed w/o partition\\n                // array cannot be partitioned, so short-circuit\\n                return false \\n            }          \\n        }\\n        \\n        return dp[(nums.count-1) & 3]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407898,
                "title": "c-easy-memoiazation",
                "content": "**C++ CODE**\\n\\n```\\n // Memoiazation\\n   bool f(vector<int>& nums,int i,vector<int>&dp)\\n    {\\n        //Base Case\\n        if(i==nums.size()) return true;\\n        if(dp[i]!=-1) return dp[i];\\n       \\n        //Case 1: 2 elements are equal\\n        if(i+1<nums.size() && nums[i]==nums[i+1])\\n        {\\n            if(f(nums,i+2,dp)) return dp[i] = true;\\n        // Case 2: 3 elements are equal\\n        if(i+2<nums.size() && nums[i+1]==nums[i+2]) \\n         if(f(nums,i+3,dp)) return dp[i] = true;\\n        }\\n        \\n        //Case 3: 3 elements are consecutive\\n        if(i+2< nums.size() && nums[i+1]==nums[i]+1 && nums[i+2]==nums[i]+2)\\n        if(f(nums,i+3,dp)) return dp[i] = true;\\n       return dp[i] = false;\\n        \\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return f(nums,0,dp);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n // Memoiazation\\n   bool f(vector<int>& nums,int i,vector<int>&dp)\\n    {\\n        //Base Case\\n        if(i==nums.size()) return true;\\n        if(dp[i]!=-1) return dp[i];\\n       \\n        //Case 1: 2 elements are equal\\n        if(i+1<nums.size() && nums[i]==nums[i+1])\\n        {\\n            if(f(nums,i+2,dp)) return dp[i] = true;\\n        // Case 2: 3 elements are equal\\n        if(i+2<nums.size() && nums[i+1]==nums[i+2]) \\n         if(f(nums,i+3,dp)) return dp[i] = true;\\n        }\\n        \\n        //Case 3: 3 elements are consecutive\\n        if(i+2< nums.size() && nums[i+1]==nums[i]+1 && nums[i+2]==nums[i]+2)\\n        if(f(nums,i+3,dp)) return dp[i] = true;\\n       return dp[i] = false;\\n        \\n    }\\n    bool validPartition(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return f(nums,0,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402831,
                "title": "python-top-down-dp-o-n",
                "content": "```\\nfrom functools import cache\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        @cache\\n        def dfs(i):\\n            if i == n: return True\\n            res = False\\n            if i+1 < n and nums[i] == nums[i+1]:\\n                res = res or dfs(i+2)\\n                if i+2 < n and nums[i+1] == nums[i+2]:\\n                    res = res or dfs(i+3)\\n            if i+2 < n and nums[i]+1 == nums[i+1] and nums[i+1]+1 == nums[i+2]:\\n                res = res or dfs(i+3)\\n            return res\\n        return dfs(0)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        @cache\\n        def dfs(i):\\n            if i == n: return True\\n            res = False\\n            if i+1 < n and nums[i] == nums[i+1]:\\n                res = res or dfs(i+2)\\n                if i+2 < n and nums[i+1] == nums[i+2]:\\n                    res = res or dfs(i+3)\\n            if i+2 < n and nums[i]+1 == nums[i+1] and nums[i+1]+1 == nums[i+2]:\\n                res = res or dfs(i+3)\\n            return res\\n        return dfs(0)",
                "codeTag": "Java"
            },
            {
                "id": 2401891,
                "title": "python-easy-dp-solution",
                "content": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [0]*(n+1)\\n        dp[0] = 1\\n        for i in range(2,n+1):\\n            if nums[i-1]==nums[i-2]:\\n                dp[i] |= dp[i-2]\\n            if i>=3 and nums[i-1]==nums[i-2]==nums[i-3]:\\n                dp[i]|=dp[i-3]\\n            \\n            if i>=3 and nums[i-1]==nums[i-2]+1==nums[i-3]+2:\\n                dp[i]|=dp[i-3]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [0]*(n+1)\\n        dp[0] = 1\\n        for i in range(2,n+1):\\n            if nums[i-1]==nums[i-2]:\\n                dp[i] |= dp[i-2]\\n            if i>=3 and nums[i-1]==nums[i-2]==nums[i-3]:\\n                dp[i]|=dp[i-3]\\n            \\n            if i>=3 and nums[i-1]==nums[i-2]+1==nums[i-3]+2:\\n                dp[i]|=dp[i-3]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399819,
                "title": "java-6-ms-one-pass-dp-faster-than-100-00-less-than-90-91",
                "content": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        boolean[] canPartition = new boolean[nums.length+1];\\n        canPartition[0] = true;\\n        // canPartition[1] = false; // cannot partition at first element (nums[0])\\n        int diff = nums[1]-nums[0];\\n        boolean equal = diff == 0;\\n        boolean incOne = diff == 1;\\n        canPartition[2] = equal & canPartition[0]; // if nums[0) == nums[1], can partition at nums[1]\\n\\t\\t// count means the consecutive num cannot be partitioned -> Over 3, return false\\n        int count = canPartition[2] ? 0 : 2;\\n        \\n        for (int i = 3; i < canPartition.length; i++) {            \\n            diff = nums[i-1]-nums[i-2];\\n            if (diff == 0) {\\n                canPartition[i] = canPartition[i-2] || (equal && canPartition[i-3]);\\n                equal = true;\\n                incOne = false;\\n            } else if (diff == 1) {\\n                canPartition[i] = incOne && canPartition[i-3];\\n                equal = false;\\n                incOne = true;\\n            } else if (canPartition[i-1]) {\\n                equal = false;\\n                incOne = false;\\n            } else return false;\\n            \\n            if (canPartition[i]) count = 0;\\n            else if (count == 2) return false;\\n            else count++;\\n        }\\n        return canPartition[nums.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        boolean[] canPartition = new boolean[nums.length+1];\\n        canPartition[0] = true;\\n        // canPartition[1] = false; // cannot partition at first element (nums[0])\\n        int diff = nums[1]-nums[0];\\n        boolean equal = diff == 0;\\n        boolean incOne = diff == 1;\\n        canPartition[2] = equal & canPartition[0]; // if nums[0) == nums[1], can partition at nums[1]\\n\\t\\t// count means the consecutive num cannot be partitioned -> Over 3, return false\\n        int count = canPartition[2] ? 0 : 2;\\n        \\n        for (int i = 3; i < canPartition.length; i++) {            \\n            diff = nums[i-1]-nums[i-2];\\n            if (diff == 0) {\\n                canPartition[i] = canPartition[i-2] || (equal && canPartition[i-3]);\\n                equal = true;\\n                incOne = false;\\n            } else if (diff == 1) {\\n                canPartition[i] = incOne && canPartition[i-3];\\n                equal = false;\\n                incOne = true;\\n            } else if (canPartition[i-1]) {\\n                equal = false;\\n                incOne = false;\\n            } else return false;\\n            \\n            if (canPartition[i]) count = 0;\\n            else if (count == 2) return false;\\n            else count++;\\n        }\\n        return canPartition[nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399276,
                "title": "sc-o-1-special-optimization-to-space-2-approach",
                "content": "Simple Memoization : Time Complexity : O(N)  || Space Complexity : O(N)\\n**No Optimization is done here**\\n```\\nclass Solution {\\n    Boolean dp[];\\n    boolean recurse(int[] nums, int ind){\\n        if(dp[ind]!=null) return dp[ind];\\n        int n=nums.length;\\n        if((n-ind)>=2 && nums[ind]==nums[ind+1] && recurse(nums,ind+2)){\\n            return dp[ind]=true;\\n        }else if((n-ind)>=3 && \\n                ((nums[ind]==nums[ind+1] && nums[ind]==nums[ind+2]) ||\\n                (nums[ind]==(nums[ind+1]-1) && nums[ind]==(nums[ind+2]-2))) &&\\n                recurse(nums,ind+3))\\n            return dp[ind]=true;\\n        return dp[ind]=false;\\n    }\\n    public boolean validPartition(int[] nums) {\\n        dp = new Boolean[nums.length+1];\\n        dp[nums.length]=true;\\n        return recurse(nums,0);\\n    }\\n}\\n```\\nOptimized Memoization : Time Complexity : O(N)  || Space Complexity : O(1)\\n**No cache memory is made here**\\n(All the changes were done to the original `nums` array to improve the space)\\n```\\nclass Solution {\\n    int n,N=10000000;\\n    boolean recurse(int[] nums, int ind){\\n        if(ind==n) return true;\\n        if(nums[ind]>=N) return (nums[ind]/N)==1;\\n        if((n-ind)>=2 && nums[ind]%N==nums[ind+1]%N && recurse(nums,ind+2)){\\n            return ((nums[ind]=(nums[ind]%N+N))/N)==1;\\n        }else if((n-ind)>=3 && \\n                (((nums[ind]%N)==(nums[ind+1]%N) && (nums[ind]%N)==(nums[ind+2]%N)) ||\\n                ((nums[ind]%N)==(nums[ind+1]%N-1) && (nums[ind]%N)==(nums[ind+2]%N-2))) &&\\n                recurse(nums,ind+3)){\\n            return ((nums[ind]=(nums[ind]%N+N))/N)==1;\\n        }\\n        return ((nums[ind]=(nums[ind]%N+N+N))/N)==1;\\n    }\\n    public boolean validPartition(int[] nums) {\\n        n=nums.length;\\n        return recurse(nums,0);\\n    }\\n}\\n```\\nIn the above code, if nums[i] is -->\\n* less than `N` then i havent computed the the dp array.\\n* more than `N` and less than `2N`, then it is computed and for index `i` and the subarray is valid.\\n* more than `2N`, then it is computed and for index `i` and the subarray is invalid\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[];\\n    boolean recurse(int[] nums, int ind){\\n        if(dp[ind]!=null) return dp[ind];\\n        int n=nums.length;\\n        if((n-ind)>=2 && nums[ind]==nums[ind+1] && recurse(nums,ind+2)){\\n            return dp[ind]=true;\\n        }else if((n-ind)>=3 && \\n                ((nums[ind]==nums[ind+1] && nums[ind]==nums[ind+2]) ||\\n                (nums[ind]==(nums[ind+1]-1) && nums[ind]==(nums[ind+2]-2))) &&\\n                recurse(nums,ind+3))\\n            return dp[ind]=true;\\n        return dp[ind]=false;\\n    }\\n    public boolean validPartition(int[] nums) {\\n        dp = new Boolean[nums.length+1];\\n        dp[nums.length]=true;\\n        return recurse(nums,0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int n,N=10000000;\\n    boolean recurse(int[] nums, int ind){\\n        if(ind==n) return true;\\n        if(nums[ind]>=N) return (nums[ind]/N)==1;\\n        if((n-ind)>=2 && nums[ind]%N==nums[ind+1]%N && recurse(nums,ind+2)){\\n            return ((nums[ind]=(nums[ind]%N+N))/N)==1;\\n        }else if((n-ind)>=3 && \\n                (((nums[ind]%N)==(nums[ind+1]%N) && (nums[ind]%N)==(nums[ind+2]%N)) ||\\n                ((nums[ind]%N)==(nums[ind+1]%N-1) && (nums[ind]%N)==(nums[ind+2]%N-2))) &&\\n                recurse(nums,ind+3)){\\n            return ((nums[ind]=(nums[ind]%N+N))/N)==1;\\n        }\\n        return ((nums[ind]=(nums[ind]%N+N+N))/N)==1;\\n    }\\n    public boolean validPartition(int[] nums) {\\n        n=nums.length;\\n        return recurse(nums,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398774,
                "title": "memorization",
                "content": "```\\nclass Solution {\\n    Boolean[] dp;\\n    public boolean validPartition(int[] nums) {\\n        dp = new Boolean[nums.length+1];\\n        Arrays.fill(dp,null);\\n        return recurr(nums,0);\\n    }\\n    public boolean recurr(int[] nums, int pos){\\n        if(pos==nums.length) return true;\\n        boolean ans=false;\\n        if(dp[pos]!=null) return dp[pos];\\n        if(pos+1<nums.length && nums[pos]==nums[pos+1]) ans = ans || recurr(nums,pos+2);\\n        if(pos+2<nums.length && nums[pos]==nums[pos+1] && nums[pos+1]==nums[pos+2]) ans = ans || recurr(nums,pos+3);\\n        if(pos+2<nums.length && nums[pos]+1==nums[pos+1] && nums[pos+1]+1==nums[pos+2]) ans = ans || recurr(nums,pos+3);\\n        return dp[pos] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[] dp;\\n    public boolean validPartition(int[] nums) {\\n        dp = new Boolean[nums.length+1];\\n        Arrays.fill(dp,null);\\n        return recurr(nums,0);\\n    }\\n    public boolean recurr(int[] nums, int pos){\\n        if(pos==nums.length) return true;\\n        boolean ans=false;\\n        if(dp[pos]!=null) return dp[pos];\\n        if(pos+1<nums.length && nums[pos]==nums[pos+1]) ans = ans || recurr(nums,pos+2);\\n        if(pos+2<nums.length && nums[pos]==nums[pos+1] && nums[pos+1]==nums[pos+2]) ans = ans || recurr(nums,pos+3);\\n        if(pos+2<nums.length && nums[pos]+1==nums[pos+1] && nums[pos+1]+1==nums[pos+2]) ans = ans || recurr(nums,pos+3);\\n        return dp[pos] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397985,
                "title": "c-simple-dp-solution-explained",
                "content": "**Approach:**\\n\\n* ```dp[i] = if the array can be partitioned up to the ith element or not```\\n* ```ans = dp[n-1]```\\n* For element dp[i], the partition is valid if:\\n\\t* dp[i - 2] == true and we have a partition of two elements, or,\\n\\t* dp[i - 3] == true and we have a partition of three elements.\\n* x = condition to check if there is a valid partition of two elements\\n* y = condition to check if there is a valid partition of three elements\\n* note that we can optimize the space by using a dp array of size 4 only as we only need to look back 3 positions\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    bool validPartition(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        vector<bool> dp(n, false);\\n        dp[1] = nums[0] == nums[1];\\n        for (int i = 2; i < n; i++)\\n        {\\n            bool x = (nums[i] == nums[i - 1]); \\n            bool y = ((nums[i] == nums[i - 1] && nums[i - 1] == nums[i - 2]) || (nums[i] - nums[i - 1] == 1 && nums[i - 1] - nums[i - 2] == 1));\\n            dp[i] = (x && ((i - 2) >= 0 ? dp[i - 2] : true) || y && ((i - 3) >= 0 ? dp[i - 3] : true));\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```dp[i] = if the array can be partitioned up to the ith element or not```\n```ans = dp[n-1]```\n```\\nclass Solution\\n{\\npublic:\\n    bool validPartition(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        vector<bool> dp(n, false);\\n        dp[1] = nums[0] == nums[1];\\n        for (int i = 2; i < n; i++)\\n        {\\n            bool x = (nums[i] == nums[i - 1]); \\n            bool y = ((nums[i] == nums[i - 1] && nums[i - 1] == nums[i - 2]) || (nums[i] - nums[i - 1] == 1 && nums[i - 1] - nums[i - 2] == 1));\\n            dp[i] = (x && ((i - 2) >= 0 ? dp[i - 2] : true) || y && ((i - 3) >= 0 ? dp[i - 3] : true));\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393909,
                "title": "easy-understanding-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<int>vis(nums.size(),0);\\n        if(nums[0]==nums[1]){\\n            vis[1]=1;\\n        }\\n        if(nums.size()>2){\\n            if(nums[0]+1==nums[1] && nums[1]+1==nums[2]){\\n                vis[2]=1;\\n            }\\n            if(nums[0]==nums[1] && nums[1]==nums[2])\\n                vis[2]=1;\\n        }\\n        \\n        for(int i=3;i<nums.size();i++){\\n            if(nums[i]==nums[i-1] && vis[i-2]==1)\\n                vis[i]=1;\\n            if(nums[i]==nums[i-1] && nums[i-1]==nums[i-2] && vis[i-3]==1)\\n                vis[i]=1;\\n            if(nums[i]==nums[i-1]+1 && nums[i-1]==nums[i-2]+1 && vis[i-3]==1)\\n                vis[i]=1;\\n        }\\n        \\n        return vis[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<int>vis(nums.size(),0);\\n        if(nums[0]==nums[1]){\\n            vis[1]=1;\\n        }\\n        if(nums.size()>2){\\n            if(nums[0]+1==nums[1] && nums[1]+1==nums[2]){\\n                vis[2]=1;\\n            }\\n            if(nums[0]==nums[1] && nums[1]==nums[2])\\n                vis[2]=1;\\n        }\\n        \\n        for(int i=3;i<nums.size();i++){\\n            if(nums[i]==nums[i-1] && vis[i-2]==1)\\n                vis[i]=1;\\n            if(nums[i]==nums[i-1] && nums[i-1]==nums[i-2] && vis[i-3]==1)\\n                vis[i]=1;\\n            if(nums[i]==nums[i-1]+1 && nums[i-1]==nums[i-2]+1 && vis[i-3]==1)\\n                vis[i]=1;\\n        }\\n        \\n        return vis[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393420,
                "title": "java-dp-o-n",
                "content": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        boolean[] dp = new boolean[nums.length+1];\\n        dp[0] = true;\\n        dp[2] = (nums[0] == nums[1]);\\n        for (int i = 2; i < nums.length; i++) {\\n            boolean a = dp[i-2] && (nums[i] == nums[i-1] && nums[i-1] == nums[i-2]);\\n            boolean b = dp[i-2] && (nums[i] - nums[i-1] == 1 && nums[i] - nums[i-2] == 2);\\n            boolean c = dp[i-1] && (nums[i] == nums[i-1]);\\n            dp[i+1] = a||b||c;\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPartition(int[] nums) {\\n        boolean[] dp = new boolean[nums.length+1];\\n        dp[0] = true;\\n        dp[2] = (nums[0] == nums[1]);\\n        for (int i = 2; i < nums.length; i++) {\\n            boolean a = dp[i-2] && (nums[i] == nums[i-1] && nums[i-1] == nums[i-2]);\\n            boolean b = dp[i-2] && (nums[i] - nums[i-1] == 1 && nums[i] - nums[i-2] == 2);\\n            boolean c = dp[i-1] && (nums[i] == nums[i-1]);\\n            dp[i+1] = a||b||c;\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392326,
                "title": "2-approach-recursion-dp-space-time-o-n",
                "content": "Recursion!!\\n```\\nclass Solution {\\npublic:\\n    vector<int>a;\\n    bool fun(int i){\\n        if(i==-1)return true;\\n        if(i<=0)return false;\\n        \\n        if(a[i]==a[i-1]){\\n            if(fun(i-2))return true;\\n            if(i>=2&&a[i]==a[i-2]){\\n                return fun(i-3);\\n            }\\n            return false;\\n        }\\n        if(i<2)return false;\\n        if(a[i]==a[i-1]+1&&a[i]==a[i-2]+2){\\n            return fun(i-3);\\n        }\\n        return false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        a=nums;\\n        return fun(nums.size()-1);\\n    }\\n};\\n```\\nDp(Tabulation)\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& a) {\\n        int n=a.size();\\n        // dp[i]-> whether partition till i th indx is possible or not!\\n        vector<bool>dp(n+1,false);\\n        dp[0]=true;\\n        for(int i=2;i<=n;i++){\\n            int indx=i-1;\\n            if(a[indx]==a[indx-1]){\\n                dp[i]=dp[i-2];\\n            }\\n            if(i<3)continue;\\n            if(a[indx]==a[indx-1]&&a[indx]==a[indx-2]){\\n                dp[i]=dp[i]||dp[i-3];\\n            }\\n            else if(a[indx]==a[indx-1]+1&&a[indx]==a[indx-2]+2){\\n                dp[i]=dp[i-3];\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>a;\\n    bool fun(int i){\\n        if(i==-1)return true;\\n        if(i<=0)return false;\\n        \\n        if(a[i]==a[i-1]){\\n            if(fun(i-2))return true;\\n            if(i>=2&&a[i]==a[i-2]){\\n                return fun(i-3);\\n            }\\n            return false;\\n        }\\n        if(i<2)return false;\\n        if(a[i]==a[i-1]+1&&a[i]==a[i-2]+2){\\n            return fun(i-3);\\n        }\\n        return false;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        a=nums;\\n        return fun(nums.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& a) {\\n        int n=a.size();\\n        // dp[i]-> whether partition till i th indx is possible or not!\\n        vector<bool>dp(n+1,false);\\n        dp[0]=true;\\n        for(int i=2;i<=n;i++){\\n            int indx=i-1;\\n            if(a[indx]==a[indx-1]){\\n                dp[i]=dp[i-2];\\n            }\\n            if(i<3)continue;\\n            if(a[indx]==a[indx-1]&&a[indx]==a[indx-2]){\\n                dp[i]=dp[i]||dp[i-3];\\n            }\\n            else if(a[indx]==a[indx-1]+1&&a[indx]==a[indx-2]+2){\\n                dp[i]=dp[i-3];\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392163,
                "title": "c-dp-memorization-easy-to-understand",
                "content": "Three cases :\\n\\ncheck for 2 consicutive are equal\\ncheck for 3 consicutive are equal\\ncheck for 3 increasing numbers\\nRecursively call for above conditions and use memorisation fo faster execution\\n\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int> &nums,int i,vector<int> &dp)\\n    {\\n        int n = nums.size();\\n        if(i == n) return true;\\n        \\n        if(dp[i] != -1) return dp[i];\\n        \\n        bool res = false;\\n        if(i+1 < n && nums[i] == nums[i+1])\\n        {\\n            res = f(nums,i+2,dp);\\n            if(i+2 < n && nums[i] == nums[i+2])\\n                res = res || f(nums,i+3,dp);\\n        }\\n        \\n        if(i+2 <n && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1)\\n            res = res || f(nums,i+3,dp);\\n        \\n        return dp[i] = res;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 2)\\n            return nums[0] == nums[1];\\n        \\n        vector<int> dp(n,-1);\\n        return f(nums,0,dp);\\n    }\\n};\\n```\\n\\n**Do not forget to upvote if you like the solution**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int> &nums,int i,vector<int> &dp)\\n    {\\n        int n = nums.size();\\n        if(i == n) return true;\\n        \\n        if(dp[i] != -1) return dp[i];\\n        \\n        bool res = false;\\n        if(i+1 < n && nums[i] == nums[i+1])\\n        {\\n            res = f(nums,i+2,dp);\\n            if(i+2 < n && nums[i] == nums[i+2])\\n                res = res || f(nums,i+3,dp);\\n        }\\n        \\n        if(i+2 <n && nums[i+1] - nums[i] == 1 && nums[i+2] - nums[i+1] == 1)\\n            res = res || f(nums,i+3,dp);\\n        \\n        return dp[i] = res;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 2)\\n            return nums[0] == nums[1];\\n        \\n        vector<int> dp(n,-1);\\n        return f(nums,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392061,
                "title": "top-down-dp-noobie-looong-solution",
                "content": "Wasn\\'t able to implement this within contest time limits \\uD83D\\uDE22\\nSince I don\\'t have much DP experience, had to go freestyle and ended up coding a long sol.\\n\\n```py\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n\\n        @cache\\n        def go(ind):\\n            if ind == n:\\n                return True\\n            \\n            count = 3\\n            prev = None\\n            sol1 = sol2 = sol3 = sol4 = False\\n            sol4_flag = True\\n            \\n            while count and ind < n:\\n                count -= 1\\n                if prev is None:\\n                    prev = nums[ind]\\n\\n                elif nums[ind] == prev:\\n                    if count == 1:\\n                        sol1 = go(ind + 1)\\n\\n                elif nums[ind] != prev:\\n                    sol4_flag = False\\n                    if count == 0:\\n                        sol2 = go(ind)\\n\\n                    else:\\n                        count = 2\\n                        bf = 0\\n                        while count and ind < n:\\n                            count -= 1\\n                            if nums[ind] - prev != 1:\\n                                bf = 1\\n                                break\\n                            prev = nums[ind]\\n                            ind += 1\\n\\n                        if count == bf == 0:\\n                            sol3 = go(ind)\\n\\n                        break\\n\\n                prev = nums[ind]\\n                ind += 1\\n\\n            if sol4_flag and count == 0:\\n                sol4 = go(ind)\\n\\n            if sol1 or sol2 or sol4 or sol3:\\n                return True\\n            return False\\n\\n        return go(0)\\n```\\n\\n**Happy Coding !!**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```py\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n\\n        @cache\\n        def go(ind):\\n            if ind == n:\\n                return True\\n            \\n            count = 3\\n            prev = None\\n            sol1 = sol2 = sol3 = sol4 = False\\n            sol4_flag = True\\n            \\n            while count and ind < n:\\n                count -= 1\\n                if prev is None:\\n                    prev = nums[ind]\\n\\n                elif nums[ind] == prev:\\n                    if count == 1:\\n                        sol1 = go(ind + 1)\\n\\n                elif nums[ind] != prev:\\n                    sol4_flag = False\\n                    if count == 0:\\n                        sol2 = go(ind)\\n\\n                    else:\\n                        count = 2\\n                        bf = 0\\n                        while count and ind < n:\\n                            count -= 1\\n                            if nums[ind] - prev != 1:\\n                                bf = 1\\n                                break\\n                            prev = nums[ind]\\n                            ind += 1\\n\\n                        if count == bf == 0:\\n                            sol3 = go(ind)\\n\\n                        break\\n\\n                prev = nums[ind]\\n                ind += 1\\n\\n            if sol4_flag and count == 0:\\n                sol4 = go(ind)\\n\\n            if sol1 or sol2 or sol4 or sol3:\\n                return True\\n            return False\\n\\n        return go(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391828,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[100005];\\n    \\n    bool helper(vector<int>& nums, int i, int n)\\n    {\\n        // base case, we have reached the end of nums then we got one partition\\n        \\n        if(i == n)\\n            return true;\\n        \\n        if(i > n)\\n            return false;\\n        \\n        // if already calculated\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        // take exactly two equals\\n        \\n        if(i + 1 < n && nums[i] == nums[i + 1])\\n        {\\n            if(helper(nums, i + 2, n))\\n                return dp[i] = true;\\n        }\\n        \\n        // take exactly three equal\\n        \\n        if(i + 2 < n && nums[i] == nums[i + 1] && nums[i + 1] == nums[i + 2])\\n        {\\n            if(helper(nums, i + 3, n))\\n                return dp[i] = true;\\n        }\\n        \\n        // take exactly three consecutive numbers\\n     \\n        if(i + 2 < n && nums[i] + 1 == nums[i + 1] && nums[i + 1] + 1 == nums[i + 2])\\n        {\\n            if(helper(nums, i + 3, n))\\n                return dp[i] = true;\\n        }\\n        \\n        return dp[i] = false;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(nums, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[100005];\\n    \\n    bool helper(vector<int>& nums, int i, int n)\\n    {\\n        // base case, we have reached the end of nums then we got one partition\\n        \\n        if(i == n)\\n            return true;\\n        \\n        if(i > n)\\n            return false;\\n        \\n        // if already calculated\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        // take exactly two equals\\n        \\n        if(i + 1 < n && nums[i] == nums[i + 1])\\n        {\\n            if(helper(nums, i + 2, n))\\n                return dp[i] = true;\\n        }\\n        \\n        // take exactly three equal\\n        \\n        if(i + 2 < n && nums[i] == nums[i + 1] && nums[i + 1] == nums[i + 2])\\n        {\\n            if(helper(nums, i + 3, n))\\n                return dp[i] = true;\\n        }\\n        \\n        // take exactly three consecutive numbers\\n     \\n        if(i + 2 < n && nums[i] + 1 == nums[i + 1] && nums[i + 1] + 1 == nums[i + 2])\\n        {\\n            if(helper(nums, i + 3, n))\\n                return dp[i] = true;\\n        }\\n        \\n        return dp[i] = false;\\n    }\\n    \\n    bool validPartition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(nums, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391691,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        int dp[n];\\n        // dp[i] denoted whether array till 0....i can be partitioned or not\\n        dp[0]=false;\\n        dp[1]=(nums[1]==nums[0]);\\n        if(n>2)dp[2]=(nums[2]==nums[1]&&dp[1])||(nums[2]-1==nums[1]&&nums[1]-1==nums[0]);\\n        for(int i=3;i<n;++i)\\n        {\\n           if((nums[i]==nums[i-1]&&dp[i-2])||(((nums[i]==nums[i-1]&&nums[i-1]==nums[i-2])||(nums[i]-1==nums[i-1]&&nums[i-1]-1==nums[i-2]))&&(i-3>=0?dp[i-3]:true)))\\n           {\\n               dp[i]=true; \\n           }\\n           else dp[i]=false;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        int dp[n];\\n        // dp[i] denoted whether array till 0....i can be partitioned or not\\n        dp[0]=false;\\n        dp[1]=(nums[1]==nums[0]);\\n        if(n>2)dp[2]=(nums[2]==nums[1]&&dp[1])||(nums[2]-1==nums[1]&&nums[1]-1==nums[0]);\\n        for(int i=3;i<n;++i)\\n        {\\n           if((nums[i]==nums[i-1]&&dp[i-2])||(((nums[i]==nums[i-1]&&nums[i-1]==nums[i-2])||(nums[i]-1==nums[i-1]&&nums[i-1]-1==nums[i-2]))&&(i-3>=0?dp[i-3]:true)))\\n           {\\n               dp[i]=true; \\n           }\\n           else dp[i]=false;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391438,
                "title": "simple-java-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    Boolean[] dp;\\n    int n;\\n    public boolean validPartition(int[] nums) {\\n        n=nums.length;\\n        dp=new Boolean[n];\\n        return isValid(nums,0);\\n    }\\n    public boolean isValid(int[] nums,int i){\\n        if(i==n) return true;\\n        boolean flag1=false;\\n        boolean flag2=false;\\n        boolean flag3=false;\\n        if(dp[i]==null){\\n            //Case1\\n            if(i<n-1 && nums[i]==nums[i+1]){\\n                flag1=isValid(nums,i+2);\\n            }\\n            //Case2\\n            if(i<n-2 && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n                flag2=isValid(nums,i+3);\\n            }\\n            //Case3\\n            if(i<n-2 && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n                flag3=isValid(nums,i+3);\\n            }\\n            dp[i]=flag1||flag2||flag3;\\n        }\\n        return dp[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[] dp;\\n    int n;\\n    public boolean validPartition(int[] nums) {\\n        n=nums.length;\\n        dp=new Boolean[n];\\n        return isValid(nums,0);\\n    }\\n    public boolean isValid(int[] nums,int i){\\n        if(i==n) return true;\\n        boolean flag1=false;\\n        boolean flag2=false;\\n        boolean flag3=false;\\n        if(dp[i]==null){\\n            //Case1\\n            if(i<n-1 && nums[i]==nums[i+1]){\\n                flag1=isValid(nums,i+2);\\n            }\\n            //Case2\\n            if(i<n-2 && nums[i]==nums[i+1] && nums[i+1]==nums[i+2]){\\n                flag2=isValid(nums,i+3);\\n            }\\n            //Case3\\n            if(i<n-2 && nums[i+1]-nums[i]==1 && nums[i+2]-nums[i+1]==1){\\n                flag3=isValid(nums,i+3);\\n            }\\n            dp[i]=flag1||flag2||flag3;\\n        }\\n        return dp[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391220,
                "title": "c-iterative-dp-simple-implementation",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n\\t\\t//dp[i+1] stores true when there is a valid partitioned array till nums[i] elements\\n        bool dp[n+1];\\n        dp[0]=1,dp[1]=0,dp[2]=nums[1]==nums[0]?1:0;\\n        for(int i=2;i<n;i++)\\n        {\\n            dp[i+1]=0;\\n            if(nums[i]==nums[i-1])\\n                dp[i+1]|=dp[i-1];\\n            if(i>=2&&nums[i]==nums[i-1]&&nums[i-1]==nums[i-2])\\n                dp[i+1]|=dp[i-2];\\n            if(i>=2&&nums[i]-nums[i-1]==1&&nums[i-1]-nums[i-2]==1)\\n                dp[i+1]|=dp[i-2];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n\\t\\t//dp[i+1] stores true when there is a valid partitioned array till nums[i] elements\\n        bool dp[n+1];\\n        dp[0]=1,dp[1]=0,dp[2]=nums[1]==nums[0]?1:0;\\n        for(int i=2;i<n;i++)\\n        {\\n            dp[i+1]=0;\\n            if(nums[i]==nums[i-1])\\n                dp[i+1]|=dp[i-1];\\n            if(i>=2&&nums[i]==nums[i-1]&&nums[i-1]==nums[i-2])\\n                dp[i+1]|=dp[i-2];\\n            if(i>=2&&nums[i]-nums[i-1]==1&&nums[i-1]-nums[i-2]==1)\\n                dp[i+1]|=dp[i-2];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391096,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dynamic-programming-iterative",
                "content": "```C#\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        bool[] dp = new bool[nums.Length + 1];\\n        dp[0] = true;\\n        \\n        for (int i = 0; i < nums.Length; i++) {\\n            if (dp[i]) {\\n                if (i < nums.Length - 1 && nums[i] == nums[i + 1]) dp[i + 2] = true;\\n                if (i < nums.Length - 2 && nums[i] == nums[i + 1] && nums[i + 1] == nums[i + 2]) dp[i + 3] = true;\\n                if (i < nums.Length - 2 && nums[i] + 1 == nums[i + 1] && nums[i + 1] + 1 == nums[i + 2]) dp[i + 3] = true;\\n            }\\n        }\\n        \\n        return dp[nums.Length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```C#\\npublic class Solution {\\n    public bool ValidPartition(int[] nums) {\\n        bool[] dp = new bool[nums.Length + 1];\\n        dp[0] = true;\\n        \\n        for (int i = 0; i < nums.Length; i++) {\\n            if (dp[i]) {\\n                if (i < nums.Length - 1 && nums[i] == nums[i + 1]) dp[i + 2] = true;\\n                if (i < nums.Length - 2 && nums[i] == nums[i + 1] && nums[i + 1] == nums[i + 2]) dp[i + 3] = true;\\n                if (i < nums.Length - 2 && nums[i] + 1 == nums[i + 1] && nums[i + 1] + 1 == nums[i + 2]) dp[i + 3] = true;\\n            }\\n        }\\n        \\n        return dp[nums.Length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391036,
                "title": "java-checking-3-conditions-simple-dp-using-recursion-and-memorization",
                "content": "\\n\\t\\n\\tclass Solution {\\n    \\n    public boolean validPartition(int[] nums) {\\n        \\n        Boolean dp[] = new Boolean[nums.length];\\n        return solution(0,nums,dp);\\n        \\n    }\\n    boolean solution(int i,int nums[],Boolean dp[]){\\n        \\n        \\n        if(i==nums.length)\\n            return true;\\n        if(dp[i]!=null)\\n            return dp[i];\\n        if(i+1 < nums.length)\\n        {\\n            if(nums[i]==nums[i+1] && solution(i+2,nums,dp))\\n            {\\n                dp[i]=true;\\n           return dp[i];\\n            }\\n        }\\n        if(i+2 < nums.length)\\n        {\\n            if(nums[i]==nums[i+1] && nums[i+1]==nums[i+2] && solution(i+3,nums,dp))\\n            {\\n                dp[i]=true;\\n           return dp[i];\\n            }\\n        }\\n        if(i+2 < nums.length)\\n       {\\n            if(nums[i+2]==1+nums[i+1] && nums[i+1]==1+nums[i] && solution(i+3,nums,dp))\\n            {\\n                dp[i]=true;\\n           return dp[i];\\n            }\\n        }\\n        return dp[i]=false;\\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public boolean validPartition(int[] nums) {\\n        \\n        Boolean dp[] = new Boolean[nums.length];\\n        return solution(0,nums,dp);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2391009,
                "title": "simple-13-lines-bottom-up-dp-solution-c-dp",
                "content": "# Please upvote \\uD83D\\uDE05\\n```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool> dp(n+1,false);\\n        dp[0]=true;\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(nums[i-1]==nums[i-2] and dp[i-2])\\n                dp[i]=true;\\n            if(i>=3 and nums[i-1]==nums[i-2] and nums[i-2]==nums[i-3] and dp[i-3])\\n                dp[i]=true;\\n            if(i>=3 and nums[i-1]-nums[i-2]==1 and nums[i-2]-nums[i-3]==1 and dp[i-3])\\n                dp[i]=true;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool> dp(n+1,false);\\n        dp[0]=true;\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(nums[i-1]==nums[i-2] and dp[i-2])\\n                dp[i]=true;\\n            if(i>=3 and nums[i-1]==nums[i-2] and nums[i-2]==nums[i-3] and dp[i-3])\\n                dp[i]=true;\\n            if(i>=3 and nums[i-1]-nums[i-2]==1 and nums[i-2]-nums[i-3]==1 and dp[i-3])\\n                dp[i]=true;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390899,
                "title": "top-down-dynamic-programming",
                "content": "```\\nclass Solution {\\n    int solve(int ind , int n , vector<int>& nums, vector<int>& dp){\\n        if(ind == n)\\n            return 1;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int ans = 0;\\n        if(ind + 1 < n && nums[ind] == nums[ind + 1])\\n            ans |= solve(ind + 2 , n , nums , dp);\\n        if(ind + 2 < n && nums[ind] == nums[ind + 1] && nums[ind] == nums[ind + 2])\\n            ans |= solve(ind + 3 , n , nums , dp);\\n        if(ind + 2 < n && nums[ind] + 1 == nums[ind + 1] && nums[ind] + 2 == nums[ind + 2])\\n            ans |= solve(ind + 3 , n , nums , dp);\\n        return dp[ind] = ans;\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp(n , -1);\\n        return solve(0 , n , nums, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int ind , int n , vector<int>& nums, vector<int>& dp){\\n        if(ind == n)\\n            return 1;\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int ans = 0;\\n        if(ind + 1 < n && nums[ind] == nums[ind + 1])\\n            ans |= solve(ind + 2 , n , nums , dp);\\n        if(ind + 2 < n && nums[ind] == nums[ind + 1] && nums[ind] == nums[ind + 2])\\n            ans |= solve(ind + 3 , n , nums , dp);\\n        if(ind + 2 < n && nums[ind] + 1 == nums[ind + 1] && nums[ind] + 2 == nums[ind + 2])\\n            ans |= solve(ind + 3 , n , nums , dp);\\n        return dp[ind] = ans;\\n    }\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp(n , -1);\\n        return solve(0 , n , nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1931951,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2012166,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011524,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011562,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011478,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011425,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 1941976,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011463,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011472,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 1913062,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 1931951,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2012166,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011524,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011562,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011478,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011425,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 1941976,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011463,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2011472,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 1913062,
                "content": [
                    {
                        "username": "priyanshu054",
                        "content": "According to the question nums should have at least one valid partion but it also showing nums = [1,1,1,2] as False....... How ??"
                    },
                    {
                        "username": "kamakaz1",
                        "content": "either the subarray has to have 3 consecutive elements or 20r 3 equal element in this case it doesnt have 3 consecutive element\\n"
                    },
                    {
                        "username": "trip1312",
                        "content": "Yeah the explanation is terrible. So I\\'m assuming the array needs to be divided into sub arrays where each sub array meets one of the three conditions?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "[@brb715](/brb715) Thanks "
                    },
                    {
                        "username": "victCh",
                        "content": "There wouldn\\'t be all this confusion if the word \\'partitioning\\' or \\'splitting\\' were used instead of \\'partition\\'"
                    },
                    {
                        "username": "brb715",
                        "content": "Every element of the array must be a part of a partition. if you take [1,1,1] then [2] does not satisfy any of the condition. Similarly, if you take [1,1] then [1,2] doesn\\'t satisfy any of the conditions. Therefore, FALSE."
                    },
                    {
                        "username": "Gaurav_nwh",
                        "content": "[1,2] contains only 2 consecutive increasing elements. We need 3 according to the condition."
                    },
                    {
                        "username": "Anuroop_",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni) [1,2] contains only 2 consecutive increasing elements. We need 3 consecutive increasing elements to satisfy the third condition"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "I was going to ask thee same 1st condition is satisfied then why?\\n"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "[@The_Shubham_Soni](/The_Shubham_Soni)  It\\'s not satisfying the 3rd condition because the 3rd condition requires 3 elements "
                    },
                    {
                        "username": "The_Shubham_Soni",
                        "content": "[@alwaysaditi](/alwaysaditi) but [1,1,1,2] follows: [1,1] 1st condition and [1,2] 3rd condition. It is satisfying then why false?"
                    },
                    {
                        "username": "VamC",
                        "content": "We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions,,,,,"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "[@amitcodder](/amitcodder) but here they have said \"one of the following condition  \" what should i take from that.."
                    },
                    {
                        "username": "htetminhlaing",
                        "content": "Apparently, all of the obtained subarrays need to satisfy the conditions....... which is considered as one valid partition."
                    },
                    {
                        "username": "udits0999",
                        "content": "no read 3rd point carefully , we can\\'t create sub array like [1,1] , [1,2] or [1,1,1], [2]\\nThat\\'s why the answer for this is false"
                    },
                    {
                        "username": "pavan_sai-1418",
                        "content": "The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not."
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Yeah, this is kind of misleading, it actually fulfills the first criteria. I think the phrasing could be better."
                    },
                    {
                        "username": "amitcodder",
                        "content": "you missed the 3rd condition.  3 consecutive increasing elements "
                    },
                    {
                        "username": "user5369RY",
                        "content": "The subarray consists of exactly 3 consecutive increasing ([1,1,1,1,2]) have 1,2 just tow  consecutive increasing  not three"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "Each of the subarrays obtained must satisfy one of the conditions for the partition to be valid"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "raise hand if, any one who thought easy after reading the question ... and then facing problem while coding the problem.... :)"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "I see many questions regarding the second test case. So, let me help you to better understand why it evaluates to false.\\n\\nFirst let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to the test case:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "Vishal8052",
                        "content": "Very confusing language. :(\\n\\n`The subarray consists of exactly 2 equal elements.`\\nI thought that a subarray can have any number of elements but exactly 2 elements must be equal. "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "yeah even i thought the same. But from 2nd test case you can see that it\\'s not true;"
                    },
                    {
                        "username": "minokazman",
                        "content": "same here"
                    },
                    {
                        "username": "user5400vw",
                        "content": "thank you leet code: you\\'ve drilled recursion + dp so much that even this problem seems routine."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I agree. LC has been puttin 2 weeks of daily DP. I also got to be much much better at DP, culminating with be resolving workBreak problem via Trie and DP (not using DP would cause TLE)."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@sanjayyyyyyy__](/sanjayyyyyyy__) remember the grind bruh. "
                    },
                    {
                        "username": "sanjayyyyyyy_",
                        "content": "bro you just demotivated me\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a DP problem. Set 1D array for DP\nHave you seen this?\n```\n[993335,993336,993337,993338,993339,993340,993341]\n```"
                    },
                    {
                        "username": "Lynn-is-me",
                        "content": "i had the same problem with you, remember adding conditions of parameter i (i>0, i>1) "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "dracky",
                        "content": "[@f20212168](/f20212168) i have used n-1 as dp size, it\\'s fine "
                    },
                    {
                        "username": "f20212168",
                        "content": "I think you might be using dp array of size n rather than n+1, so you will get wrong answer in that test case"
                    },
                    {
                        "username": "ssohamm",
                        "content": "when the array is split after index 3 ([993335, 993336, 993337] [993338, 993339, 993340, 993341]), the 3nd subarray contains 4 consecutive elements"
                    },
                    {
                        "username": "006arjunks",
                        "content": "this is similar to [1,2,3,4,5,6,7]\\nIf it was [1,2,3,4,5,6] would be true"
                    },
                    {
                        "username": "geekyshark",
                        "content": "getting TLE even after memoization, why god(insert crying emoji)"
                    },
                    {
                        "username": "kushalbanik",
                        "content": "Yes Its running 110/117 for me :\"\") (JAVA)"
                    },
                    {
                        "username": "aasthad27",
                        "content": "send array through reference \\n"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array through reference\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "The solution only accepts O(n) solution based on what I\\'ve experienced."
                    },
                    {
                        "username": "wave5902",
                        "content": "same, i tried partition dp."
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "[@dikshawali](/dikshawali)  are you passing by address?\\n"
                    },
                    {
                        "username": "dikshawali",
                        "content": "same here"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Very similar problem to  [Word Break](https://leetcode.com/problems/word-break/).\\n\\nTip: \\nRecurrence relation -> If the current subarray works (i.e. satisfy one the three conditions) then check if the rest of the array works. "
                    },
                    {
                        "username": "Yize-Dai",
                        "content": "Good job omg"
                    },
                    {
                        "username": "aDDyy",
                        "content": "Again its another DP day\\uD83D\\uDE43\\uD83E\\uDEE0"
                    },
                    {
                        "username": "Mihir_Udhani",
                        "content": "Hello there,\\nIs this array has valid partition \\n[10,10,10,10,10,10,10,10,10,10,10,10,1,1,1,5,5,5,8,8,8,8,8,8,8,8,8,8]"
                    },
                    {
                        "username": "rp20",
                        "content": "this test case will return true according to the question \\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Yes it has valid partition:\n10,10,10 | 10,10,10 | 10,10,10 | 10,10,10 | 1,1,1 | 5,5,5 | 8,8,8 | 8,8,8 | 8,8 | 8,8 \n[OR]\n10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 10,10 | 1,1,1 | 5,5,5 | 8,8 | 8,8 | 8,8 | 8,8 | 8,8\n...\nand many more..."
                    },
                    {
                        "username": "__sunny15__",
                        "content": "acc to the logic it should be a true but over the discussion it is false.\nbcz, last 8 is single there, it should have been fulfilling any of the condition , then it can be true but not here "
                    },
                    {
                        "username": "prakhar_20",
                        "content": "even I am getting error in this :("
                    },
                    {
                        "username": "smresponsibilities",
                        "content": "This array has valid partitions\\nas they satisfy the first two conditions.\\n10,1,5 can be divided into groups of 3 (rule 2) and 8 can be divided into groups of 2 eights(or groups of 3 eights and 2 eights)."
                    },
                    {
                        "username": "_vicks",
                        "content": "true"
                    },
                    {
                        "username": "user7077Og",
                        "content": "false"
                    }
                ]
            },
            {
                "id": 2012496,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2012034,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2011448,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2012406,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2012189,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2072628,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2012888,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2012626,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2012521,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2012328,
                "content": [
                    {
                        "username": "Utsarg",
                        "content": "How do you know, this question needs dp, how is it intuitative? Kindly answer.\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "At a minimum, you will need recursion to solve this problem. Assuming you can do that, you will probably get a TLE and need to add some memoization to speed up your code."
                    },
                    {
                        "username": "sandipkushwaha",
                        "content": "If you want to better understanding of DP you can prefer this DP series by Striver\\nhttps://www.youtube.com/playlist?list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY  It will help you lot."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@codenish](/codenish) yeah, i also observed that ,i\\'m new to dp as well. Thanks for helping."
                    },
                    {
                        "username": "Utsarg",
                        "content": "[@krhemant172003](/krhemant172003)  Thanks. yes, it makes sense now."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Whenever there is a situation where at each point we have different paths or possiblity to follow to reach the result and we are sure that one of them would lead us to the desired result.\\n   To tackle such situations where we need to **check all the paths or possiblity** then we think of using DP or recursion.\\n \\nI hope this helps \\uD83D\\uDE42\\uD83D\\uDE42"
                    },
                    {
                        "username": "codenish",
                        "content": "Even i am confused and new to DP, but i think dividing the array into subarray, thus DP comes. But need more insights. "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Question looked deceptively simple, but the real challenge was getting my code to hit the gym \\u2013 optimization gym, that is. Started with a coding ballad, ended up with a **TLE** rap. \\uD83C\\uDFCB\\uFE0F\\u200D\\u2642\\uFE0F\\uD83D\\uDCA8 But fear not, after some serious algorithm cardio, my code finally flexed its \"Accepted\" muscles. Remember, it\\'s not just about the logic; it\\'s the optimization hustle that turns a coder into a LeetCode rockstar! \\uD83C\\uDFB8\\uD83D\\uDE80\\n\\nThe acceptance rate is low because of TLE which most of us gets in this problem."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "Hint:\\nNever think of sorting the input \\uD83D\\uDE43"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@Baymax_](/Baymax_) \\nI think it does make sense somehow \\nlike he just wants to partition the array to valid patterns \\uD83D\\uDE41"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Why would anyone sort if we already know that we need to deal with sub-arrays.."
                    },
                    {
                        "username": "StefanelStan",
                        "content": " A very intuitive DP problem. Use a Boolean[] partitions to mark if you can make a partition from index [0..n-1]. For each of the 3 conditions, check if they are met by turn, and if yes, set the result of partition[index] to be the result (OR operation) of partition check from index +2/+3.\\nReturn the result of partition[0]."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Initially, it seemed to be a variation of MCM pattern. But, even after memoization it gives TLE :(\nWhat could be the reason for it???\n\nBelow is the code:\n https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020052052/\n\nAbove code & the one that got submitted seems to follow the same logic. Then, why one gave TLE & other is submitted successfully? Below is the code which is submitted successfully\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020022174/"
                    },
                    {
                        "username": "lj1270",
                        "content": "Similar question to Work Break!"
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "can anyone explain why for second case it is false?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a valid partition means that all subArrays need to be valid, not just one. There is no way to combine the two into any valid subArray"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "After reading the problem: It\\'s way too hard man, it will use Matrix Chain Multiplication and blah blah blah\\nAfter reading the editorial: Damn it was more than easy . Am I dumb ???"
                    },
                    {
                        "username": "codenish",
                        "content": "In problem statement it\\'s mentioned \"We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions\" \\n\\nthen how come nums = [1,1,1,2] is not valid? "
                    },
                    {
                        "username": "codenish",
                        "content": "[@sober_junkie](/sober_junkie) So that means we need to fulfill all the conditions? but this contradicts what given in the problem statement. "
                    },
                    {
                        "username": "sober_junkie",
                        "content": "u can make 1,1 and 1,2 but heres the issue, u need atleast 3 numbers consecutively increasing like 1,2,3"
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is divided into two stages:\\nThe first step is to understand what needs to be done.\\nThe second step is to come up with a solution.\\nAnd in this task, the first stage is much more difficult than the second!"
                    }
                ]
            },
            {
                "id": 2012169,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2012031,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2011936,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2011684,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2011532,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2011516,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2055865,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2044522,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2044516,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2015804,
                "content": [
                    {
                        "username": "Aadil42",
                        "content": "Let me tell you about stupid human psychology(Yes, I\\'m assuming myself as a normal human being). I\\'m no psychiatrist but, this is what I observed in myself. From the past few weekends we were given difficult DP problems so I thought this weekend would be the same. I thought I am never going to solve it by myself. I have to see a solution. But, after seeing the solution. I can say the problem is really hard. I should have been able to solve this on my own. just run recursion with memo. It\\'s really simple."
                    },
                    {
                        "username": "swnsma",
                        "content": "First 40 DP problems: \\'OMG, how to solve this? Need to read Editorial\\'.\\nAfter 40\\'th DP problem: \\'OMG, why so routine?\\'."
                    },
                    {
                        "username": "minokazman",
                        "content": "bruh .. I\\'m getting Memory Limit Exceeded ... wtf leetcode"
                    },
                    {
                        "username": "vineet_tiwari",
                        "content": "try to send the array by reference\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Leetcode is obsessed with DP."
                    },
                    {
                        "username": "almostmonday",
                        "content": "[O(1) space in-place solution that isn\\'t in Editorial](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3901484/o-1-space-in-place-solution-that-isn-t-in-editorial/)"
                    },
                    {
                        "username": "lightingghost",
                        "content": "This problem is also known as Mahjong :-)"
                    },
                    {
                        "username": "Rich_Lin",
                        "content": "Guess I\\'m not the only one who\\'s bad in English after reading the description lol.\\nLike seeing \"The subarray consists of exactly 3\" and \"The subarray consists of exactly 2\" and then tells you [1,1,1,2] is false.\\nLike......wat?\\nI saw people explained it in the comment bur still, wtf man.\\nIt\\'s not gonna kill you if you can describe it much more....clearly or something."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I found a similar problem on codeforces, it has similar \"Dynamic Programming\" solution:\\n- https://codeforces.com/gym/104157/problem/D"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "this is a pretty disgusting problem... not too hard, just annoying "
                    },
                    {
                        "username": "isha_406",
                        "content": "problem description not clear i though subarray could have any number of elements but exactly two of them should be equal."
                    },
                    {
                        "username": "sober_junkie",
                        "content": "the description clearly states that there are 2 other ways of having 3 numbers in a subarray. The word 'exactly' has been highlighted in bold. Be patient with every single word in the question and you wont miss any details. "
                    }
                ]
            },
            {
                "id": 2013636,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2013090,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2013064,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2013023,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2013009,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2012977,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2012886,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2012764,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2012689,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2012669,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "I understood the problem this way. We must split the entire array given to us into the corresponding \\'real\\' subarrays.\\nThat is, the array [1, 2, 3, 3, 4, 5, 7, 7, 7] can be divided into the following [1, 2, 3], [3, 4, 5], [7, 7, 7] and it will be true.\\nAnd if the array is [1, 2, 3, 3, 4, 5, 7, 7, 8] then => [1, 2, 3], [3, 4, 5], [7, 7] and 8 us does not meet any of the conditions for \\'real\\' subarrays.\\nSo this is false.\\nAnd accordingly, for examples from the condition [4, 4, 4, 5, 6] is divided into [4, 4] and [4, 5, 6]; => true.\\nAnd for [1, 1, 1, 2]. We can divide by [1, 1] and the remaining [1] , [2] or [1,2] do not meet the conditions of the problem. Or we can divide by [1, 1, 1] and the remaining 2 also does not meet the conditions for \\'real\\' subarrays. => false\\nGood luck with your decision."
                    },
                    {
                        "username": "z3eg",
                        "content": "i just love how good understanding of recursion is not enough anymore. wrote a decent recursive solution in like 10 mins, but it TLEs at 54/117. \\nDPcode upsetting me third day in a row. let\\'s make all easy problems require to use DP too, shall we?"
                    },
                    {
                        "username": "tejassx",
                        "content": "The question is phrased very poorly. I was also confused after reading it for the first time. \\nLet me help you understand the question:\\n\\nThe question states that:\\n1. You have to divide the array \\'nums\\' into subarrays. There can be multiple subarrays, but we don\\'t have to consider all of them.\\n2. Our goal is to find one partition among all the possible subarrays such that each subarray satisfies at least one of the given three conditions.\\n\\nNow, let\\'s consider the first example:\\n\\nFor the array [4, 4, 4, 5, 6], can be divided into many possible subarrays. \\nHowever, our objective is to identify a single partition where all subarrays adhere to at least one of the three conditions.\\n\\nIn this case, we can find a pair that fulfills the conditions: \\n[4, 4] and [4, 5, 6]\\nThe subarray [4, 4] satisfies the 1st condition, and [4, 5, 6] satisfies the 3rd condition. \\nWhile there might be other subarrays that might not meet these conditions, but we have found one pair that does, so we return \\'true\\'.\\n\\nNow, let\\'s examine the second example:\\nThe array [1, 1, 1, 2] can be partitioned in multiple ways. \\nHowever, there is no pair that fulfills the requirement for all subarrays to meet at least one condition.\\n\\nFor instance, [1, 1] satisfies the 1st condition, but [1, 2] doesn\\'t satisfy any condition. Similarly, [1, 1, 1] satisfies the 2nd condition, but [2] doesn\\'t satisfy any condition."
                    },
                    {
                        "username": "ak_3101",
                        "content": "Anyone else thought this was a MCM question?"
                    },
                    {
                        "username": "thrillobit",
                        "content": "Testcase [1,2,2,2,3] return \\'false\\'. Subarrays [1,2,3] and [2,2] satisfy the condition. \\nThank you, leetcode, for giving us a clear question :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[1,2,3] is not a subArray, it\\'s a subSequence, subArrays need to be continuous by definition."
                    },
                    {
                        "username": "divyeshgarg",
                        "content": "This feels like Rummy"
                    },
                    {
                        "username": "k1174",
                        "content": "Help me for storing subproblem. they are colliding .\\n\\n `class Solution {\\n    public boolean validPartition(int[] nums) {\\n\\n        int[] dp = new int[nums.length];\\n             //window of 2               //window of three\\n        return makePartition(nums, 0, 1, dp) | makePartition(nums, 0, 2, dp);\\n         \\n    }\\n\\n    boolean makePartition(int[] nums, int index, int window, int[] dp) {\\n    // Out of array\\n    if (index + window >= nums.length) return false;\\n\\n    // Checking if window is valid\\n    if (window == 1) {\\n        if (nums[index] != nums[index + 1]) return false;\\n    } else {\\n        if (nums[index] == nums[index + 1] && nums[index + 1] == nums[index + 2]);\\n        else if (nums[index] + 1 == nums[index + 1] && nums[index + 1] + 1 == nums[index + 2]);\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    // If we checked till the end\\n    if (index + window == nums.length - 1) return true;\\n\\n    // Checking if we checked previously\\n    if (dp[index] != 0) {\\n        return dp[index] == 1;\\n    }\\n\\n    // Checking if for 2 or 3 is possible or not, here we don\\'t want to track which subarray makes\\n    boolean ans = makePartition(nums, index + window, 1, dp) || makePartition(nums, index + window, 2, dp);\\n\\n    // Storing in dp\\n    dp[index] = (ans) ? 1 : -1;\\n    System.out.println(index + \": \" + dp[index]);\\n\\n    return ans;\\n}\\n\\n}`"
                    },
                    {
                        "username": "curryGoat",
                        "content": "```\\n//What is wrong here\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int sol(int i, vector<int>&nums, int n){\\n        if(i >= n)\\n            return true;\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n\\n        if(i + 2 < n && nums[i] == nums[i+1] == nums[i+2])\\n            ans = ans | sol(i+3, nums, n);\\n\\n \\n        if(i + 2 < n && (nums[i+1] - nums[i] == 1) && (nums[i+2] - nums[i+1] == 1))\\n            ans = ans | sol(i+3, nums, n);\\n\\n        if(i + 1 < n && nums[i] == nums[i+1])\\n            ans = ans| sol(i+2, nums, n);\\n            \\n        return dp[i] = ans;\\n    }\\n    bool validPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, nums, n);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "i have did the same mistake previously you are not taking the case into consideration in which three equal elements comes \\n\\nnums[i] == nums[i+1] == nums[i+2] is wrong way of comparision \\n\\nuse nums[i] == nums[i+1] && nums[i+1]== nums[i+2]"
                    },
                    {
                        "username": "Gothram",
                        "content": "If the first condition(consists of exactly 2 equal elements) is true, then what is the need of the second condition?\\nIf second condition is true, then the first condition will always be true. Is there a need to check the second condition? \\nDoes the second condition seem redundant?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "some helpful test cases\\n`nums = [10,20,30]`\\n`nums=[813110,813110,813110,93730,93730,93730,757614,757615,757616,757617,757618,757619,757620,757621,757622,757623,757624,757625,757626,757627,757628,757629,757630,757631,757632,757633,757634,757635,757636,757637,757638,757639,757640,757641,757642,757643,757644,757645,757646,757647,757648,757649,757650,757651,757652,757653,757654,757655,757656,757657,757658,757659,757660,757661,757662,757663,757664,757614,757614,757614,790795,790795,790795,790795,790795,946124,946125,946126,946127,946128,946129,946130,946131,946132,946133,946134,946135,946136,946137,946138,946139,946140,946141,946142,946143,946144,946145,946146,946147,946148,946149,946150,946151,946152,946153,946154,946155,946156,946157,946158,946159,946160,946161,946162,946163,946164,946165,946166,946167,946168,946169,946170,946171,946172,946173,946174,874544,874545,874546,874547,874548,874549,874550,874551,874552,874553,874554,874555,874556,874557,874558,874559,874560,874561,874562,874563,874564,874565,874566,874567,874568,874569,874570,874571,874572,874573,874574,874575,874576,874577,874578,874579,132994,132994,132994,132994,132994,132994,165386,165387,165388,165389,165390,165391,165392,165393,165394,165395,165396,165397,165398,165399,165400,165401,165402,165403,165404,165405,165406,165407,165408,165409,165410,165411,165412,165413,165414,165415,165416,165417,165418,165419,165420,165421,165422,165423,165424,165425,165426,165427,165428,165429,165430,165431,165432,165433,875923,875923,875923,275623,275623,908388,908388,706460,706460,234771,234772,234773,234774,234775,234776,234777,234778,234779,234780,234781,234782,234783,234784,234785,234786,234787,234788,234789,234790,234791,234792,234793,234794,234795,234796,234797,234798,234799,234800,234801,234802,234803,234804,234805,234806,234807,234808,234809,234810,234811,234812,234813,234814,234815,234771,234772,234773,234774,234775,234776,234777,234778,234779,622633,622634,622635,622636,622637,622638,622639,622640,622641,622642,622643,622644,622645,622646,622647,622648,622649,622650,622651,622652,622653,622654,622655,622656,622657,622658,622659,622660,622661,622662,622663,622664,622665,622666,622667,622668,622669,622670,622671,622672,622673,622674,622675,622676,622677,969499,969499,235391,235391,825372,825372,636415,636415,381131,381131,381131,782433,782433,782433,498700,498700,498700,673646,673646,673646,380878,380878,380878,380878,380878,859809,859810,859811,859812,859813,859814,931737,931737,695097,695098,695099,695100,695101,695102,695103,695104,695105,353622,353623,353624,353625,353626,353627,353628,353629,353630,353631,353632,353633,353634,353635,353636,353637,353638,353639,353640,353641,353642,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214014,214014,214014,214015,214016,214017,214018,214019,214020,214021,214022,214023,214024,214025,214026,214027,214028,214029,214030,214031,214032,214033,214034,214035,214036,214037,214038,214039,214040,214041,214042,214043,214044,214045,214046,214047,214048,214049,214050,214051,214052,214053,214054,214055,214056,214057,214058,214059,214060,214061,489431,489432,489433,489434,489435,489436,489437,489438,489439,489440,489441,489442,489443,489444,489445,489446,489447,489448,489449,489450,489451,489452,489453,489454,910992,910993,910994,910995,910996,910997,910998,910999,911000,911001,911002,911003,911004,911005,911006,911007,911008,911009,911010,911011,911012,911013,911014,911015,911016,911017,911018,911019,911020,911021,911022,911023,911024,650165,650166,650167,650168,650169,650170,650171,650172,650173,650174,650175,650176,650177,650178,650179,168518,168518,168518,262862,262863,262864,262865,262866,262867,262868,262869,262870,262871,262872,262873,262874,262875,262876,262877,262878,262879,262880,262881,262882,262883,262884,262885,262886,262887,262888,262889,262890,262891,262892,262893,262894,262895,262896,262897,262898,262899,262900,262901,262902,262903,414662,414662,414662,857576,857576,304581,304581,304581,843294,843294,843294,865948,865948,865948,860791,860791,924288,924289,924290,924291,924292,924293,924294,924295,924296,924297,924298,924299,924300,924301,924302,924303,924304,924305,924306,924307,924308,924309,924310,924311,924312,924313,924314,924315,924316,924317,821157,821157,517455,517456,517457,517458,517459,517460,517461,517462,517463,517464,517465,517466,517467,517468,517469,517470,517471,517472,517473,517474,517475,517476,517477,517478,517479,517480,517481,517482,517483,517484,517485,517486,517487,517488,517489,517490,517491,517492,517493,517494,517495,517496,517497,517498,517499,517500,517501,517502,517503,517504,517505,517455,517455,827261,827261,455977,455977,455977,761084,761084,761084,950365,950365,950365,368912,368912,368912,368912,43738,43738,43738,464453,464454,464455,464456,464457,464458,464459,464460,464461,464462,464463,464464,464465,464466,464467,464468,464469,464470,464471,464472,464473,464474,464475,464476,464477,464478,464479,464480,464481,464482,464483,464484,464485,464486,464487,464488,464489,464490,464491,464492,464493,464494,464495,464496,464497,464498,464499,464500,464501,464502,464503,848642,848642,914277,914278,914279,914280,914281,914282,914283,914284,914285,914286,914287,914288,914289,914290,914291,914292,914293,914294,914295,914296,914297,914298,914299,914300,914301,914302,914303,914304,914305,914306,914307,914308,914309,914310,914311,914312,914313,914314,914315,914316,914317,914318,914319,914320,914321,914322,914323,914324,914325,914326,914327,107434,107434,107434,107434,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706439,706440,706441,706442,706443,706444,706445,706446,706447,706448,706449,706450,706451,706452,706453,706454,706455,706456,706457,706458,706459,706460,706461,706462,706463,706464,706465,706466,706467,706468,706469,706470,706471,706472,706473,706474,706475,706476,706477,706478,706479,706480,706481,706482,706483,706484,706485,706486,888801,888801,888801,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,296995,296995,296995,296996,296997,296998,296999,297000,297001,297002,297003,297004,297005,297006,297007,297008,297009,297010,297011,297012,297013,297014,297015,297016,297017,297018,297019,297020,297021,297022,297023,297024,297025,297026,297027,297028,297029,297030,25531,25532,25533,25534,25535,25536,893772,893772,893772,893772,893773,893774,893775,893776,893777,893778,893779,893780,893781,893782,893783,893784,893785,893786,893787,893788,893789,893790,893791,893792,893793,893794,893795,893796,893797,893798,893799,893800,893801,893802,893803,893804,893805,893806,893807,893808,893809,893810,680404,680404,680404,88791,88791,88791,221402,221402,80435,80436,80437,80438,80439,80440,80441,80442,80443,80444,80445,80446,80447,80448,80449,80450,80451,80452,80435,80435,80435,598527,598527,598527,598527,598528,598529,598530,598531,598532,598533,598534,598535,598536,598537,598538,598539,598540,598541,598542,598543,598544,598545,598546,598547,598548,598549,598550,598551,598552,598553,598554,598555,598556,598557,598558,598559,598560,598561,598562,598563,598564,598565,400026,400026,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,123378,123378,123378,123378,123379,123380,123381,123382,123383,123384,123385,123386,123387,123388,123389,123390,123391,123392,123393,123394,123395,123396,123397,123398,123399,123400,123401,942843,942843,12350,12351,12352,12353,12354,12355,12356,12357,12358,12359,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,12370,985984,985985,985986,985987,985988,985989,985990,985991,985992,985993,985994,985995,985996,985997,985998,985999,986000,986001,986002,986003,986004,986005,986006,986007,986008,986009,986010,986011,986012,986013,986014,986015,986016,986017,986018,986019,986020,986021,986022,986023,986024,986025,985984,985984,985984,884935,884935,115156,115156,629333,629334,629335,629336,629337,629338,907866,907866,907866,907866,907866,907866,907866,907866,174954,174954,174954,176040,176040,176040,119171,119172,119173,119174,119175,119176,119177,119178,119179,119180,119181,119182,119183,119184,119185,119186,119187,119188,119189,119190,119191,119192,119193,119194,119195,119196,119197,119198,119199,119200,119201,119202,119203,856981,856981,856981,856982,856983,856984,856985,856986,856987,856988,856989,856990,856991,856992,856993,856994,856995,856996,856997,856998,791260,791260,791260,791260,791260,466195,466195,466195,466195,466195,466195,466195,476447,476447,211849,211849,211849,211849,211849,211849,156881,156882,156883,156884,156885,156886,156887,156888,156889,156890,156891,156892,156893,156894,156895,156896,156897,156898,156899,156900,156901,156902,156903,156904,156905,156906,156907,156908,156909,156910,156911,156912,156913,156914,156915,156916,156917,156918,156919,156920,156921,156922,156923,156924,156925,156148,156148,149401,149402,149403,149404,149405,149406,149407,149408,149409,149410,149411,149412,149413,149414,149415,149416,149417,149418,149419,149420,149421,149422,149423,149424,149425,149426,149427,149428,149429,149430,149431,149432,149433,149434,149435,149436,149437,149438,149439,614437,614437,899845,899845,899845,899845,899845,899845,899845,932522,932523,932524,932525,932526,932527,932528,932529,932530,932531,932532,932533,932534,932535,932536,932537,932538,932539,932540,932541,932542,932543,932544,932545,932546,932547,932548,932549,932550,932551,932552,932553,932554,932555,932556,932557,932558,932559,932560,932561,932562,932563,932564,932565,932566,789640,789640,254257,254257,254257,287859,287859,287859,518968,518968,518968,105961,105961,203958,203959,203960,203961,203962,203963,203964,203965,203966,203967,203968,203969,203970,203971,203972,203973,203974,203975,203976,203977,203978,203979,203980,203981,203982,203983,203984,203985,203986,203987,203988,203989,203990,499238,499239,499240,499241,499242,499243,499244,499245,499246,499247,499248,499249,499250,499251,499252,499253,499254,499255,397413,397413,397413,397413,397414,397415,397416,397417,397418,397419,397420,397421,397422,397423,397424,397425,397426,397427,506261,506262,506263,506264,506265,506266,506267,506268,506269,506270,506271,506272,506273,506274,506275,506276,506277,506278,506279,506280,506281,506282,506283,506284,506285,506286,506287,121576,121576,553264,553264,553264,553264,553264,417192,417192,417192,417192,417192,417192,445062,445062,281330,281330,281330,546374,546374,364475,364475,364475,806933,806933,806933,178567,178568,178569,178570,178571,178572,178573,178574,178575,178576,178577,178578,178579,178580,178581,178582,178583,178584,178585,178586,178587,178588,178589,178590,424855,424855,424855,113310,113310,113310,815935,815935,205078,205079,205080,205081,205082,205083,205084,205085,205086,205087,205088,205089,205090,205091,205092,205093,205094,205095,205096,205097,205098,205099,205100,205101,205102,205103,205104,205105,205106,205107,205108,205109,205110,205111,205112,205113,205114,205115,205116,205117,205118,205119,205120,205121,205122,205123,205124,205125,205126,205127,205128,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117150,117150,117150,117151,117152,117153,117154,117155,117156,117157,117158,117159,117160,117161,117162,117163,117164,117165,117166,117167,117168,117169,117170,117171,117172,117173,117174,117175,117176,117177,117178,117179,117180,117181,117182,117183,117184,117185,117150,117150,621758,621759,621760,621761,621762,621763,621764,621765,621766,621767,621768,621769,621770,621771,621772,621773,621774,621775,621776,621777,621778,621779,621780,621781,621782,621783,621784,621785,621786,621787,730726,730726,730726,730726,730726,375049,375050,375051,375052,375053,375054,375055,375056,375057,375058,375059,375060,375061,375062,375063,327733,327734,327735,327736,327737,327738,327739,327740,327741,327742,327743,327744,327745,327746,327747,327748,327749,327750,327751,327752,327753,327754,327755,327756,327757,327758,327759,327760,327761,327762,327763,327764,327765,327766,327767,327768,327769,327770,327771,327772,327773,327774,839978,839978,839978,381160,381161,381162,381163,381164,381165,381166,381167,381168,381169,381170,381171,381172,381173,381174,381175,381176,381177,381178,381179,381180,381181,381182,381183,381184,381185,381186,381187,381188,381189,381190,381191,381192,381193,381194,381195,381196,381197,381198,381160,381160,381160,381160,381160,53276,53277,53278,53279,53280,53281,53282,53283,53284,53285,53286,53287,53288,53289,53290,53291,53292,53293,53294,53295,53296,53297,53298,53299,22772,22772,22772,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22772,22773,22774,22775,22776,22777,22778,22779,22780,22781,22782,22783,22784,22785,22786,22787,22788,22789,22790,22791,22792,22793,22794,22795,22796,22797,22798,22799,22800,22801,22802,22803,22804,22772,22772,22772,22772,22772,22772,171357,171358,171359,171360,171361,171362,171363,171364,171365,246783,246783,246783,246783,246783,100489,100490,100491,100492,100493,100494,100495,100496,100497,100498,100499,100500,100501,100502,100503,100504,100505,100506,100507,100508,100509,100510,100511,100512,100513,100514,100515,100516,100517,100518,100519,100520,100521,100522,100523,100524,100525,100526,100527,100528,100529,100530,819088,819088,819088,661056,661057,661058,661059,661060,661061,661062,661063,661064,661065,661066,661067,661068,661069,661070,661071,661072,661073,661074,661075,661076,661077,661078,661079,661080,661081,661082,661083,661084,661085,661086,661087,661088,661089,661090,661091,661092,661093,661094,661095,661096,661097,661098,661099,661100,661101,661102,661103,661104,661105,661106,747925,747926,747927,747928,747929,747930,747931,747932,747933,747934,747935,747936,747937,747938,747939,747940,747941,747942,747943,747944,747945,747946,747947,747948,747949,747950,747951,747952,747953,747954,747955,747956,747957,747958,747959,747960,747961,747962,747963,747964,747965,747966,747925,747925,899318,899318,899318,300825,300826,300827,300828,300829,300830,300831,300832,300833,300834,300835,300836,300837,300838,300839,300840,300841,300842,300843,300844,300845,300846,300847,300848,300849,300850,300851,300852,300853,300854,300855,300856,300857,300858,300859,300860,300861,300862,300863,300864,300865,300866,300867,300868,300869,965938,965939,965940,965941,965942,965943,965944,965945,965946,965947,965948,965949,965950,965951,965952,868259,868259,868259,29989,29989,29989,508224,508224,267104,267104,404209,404209,389536,389536,339269,339269,339269,86590,86591,86592,86593,86594,86595,86596,86597,86598,86599,86600,86601,86602,86603,86604,86605,86606,86607,86608,86609,86610,86611,86612,86613,86614,86615,86616,86590,86590,86590,86590,86590,86590,86590,86590,86590,86590,772307,772307,137854,137855,137856,137857,137858,137859,137860,137861,137862,137863,137864,137865,137866,137867,137868,137869,137870,137871,137872,137873,137874,137875,137876,137877,137878,137879,137880,137881,137882,137883,137884,137885,137886,137887,137888,137889,137890,137891,137892,696935,696935,700272,700272,700272,342365,342365,342365,342365,342366,342367,342368,342369,342370,342371,342372,342373,342374,342375,342376,342377,342378,342379,342380,342381,342382,342383,342384,342385,342386,342387,342388,342389,342390,342391,342392,342393,342394,342395,342396,342397,342398,342399,342400,626749,626749,700257,700257,700257,700257,700257,700257,700257,81253,81253,81253,81253,81254,81255,81256,81257,81258,81259,81260,81261,81262,81263,81264,81265,81266,81267,81268,81269,81270,81271,81272,81273,81274,81275,81276,81277,81278,81279,81280,81281,81282,81283,81284,81285,81253,81253,605031,605032,605033,605034,605035,605036,605037,605038,605039,605040,605041,605042,605043,605044,605045,605046,605047,605048,605049,605050,605051,605052,605053,605054,605055,605056,605057,605058,605059,605060,605061,605062,605063,605064,605065,605066,605067,605068,605069,605070,605071,605072,605073,605074,605075,605076,605077,605078,605079,605080,605081,605031,605031,605031,605031,418756,418756,418756,418757,418758,418759,418760,418761,418762,418763,418764,418765,418766,418767,418768,418769,418770,418771,418772,418773,418774,418775,418776,418777,418778,418779,418780,418781,418782,862210,862210,745903,745903,745903,745904,745905,745906,745907,745908,745909,745910,745911,745912,745913,745914,745915,745916,745917,745918,745919,745920,745921,745922,745923,745924,745925,745926,745927,745928,745929,745930,745931,745932,745933,745934,745935,745936,745937,745938,745939,745940,745941,745942,745943,745944,745945,745946,745947,745948,745949,745950,745951,745952,745953,630048,630049,630050,630051,630052,630053,630054,630055,630056,630057,630058,630059,630060,630061,630062,630063,630064,630065,630066,630067,630068,630069,630070,630071,630072,630073,630074,630075,630076,630077,630078,630079,630080,630081,630082,630083,641423,641423,911701,911701,911701,781001,781001,781001,986649,986649,986649,986649,986650,986651,986652,986653,986654,986655,986656,986657,986658,986659,986660,986661,986662,986663,986664,986665,986666,986667,986668,986669,986670,986671,986672,986673,986674,986675,986676,986677,986678,986679,986680,986681,986682,986683,986684,986685,986686,986687,986688,986689,986690,718772,718772,724223,724224,724225,724226,724227,724228,724229,724230,724231,724232,724233,724234,506520,506521,506522,506523,506524,506525,506526,506527,506528,506529,506530,506531,506532,506533,506534,506535,506536,506537,506538,506539,506540,506541,506542,506543,506544,506545,506546,506547,506548,506549,506550,506551,506552,506553,506554,506555,350730,350731,350732,350733,350734,350735,350736,350737,350738,350739,350740,350741,350742,350743,350744,350745,350746,350747,350748,350749,350750,350751,350752,350753,350754,350755,350756,350757,350758,350759,350760,350761,350762,350763,350764,350765,350766,350767,350768,350769,350770,350771,350772,350773,350774,350775,350776,350777,350778,350779,350780,282616,282617,282618,282619,282620,282621,282622,282623,282624,282625,282626,282627,282628,282629,282630,282631,282632,282633,282634,282635,282636,282637,282638,282639,282640,282641,282642,282643,282644,282645,282646,282647,282648,282649,282650,282651,637063,637063,489686,489687,489688,489689,489690,489691,489692,489693,489694,489695,489696,489697,489698,489699,489700,489701,489702,489703,489686,489686,489686,166065,166065,166065,184506,184507,184508,184509,184510,184511,184512,184513,184514,184515,184516,184517,184518,184519,184520,4824,4824,4824,562402,562402,562402,562402,562402,949194,949195,949196,949197,949198,949199,949200,949201,949202,949203,949204,949205,949206,949207,949208,949209,949210,949211,949212,949213,949214,949215,949216,949217,949218,949219,949220,949221,949222,949223,949224,949225,949226,949227,949228,949229,89226,89226,89226,629570,629570,629570,208636,208637,208638,208639,208640,208641,208642,208643,208644,208645]`"
                    }
                ]
            },
            {
                "id": 2012633,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012585,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012486,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012485,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012445,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012434,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012370,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012334,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012311,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012275,
                "content": [
                    {
                        "username": "Indra_22",
                        "content": "Return true if the array has at least one valid partition. Otherwise, return false.\\n\\nI think this is the very confusion statement for the all people.. \\n\\nHere LeetCode makes a mistake instead of at least one partition they have to write all partition how I will explain you ..\\n\\nconsider the given testcase\\n `[1,1,1,2,3,5,5]`\\nfor this test case let we do dry run ..\\n\\nStep: 1) firstly we do partition after i=1 then our array will become like this \\n`1,1 | 1,2,3,5,5`\\nthis is our first partition.\\n\\nnow what we have to do is that as per our problem statement we can check both the subarray \\nour left subarray is good subarray \\nbut what about the our right subarray for that again, \\n\\nStep: 2) we do the partition after i=4 then our array will become like this \\n`1,1 | 1,2,3 | 5,5`\\nthis is our second partition \\n\\nand again we check both the subarray is it good or bad for the second partition \\nand here both the left subarray \\n`1,2,3`\\nand the right subarray \\n`5,5`\\n\\nboth subarray is good so it is done for the second partition and we return true from the second partition to the \\nfirst partition where we check left subarray but for the right subarray we simply call recursive function and than for \\nthe first partition left and right subarray both are good so we return true as our ans..\\n\\n\\nso what we have to learn by doing that is that we check all the partition if any partition will return false than our output will be false so that\\'s why leetcode have write \"Return true if the array has at least one valid partition. Otherwise, return false.\" \\ninstead of at least one partition  they have to write all the partition."
                    },
                    {
                        "username": "haardtripathi",
                        "content": "please check my solution\\n\\n\\n\\nclass Solution(object):\\n    def validPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        #case1 taking 2\\n        check=0\\n        a=str(nums)\\n        while(a!=\\'\\'):\\n\\n            if(len(a)>=2 and a[0]==a[1]):\\n                a=a[2:]\\n                if(a==\\'\\'):\\n                    check=1\\n                    break\\n            else:\\n                if(len(a)>=3 and int(a[0])+2==int(a[1])+1==int(a[2])):\\n                    a=a[3:]\\n                    if(a==\\'\\'):\\n                        check=1\\n                        break\\n                else:\\n                    check=0\\n                    break\\n\\n        check1=0\\n        a1=str(nums)\\n        while(a1!=\\'\\'):\\n\\n            if(len(a1)>=3 and a1[0]==a1[1]==a1[2]):\\n                a1=a1[3:]\\n                if(a1==\\'\\'):\\n                    check1=1\\n                    break\\n            else:\\n                if(len(a1)>=3 and int(a1[0])+2==int(a1[1])+1==int(a1[2])):\\n                    a1=a1[3:]\\n                    if(a1==\\'\\'):\\n                        check1=1\\n                        break\\n                else:\\n                    check1=0\\n                    break\\n        if(check==1 or check1==1):\\n            return \\'true\\'\\n        else:\\n            return \\'false\\'\\n\\n\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**nande??????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**WHY?????????**\\nInput: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array."
                    },
                    {
                        "username": "ramanchik",
                        "content": "[1,1] (valid) + [1,2] (not valid)\\n[1,1,1] (valid) + [2] (not valid)\\nboth ways are not valid for partition"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "`exact two equal elements`: size of subarray has to be `2` only\n`exact three equal elements `: size of subarray has to be `3 `only\n`exact 3 consecutive elements`: size of subarray has to be `3 `only\n** also, the left and right subarrays at the partition index, both has to fulfill the any of the above conditions( that is why 2nd example returns false)."
                    },
                    {
                        "username": "deveshsharma912",
                        "content": "Can anyone tell Why My code is not working ?\\nOpt is choice whether i am checking for 2 len subaaray or 3 \\nand prev , idx are used to track the length of subaaray\\n\\nbool ans(int idx, int prev,int opt,vector<int>&nums,vector<vector<int>>&dp)\\n{\\n    if(idx==nums.size())\\n      return false;\\n    if(dp[opt][idx]!=-1)\\n      return dp[opt][idx];\\n    if(opt==0&&(idx-prev==1))\\n    {\\n        if(nums[prev]!=nums[idx])\\n          return false;\\n        if(idx==(nums.size()-1))\\n         return true;\\n        return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n    if(opt==1&&(idx-prev==2))\\n    {\\n        int fl=1;\\n        if((nums[prev]==nums[prev+1])&&(nums[prev+1]==nums[prev+2]))\\n           fl=0;\\n        if((nums[prev]+1==nums[prev+1])&&(nums[prev+1]+1==nums[prev+2]))\\n           fl=min(0,fl);\\n           \\n        if(fl==1)\\n         return false;\\n        if(idx==(nums.size()-1))\\n        return true;\\n\\n         return dp[opt][idx]=max(ans(idx+1,idx+1,0,nums,dp),ans(idx+1,idx+1,1,nums,dp));\\n    }\\n     return ans(idx+1,prev,opt,nums,dp);\\n\\n}\\nclass Solution {\\npublic:\\n    bool validPartition(vector<int>& nums) {\\n        vector<vector<int>>dp(2,vector<int>(nums.size(),-1));\\n        return max(ans(1,0,0,nums,dp),ans(1,0,1,nums,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Some fairly easy DP problems for the weekend \\uD83E\\uDD73"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "New day, new dp problem : )  ....."
                    },
                    {
                        "username": "DivyanshuS",
                        "content": "bool dp(int l, int r, vector<int>& nums, map<vector<int>, int> &memo){\\n        if(memo[{l, r}])  return memo[{l, r}];\\n        if(l == r)  return false;\\n        if(r-l == 1)    return nums[l] == nums[r];\\n        if(r-l == 2)    return nums[l] == nums[l+1] && nums[l+1] == nums[r] || nums[l+1] - nums[l] == 1 && nums[r] - nums[l+1] == 1;\\n\\n        for(int i = l; i < r-1; i++ ){\\n            if(dp(l, i, nums, memo) && dp(i+1, r, nums, memo))  return memo[{l, r}] = true;\\n        }\\n\\n        return memo[{l, r}] = false;\\n\\n    }\\nWhy is my solution getting TLE ?"
                    },
                    {
                        "username": "chaotic_10",
                        "content": "WHAT IS WRONG WITH MY CODE ??\nIT FAILS TO PASS THE SECOND TEST CASE : 1112\n``class Solution {\npublic:\n    bool checker(vector<int>& nums, int idx, int equal_count, int diff) {\n        if (idx == 0) {\n            return equal_count >= 2 || diff == 2;\n        }\n        \n        if (equal_count >= 2 || diff == 2) {\n            return true;\n        }\n           \n        if (idx > 0) {\n            if (nums[idx] == nums[idx - 1]) {\n                return checker(nums, idx - 1, equal_count + 1, diff);\n            }\n            else if (nums[idx] - nums[idx - 1] == 1) {\n                return checker(nums, idx - 1, equal_count, diff + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        \n        return false; // Default return statement\n    }\n\n    bool validPartition(vector<int>& nums) {\n        int n = nums.size();\n        int idx = n - 1;\n        return checker(nums, idx, 0, 0);\n    }\n};``"
                    }
                ]
            },
            {
                "id": 2012239,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2012231,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2012187,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2012142,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2012113,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2012062,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2011926,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2011903,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2011892,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2011843,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "BTW,  I think this is a good example to understand union-find, refer to the solution:\\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3903155/c-solution-based-on-graph-theory-and-union-find/"
                    },
                    {
                        "username": "rsingh2003",
                        "content": "The problem statement is not that much clear.\\nYou have to read through the discussion to solve this problem.\\nThe problem statement means that the subarray will be valid if either a subarray of size 2 has equal elements or a subarray of size 3 have all equal elements, or a subarray of size 3 has consecutive elements.\\nOnce the problem statement become clear, then this question is a cake walk."
                    },
                    {
                        "username": "prabal17",
                        "content": "array [1,1,1,2 ] should be valid \\nbecause subarrays can be [1,1,1] and [2]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "2 is not a valid subarray, a valid partition means that the whole array is divided into valid subarrays, not that there is at least one valid subarray in nums"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is easy recurison+cache i dont feel sunday:)"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "Why I still get TLE even after memoization. able to run only 67/117 test cases"
                    },
                    {
                        "username": "mohitdbst",
                        "content": "To be frank language was a bit confusing at first but here is the tip try to read understand the options along with the test cases .\n\nComing to solution hint since the question is giving option you can go for recursion and since the constraints are high what you can do for that? \n\nany idea ??\n\n\n\n\n\n\n\n\n\n\nYes , memoization . \n\nYou can refer to my  code( both c++ and java)\nhttps://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902614/c-java-recursion-memoization/"
                    },
                    {
                        "username": "arpitchavan",
                        "content": "Can anyone explain how the second test case output is false ?. According to conditions given in problem statement second test case is fulfilling the criteria."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "Its not fulfilling the conditions.\\nif we consider the first two elements [1,1] as valid then we are left with only [1,2] which is not valid as both the elements are different and for a subarray of length 2 to be valid both the elements should be equal. As according to the third condition we can have \"3\" consecutive increasing elements with difference of 1 to be valid, but in our case we only have 2 elements so it fails.\\nif we take the first 3 elements [1,1,1] as a valid subarray then we are only left with [2] which is not valid."
                    },
                    {
                        "username": "aitachii",
                        "content": "It\\'s been months of dp problems, Trie problems when?"
                    },
                    {
                        "username": "jPank1983",
                        "content": "Is nums=[1,1] makes a valid partition? "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "Yes, it is a valid partition. The whole array is the first case that is mentioned in the statement."
                    },
                    {
                        "username": "psionl0",
                        "content": "Brute Force FTW : https://leetcode.com/submissions/detail/1019831784/\n(I did memoize the solution but that didn't save me any time https://leetcode.com/submissions/detail/1020726590/)"
                    }
                ]
            },
            {
                "id": 2011786,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011680,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011545,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011531,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011525,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011517,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011502,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011497,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011471,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            },
            {
                "id": 2011410,
                "content": [
                    {
                        "username": "arshita129",
                        "content": "confusing question. How is second test case false? [1,1,1,2] satisfies the first condition right? It can be partitioned to [1,1] and [1,2]. Here [1,1] satisfies the first point and [1,2] satisfies the third point. How is this false then? Isn\\'t it same as the first case [4,4,4,5,6] divided to [4,4] and [4,5,6]"
                    },
                    {
                        "username": "arshita129",
                        "content": "[@Seedpod](/Seedpod)  Oh right.. Thanks"
                    },
                    {
                        "username": "Seedpod",
                        "content": "[1,2] does NOT satisfy the third point. There are only two consecutive increasing elements.\\n\\nThe third point is \"The subarray consists of exactly 3 consecutive increasing elements\""
                    },
                    {
                        "username": "prakhar_20",
                        "content": "Array is sorted right ??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "Not necessarily"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "maybe maybe not they didn\\'t mentioned it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We are trying to determine whether there is at least one method to divide the provided array into subarrays, while ensuring that each of these subarrays meets one of the three specified conditions."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "OMG, I\\'ve spent, like, 3 hours coding my solution, to hit a TLE\\n\\nAnd then, I understood that arrays could only be **contiguous**.\\nThis brings the problem from 4-dimentional DP to 1-dimentional DP, and I should admit, that\\'s quite a simplification!"
                    },
                    {
                        "username": "shivamjoshi902",
                        "content": "Is the given array sorted?"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "And you shouldn\\'t sort it"
                    },
                    {
                        "username": "Seedpod",
                        "content": "No, it isn\\'t necessarily sorted"
                    },
                    {
                        "username": "SaiTeja134",
                        "content": "Can anyone explain why 2nd case is not a valid??"
                    },
                    {
                        "username": "Seedpod",
                        "content": "We know that all partitions have to fulfill one of the three conditions listed above. This means that each partition has to be at least of length 2, and at most of length 3.\n\nHence, [1,1,1,2] can only be partitioned in the following way:\n[1,1][1,2] => first partition meets condition 1, second partition does not meet any condition\n\nSince there is no possible way to partition the array such that all partitions fulfill at least one of the three conditions, we return false."
                    },
                    {
                        "username": "Vedant-001",
                        "content": "First let me reframe the question to make it easier to understand.\\nA valid partition - partitioning the array in such a way that every subarray fulfils at least one of the given 3 criteria.\\n\\nNow coming to your question:\\n[1,1,1,2] can be partitioned in the following ways:\\n1. [1],[1],[1],[2]\\n2. [1,1],[1],[2]\\n3. [1,1,1],[2] {first subarray satisfies condition 2 but the second subarray doesn\\'t satisfy any condition}\\n4. [1,1],[1,2] {again the same case as above}\\n5. and so on....\\nNone of the partitions is such that \\'All the subarrays\\' satisfy at least one condition.\\n\\nSo, there exists no partition which makes all the obtained subaraays result in true for at least one of the conditions.\\nHence, the given case should return false."
                    },
                    {
                        "username": "TolemyKashyap",
                        "content": "For the 2nd testcase [1,1,1,2] .....Here the partitions can be ([1,1,1] and [2]) or ([1,1] and [1,2]). Here in 1st case [1,1,1] satisfies the condition 2 but [2] does not satisfy any so it is not a valid partition. Similarly for case 2 [1,1] satisfies the condition 1 but [1,2] does not satisfy any condition. Thus no valid partition is possible for [1,1,1,2]"
                    },
                    {
                        "username": "etstst",
                        "content": "The imposter syndrome I experienced while trying to answer this question was immense. \\uD83E\\uDEE0"
                    },
                    {
                        "username": "MinaEskandar",
                        "content": "how is [1,1,1,2] false?\\nwe should be able to create [1,1,1] which satisfies the second point (exactly three equal elements)"
                    },
                    {
                        "username": "Seedpod",
                        "content": "When you partition it in the way you\\'ve described above, we get the following partitions:\\n[1,1,1][2]\\n\\nSo while the first partition indeed satisfies the second condition, the second partition does not satisfy any condition.\\n\\nI think the phrasing of the question is confusing: \"Return true if the array has at least one valid partition. Otherwise, return false.\"\\nWhat it means is \"Return true if there is at least one way in which to partition the array such that all subarrays satisfy one of the three conditions\"."
                    },
                    {
                        "username": "yvjawahar",
                        "content": "Input: nums = [1,1,1,2]\\nOutput: false\\nExplanation: There is no valid partition for this array.   can anyone please this better"
                    },
                    {
                        "username": "psionl0",
                        "content": "Each subarray must meet one of the conditions. Here, [1,1] meets the first condition but [1,2] doesn\\'t meet any of the conditions. Also, [1,1,1] meets the second condition but [2] doesn\\'t meet any conditions. There is no way to partition this array so that the second subarray meets one of the conditions."
                    },
                    {
                        "username": "user8272RT",
                        "content": "When we add a new element to the array, we only need to check the previous 2 elements and the validity of the preceding array to determine if a valid partition exists."
                    }
                ]
            }
        ]
    }
]