[
    {
        "title": "3Sum",
        "question_content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\n&nbsp;\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 3000\n\t-105 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 7402,
                "title": "share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments",
                "content": "the key idea is the same as the `TwoSum` problem. When we fix the `1st` number, the `2nd` and `3rd` number can be found following the same reasoning as `TwoSum`. \\n\\nThe only difference is that, the `TwoSum` problem of LEETCODE has a unique solution. However, in `ThreeSum`, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could\\'ve ended up with a solution with so many duplicates.\\n\\nThe naive solution for the duplicates will be using the STL methods like below :\\n\\n\\n    std::sort(res.begin(), res.end());\\n    res.erase(unique(res.begin(), res.end()), res.end());\\n\\n\\nBut according to my submissions, this way will cause you double your time consuming almostly.\\n\\nA better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not.\\n\\nIf the three numbers formed a solution, we can safely ignore all the duplicates of them.\\n\\nWe can do this to all the three numbers such that we can remove the duplicates. \\n\\nHere\\'s my AC C++ Code:\\n\\n\\n    vector<vector<int> > threeSum(vector<int> &num) {\\n        \\n        vector<vector<int> > res;\\n\\n        std::sort(num.begin(), num.end());\\n\\n        for (int i = 0; i < num.size(); i++) {\\n            \\n            int target = -num[i];\\n            int front = i + 1;\\n            int back = num.size() - 1;\\n\\n            while (front < back) {\\n\\n                int sum = num[front] + num[back];\\n                \\n                // Finding answer which start from number num[i]\\n                if (sum < target)\\n                    front++;\\n\\n                else if (sum > target)\\n                    back--;\\n\\n                else {\\n                    vector<int> triplet = {num[i], num[front], num[back]};\\n                    res.push_back(triplet);\\n                    \\n                    // Processing duplicates of Number 2\\n                    // Rolling the front pointer to the next different number forwards\\n                    while (front < back && num[front] == triplet[1]) front++;\\n\\n                    // Processing duplicates of Number 3\\n                    // Rolling the back pointer to the next different number backwards\\n                    while (front < back && num[back] == triplet[2]) back--;\\n                }\\n                \\n            }\\n\\n            // Processing duplicates of Number 1\\n            while (i + 1 < num.size() && num[i + 1] == num[i]) \\n                i++;\\n\\n        }\\n        \\n        return res;\\n        \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "the key idea is the same as the `TwoSum` problem. When we fix the `1st` number, the `2nd` and `3rd` number can be found following the same reasoning as `TwoSum`. \\n\\nThe only difference is that, the `TwoSum` problem of LEETCODE has a unique solution. However, in `ThreeSum`, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could\\'ve ended up with a solution with so many duplicates.\\n\\nThe naive solution for the duplicates will be using the STL methods like below :\\n\\n\\n    std::sort(res.begin(), res.end());\\n    res.erase(unique(res.begin(), res.end()), res.end());\\n\\n\\nBut according to my submissions, this way will cause you double your time consuming almostly.\\n\\nA better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not.\\n\\nIf the three numbers formed a solution, we can safely ignore all the duplicates of them.\\n\\nWe can do this to all the three numbers such that we can remove the duplicates. \\n\\nHere\\'s my AC C++ Code:\\n\\n\\n    vector<vector<int> > threeSum(vector<int> &num) {\\n        \\n        vector<vector<int> > res;\\n\\n        std::sort(num.begin(), num.end());\\n\\n        for (int i = 0; i < num.size(); i++) {\\n            \\n            int target = -num[i];\\n            int front = i + 1;\\n            int back = num.size() - 1;\\n\\n            while (front < back) {\\n\\n                int sum = num[front] + num[back];\\n                \\n                // Finding answer which start from number num[i]\\n                if (sum < target)\\n                    front++;\\n\\n                else if (sum > target)\\n                    back--;\\n\\n                else {\\n                    vector<int> triplet = {num[i], num[front], num[back]};\\n                    res.push_back(triplet);\\n                    \\n                    // Processing duplicates of Number 2\\n                    // Rolling the front pointer to the next different number forwards\\n                    while (front < back && num[front] == triplet[1]) front++;\\n\\n                    // Processing duplicates of Number 3\\n                    // Rolling the back pointer to the next different number backwards\\n                    while (front < back && num[back] == triplet[2]) back--;\\n                }\\n                \\n            }\\n\\n            // Processing duplicates of Number 1\\n            while (i + 1 < num.size() && num[i + 1] == num[i]) \\n                i++;\\n\\n        }\\n        \\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1462423,
                "title": "c-both-two-pointers-and-hashmap-approach-explained",
                "content": "Requirements we need to fulfil:  Find the triplets having sum = 0.\\n\\nAs array has both -ve and +ve numbers, firstly we sort the array. Sorted array would have -ve numbers together and +ve numbers together in an increasing order. This will make easy for searching the required numbers to make a 0 sum.\\n\\nBase cases after sorting:\\n- If array size is < 3, means no triplet would exist from that array. Return empty vector of vectors.\\n- If first element is +ve, that means there is no -ve number by which we can make a 0 triplet sum. Return empty vector of vectors.\\n\\n### Two Pointer Approach:\\n\\nThe basic thinking logic for this is: Fix any one number in sorted array and find the other two numbers after it. The other two numbers can be easily found using two pointers (as array is sorted) and two numbers should have sum = -1*(fixed number).\\n\\n- Traverse the array and fix a number at every iteration.\\n- If number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\n- If number is getting repeated, ignore the lower loop and continue. This is for unique triplets. We want the last instance of the fixed number, if it is repeated.\\n- Make two pointers high and low, and initialize sum as 0.\\n- Search between two pointers, just similiar to binary search. Sum = num[i] + num[low] + num[high].\\n- If sum is -ve, means, we need more +ve numbers to make it 0, increament low (low++).\\n- If sum is +ve, means, we need more -ve numbers to make it 0, decreament high (high--).\\n- If sum is 0, that means we have found the required triplet, push it in answer vector.\\n- Now again, to avoid duplicate triplets, we have to navigate to last occurences of num[low] and num[high] respectively. Update the low and high with last occurences of low and high.\\n\\nMy Two Pointer Submission:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());    //Sorted Array\\n        if(nums.size() < 3){    //Base case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){        //Base case 2\\n            return {};\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            if(i > 0 && nums[i] == nums[i - 1]){    //If number is getting repeated, ignore the lower loop and continue.\\n                continue;\\n            }\\n            int low = i + 1 , high = nums.size() - 1;   //Make two pointers high and low, and initialize sum as 0.\\n            int sum = 0;\\n            while(low < high){                          //Search between two pointers, just similiar to binary search.\\n                sum = nums[i] + nums[low] + nums[high];\\n                if(sum > 0){   //If sum is +ve, means, we need more -ve numbers to make it 0, decreament high (high--).\\n                    high--;\\n                } else if(sum < 0){ //If sum is -ve, means, we need more +ve numbers to make it 0, increament low (low++).\\n                    low++;\\n                } else {\\n                    answer.push_back({nums[i] , nums[low] , nums[high]});  //we have found the required triplet, push it in answer vector\\n                    int last_low_occurence = nums[low] , last_high_occurence = nums[high];  //Now again, to avoid duplicate triplets, we have to navigate to last occurences of num[low] and num[high] respectively\\n                    while(low < high && nums[low] == last_low_occurence){   // Update the low and high with last occurences of low and high.\\n                        low++;\\n                    }\\n                    while(low < high && nums[high] == last_high_occurence){\\n                        high--;\\n                    }\\n                }\\n            }\\n        }\\n        return answer;      //Return the answer vector.\\n    }\\n};\\n```\\n\\n### HashMap Approach:\\n\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap. \\n\\n- Here also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop. \\n- If number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\n- Make a nested loop to fix a number after the first fixed number. (num[j])\\n- To make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\n- Now, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\n- Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n- Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n- Return answer vector.\\n\\nMy HashMap Submission:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IT IF YOU LIKED IT, IT REALLY MOTIVATES :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());    //Sorted Array\\n        if(nums.size() < 3){    //Base case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){        //Base case 2\\n            return {};\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            if(i > 0 && nums[i] == nums[i - 1]){    //If number is getting repeated, ignore the lower loop and continue.\\n                continue;\\n            }\\n            int low = i + 1 , high = nums.size() - 1;   //Make two pointers high and low, and initialize sum as 0.\\n            int sum = 0;\\n            while(low < high){                          //Search between two pointers, just similiar to binary search.\\n                sum = nums[i] + nums[low] + nums[high];\\n                if(sum > 0){   //If sum is +ve, means, we need more -ve numbers to make it 0, decreament high (high--).\\n                    high--;\\n                } else if(sum < 0){ //If sum is -ve, means, we need more +ve numbers to make it 0, increament low (low++).\\n                    low++;\\n                } else {\\n                    answer.push_back({nums[i] , nums[low] , nums[high]});  //we have found the required triplet, push it in answer vector\\n                    int last_low_occurence = nums[low] , last_high_occurence = nums[high];  //Now again, to avoid duplicate triplets, we have to navigate to last occurences of num[low] and num[high] respectively\\n                    while(low < high && nums[low] == last_low_occurence){   // Update the low and high with last occurences of low and high.\\n                        low++;\\n                    }\\n                    while(low < high && nums[high] == last_high_occurence){\\n                        high--;\\n                    }\\n                }\\n            }\\n        }\\n        return answer;      //Return the answer vector.\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7392,
                "title": "python-easy-to-understand-solution-o-n-n-time",
                "content": "        \\n    def threeSum(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if s < 0:\\n                    l +=1 \\n                elif s > 0:\\n                    r -= 1\\n                else:\\n                    res.append((nums[i], nums[l], nums[r]))\\n                    while l < r and nums[l] == nums[l+1]:\\n                        l += 1\\n                    while l < r and nums[r] == nums[r-1]:\\n                        r -= 1\\n                    l += 1; r -= 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def threeSum(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if s < 0:\\n                    l +=1 \\n                elif s > 0:\\n                    r -= 1\\n                else:\\n                    res.append((nums[i], nums[l], nums[r]))\\n                    while l < r and nums[l] == nums[l+1]:\\n                        l += 1\\n                    while l < r and nums[r] == nums[r-1]:\\n                        r -= 1\\n                    l += 1; r -= 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 725950,
                "title": "python-5-easy-steps-beats-97-4-annotated",
                "content": "```python\\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\\n\\n\\tres = set()\\n\\n\\t#1. Split nums into three lists: negative numbers, positive numbers, and zeros\\n\\tn, p, z = [], [], []\\n\\tfor num in nums:\\n\\t\\tif num > 0:\\n\\t\\t\\tp.append(num)\\n\\t\\telif num < 0: \\n\\t\\t\\tn.append(num)\\n\\t\\telse:\\n\\t\\t\\tz.append(num)\\n\\n\\t#2. Create a separate set for negatives and positives for O(1) look-up times\\n\\tN, P = set(n), set(p)\\n\\n\\t#3. If there is at least 1 zero in the list, add all cases where -num exists in N and num exists in P\\n\\t#   i.e. (-3, 0, 3) = 0\\n\\tif z:\\n\\t\\tfor num in P:\\n\\t\\t\\tif -1*num in N:\\n\\t\\t\\t\\tres.add((-1*num, 0, num))\\n\\n\\t#3. If there are at least 3 zeros in the list then also include (0, 0, 0) = 0\\n\\tif len(z) >= 3:\\n\\t\\tres.add((0,0,0))\\n\\n\\t#4. For all pairs of negative numbers (-3, -1), check to see if their complement (4)\\n\\t#   exists in the positive number set\\n\\tfor i in range(len(n)):\\n\\t\\tfor j in range(i+1,len(n)):\\n\\t\\t\\ttarget = -1*(n[i]+n[j])\\n\\t\\t\\tif target in P:\\n\\t\\t\\t\\tres.add(tuple(sorted([n[i],n[j],target])))\\n\\n\\t#5. For all pairs of positive numbers (1, 1), check to see if their complement (-2)\\n\\t#   exists in the negative number set\\n\\tfor i in range(len(p)):\\n\\t\\tfor j in range(i+1,len(p)):\\n\\t\\t\\ttarget = -1*(p[i]+p[j])\\n\\t\\t\\tif target in N:\\n\\t\\t\\t\\tres.add(tuple(sorted([p[i],p[j],target])))\\n\\n\\treturn res\\n```\\n<img src = \"https://assets.leetcode.com/users/images/86c4a895-77e4-45ac-bebe-21a543b1cfe8_1594231844.7854018.png\" width = \"500px\">",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\\n\\n\\tres = set()\\n\\n\\t#1. Split nums into three lists: negative numbers, positive numbers, and zeros\\n\\tn, p, z = [], [], []\\n\\tfor num in nums:\\n\\t\\tif num > 0:\\n\\t\\t\\tp.append(num)\\n\\t\\telif num < 0: \\n\\t\\t\\tn.append(num)\\n\\t\\telse:\\n\\t\\t\\tz.append(num)\\n\\n\\t#2. Create a separate set for negatives and positives for O(1) look-up times\\n\\tN, P = set(n), set(p)\\n\\n\\t#3. If there is at least 1 zero in the list, add all cases where -num exists in N and num exists in P\\n\\t#   i.e. (-3, 0, 3) = 0\\n\\tif z:\\n\\t\\tfor num in P:\\n\\t\\t\\tif -1*num in N:\\n\\t\\t\\t\\tres.add((-1*num, 0, num))\\n\\n\\t#3. If there are at least 3 zeros in the list then also include (0, 0, 0) = 0\\n\\tif len(z) >= 3:\\n\\t\\tres.add((0,0,0))\\n\\n\\t#4. For all pairs of negative numbers (-3, -1), check to see if their complement (4)\\n\\t#   exists in the positive number set\\n\\tfor i in range(len(n)):\\n\\t\\tfor j in range(i+1,len(n)):\\n\\t\\t\\ttarget = -1*(n[i]+n[j])\\n\\t\\t\\tif target in P:\\n\\t\\t\\t\\tres.add(tuple(sorted([n[i],n[j],target])))\\n\\n\\t#5. For all pairs of positive numbers (1, 1), check to see if their complement (-2)\\n\\t#   exists in the negative number set\\n\\tfor i in range(len(p)):\\n\\t\\tfor j in range(i+1,len(p)):\\n\\t\\t\\ttarget = -1*(p[i]+p[j])\\n\\t\\t\\tif target in N:\\n\\t\\t\\t\\tres.add(tuple(sorted([p[i],p[j],target])))\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 143636,
                "title": "java-with-set",
                "content": "```\\n        public  List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> res  = new HashSet<>();\\n        if(nums.length==0) return new ArrayList<>(res);\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length-2;i++){\\n            int j =i+1;\\n           int  k = nums.length-1;\\n            while(j<k){\\n                int sum = nums[i]+nums[j]+nums[k];\\n                if(sum==0)res.add(Arrays.asList(nums[i],nums[j++],nums[k--]));\\n                else if (sum >0) k--;\\n                else if (sum<0) j++;\\n            }\\n\\n        }\\n        return new ArrayList<>(res);\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        public  List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> res  = new HashSet<>();\\n        if(nums.length==0) return new ArrayList<>(res);\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length-2;i++){\\n            int j =i+1;\\n           int  k = nums.length-1;\\n            while(j<k){\\n                int sum = nums[i]+nums[j]+nums[k];\\n                if(sum==0)res.add(Arrays.asList(nums[i],nums[j++],nums[k--]));\\n                else if (sum >0) k--;\\n                else if (sum<0) j++;\\n            }\\n\\n        }\\n        return new ArrayList<>(res);\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109452,
                "title": "c-easiest-beginner-friendly-sol-set-two-pointer-approach-o-n-2-logn-time-and-o-n-space",
                "content": "# Intuition of this Problem:\\nSet is used to prevent duplicate triplets and parallely we will use two pointer approach to maintain J and k.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Sort the input array\\n2. Initialize a set to store the unique triplets and an output vector to store the final result\\n3. Iterate through the array with a variable i, starting from index 0.\\n4. Initialize two pointers, j and k, with j starting at i+1 and k starting at the end of the array.\\n5. In the while loop, check if the sum of nums[i], nums[j], and nums[k] is equal to 0. If it is, insert the triplet into the set and increment j and decrement k to move the pointers.\\n6. If the sum is less than 0, increment j. If the sum is greater than 0, decrement k.\\n7. After the while loop, iterate through the set and add each triplet to the output vector.\\n8. Return the output vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code:\\n```C++ []\\n//Optimized Approach - O(n^2 logn + nlogn) - o(n^2 logn) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int target = 0;\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto triplets : s)\\n            output.push_back(triplets);\\n        return output;\\n    }\\n};\\n```\\n```C++ []\\n//Bruteforce Approach - O(n^3) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                for(int k = j+1; k < nums.size(); k++){\\n                    vector<int> temp;\\n                    if(nums[i] + nums[j] + nums[k] == 0){\\n                        temp.push_back(nums[i]);\\n                        temp.push_back(nums[j]);\\n                        temp.push_back(nums[k]);\\n                        s.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        for(auto allTriplets : s)\\n            output.push_back(allTriplets);\\n        return output;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        int target = 0;\\n        Arrays.sort(nums);\\n        Set<List<Integer>> s = new HashSet<>();\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++){\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        output.addAll(s);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n^2 logn)** // where n is the size of array\\nSorting takes O(nlogn) time and loop takes O(n^2) time, So the overall time complexity is O(nlogn + n^2 logn) - O(n^2 logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** // for taking hashset.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers"
                ],
                "code": "```C++ []\\n//Optimized Approach - O(n^2 logn + nlogn) - o(n^2 logn) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int target = 0;\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto triplets : s)\\n            output.push_back(triplets);\\n        return output;\\n    }\\n};\\n```\n```C++ []\\n//Bruteforce Approach - O(n^3) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                for(int k = j+1; k < nums.size(); k++){\\n                    vector<int> temp;\\n                    if(nums[i] + nums[j] + nums[k] == 0){\\n                        temp.push_back(nums[i]);\\n                        temp.push_back(nums[j]);\\n                        temp.push_back(nums[k]);\\n                        s.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        for(auto allTriplets : s)\\n            output.push_back(allTriplets);\\n        return output;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        int target = 0;\\n        Arrays.sort(nums);\\n        Set<List<Integer>> s = new HashSet<>();\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++){\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        output.addAll(s);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        target = 0\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    s.add((nums[i], nums[j], nums[k]))\\n                    j += 1\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        output = list(s)\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281302,
                "title": "javascript-with-lots-of-explanatory-comments",
                "content": "This problem stumped me for a long time, even though in principle it should be similar to the 2-sum problem. So I littered it with comments since I couldn\\'t understand it any other way.\\n\\nI hope this ends up being useful to someone else!\\n\\n```\\nfunction threeSum(nums) {\\n\\tconst results = []\\n\\n\\t// obviously irrelevant if we don\\'t have at least 3 numbers to play with!\\n\\tif (nums.length < 3) return results\\n\\n\\t// having the numbers in ascending order will make this problem much easier.\\n\\t// also, knowing the overall problem  will take at least O(N^2) time, we can\\n\\t// afford the O(NlogN) sort operation\\n\\tnums = nums.sort((a, b) => a - b)\\n\\n    // if the question asks us for a custom target, we can control it here\\n\\tlet target = 0\\n\\n\\tfor (let i = 0; i < nums.length - 2; i++) {\\n\\t\\t// `i` represents the \"left\" most number in our sorted set.\\n\\t\\t// once this number hits 0, there\\'s no need to go further since\\n\\t\\t// positive numbers cannot sum to a negative number\\n\\t\\tif (nums[i] > target) break\\n\\n\\t\\t// we don\\'t want repeats, so skip numbers we\\'ve already seen\\n\\t\\tif (i > 0 && nums[i] === nums[i - 1]) continue\\n\\n\\t\\t// `j` represents the \"middle\" element between `i` and `k`.\\n\\t\\t// we will increment this up through the array while `i` and `k`\\n\\t\\t// are anchored to their positions. we will decrement `k` for\\n\\t\\t// for each pass through the array, and finally increment `i`\\n\\t\\t// once `j` and `k` meet.\\n\\t\\tlet j = i + 1\\n\\n\\t\\t// `k` represents the \"right\" most element\\n\\t\\tlet k = nums.length - 1\\n\\t\\t\\n\\t\\t// to summarize our setup, we have `i` that starts at the beginning,\\n\\t\\t// `k` that starts at the end, and `j` that races in between the two.\\n\\t\\t//\\n\\t\\t// note that `i` is controlled by our outer for-loop and will move the slowest.\\n\\t\\t// in the meantime, `j` and `k` will take turns inching towards each other depending\\n\\t\\t// on some logic we\\'ll set up below. once they collide, `i` will be incremented up\\n\\t\\t// and we\\'ll repeat the process.\\n\\n\\t\\twhile (j < k) {\\n\\t\\t\\tlet sum = nums[i] + nums[j] + nums[k]\\n\\n\\t\\t\\t// if we find the target sum, increment `j` and decrement `k` for\\n\\t\\t\\t// other potential combos where `i` is the anchor\\n\\t\\t\\tif (sum === target) {\\n\\t\\t\\t\\t// store the valid threesum\\n\\t\\t\\t\\tresults.push([nums[i], nums[j], nums[k]])\\n\\n\\t\\t\\t\\t// this is important! we need to continue to increment `j` and decrement `k`\\n\\t\\t\\t\\t// as long as those values are duplicated. in other words, we wanna skip values\\n\\t\\t\\t\\t// we\\'ve already seen. otherwise, an input array of [-2,0,0,2,2] would result in\\n\\t\\t\\t\\t// [[-2,0,2], [-2,0,2]].\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t// (i\\'m not a fan of this part because we\\'re doing a while loop as we\\'re\\n\\t\\t\\t\\t// already inside of another while loop...)\\n\\t\\t\\t\\twhile (nums[j] === nums[j + 1]) j++\\n\\t\\t\\t\\twhile (nums[k] === nums[k - 1]) k--\\n\\n\\t\\t\\t\\t// finally, we need to actually move `j` forward and `k` backward to the\\n\\t\\t\\t\\t// next unique elements. the previous while loops will not handle this.\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\tk--\\n\\n\\t\\t\\t// if the sum is too small, increment `j` to get closer to the target\\n\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\tj++\\n\\n\\t\\t\\t// if the sum is too large, decrement `k` to get closer to the target\\n\\t\\t\\t} else { // (sum > target)\\n\\t\\t\\t\\tk--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn results\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction threeSum(nums) {\\n\\tconst results = []\\n\\n\\t// obviously irrelevant if we don\\'t have at least 3 numbers to play with!\\n\\tif (nums.length < 3) return results\\n\\n\\t// having the numbers in ascending order will make this problem much easier.\\n\\t// also, knowing the overall problem  will take at least O(N^2) time, we can\\n\\t// afford the O(NlogN) sort operation\\n\\tnums = nums.sort((a, b) => a - b)\\n\\n    // if the question asks us for a custom target, we can control it here\\n\\tlet target = 0\\n\\n\\tfor (let i = 0; i < nums.length - 2; i++) {\\n\\t\\t// `i` represents the \"left\" most number in our sorted set.\\n\\t\\t// once this number hits 0, there\\'s no need to go further since\\n\\t\\t// positive numbers cannot sum to a negative number\\n\\t\\tif (nums[i] > target) break\\n\\n\\t\\t// we don\\'t want repeats, so skip numbers we\\'ve already seen\\n\\t\\tif (i > 0 && nums[i] === nums[i - 1]) continue\\n\\n\\t\\t// `j` represents the \"middle\" element between `i` and `k`.\\n\\t\\t// we will increment this up through the array while `i` and `k`\\n\\t\\t// are anchored to their positions. we will decrement `k` for\\n\\t\\t// for each pass through the array, and finally increment `i`\\n\\t\\t// once `j` and `k` meet.\\n\\t\\tlet j = i + 1\\n\\n\\t\\t// `k` represents the \"right\" most element\\n\\t\\tlet k = nums.length - 1\\n\\t\\t\\n\\t\\t// to summarize our setup, we have `i` that starts at the beginning,\\n\\t\\t// `k` that starts at the end, and `j` that races in between the two.\\n\\t\\t//\\n\\t\\t// note that `i` is controlled by our outer for-loop and will move the slowest.\\n\\t\\t// in the meantime, `j` and `k` will take turns inching towards each other depending\\n\\t\\t// on some logic we\\'ll set up below. once they collide, `i` will be incremented up\\n\\t\\t// and we\\'ll repeat the process.\\n\\n\\t\\twhile (j < k) {\\n\\t\\t\\tlet sum = nums[i] + nums[j] + nums[k]\\n\\n\\t\\t\\t// if we find the target sum, increment `j` and decrement `k` for\\n\\t\\t\\t// other potential combos where `i` is the anchor\\n\\t\\t\\tif (sum === target) {\\n\\t\\t\\t\\t// store the valid threesum\\n\\t\\t\\t\\tresults.push([nums[i], nums[j], nums[k]])\\n\\n\\t\\t\\t\\t// this is important! we need to continue to increment `j` and decrement `k`\\n\\t\\t\\t\\t// as long as those values are duplicated. in other words, we wanna skip values\\n\\t\\t\\t\\t// we\\'ve already seen. otherwise, an input array of [-2,0,0,2,2] would result in\\n\\t\\t\\t\\t// [[-2,0,2], [-2,0,2]].\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t// (i\\'m not a fan of this part because we\\'re doing a while loop as we\\'re\\n\\t\\t\\t\\t// already inside of another while loop...)\\n\\t\\t\\t\\twhile (nums[j] === nums[j + 1]) j++\\n\\t\\t\\t\\twhile (nums[k] === nums[k - 1]) k--\\n\\n\\t\\t\\t\\t// finally, we need to actually move `j` forward and `k` backward to the\\n\\t\\t\\t\\t// next unique elements. the previous while loops will not handle this.\\n\\t\\t\\t\\tj++\\n\\t\\t\\t\\tk--\\n\\n\\t\\t\\t// if the sum is too small, increment `j` to get closer to the target\\n\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\tj++\\n\\n\\t\\t\\t// if the sum is too large, decrement `k` to get closer to the target\\n\\t\\t\\t} else { // (sum > target)\\n\\t\\t\\t\\tk--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn results\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7438,
                "title": "c-two-pointes-solution-easy-way-to-handle-duplicaiton",
                "content": "        \\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        for (unsigned int i=0; i<nums.size(); i++) {\\n            if ((i>0) && (nums[i]==nums[i-1]))\\n                continue;\\n            int l = i+1, r = nums.size()-1;\\n            while (l<r) {\\n                int s = nums[i]+nums[l]+nums[r];\\n                if (s>0) r--;\\n                else if (s<0) l++;\\n                else {\\n                    res.push_back(vector<int> {nums[i], nums[l], nums[r]});\\n                    while (nums[l]==nums[l+1]) l++;\\n                    while (nums[r]==nums[r-1]) r--;\\n                    l++; r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "        \\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        for (unsigned int i=0; i<nums.size(); i++) {\\n            if ((i>0) && (nums[i]==nums[i-1]))\\n                continue;\\n            int l = i+1, r = nums.size()-1;\\n            while (l<r) {\\n                int s = nums[i]+nums[l]+nums[r];\\n                if (s>0) r--;\\n                else if (s<0) l++;\\n                else {\\n                    res.push_back(vector<int> {nums[i], nums[l], nums[r]});\\n                    while (nums[l]==nums[l+1]) l++;\\n                    while (nums[r]==nums[r-1]) r--;\\n                    l++; r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3186495,
                "title": "best-c-3-solution-two-pointers-sorting-hash-table-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Three Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n2. Solved using Array(Two Nested Loop) + Sorting + Hash Table(set).\\n3. Solved using Array(Two Nested Loop) + Sorting. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    if((nums[i] + nums[j] + nums[k] == 0) && i != j && j != k && k != i){\\n                        set.insert({nums[i], nums[j], nums[k]});\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Two Nested Loop) + Sorting + Hash Table(set).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-2; i++){\\n            int low = i+1, high = n-1;\\n            while(low < high){\\n                if(nums[i] + nums[low] + nums[high] < 0){\\n                    low++;\\n                }\\n                else if(nums[i] + nums[low] + nums[high] > 0){\\n                    high--;\\n                }\\n                else{\\n                    set.insert({nums[i], nums[low], nums[high]});\\n                    low++;\\n                    high--;\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array(Two Nested Loop) + Sorting. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-1; i++){\\n            int low = i+1, high = n-1;\\n            while(low < high){\\n                if(nums[i] + nums[low] + nums[high] < 0){\\n                    low++;\\n                }\\n                else if(nums[i] + nums[low] + nums[high] > 0){\\n                    high--;\\n                }\\n                else{\\n                    output.push_back({nums[i], nums[low], nums[high]});\\n                    int tempIndex1 = low, tempIndex2 = high;\\n                    while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                    while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                }\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    if((nums[i] + nums[j] + nums[k] == 0) && i != j && j != k && k != i){\\n                        set.insert({nums[i], nums[j], nums[k]});\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Two Nested Loop) + Sorting + Hash Table(set).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-2; i++){\\n            int low = i+1, high = n-1;\\n            while(low < high){\\n                if(nums[i] + nums[low] + nums[high] < 0){\\n                    low++;\\n                }\\n                else if(nums[i] + nums[low] + nums[high] > 0){\\n                    high--;\\n                }\\n                else{\\n                    set.insert({nums[i], nums[low], nums[high]});\\n                    low++;\\n                    high--;\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array(Two Nested Loop) + Sorting. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-1; i++){\\n            int low = i+1, high = n-1;\\n            while(low < high){\\n                if(nums[i] + nums[low] + nums[high] < 0){\\n                    low++;\\n                }\\n                else if(nums[i] + nums[low] + nums[high] > 0){\\n                    high--;\\n                }\\n                else{\\n                    output.push_back({nums[i], nums[low], nums[high]});\\n                    int tempIndex1 = low, tempIndex2 = high;\\n                    while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                    while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                }\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7498,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/75883/python-solution-with-detailed-explanation\\n\\n**3Sum** https://leetcode.com/problems/3sum/\\n\\n**Sort based algorithm**\\n* a+b = -c. 3SUM reduces to 2SUM problem.\\n\\n**Handling Duplicates in 2SUM**\\n* Say index s and e are forming a solution in a sorted array. Now givens nums[s], there is a unique nums[e] such that nums[s]+nums[e]=Target. Therefore, if nums[s+1] is the same as nums[s], then searching in range s+1 to e will give us a duplicate solution. Thus we must move s till nums[s] != nums[s-1] to avoid getting duplicates.\\n```\\n                        while s<e and nums[s] == nums[s-1]:\\n                            s = s+1\\n```\\n\\n**Handling Duplicates in 3SUM**\\n* Imagine we are at index i and we have invoked the 2SUM problem from index i+1 to end of the array. Now once the 2SUM terminates, we will have a list of all triplets which include nums[i]. To avoid duplicates, we must skip all nums[i] where nums[i] == nums[i-1].\\n```\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n```\\n\\n**Code**\\n```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        N, result = len(nums), []\\n        for i in range(N):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            target = nums[i]*-1\\n            s,e = i+1, N-1\\n            while s<e:\\n                if nums[s]+nums[e] == target:\\n                    result.append([nums[i], nums[s], nums[e]])\\n                    s = s+1\\n                    while s<e and nums[s] == nums[s-1]:\\n                        s = s+1\\n                elif nums[s] + nums[e] < target:\\n                    s = s+1\\n                else:\\n                    e = e-1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n                        while s<e and nums[s] == nums[s-1]:\\n                            s = s+1\\n```\n```\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n```\n```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        N, result = len(nums), []\\n        for i in range(N):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            target = nums[i]*-1\\n            s,e = i+1, N-1\\n            while s<e:\\n                if nums[s]+nums[e] == target:\\n                    result.append([nums[i], nums[s], nums[e]])\\n                    s = s+1\\n                    while s<e and nums[s] == nums[s-1]:\\n                        s = s+1\\n                elif nums[s] + nums[e] < target:\\n                    s = s+1\\n                else:\\n                    e = e-1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736346,
                "title": "java-easiest-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)^2\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/b2920264-cce0-4b2e-b47e-494b3e03b313_1688818718.3466094.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // Sort the array\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            // Skip duplicate elements for i\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (sum == 0) {\\n                    // Found a triplet with zero sum\\n                    ans.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n\\n                    // Skip duplicate elements for j\\n                    while (j < k && nums[j] == nums[j + 1]) {\\n                        j++;\\n                    }\\n\\n                    // Skip duplicate elements for k\\n                    while (j < k && nums[k] == nums[k - 1]) {\\n                        k--;\\n                    }\\n\\n                    // Move the pointers\\n                    j++;\\n                    k--;\\n                } else if (sum < 0) {\\n                    // Sum is less than zero, increment j to increase the sum\\n                    j++;\\n                } else {\\n                    // Sum is greater than zero, decrement k to decrease the sum\\n                    k--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // Sort the array\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            // Skip duplicate elements for i\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (sum == 0) {\\n                    // Found a triplet with zero sum\\n                    ans.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n\\n                    // Skip duplicate elements for j\\n                    while (j < k && nums[j] == nums[j + 1]) {\\n                        j++;\\n                    }\\n\\n                    // Skip duplicate elements for k\\n                    while (j < k && nums[k] == nums[k - 1]) {\\n                        k--;\\n                    }\\n\\n                    // Move the pointers\\n                    j++;\\n                    k--;\\n                } else if (sum < 0) {\\n                    // Sum is less than zero, increment j to increase the sum\\n                    j++;\\n                } else {\\n                    // Sum is greater than zero, decrement k to decrease the sum\\n                    k--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441821,
                "title": "c-solution-with-explanations-for-newbies-3",
                "content": "```\\n//We declare the list of lists that will contain our solution\\n            IList<IList<int>> result = new List<IList<int>>();\\n\\n            //The edge case\\n            if (nums.Length <= 2) return result;\\n            \\n            /*For the first, we have to sort the nums*/\\n            Array.Sort(nums);\\n\\n            /*Here we declare 3 indexes. This is how it works. \\n            -4 -2 -3 -1 0 0 0 2 3 10 21\\n             s  l                     r \\n             \\n             s - start index, l - left index, r - right index */\\n            int start = 0, left, right;\\n\\n            /*The target is that the number we are looking for to be composed out of 2 numbers from our array.\\n            for example, if we have the startIndex at -4, we are looking for those two numbers in the given array\\n            which, summed up will be the oposite of -4, which is 4, cuz -4 + 4 = 0 (duh) */\\n            int target;\\n\\n            /*The start goes from 0 to length-2 becuse look here\\n             -4 -2 -3 -1 0 0 0 2 3 10 21\\n                                 s  l  r      */\\n            while (start<nums.Length-2)\\n            {\\n                target = nums[start] * -1;\\n                left = start + 1;\\n                right = nums.Length - 1;\\n\\n                /*Now, the start index is fixed and we move the left and right indexes to find those two number\\n                which summed up will be the oposite of nums[s]  */\\n                while (left < right)\\n                {\\n                    /*The array is sorted, so if we move to the left the right index, the sum will decrese */\\n                    if (nums[left] + nums[right] > target)\\n                    {\\n                        --right;\\n                    }\\n\\n                    /*Here is the oposite, it the sum of nums[l] and nums[r] is less that what we are looking for,\\n                    then we move the left index, which means that the sum will increase due to the sorted array.\\n                    the left index will jump to a bigger value */\\n                    else if (nums[left] + nums[right] < target)\\n                    {\\n                        ++left;\\n                    }\\n                    /*If none of those are true, then it means that nums[l]+nums[r] = our desired value */\\n                    else\\n                    {\\n                        /*Here we create the solution and add it to the list of lists which contains the result. */\\n                        List<int> OneSolution = new List<int>() { nums[start], nums[left], nums[right] };\\n                        result.Add(OneSolution);\\n\\n                        /*Now, in order to generate different solutions, we have to jump over\\n                        repetitive values in the array.  */\\n                        while (left < right && nums[left] == OneSolution[1])\\n                            ++left;\\n                        while (left < right && nums[right] == OneSolution[2])\\n                            --right;\\n                    }\\n\\n                }\\n                /*Now we do the same thing to the start index. */\\n                int currentStartNumber = nums[start];\\n                while (start < nums.Length - 2 && nums[start] == currentStartNumber)\\n                    ++start;\\n            }\\n            return result;\\n```\\nIf it was useful for you, don\\'t forget to smash that upvote button <3",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C#"
                ],
                "code": "```\\n//We declare the list of lists that will contain our solution\\n            IList<IList<int>> result = new List<IList<int>>();\\n\\n            //The edge case\\n            if (nums.Length <= 2) return result;\\n            \\n            /*For the first, we have to sort the nums*/\\n            Array.Sort(nums);\\n\\n            /*Here we declare 3 indexes. This is how it works. \\n            -4 -2 -3 -1 0 0 0 2 3 10 21\\n             s  l                     r \\n             \\n             s - start index, l - left index, r - right index */\\n            int start = 0, left, right;\\n\\n            /*The target is that the number we are looking for to be composed out of 2 numbers from our array.\\n            for example, if we have the startIndex at -4, we are looking for those two numbers in the given array\\n            which, summed up will be the oposite of -4, which is 4, cuz -4 + 4 = 0 (duh) */\\n            int target;\\n\\n            /*The start goes from 0 to length-2 becuse look here\\n             -4 -2 -3 -1 0 0 0 2 3 10 21\\n                                 s  l  r      */\\n            while (start<nums.Length-2)\\n            {\\n                target = nums[start] * -1;\\n                left = start + 1;\\n                right = nums.Length - 1;\\n\\n                /*Now, the start index is fixed and we move the left and right indexes to find those two number\\n                which summed up will be the oposite of nums[s]  */\\n                while (left < right)\\n                {\\n                    /*The array is sorted, so if we move to the left the right index, the sum will decrese */\\n                    if (nums[left] + nums[right] > target)\\n                    {\\n                        --right;\\n                    }\\n\\n                    /*Here is the oposite, it the sum of nums[l] and nums[r] is less that what we are looking for,\\n                    then we move the left index, which means that the sum will increase due to the sorted array.\\n                    the left index will jump to a bigger value */\\n                    else if (nums[left] + nums[right] < target)\\n                    {\\n                        ++left;\\n                    }\\n                    /*If none of those are true, then it means that nums[l]+nums[r] = our desired value */\\n                    else\\n                    {\\n                        /*Here we create the solution and add it to the list of lists which contains the result. */\\n                        List<int> OneSolution = new List<int>() { nums[start], nums[left], nums[right] };\\n                        result.Add(OneSolution);\\n\\n                        /*Now, in order to generate different solutions, we have to jump over\\n                        repetitive values in the array.  */\\n                        while (left < right && nums[left] == OneSolution[1])\\n                            ++left;\\n                        while (left < right && nums[right] == OneSolution[2])\\n                            --right;\\n                    }\\n\\n                }\\n                /*Now we do the same thing to the start index. */\\n                int currentStartNumber = nums[start];\\n                while (start < nums.Length - 2 && nums[start] == currentStartNumber)\\n                    ++start;\\n            }\\n            return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369728,
                "title": "short-c-solution-beats-98-using-sorting-2-pointer-method",
                "content": "```cpp\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n\\tstd::vector<vector<int>> result;\\n\\tif (nums.empty()) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\tstd::size_t n_size = nums.size();\\n\\tstd::sort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n_size; ++i) {\\n\\t\\t// all numbers from now on will be greater than 0, no point in continuing\\n\\t\\tif (nums[i] > 0) break;\\n\\n\\t\\t// we have seen this number & combo before; skip\\n\\t\\tif (i > 0 and nums[i] == nums[i-1]) continue;\\n\\n\\t\\tint left = i+1, right = n_size - 1;\\n\\t\\twhile (left < right) {\\n\\t\\t\\tint sum = nums[i] + nums[left] + nums[right];\\n\\t\\t\\tif (sum < 0) {\\n\\t\\t\\t\\t++left;\\n\\t\\t\\t} else if (sum > 0) {\\n\\t\\t\\t\\t--right;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.push_back({nums[i], nums[left], nums[right]});\\n\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t// we have seen this number & combo before; skip\\n\\t\\t\\t\\twhile (left < right && nums[left] == last_left) ++left;\\n\\t\\t\\t\\twhile (left < right && nums[right] == last_right) --right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```cpp\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n\\tstd::vector<vector<int>> result;\\n\\tif (nums.empty()) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\tstd::size_t n_size = nums.size();\\n\\tstd::sort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n_size; ++i) {\\n\\t\\t// all numbers from now on will be greater than 0, no point in continuing\\n\\t\\tif (nums[i] > 0) break;\\n\\n\\t\\t// we have seen this number & combo before; skip\\n\\t\\tif (i > 0 and nums[i] == nums[i-1]) continue;\\n\\n\\t\\tint left = i+1, right = n_size - 1;\\n\\t\\twhile (left < right) {\\n\\t\\t\\tint sum = nums[i] + nums[left] + nums[right];\\n\\t\\t\\tif (sum < 0) {\\n\\t\\t\\t\\t++left;\\n\\t\\t\\t} else if (sum > 0) {\\n\\t\\t\\t\\t--right;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.push_back({nums[i], nums[left], nums[right]});\\n\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t// we have seen this number & combo before; skip\\n\\t\\t\\t\\twhile (left < right && nums[left] == last_left) ++left;\\n\\t\\t\\t\\twhile (left < right && nums[right] == last_right) --right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429962,
                "title": "9-lines-code-simplest-specially-for-beginners-detailed-explanation-of-approach-two-pointer",
                "content": "first of all sort the array so that you will apply my approach of two pointers.\\n\\ntraverse the whole array.\\n\\nif there is duplicate of an element in an array then simply go to the next element thats why i write this step.\\n**if(i>0 && nums[i]==nums[i-1])**\\n          {\\n              continue;\\n            }\\nthen make two pointer first is i+1 and other is the last element .\\n\\ncheck that if sum of all nums[i]+nums[low]+nums[high]=0.\\nthen simply insert it in the 2-d vector.\\n\\n\\nif nums[low] has a duplicate value the simply increment the value of low that\\'s why i have writtened the step.\\n\\n** int val1=nums[j];\\n                while(j<k && nums[j]==val1)\\n                    j++;**\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\nsimilarly for high if there is any dulicate value of nums[high] then simply decremenet the value of high.\\n\\n** int val2=nums[k];\\n                while(j<k && nums[k]==val2)\\n                    k--;**\\n\\t\\t\\t\\t\\t\\n**lastly check if the sum of all three nums[i],nums[low],nums[high] is less than 0\\nthen simply increment low pointer.\\nnow this is the main reason behind that sorting of vector.\\ncheck if the sum of all three nums[i],nums[low],nums[high] is greater  than 0\\nthen simply decrement high pointer**.\\n\\n\\n\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n      \\n      vector<vector<int>> v;\\n      \\n        \\n        sort(nums.begin(),nums.end());\\n        \\n       \\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])   continue;\\n             int j=i+1, k=nums.size()-1;\\n           \\n            \\n            while(j<k){\\n            \\n            if(nums[i]+nums[j]+nums[k]==0)\\n            {\\n               v.push_back({nums[i],nums[j],nums[k]});\\n                \\n               \\n                int val1=nums[j];\\n                while(j<k && nums[j]==val1) j++;\\n                    \\n                \\n                 int val2=nums[k];\\n                while(j<k && nums[k]==val2) k--;\\n                   \\n            }\\n                \\n                else if(nums[i]+nums[j]+nums[k]<0)  j++;\\n                  \\n                \\n                  \\n                else if(nums[i]+nums[j]+nums[k]>0)  k--;\\n                  \\n        }\\n        }\\n        \\n        \\n        return v;\\n    }\\n\\t\\n\\t//keep coding Guys \\n\\t// Happy coding \\n\\t\\n\\t// Guys plz plz plz upvote my solution if you really understands and like it .and comment if you have any doubt.\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "first of all sort the array so that you will apply my approach of two pointers.\\n\\ntraverse the whole array.\\n\\nif there is duplicate of an element in an array then simply go to the next element thats why i write this step.\\n**if(i>0 && nums[i]==nums[i-1])**\\n          {\\n              continue;\\n            }\\nthen make two pointer first is i+1 and other is the last element .\\n\\ncheck that if sum of all nums[i]+nums[low]+nums[high]=0.\\nthen simply insert it in the 2-d vector.\\n\\n\\nif nums[low] has a duplicate value the simply increment the value of low that\\'s why i have writtened the step.\\n\\n** int val1=nums[j];\\n                while(j<k && nums[j]==val1)\\n                    j++;**\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\nsimilarly for high if there is any dulicate value of nums[high] then simply decremenet the value of high.\\n\\n** int val2=nums[k];\\n                while(j<k && nums[k]==val2)\\n                    k--;**\\n\\t\\t\\t\\t\\t\\n**lastly check if the sum of all three nums[i],nums[low],nums[high] is less than 0\\nthen simply increment low pointer.\\nnow this is the main reason behind that sorting of vector.\\ncheck if the sum of all three nums[i],nums[low],nums[high] is greater  than 0\\nthen simply decrement high pointer**.\\n\\n\\n\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n      \\n      vector<vector<int>> v;\\n      \\n        \\n        sort(nums.begin(),nums.end());\\n        \\n       \\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])   continue;\\n             int j=i+1, k=nums.size()-1;\\n           \\n            \\n            while(j<k){\\n            \\n            if(nums[i]+nums[j]+nums[k]==0)\\n            {\\n               v.push_back({nums[i],nums[j],nums[k]});\\n                \\n               \\n                int val1=nums[j];\\n                while(j<k && nums[j]==val1) j++;\\n                    \\n                \\n                 int val2=nums[k];\\n                while(j<k && nums[k]==val2) k--;\\n                   \\n            }\\n                \\n                else if(nums[i]+nums[j]+nums[k]<0)  j++;\\n                  \\n                \\n                  \\n                else if(nums[i]+nums[j]+nums[k]>0)  k--;\\n                  \\n        }\\n        }\\n        \\n        \\n        return v;\\n    }\\n\\t\\n\\t//keep coding Guys \\n\\t// Happy coding \\n\\t\\n\\t// Guys plz plz plz upvote my solution if you really understands and like it .and comment if you have any doubt.\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2602454,
                "title": "python-java-solution-100-explained",
                "content": "# PYTHON CODE\\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]: \\n        nums.sort() # sorting cause we need to avoid duplicates, with this duplicates will be near to each other\\n        l=[]\\n        for i in range(len(nums)):  #this loop will help to fix the one number i.e, i\\n            if i>0 and nums[i-1]==nums[i]:  #skipping if we found the duplicate of i\\n                continue \\n\\t\\t\\t\\n\\t\\t\\t#NOW FOLLOWING THE RULE OF TWO POINTERS AFTER FIXING THE ONE VALUE (i)\\n            j=i+1 #taking j pointer larger than i (as said in ques)\\n            k=len(nums)-1 #taking k pointer from last \\n            while j<k: \\n                s=nums[i]+nums[j]+nums[k] \\n                if s>0: #if sum s is greater than 0(target) means the larger value(from right as nums is sorted i.e, k at right) \\n\\t\\t\\t\\t#is taken and it is not able to sum up to the target\\n                    k-=1  #so take value less than previous\\n                elif s<0: #if sum s is less than 0(target) means the shorter value(from left as nums is sorted i.e, j at left) \\n\\t\\t\\t\\t#is taken and it is not able to sum up to the target\\n                    j+=1  #so take value greater than previous\\n                else:\\n                    l.append([nums[i],nums[j],nums[k]]) #if sum s found equal to the target (0)\\n                    j+=1 \\n                    while nums[j-1]==nums[j] and j<k: #skipping if we found the duplicate of j and we dont need to check \\n\\t\\t\\t\\t\\t#the duplicate of k cause it will automatically skip the duplicate by the adjustment of i and j\\n                        j+=1   \\n        return l\\n```\\n\\n# JAVA CODE\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) { \\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for (int i=0; i<nums.length; i++){\\n            if (i>0 && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            int j = i+1;\\n            int k = nums.length - 1;\\n            while (j<k){\\n                int s = nums[i]+ nums[j]+ nums[k];\\n                if (s > 0){\\n                    k -= 1;\\n                }\\n                else if (s < 0){\\n                    j += 1;\\n                }\\n                else{\\n                    arr.add(new ArrayList<>(Arrays.asList(nums[i],nums[j],nums[k]))); \\n                    j+=1;\\n                    while (j<k && nums[j] == nums[j-1]){\\n                        j+=1;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]: \\n        nums.sort() # sorting cause we need to avoid duplicates, with this duplicates will be near to each other\\n        l=[]\\n        for i in range(len(nums)):  #this loop will help to fix the one number i.e, i\\n            if i>0 and nums[i-1]==nums[i]:  #skipping if we found the duplicate of i\\n                continue \\n\\t\\t\\t\\n\\t\\t\\t#NOW FOLLOWING THE RULE OF TWO POINTERS AFTER FIXING THE ONE VALUE (i)\\n            j=i+1 #taking j pointer larger than i (as said in ques)\\n            k=len(nums)-1 #taking k pointer from last \\n            while j<k: \\n                s=nums[i]+nums[j]+nums[k] \\n                if s>0: #if sum s is greater than 0(target) means the larger value(from right as nums is sorted i.e, k at right) \\n\\t\\t\\t\\t#is taken and it is not able to sum up to the target\\n                    k-=1  #so take value less than previous\\n                elif s<0: #if sum s is less than 0(target) means the shorter value(from left as nums is sorted i.e, j at left) \\n\\t\\t\\t\\t#is taken and it is not able to sum up to the target\\n                    j+=1  #so take value greater than previous\\n                else:\\n                    l.append([nums[i],nums[j],nums[k]]) #if sum s found equal to the target (0)\\n                    j+=1 \\n                    while nums[j-1]==nums[j] and j<k: #skipping if we found the duplicate of j and we dont need to check \\n\\t\\t\\t\\t\\t#the duplicate of k cause it will automatically skip the duplicate by the adjustment of i and j\\n                        j+=1   \\n        return l\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) { \\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for (int i=0; i<nums.length; i++){\\n            if (i>0 && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            int j = i+1;\\n            int k = nums.length - 1;\\n            while (j<k){\\n                int s = nums[i]+ nums[j]+ nums[k];\\n                if (s > 0){\\n                    k -= 1;\\n                }\\n                else if (s < 0){\\n                    j += 1;\\n                }\\n                else{\\n                    arr.add(new ArrayList<>(Arrays.asList(nums[i],nums[j],nums[k]))); \\n                    j+=1;\\n                    while (j<k && nums[j] == nums[j-1]){\\n                        j+=1;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7384,
                "title": "my-python-solution-based-on-2-sum-200-ms-beat-93-37",
                "content": "    class Solution(object):\\n        def threeSum(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            if len(nums) < 3:\\n                return []\\n            nums.sort()\\n            res = set()\\n            for i, v in enumerate(nums[:-2]):\\n                if i >= 1 and v == nums[i-1]:\\n                    continue\\n                d = {}\\n                for x in nums[i+1:]:\\n                    if x not in d:\\n                        d[-v-x] = 1\\n                    else:\\n                        res.add((v, -v-x, x))\\n            return map(list, res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        def threeSum(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            if len(nums) < 3:\\n                return []\\n            nums.sort()\\n            res = set()\\n            for i, v in enumerate(nums[:-2]):\\n                if i >= 1 and v == nums[i-1]:\\n                    continue\\n                d = {}",
                "codeTag": "Java"
            },
            {
                "id": 7373,
                "title": "share-my-simple-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> threeSum(int[] nums) {\\n            List<List<Integer>> result = new ArrayList<>();\\n            if(nums.length < 3) return result;\\n            Arrays.sort(nums);\\n            int i = 0;\\n            while(i < nums.length - 2) {\\n                if(nums[i] > 0) break;\\n                int j = i + 1;\\n                int k = nums.length - 1;\\n                while(j < k) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    if(sum <= 0) while(nums[j] == nums[++j] && j < k);\\n                    if(sum >= 0) while(nums[k--] == nums[k] && j < k);\\n                }\\n                while(nums[i] == nums[++i] && i < nums.length - 2);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> threeSum(int[] nums) {\\n            List<List<Integer>> result = new ArrayList<>();\\n            if(nums.length < 3) return result;\\n            Arrays.sort(nums);\\n            int i = 0;\\n            while(i < nums.length - 2) {\\n                if(nums[i] > 0) break;\\n                int j = i + 1;\\n                int k = nums.length - 1;\\n                while(j < k) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    if(sum <= 0) while(nums[j] == nums[++j] && j < k);\\n                    if(sum >= 0) while(nums[k--] == nums[k] && j < k);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 561981,
                "title": "java-python-sort-then-two-pointers-clean-concise",
                "content": "**Idea**\\n- Sort `nums` in increasing order.\\n- Fix `nums[i]` by itearting `i` in `[0..n-1]`\\n\\t- Two pointers in range `[i+1..n-1]` to find `nums[l]` and `nums[r]` so that `nums[i] + nums[l] + nums[r] = 0`\\n- But, remember to skip duplicate elements as well.\\n\\n<iframe src=\"https://leetcode.com/playground/7ynfAyJD/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nComplexity\\n- Time: `O(n^2)`\\n- Extra space (without counting output as space): `O(1)`",
                "solutionTags": [],
                "code": "**Idea**\\n- Sort `nums` in increasing order.\\n- Fix `nums[i]` by itearting `i` in `[0..n-1]`\\n\\t- Two pointers in range `[i+1..n-1]` to find `nums[l]` and `nums[r]` so that `nums[i] + nums[l] + nums[r] = 0`\\n- But, remember to skip duplicate elements as well.\\n\\n<iframe src=\"https://leetcode.com/playground/7ynfAyJD/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nComplexity\\n- Time: `O(n^2)`\\n- Extra space (without counting output as space): `O(1)`",
                "codeTag": "Unknown"
            },
            {
                "id": 3523898,
                "title": "beats-99-48-44-145-top-interview-question",
                "content": "# Intuition\\n*3 solutions, Each latter is more optimized!*\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n ***Note, these are worst case complexity, optimization improves the runtime.***\\n\\n- Space complexity:\\nO(n)\\n ***Note, This is the dominant or the higher order space complexity, while optimizing the space incurred might be higher but it will always be linear to the input size..***\\n\\n\\n# Approach - 1\\nThe 3-sum problem using the two-pointer approach. Here\\'s a breakdown of how it works:\\n\\n1. The function `threeSum` takes an input list of integers called `nums` and returns a list of lists, representing the triplets that satisfy the 3-sum condition.\\n\\n2. The first step is to sort the input array `nums` in ascending order using the `sort()` method. Sorting the array is necessary to apply the two-pointer approach efficiently.\\n\\n3. A set called `triplets` is initialized to store the unique triplets that satisfy the 3-sum condition. Using a set helps avoid duplicate entries in the final result.\\n\\n4. The code then proceeds with a loop that iterates through each element of the array, up to the second-to-last element (`len(nums) - 2`). This is because we need at least three elements to form a triplet.\\n\\n5. Within the loop, the current element at index `i` is assigned to the variable `firstNum`. Two pointers, `j` and `k`, are initialized. `j` starts from `i + 1` (the element next to `firstNum`), and `k` starts from the last element of the array.\\n\\n6. A while loop is used to find the pairs (`secondNum` and `thirdNum`) that can form a triplet with `firstNum`. The loop continues as long as `j` is less than `k`.\\n\\n7. Inside the while loop, the current values at indices `j` and `k` are assigned to `secondNum` and `thirdNum`, respectively.\\n\\n8. The `potentialSum` variable stores the sum of `firstNum`, `secondNum`, and `thirdNum`.\\n\\n9. If `potentialSum` is greater than 0, it means the sum is too large. In this case, we decrement `k` to consider a smaller value.\\n\\n10. If `potentialSum` is less than 0, it means the sum is too small. In this case, we increment `j` to consider a larger value.\\n\\n11. If `potentialSum` is equal to 0, it means we have found a triplet that satisfies the 3-sum condition. The triplet `(firstNum, secondNum, thirdNum)` is added to the `triplets` set. Additionally, both `j` and `k` are incremented and decremented, respectively, to explore other possible combinations.\\n\\n12. After the loop ends, the function returns the `triplets` set, which contains all the unique triplets that sum to zero.\\n\\n# Code : Beats 23.46% *(Easy to understand)*\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        triplets = set()\\n        for i in range(len(nums) - 2):\\n            firstNum = nums[i]\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                secondNum  = nums[j]\\n                thirdNum = nums[k]\\n\\n                potentialSum = firstNum + secondNum + thirdNum \\n                if potentialSum > 0:\\n                    k -= 1\\n                elif potentialSum < 0:\\n                    j += 1\\n                else:\\n                    triplets.add((firstNum , secondNum ,thirdNum))\\n                    j += 1\\n                    k -= 1\\n        return triplets\\n```\\n\\n# Approach - 2\\nThis is an *`enhanced version`* of the previous solution. It includes additional checks to skip duplicate values and improve efficiency. Here\\'s an explanation of the changes and the updated time and space complexity:\\n\\nChanges in the Code:\\n1. Right after sorting the array, the code includes an `if` statement to check for duplicate values of the first number. If `nums[i]` is the same as `nums[i - 1]`, it means we have already processed a triplet with the same first number, so we skip the current iteration using the `continue` statement.\\n\\n2. Inside the `else` block where a triplet is found, the code includes two additional `while` loops to skip duplicate values of the second and third numbers. These loops increment `j` and decrement `k` until the next distinct values are encountered.\\n\\n\\nOverall, the time complexity is improved due to skipping duplicate values, resulting in a more efficient execution. The time complexity remains O(n^2) in the worst case but with better average-case performance.\\n\\n\\n# Code: Optimized, Beats: 57.64%\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        triplets = set()\\n        for i in range(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue  # Skip duplicate values of the first number\\n            firstNum = nums[i]\\n            j, k = i + 1, len(nums) - 1\\n            while j < k:\\n                secondNum, thirdNum = nums[j], nums[k]\\n                potentialSum = firstNum + secondNum + thirdNum \\n                if potentialSum > 0:\\n                    k -= 1\\n                elif potentialSum < 0:\\n                    j += 1\\n                else:\\n                    triplets.add((firstNum, secondNum, thirdNum))\\n                    j, k = j + 1, k - 1\\n                    while j < k and nums[j] == nums[j - 1]:\\n                        j += 1  # Skip duplicate values of the second number\\n                    while j < k and nums[k] == nums[k + 1]:\\n                        k -= 1  # Skip duplicate values of the third number\\n        return triplets\\n```\\n\\n# Approach - 3\\n\\nThis code is another implementation of the Three Sum problem that uses `defaultdict` from the `collections` module. Here\\'s an explanation of the code:\\n\\n1. The code initializes three variables: `negative`, `positive`, and `zeros` as defaultdicts with a default value of 0. These dictionaries will store the count of negative numbers, positive numbers, and zeros, respectively.\\n\\n2. The `for` loop iterates through each number in the input `nums` list and increments the count of the corresponding dictionary based on whether the number is negative, positive, or zero.\\n\\n3. The code initializes an empty list called `result`, which will store the triplets that add up to zero.\\n\\n4. If there are one or more zeros in the input list, the code loops through the negative numbers and checks if the complement of the negative number exists in the positive numbers dictionary. If it does, the code appends a triplet of (0, n, -n) to the `result` list.\\n\\n5. If there are more than two zeros in the input list, the code appends a triplet of (0,0,0) to the `result` list.\\n\\n6. The code loops through pairs of negative and positive dictionaries and iterates through each pair of keys `(j, k)` in the dictionary. Then, it loops through each pair of keys `(j2, k2)` in the same dictionary, starting from the current index in the outer loop to avoid duplicates. Finally, the code checks if the complement of the sum of the two keys exists in the opposite dictionary (e.g., if the current loop is on the negative dictionary, it checks if the complement exists in the positive dictionary). If it does, the code appends a triplet of `(j, j2, -j-j2)` to the `result` list.\\n\\n7. The `result` list is returned at the end of the function.\\n\\n\\n# Code - Beats: 99.48\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        negative = defaultdict(int)\\n        positive = defaultdict(int)\\n        zeros = 0\\n        for num in nums:\\n            if num < 0:\\n                negative[num] += 1\\n            elif num > 0:\\n                positive[num] += 1\\n            else:\\n                zeros += 1\\n        \\n        result = []\\n        if zeros:\\n            for n in negative:\\n                if -n in positive:\\n                    result.append((0, n, -n))       \\n            if zeros > 2:\\n                result.append((0,0,0))\\n\\n        for set1, set2 in ((negative, positive), (positive, negative)):\\n            set1Items = list(set1.items())\\n            for i, (j, k) in enumerate(set1Items):\\n                for j2, k2 in set1Items[i:]:\\n                    if j != j2 or (j == j2 and k > 1):\\n                        if -j-j2 in set2:\\n                            result.append((j, j2, -j-j2))\\n        return result\\n```\\n\\n# Above Complexity: [in Depth]\\n\\n`Time Complexity`:\\n1. The `for` loop that counts the occurrence of each number in the input list takes `O(n)` time.\\n\\n2. The loop that checks for zero triplets takes `O(n)` time in the worst case, as it iterates through each negative number and checks if its complement exists in the positive numbers dictionary.\\n\\n3. The loop that checks for non-zero triplets takes `O(n^2)` time in the worst case, as it iterates through each pair of keys in each dictionary and checks if their complement exists in the opposite dictionary.\\n\\n4. The overall `time complexity` of the function is `O(n^2)`, as the loop that takes the most time is the one that checks for non-zero triplets.\\n\\n`Space Complexity`:\\n1. The space complexity is `O(n)` for the three `defaultdict` dictionaries, as they store the count of each number in the input list.\\n\\n2. The space complexity of the `result` list is also `O(n)` in the worst case, as there can be up to `O(n)` triplets that add up to zero\\n\\n\\nIn summary, this implementation of the Three Sum problem also has a time complexity of `O(n^2)` and a space complexity of `O(n)`. However, it uses `defaultdict` to count the occurrence of each number in the input list and improves the efficiency of checking for zero triplets by using a dictionary lookup instead of iterating through the list.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        triplets = set()\\n        for i in range(len(nums) - 2):\\n            firstNum = nums[i]\\n            j = i + 1\\n            k = len(nums) - 1\\n            while j < k:\\n                secondNum  = nums[j]\\n                thirdNum = nums[k]\\n\\n                potentialSum = firstNum + secondNum + thirdNum \\n                if potentialSum > 0:\\n                    k -= 1\\n                elif potentialSum < 0:\\n                    j += 1\\n                else:\\n                    triplets.add((firstNum , secondNum ,thirdNum))\\n                    j += 1\\n                    k -= 1\\n        return triplets\\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        triplets = set()\\n        for i in range(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue  # Skip duplicate values of the first number\\n            firstNum = nums[i]\\n            j, k = i + 1, len(nums) - 1\\n            while j < k:\\n                secondNum, thirdNum = nums[j], nums[k]\\n                potentialSum = firstNum + secondNum + thirdNum \\n                if potentialSum > 0:\\n                    k -= 1\\n                elif potentialSum < 0:\\n                    j += 1\\n                else:\\n                    triplets.add((firstNum, secondNum, thirdNum))\\n                    j, k = j + 1, k - 1\\n                    while j < k and nums[j] == nums[j - 1]:\\n                        j += 1  # Skip duplicate values of the second number\\n                    while j < k and nums[k] == nums[k + 1]:\\n                        k -= 1  # Skip duplicate values of the third number\\n        return triplets\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        negative = defaultdict(int)\\n        positive = defaultdict(int)\\n        zeros = 0\\n        for num in nums:\\n            if num < 0:\\n                negative[num] += 1\\n            elif num > 0:\\n                positive[num] += 1\\n            else:\\n                zeros += 1\\n        \\n        result = []\\n        if zeros:\\n            for n in negative:\\n                if -n in positive:\\n                    result.append((0, n, -n))       \\n            if zeros > 2:\\n                result.append((0,0,0))\\n\\n        for set1, set2 in ((negative, positive), (positive, negative)):\\n            set1Items = list(set1.items())\\n            for i, (j, k) in enumerate(set1Items):\\n                for j2, k2 in set1Items[i:]:\\n                    if j != j2 or (j == j2 and k > 1):\\n                        if -j-j2 in set2:\\n                            result.append((j, j2, -j-j2))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404887,
                "title": "python3-solution-extend-from-sum-2",
                "content": "``` python\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n        result = set()\\n        for i in range(len(nums)):\\n            l = i + 1\\n            r = len(nums) - 1\\n            target = 0 - nums[i]\\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    result.add((nums[i], nums[l], nums[r]))\\n                    l += 1\\n                    r -= 1\\n                elif nums[l] + nums[r] < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return list(result)\\n```\\n\\nThis solution is extended from 2 sum.\\n\\nWe first loop the list from left to right, so our target is `0 - current value`.\\n\\nThen, we can use 2 sum solution to find the target from our remaining list.\\n\\nThe two sum solution is sort the array first then use two pointers one move from left to right if current sum lower than target, the another one move from right to left if current sum larger than target. So when we solve the 3 sum problem we can sort the whole list first, in this way, we can also guarantee the answers we get are in the same order. for example, [-3, 1, 2] always in this order rather than [2, 1, -3] or [1, 2, -3], which simplifier our deduplication.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` python\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums = sorted(nums)\\n        result = set()\\n        for i in range(len(nums)):\\n            l = i + 1\\n            r = len(nums) - 1\\n            target = 0 - nums[i]\\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    result.add((nums[i], nums[l], nums[r]))\\n                    l += 1\\n                    r -= 1\\n                elif nums[l] + nums[r] < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return list(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7514,
                "title": "20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum",
                "content": "    vector<vector<int> > threeSum(vector<int>& nums) {\\n        if(nums.size() <=2) return {};\\n        vector<vector<int> > rtn;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i =0; i < nums.size();){\\n            int start = i+1, end = nums.size()-1;\\n    \\n            while(start < end){\\n                if(nums[i]+nums[start]+nums[end] == 0){\\n                    rtn.push_back({nums[i],nums[start],nums[end]});\\n                    start++;\\n                    end--;\\n                    while((start < end) && nums[start] == nums[start-1]) start++;\\n                    while((start < end) && nums[end] == nums[end+1]) end--;\\n    \\n                }else if(nums[i]+nums[start]+nums[end]<0){\\n                    start++;\\n                    while((start < end) && nums[start] == nums[start-1]) start++;\\n                }else{\\n                    end--;\\n                    while((start < end) && nums[end] == nums[end+1]) end--;\\n                }\\n            }\\n            \\n            i++;\\n            while((i < nums.size()) && nums[i] == nums[i-1])\\n                i++;\\n            \\n        }\\n        return rtn;\\n    }\\n\\nThanks to my friend Yang Li inspired me of using two pointers",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<vector<int> > threeSum(vector<int>& nums) {\\n        if(nums.size() <=2) return {};\\n        vector<vector<int> > rtn;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i =0; i < nums.size();){\\n            int start = i+1, end = nums.size()-1;\\n    \\n            while(start < end){\\n                if(nums[i]+nums[start]+nums[end] == 0){\\n                    rtn.push_back({nums[i],nums[start],nums[end]});\\n                    start++;\\n                    end--;\\n                    while((start < end) && nums[start] == nums[start-1]) start++;\\n                    while((start < end) && nums[end] == nums[end+1]) end--;\\n    \\n                }else if(nums[i]+nums[start]+nums[end]<0){\\n                    start++;\\n                    while((start < end) && nums[start] == nums[start-1]) start++;\\n                }else{\\n                    end--;\\n                    while((start < end) && nums[end] == nums[end+1]) end--;\\n                }\\n            }\\n            \\n            i++;\\n            while((i < nums.size()) && nums[i] == nums[i-1])\\n                i++;\\n            \\n        }\\n        return rtn;\\n    }\\n\\nThanks to my friend Yang Li inspired me of using two pointers",
                "codeTag": "Unknown"
            },
            {
                "id": 1144266,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func threeSum(_ nums: [Int]) -> [[Int]] {\\n        \\n        var result: [[Int]] = []\\n        let nums = nums.sorted()\\n        let len = nums.count\\n        \\n        guard len >= 3 else { return result }\\n        \\n        for i in 0..<len {\\n            if i > 0 && nums[i] == nums[i-1] { continue }\\n            \\n            let num = 0 - nums[i]\\n            var a = i + 1, b = len - 1\\n            \\n            while a < b {\\n                let numA = nums[a], numB = nums[b]\\n                let sum = numA + numB\\n                if sum == num {\\n                    result.append([nums[i], numA, numB])\\n                    a += 1\\n                    b -= 1\\n                    while a < b && nums[a] == nums[a-1] { a += 1 }\\n                    while a < b && nums[b] == nums[b+1] { b -= 1 }\\n                } else {\\n                    sum > num ? b -= 1 : (a += 1)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.029 (0.031) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.threeSum([-1,0,1,2,-1,-4])\\n        XCTAssertEqual(value, [[-1,-1,2],[-1,0,1]])\\n    }\\n    func test1() {\\n        let value = solution.threeSum([])\\n        XCTAssertEqual(value, [])\\n    }\\n    func test2() {\\n        let value = solution.threeSum([0])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func threeSum(_ nums: [Int]) -> [[Int]] {\\n        \\n        var result: [[Int]] = []\\n        let nums = nums.sorted()\\n        let len = nums.count\\n        \\n        guard len >= 3 else { return result }\\n        \\n        for i in 0..<len {\\n            if i > 0 && nums[i] == nums[i-1] { continue }\\n            \\n            let num = 0 - nums[i]\\n            var a = i + 1, b = len - 1\\n            \\n            while a < b {\\n                let numA = nums[a], numB = nums[b]\\n                let sum = numA + numB\\n                if sum == num {\\n                    result.append([nums[i], numA, numB])\\n                    a += 1\\n                    b -= 1\\n                    while a < b && nums[a] == nums[a-1] { a += 1 }\\n                    while a < b && nums[b] == nums[b+1] { b -= 1 }\\n                } else {\\n                    sum > num ? b -= 1 : (a += 1)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.threeSum([-1,0,1,2,-1,-4])\\n        XCTAssertEqual(value, [[-1,-1,2],[-1,0,1]])\\n    }\\n    func test1() {\\n        let value = solution.threeSum([])\\n        XCTAssertEqual(value, [])\\n    }\\n    func test2() {\\n        let value = solution.threeSum([0])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738423,
                "title": "python3-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []        # Triples\\n        n = len(nums)   # Length of the list\\n        nums.sort()     # We need to sort the list first!\\n        \\n        for i in range(n-2):\\n            \\n            # Since the list is sorted, if nums[i] > 0, then all \\n            # nums[j] with j > i are positive as well, and we cannot\\n            # have three positive numbers sum up to 0. Return immediately.\\n            if nums[i] > 0:\\n                break\\n                \\n            # The nums[i] == nums[i-1] condition helps us avoid duplicates.\\n            # E.g., given [-1, -1, 0, 0, 1], when i = 0, we see [-1, 0, 1]\\n            # works. Now at i = 1, since nums[1] == -1 == nums[0], we avoid\\n            # this iteration and thus avoid duplicates. The i > 0 condition\\n            # is to avoid negative index, i.e., when i = 0, nums[i-1] = nums[-1]\\n            # and you don\\'t want to skip this iteration when nums[0] == nums[-1]\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n                \\n            # Classic two pointer solution\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if s < 0: # sum too small, move left ptr\\n                    l += 1\\n                elif s > 0: # sum too large, move right ptr\\n                    r -= 1\\n                else:\\n                    res.append([nums[i], nums[l], nums[r]])\\n                    \\n                    # we need to skip elements that are identical to our\\n                    # current solution, otherwise we would have duplicated triples\\n                    while l < r and nums[l] == nums[l+1]:\\n                        l += 1\\n                    while l < r and nums[r] == nums[r-1]:\\n                        r -= 1\\n                    l += 1\\n                    r -= 1\\n        return res\\n            \\n```\\nComment if you have any questions. I will reply asap.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []        # Triples\\n        n = len(nums)   # Length of the list\\n        nums.sort()     # We need to sort the list first!\\n        \\n        for i in range(n-2):\\n            \\n            # Since the list is sorted, if nums[i] > 0, then all \\n            # nums[j] with j > i are positive as well, and we cannot\\n            # have three positive numbers sum up to 0. Return immediately.\\n            if nums[i] > 0:\\n                break\\n                \\n            # The nums[i] == nums[i-1] condition helps us avoid duplicates.\\n            # E.g., given [-1, -1, 0, 0, 1], when i = 0, we see [-1, 0, 1]\\n            # works. Now at i = 1, since nums[1] == -1 == nums[0], we avoid\\n            # this iteration and thus avoid duplicates. The i > 0 condition\\n            # is to avoid negative index, i.e., when i = 0, nums[i-1] = nums[-1]\\n            # and you don\\'t want to skip this iteration when nums[0] == nums[-1]\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n                \\n            # Classic two pointer solution\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if s < 0: # sum too small, move left ptr\\n                    l += 1\\n                elif s > 0: # sum too large, move right ptr\\n                    r -= 1\\n                else:\\n                    res.append([nums[i], nums[l], nums[r]])\\n                    \\n                    # we need to skip elements that are identical to our\\n                    # current solution, otherwise we would have duplicated triples\\n                    while l < r and nums[l] == nums[l+1]:\\n                        l += 1\\n                    while l < r and nums[r] == nums[r-1]:\\n                        r -= 1\\n                    l += 1\\n                    r -= 1\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676313,
                "title": "java-binary-search-two-pointers-hashmap-5-solutions",
                "content": "# without sort\\n```\\n    //Runtime: 384 ms, faster than 24.18% of Java online submissions for 3Sum.\\n    //Memory Usage: 120.2 MB, less than 15.92% of Java online submissions for 3Sum.\\n    //without sort\\n    //Time: O(N * N * log3); Space:O(N)\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n\\n        Set<Integer> duplicatedSet = new HashSet<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            if (!duplicatedSet.add(nums[i])) continue;\\n\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int value = 0 - nums[i] - nums[j];\\n                if (map.containsKey(value) && map.get(value) == i) {\\n                    List<Integer> list = new ArrayList<>(Arrays.asList(nums[i], nums[j], value));\\n                    Collections.sort(list);\\n                    resultSet.add(list);\\n                }\\n                map.put(nums[j], i);\\n            }\\n        }\\n        return new ArrayList<>(resultSet) ;\\n    }\\n```\\n\\n# Two pointers\\n```\\n\\n    //Runtime: 47 ms, faster than 35.83% of Java online submissions for 3Sum.\\n    //Memory Usage: 60.1 MB, less than 32.20% of Java online submissions for 3Sum.\\n    //Two pointers\\n    //Time: O(N * LogN + N * N); Space : O(N + LogN)\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i <= nums.length - 3 && nums[i] <= 0;){\\n            int left = i + 1, right = nums.length - 1;\\n            if (0 - nums[i] - nums[left] < 0) break;\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum > 0) {\\n                    right--;\\n                    while (left < right && nums[right] == nums[right + 1]) right--; //skip duplicated number\\n                } else {\\n                    if (sum == 0) {\\n                        resultSet.add(Arrays.asList(nums[i], nums[left], nums[right]));\\n                        right--;\\n                        while (left < right && nums[right] == nums[right + 1]) right--;\\n                    }\\n                    left++;\\n                    while (left < right && nums[left] == nums[left - 1]) left++;\\n                }\\n            }\\n            i++;\\n            while(i < nums.length - 2 && nums[i] == nums[i - 1]) i++;\\n        }\\n        return new ArrayList<>(resultSet);\\n    }\\n```\\n# Binary Search\\n```\\n\\n    //Runtime: 99 ms, faster than 29.77% of Java online submissions for 3Sum.\\n    //Memory Usage: 60.2 MB, less than 31.74% of Java online submissions for 3Sum.\\n    //Binary Search\\n    //Time: O(N * logN + N * N * logN); Space:O(N + LogN)\\n    public List<List<Integer>> threeSum_3(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums.length - 2 && nums[i] <= 0;){\\n            for (int j = i + 1; j < nums.length && nums[i] + nums[j] <= 0;) {\\n                int value = 0 - nums[i] - nums[j];\\n                if (value < 0) return new ArrayList<>(resultSet);\\n                int idx = Arrays.binarySearch(nums, j + 1, nums.length, value);\\n                if (idx >= 0)\\n                    resultSet.add(Arrays.asList(nums[i], nums[j], value));\\n                j++;\\n                while (j < nums.length && nums[j] == nums[j - 1]) j++;\\n            }\\n            i++;\\n            while(i < nums.length - 2 && nums[i] == nums[i - 1]) i++;\\n        }\\n        return new ArrayList<>(resultSet);\\n    }\\n```\\n# HashMap\\n```\\n\\n    //Runtime: 106 ms, faster than 29.54% of Java online submissions for 3Sum.\\n    //Memory Usage: 70.8 MB, less than 23.87% of Java online submissions for 3Sum.\\n    //HashMap\\n    //Time:O(N * logN + N * N); Space: O(N + logN + N)\\n    public List<List<Integer>> threeSum_2(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++) map.put(nums[i], i);\\n\\n        for(int i = 0; i < nums.length - 2 && nums[i] <= 0;){\\n            for (int j = i + 1; j < nums.length && nums[i] + nums[j] <= 0;) {\\n                int value = 0 - nums[i] - nums[j];\\n                //if (value < 0) break;\\n                if (value < 0) return new ArrayList<>(resultSet);\\n                if (value < nums[j]) break;\\n                if (map.containsKey(value) && map.get(value) > j)\\n                    resultSet.add(Arrays.asList(nums[i], nums[j], value));\\n                j++;\\n                while(j < nums.length && nums[j] == nums[j - 1]) j++;\\n            }\\n            i++;\\n            while(i < nums.length - 2 && nums[i] == nums[i - 1]) i++;\\n        }\\n        return new ArrayList<>(resultSet) ;\\n    }\\n```\\n# brute force\\n```\\n\\n    //TLE\\n    //brute force\\n    //Time: O(N * N * N * log3); Space: O(N)\\n    public List<List<Integer>> threeSum_brute(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n        for (int i = 0; i < nums.length - 2; i++)\\n            for (int j= i + 1; j < nums.length - 1; j++)\\n                for (int k = j + 1 ; k < nums.length; k++)\\n                    if (0 == nums[i] + nums[j] + nums[k]) {\\n                        List<Integer> list = new ArrayList<>(Arrays.asList(nums[i], nums[j], nums[k]));\\n                        Collections.sort(list);\\n                        resultSet.add(list);\\n                    }\\n        return new ArrayList<>(resultSet);\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n    //Runtime: 384 ms, faster than 24.18% of Java online submissions for 3Sum.\\n    //Memory Usage: 120.2 MB, less than 15.92% of Java online submissions for 3Sum.\\n    //without sort\\n    //Time: O(N * N * log3); Space:O(N)\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n\\n        Set<Integer> duplicatedSet = new HashSet<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            if (!duplicatedSet.add(nums[i])) continue;\\n\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int value = 0 - nums[i] - nums[j];\\n                if (map.containsKey(value) && map.get(value) == i) {\\n                    List<Integer> list = new ArrayList<>(Arrays.asList(nums[i], nums[j], value));\\n                    Collections.sort(list);\\n                    resultSet.add(list);\\n                }\\n                map.put(nums[j], i);\\n            }\\n        }\\n        return new ArrayList<>(resultSet) ;\\n    }\\n```\n```\\n\\n    //Runtime: 47 ms, faster than 35.83% of Java online submissions for 3Sum.\\n    //Memory Usage: 60.1 MB, less than 32.20% of Java online submissions for 3Sum.\\n    //Two pointers\\n    //Time: O(N * LogN + N * N); Space : O(N + LogN)\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i <= nums.length - 3 && nums[i] <= 0;){\\n            int left = i + 1, right = nums.length - 1;\\n            if (0 - nums[i] - nums[left] < 0) break;\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum > 0) {\\n                    right--;\\n                    while (left < right && nums[right] == nums[right + 1]) right--; //skip duplicated number\\n                } else {\\n                    if (sum == 0) {\\n                        resultSet.add(Arrays.asList(nums[i], nums[left], nums[right]));\\n                        right--;\\n                        while (left < right && nums[right] == nums[right + 1]) right--;\\n                    }\\n                    left++;\\n                    while (left < right && nums[left] == nums[left - 1]) left++;\\n                }\\n            }\\n            i++;\\n            while(i < nums.length - 2 && nums[i] == nums[i - 1]) i++;\\n        }\\n        return new ArrayList<>(resultSet);\\n    }\\n```\n```\\n\\n    //Runtime: 99 ms, faster than 29.77% of Java online submissions for 3Sum.\\n    //Memory Usage: 60.2 MB, less than 31.74% of Java online submissions for 3Sum.\\n    //Binary Search\\n    //Time: O(N * logN + N * N * logN); Space:O(N + LogN)\\n    public List<List<Integer>> threeSum_3(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums.length - 2 && nums[i] <= 0;){\\n            for (int j = i + 1; j < nums.length && nums[i] + nums[j] <= 0;) {\\n                int value = 0 - nums[i] - nums[j];\\n                if (value < 0) return new ArrayList<>(resultSet);\\n                int idx = Arrays.binarySearch(nums, j + 1, nums.length, value);\\n                if (idx >= 0)\\n                    resultSet.add(Arrays.asList(nums[i], nums[j], value));\\n                j++;\\n                while (j < nums.length && nums[j] == nums[j - 1]) j++;\\n            }\\n            i++;\\n            while(i < nums.length - 2 && nums[i] == nums[i - 1]) i++;\\n        }\\n        return new ArrayList<>(resultSet);\\n    }\\n```\n```\\n\\n    //Runtime: 106 ms, faster than 29.54% of Java online submissions for 3Sum.\\n    //Memory Usage: 70.8 MB, less than 23.87% of Java online submissions for 3Sum.\\n    //HashMap\\n    //Time:O(N * logN + N * N); Space: O(N + logN + N)\\n    public List<List<Integer>> threeSum_2(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++) map.put(nums[i], i);\\n\\n        for(int i = 0; i < nums.length - 2 && nums[i] <= 0;){\\n            for (int j = i + 1; j < nums.length && nums[i] + nums[j] <= 0;) {\\n                int value = 0 - nums[i] - nums[j];\\n                //if (value < 0) break;\\n                if (value < 0) return new ArrayList<>(resultSet);\\n                if (value < nums[j]) break;\\n                if (map.containsKey(value) && map.get(value) > j)\\n                    resultSet.add(Arrays.asList(nums[i], nums[j], value));\\n                j++;\\n                while(j < nums.length && nums[j] == nums[j - 1]) j++;\\n            }\\n            i++;\\n            while(i < nums.length - 2 && nums[i] == nums[i - 1]) i++;\\n        }\\n        return new ArrayList<>(resultSet) ;\\n    }\\n```\n```\\n\\n    //TLE\\n    //brute force\\n    //Time: O(N * N * N * log3); Space: O(N)\\n    public List<List<Integer>> threeSum_brute(int[] nums) {\\n        Set<List<Integer>> resultSet = new HashSet();\\n        for (int i = 0; i < nums.length - 2; i++)\\n            for (int j= i + 1; j < nums.length - 1; j++)\\n                for (int k = j + 1 ; k < nums.length; k++)\\n                    if (0 == nums[i] + nums[j] + nums[k]) {\\n                        List<Integer> list = new ArrayList<>(Arrays.asList(nums[i], nums[j], nums[k]));\\n                        Collections.sort(list);\\n                        resultSet.add(list);\\n                    }\\n        return new ArrayList<>(resultSet);\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7585,
                "title": "simple-o-n-2-two-pointers-java-solution",
                "content": "**Runtime = O(n^2); Space = O(1)**\\n\\n    public List<List<Integer>> threeSum(int[] A) {\\n    \\tList<List<Integer>>res = new ArrayList<List<Integer>>();\\n    \\tif (A == null || A.length == 0)\\n    \\t\\treturn res;\\n    \\tArrays.sort(A);\\n    \\tfor (int i = 0; i < A.length; i++) {\\n    \\t\\tif (i - 1 >= 0 && A[i] == A[i - 1]) continue;// Skip equal elements to avoid duplicates\\n    \\t\\t  \\n    \\t\\tint left = i + 1, right = A.length - 1; \\n    \\t\\twhile (left < right) {// Two Pointers\\n    \\t\\t\\tint sum = A[i] + A[left] + A[right];\\n    \\t\\t\\tif (sum == 0) { \\n    \\t\\t\\t\\tres.add(Arrays.asList(A[i], A[left], A[right]));\\n    \\t\\t\\t\\twhile (left + 1 < right && A[left] == A[left+1])// Skip equal elements to avoid duplicates\\n    \\t\\t\\t\\t\\tleft++;\\n    \\t\\t\\t\\twhile (right -1 > left && A[right] == A[right-1])// Skip equal elements to avoid duplicates\\n    \\t\\t\\t\\t\\tright--;\\n    \\t\\t\\t\\tleft++; \\n    \\t\\t\\t\\tright--;\\n    \\t\\t\\t} else if (sum < 0) { \\n    \\t\\t\\t\\tleft++;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tright--;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "**Runtime = O(n^2); Space = O(1)**\\n\\n    public List<List<Integer>> threeSum(int[] A) {\\n    \\tList<List<Integer>>res = new ArrayList<List<Integer>>();\\n    \\tif (A == null || A.length == 0)\\n    \\t\\treturn res;\\n    \\tArrays.sort(A);\\n    \\tfor (int i = 0; i < A.length; i++) {\\n    \\t\\tif (i - 1 >= 0 && A[i] == A[i - 1]) continue;// Skip equal elements to avoid duplicates\\n    \\t\\t  \\n    \\t\\tint left = i + 1, right = A.length - 1; \\n    \\t\\twhile (left < right) {// Two Pointers\\n    \\t\\t\\tint sum = A[i] + A[left] + A[right];\\n    \\t\\t\\tif (sum == 0) { \\n    \\t\\t\\t\\tres.add(Arrays.asList(A[i], A[left], A[right]));\\n    \\t\\t\\t\\twhile (left + 1 < right && A[left] == A[left+1])// Skip equal elements to avoid duplicates\\n    \\t\\t\\t\\t\\tleft++;\\n    \\t\\t\\t\\twhile (right -1 > left && A[right] == A[right-1])// Skip equal elements to avoid duplicates\\n    \\t\\t\\t\\t\\tright--;\\n    \\t\\t\\t\\tleft++; \\n    \\t\\t\\t\\tright--;\\n    \\t\\t\\t} else if (sum < 0) { \\n    \\t\\t\\t\\tleft++;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tright--;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 7631,
                "title": "simple-java-solution-without-using-hash-set",
                "content": "    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        for(int i = 0; i < nums.length-2; i++) {\\n            if(i > 0 && (nums[i] == nums[i-1])) continue; // avoid duplicates\\n            for(int j = i+1, k = nums.length-1; j<k;) {\\n                if(nums[i] + nums[j] + nums[k] == 0) {\\n                    list.add(Arrays.asList(nums[i],nums[j],nums[k]));\\n                    j++;k--;\\n                    while((j < k) && (nums[j] == nums[j-1]))j++;// avoid duplicates\\n                    while((j < k) && (nums[k] == nums[k+1]))k--;// avoid duplicates\\n                }else if(nums[i] + nums[j] + nums[k] > 0) k--;\\n                else j++;\\n            }\\n        }\\n        return list;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        for(int i = 0; i < nums.length-2; i++) {\\n            if(i > 0 && (nums[i] == nums[i-1])) continue; // avoid duplicates\\n            for(int j = i+1, k = nums.length-1; j<k;) {\\n                if(nums[i] + nums[j] + nums[k] == 0) {\\n                    list.add(Arrays.asList(nums[i],nums[j],nums[k]));\\n                    j++;k--;\\n                    while((j < k) && (nums[j] == nums[j-1]))j++;// avoid duplicates\\n                    while((j < k) && (nums[k] == nums[k+1]))k--;// avoid duplicates\\n                }else if(nums[i] + nums[j] + nums[k] > 0) k--;\\n                else j++;\\n            }\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3293156,
                "title": "easy-to-understand-simple-java-code-using-set",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a list of set and then iterate over nums array and then use two pointer method to find the sum of all the three numbers required and if the sum is equal to zero then make a new ArrayList and store all the three numbers in it and then store that ArrayList in the set of list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> ans=new HashSet<>();\\n        for(int i = 0; i < nums.length-2; i++){\\n            int p1 = i+1;\\n            int p2 = nums.length-1;\\n            while(p1 < p2){\\n                int sum = nums[i]+nums[p1]+nums[p2];\\n                if(sum == 0){\\n                    ArrayList<Integer> sp = new ArrayList<>();\\n                    sp.add(nums[i]);\\n                    sp.add(nums[p1]);\\n                    sp.add(nums[p2]);\\n                    \\n                    ans.add(sp);\\n                    p1++;\\n                }\\n                else if(sum < 0){\\n                    p1++;\\n                }\\n                else{\\n                    p2--;\\n                }\\n            }\\n        }\\n        return new ArrayList<>(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> ans=new HashSet<>();\\n        for(int i = 0; i < nums.length-2; i++){\\n            int p1 = i+1;\\n            int p2 = nums.length-1;\\n            while(p1 < p2){\\n                int sum = nums[i]+nums[p1]+nums[p2];\\n                if(sum == 0){\\n                    ArrayList<Integer> sp = new ArrayList<>();\\n                    sp.add(nums[i]);\\n                    sp.add(nums[p1]);\\n                    sp.add(nums[p2]);\\n                    \\n                    ans.add(sp);\\n                    p1++;\\n                }\\n                else if(sum < 0){\\n                    p1++;\\n                }\\n                else{\\n                    p2--;\\n                }\\n            }\\n        }\\n        return new ArrayList<>(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691287,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar threeSum = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    const result = [];\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        let low = i+1, high = nums.length-1, sum = 0;\\n        \\n        while(low < high) {\\n            sum = nums[i] + nums[low] + nums[high];\\n            \\n            if(sum === 0) {\\n                result.push([nums[i], nums[low], nums[high]]);\\n                while(nums[low+1] === nums[low]) low++;\\n                while(nums[high-1] === nums[high]) high--;\\n                low++;\\n                high--;\\n            } else if(sum < 0) low++;\\n            else high--;\\n        }\\n        while(nums[i+1] === nums[i]) i++;\\n    }\\n    return result;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar threeSum = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    const result = [];\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        let low = i+1, high = nums.length-1, sum = 0;\\n        \\n        while(low < high) {\\n            sum = nums[i] + nums[low] + nums[high];\\n            \\n            if(sum === 0) {\\n                result.push([nums[i], nums[low], nums[high]]);\\n                while(nums[low+1] === nums[low]) low++;\\n                while(nums[high-1] === nums[high]) high--;\\n                low++;\\n                high--;\\n            } else if(sum < 0) low++;\\n            else high--;\\n        }\\n        while(nums[i+1] === nums[i]) i++;\\n    }\\n    return result;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792264,
                "title": "simple-c-optimized-solution-handle-duplicate-edge-case-also-o-n-2-cpp",
                "content": "``\\n      This method uses Sorting to arrive at the correct result and is solved in O(n2) time, without using extra space\\n      Algorithm:\\n\\n        Sort the array in ascending order.\\n        Traverse the array from start to end.\\n        For every index i, create two variables l = i + 1 and r = n \\u2013 1\\n        Run a loop until l is less than r, if the sum of array[l], array[r] is equal to zero then print the triplet and break the loop\\n        If the sum is less than zero then increment value of l, by increasing value of l the sum will increase as the array is sorted, so array[l+1] > array [l]\\n        If the sum is greater than zero then decrement value of r, by increasing value of l the sum will decrease as the array is sorted, so array[r-1] < array [r].\\n``\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n   \\n        //\\n        vector<vector<int>> res;\\n        //sort\\n        sort(nums.begin(),nums.end());\\n        \\n        for(unsigned int i = 0; i < nums.size();i++){\\n             // initialize left and right \\n           //to handle duplicates\\n            if(i > 0 && nums[i]==nums[i-1])\\n                continue;\\n             int l = i + 1; \\n            int r = nums.size() - 1; \\n            int x = nums[i]; \\n            \\n            while (l < r) \\n            {    \\n                if (x + nums[l] + nums[r] == 0) {\\n                    res.push_back(vector<int>{x,nums[l],nums[r]});\\n                    //to handle duplicates\\n                    while (l<r && nums[l] == nums[l+1]) \\n                        l++;\\n                    // to handle duplicates\\n                    while (l<r && nums[r] == nums[r-1]) \\n                        r--;\\n                    l++;\\n                    r--;\\n                    //break;\\n                }\\n                // If sum of three elements is less \\n                // than zero then increment in left \\n                else if (x + nums[l] + nums[r] < 0) \\n                    l++; \\n  \\n                // if sum is greater than zero than \\n                // decrement in right side \\n                else\\n                    r--; \\n            }\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n   \\n        //\\n        vector<vector<int>> res;\\n        //sort\\n        sort(nums.begin(),nums.end());\\n        \\n        for(unsigned int i = 0; i < nums.size();i++){\\n             // initialize left and right \\n           //to handle duplicates\\n            if(i > 0 && nums[i]==nums[i-1])\\n                continue;\\n             int l = i + 1; \\n            int r = nums.size() - 1; \\n            int x = nums[i]; \\n            \\n            while (l < r) \\n            {    \\n                if (x + nums[l] + nums[r] == 0) {\\n                    res.push_back(vector<int>{x,nums[l],nums[r]});\\n                    //to handle duplicates\\n                    while (l<r && nums[l] == nums[l+1]) \\n                        l++;\\n                    // to handle duplicates\\n                    while (l<r && nums[r] == nums[r-1]) \\n                        r--;\\n                    l++;\\n                    r--;\\n                    //break;\\n                }\\n                // If sum of three elements is less \\n                // than zero then increment in left \\n                else if (x + nums[l] + nums[r] < 0) \\n                    l++; \\n  \\n                // if sum is greater than zero than \\n                // decrement in right side \\n                else\\n                    r--; \\n            }\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169885,
                "title": "python",
                "content": "### 15 3Sum\\n```\\n> Time Complexity O(n^2)\\n> Space Complexity O(1)\\n\\n\\n```\\n\\n<br>\\n\\n```python\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        res = []\\n        nums.sort()\\n        if len(nums) < 3:\\n            return res\\n\\n        for i in range(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            l, r = i + 1, len(nums) - 1\\n            while l < r :\\n                s = nums[i] + nums[l] + nums[r]\\n                if s == 0:\\n                    res.append([nums[i] ,nums[l] ,nums[r]])\\n                    l += 1; r -= 1\\n                    while l < r and nums[l] == nums[l - 1]: l += 1\\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\\n                elif s < 0 :\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res      \\n```\\n",
                "solutionTags": [],
                "code": "```\\n> Time Complexity O(n^2)\\n> Space Complexity O(1)\\n\\n\\n```\n```python\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        res = []\\n        nums.sort()\\n        if len(nums) < 3:\\n            return res\\n\\n        for i in range(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            l, r = i + 1, len(nums) - 1\\n            while l < r :\\n                s = nums[i] + nums[l] + nums[r]\\n                if s == 0:\\n                    res.append([nums[i] ,nums[l] ,nums[r]])\\n                    l += 1; r -= 1\\n                    while l < r and nums[l] == nums[l - 1]: l += 1\\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\\n                elif s < 0 :\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234102,
                "title": "python-two-pointers-time-o-n-2-space-o-1-explained",
                "content": "# Explaination:\\n**Understanding the Problem:**\\nWe are given an array of unsorted numbers and our goal is to find all instances of 3 numbers which sum to a total of 0. There could be duplicates so its possible to have duplicate triplets.\\n**Example:** We are given the input [-1,-1,0,1,2]\\nWe could have two instances of [-1, 0, 1], [-1, 0, 1].\\nNotice that example input I gave is sorted, its easier to find the duplicates in a sorted array than if the array was something like this: [-1, 2, 0, -1, 1]. \\nIf the array is sorted we can easily see if we\\'re at a duplicate number because we can look 1 index behind it to compare the numbers and see if they\\'re the same, if they are, then we have visited this number already before, since we are going from left to right in our array.\\n\\n**Approach:**\\n1. We will first sort the given input depending on the language some built in sorting algorithms do use space complexity, but we wont count this. You can mention during your interview Python uses `timsort` and it has a space complexity of O(N) but you can ask if they want to count this or ignore it and assume its O(1).\\n2. Now that all our numbers are sorted in acending order, we will make our `triplets` array, to hold our valid triplets that sum to 0.\\n3. Now the problem says its Two Pointers, which it is, but the Two Pointer algorithm will take place inside of a `for` loop, so you could say we have 3 pointers, since the `for` loop will count as our starting pointer and we will do a Two Pointer search algorithm on every number AFTER the current index in our `for` loop.\\n4. We will have a `if` statement to check the previous index value and compare it to the current index value, if they are the same, we skip, because this will end up giving us a duplicate triplet.\\n5. Now we will setup our Two Pointer algorithm. `left` will be `i + 1` since we need 3 different numbers to sum up. `right` will be `len(nums) - 1`, it will always start from the end of the array.\\n6. Now we setup the while loop to be `left < right` the reason we don\\'t do `<=` is because we don\\'t want `left` and `right` to overlap, we will end up adding up two of the same numbers if that happens.\\n7. `curSum` will hold the current total sum of all 3 numbers for the 3 pointers we have.\\n8. If `curSum` is 0, that means we found a triplet that sums to 0. So we will save all 3 numbers in a triple pair array and append it into our `triplets` array. Then we will move both the `left` and `right` pointers. `left` will increase by 1 and `right` will decrease by 1. We have 2 `while` loops to check if the new values for `left` and `right ` are duplicates, if they are, they keep iterating until they are at a unique number of until the 2 pointers overlap.\\n9. Else if the current sum is less than 0, then we need a bigger sum, since our array is sorted we know numbers get greater as you go from left to right. So we increment our `left` pointer by 1 to get either a duplicate or a bigger value.\\n10. Else if the current sum is greater than 0 then we need a smaller sum. Since the array is sorted we know numbers get greater as you go from left to right, so to get a smaller value we might go to the left side of our array instead of going towards the right. So we decrement our right pointer to get either a duplicate or smaller value.\\n11. We keep doing this until we explored the entire array and return the triplets results.\\n**Note:** The reason why our `for` loop goes until `len(nums) - 2` is because we don\\'t need to explore further, we have 3 pointers, our first pointer from the `for` loop just needs to go until `len(nums) - 2` EXCLUSIVE, so when it reaches that point it will break. The other 2 pointers will have already explored those last 2 numbers.\\n\\n**Time O(N^2) | Space O(1)**\\nTime is O(N^2), basically called n squared or N * N, because our `for` loop will loop through almost the entire array so we round it to O(N) and Two Pointer algorithm is O(N), hence why the full answer is O(N^2) because for every iteration in the `for` loop O(N) we do a Two Pointer search O(N). \\nSpace is O(1) because we don\\'t count the `.sort` space complexity for Python, you can verify this with the interviewer, tell them Python uses `timsort` and you\\'re aware it uses O(N) space and ask if they want to count this or not.\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort() # We sort nums first to more easily find duplicate numbers\\n        triplets = [] # We will store all the valid triplets in here\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue # Skip duplicates\\n                \\n            left = i + 1\\n            right = len(nums) - 1\\n            \\n            while left < right:\\n                curSum = nums[i] + nums[left] + nums[right]\\n                if curSum == 0:\\n                    triplets.append([nums[i], nums[left], nums[right]])\\n                    left += 1\\n                    right -= 1;\\n                    \\n                    # Skip all duplicates on left side\\n                    while left < right and nums[left - 1] == nums[left]:\\n                        left += 1\\n                    \\n                    # Skip all duplicates on right side\\n                    while left < right and nums[right + 1] == nums[right]:\\n                        right -= 1\\n                elif curSum < 0:\\n                    left += 1 # Our sum is too small, so we try to increase the sum\\n                else:\\n                    right -= 1 # Our sum is too big, so we try to decrease the sum\\n        return triplets\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort() # We sort nums first to more easily find duplicate numbers\\n        triplets = [] # We will store all the valid triplets in here\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue # Skip duplicates\\n                \\n            left = i + 1\\n            right = len(nums) - 1\\n            \\n            while left < right:\\n                curSum = nums[i] + nums[left] + nums[right]\\n                if curSum == 0:\\n                    triplets.append([nums[i], nums[left], nums[right]])\\n                    left += 1\\n                    right -= 1;\\n                    \\n                    # Skip all duplicates on left side\\n                    while left < right and nums[left - 1] == nums[left]:\\n                        left += 1\\n                    \\n                    # Skip all duplicates on right side\\n                    while left < right and nums[right + 1] == nums[right]:\\n                        right -= 1\\n                elif curSum < 0:\\n                    left += 1 # Our sum is too small, so we try to increase the sum\\n                else:\\n                    right -= 1 # Our sum is too big, so we try to decrease the sum\\n        return triplets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159573,
                "title": "c-beats-100",
                "content": "```\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        if(nums.size()<=2)return result;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            int a = nums[i];\\n            if(a > 0) break;\\n            if (i > 0 && a == nums[i - 1]) continue;\\n            for (long j = i + 1, k = nums.size() - 1; j < k;) {\\n                int b = nums[j];\\n                int c = nums[k];\\n                int value = a + b + c;\\n                if (value == 0) {\\n                    result.push_back(vector<int>({a, b, c}));\\n                    while (j<k && b == nums[++j]);\\n                    while (j < k &&c == nums[--k]);\\n                } else if (value > 0) {\\n                    k--;\\n                } else {\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        if(nums.size()<=2)return result;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            int a = nums[i];\\n            if(a > 0) break;\\n            if (i > 0 && a == nums[i - 1]) continue;\\n            for (long j = i + 1, k = nums.size() - 1; j < k;) {\\n                int b = nums[j];\\n                int c = nums[k];\\n                int value = a + b + c;\\n                if (value == 0) {\\n                    result.push_back(vector<int>({a, b, c}));\\n                    while (j<k && b == nums[++j]);\\n                    while (j < k &&c == nums[--k]);\\n                } else if (value > 0) {\\n                    k--;\\n                } else {\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1363302,
                "title": "c-brute-force-optimal-two-pointer-method-commented-time-o-n-2-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n\\t    // Brute Force Solution Time O(N^3) & Auxiliary Space O(1)\\n        int len=nums.size();\\n        if(len==0 || len<3) // Atleast three elemnets needed for a triplet\\n            return {};\\n        set<vector<int>> s; // Set stores unique elements only(duplicate triplets not added)\\n        sort(nums.begin(),nums.end());\\n        // Compare all cases of group of three elements for their sum=0 in O(N^3) time\\n        for(int i=0;i<len-2;i++){\\n            for(int j=i+1;j<len-1;j++){\\n                for(int k=j+1;k<len;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                }\\n            }\\n        }\\n        // Insert all unique triplets in result vector\\n        vector<vector<int>> ans(s.begin(),s.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums){\\n\\t\\t// Optimal Solution Time O(N^2) & Auxiliary Space O(1)\\n\\t\\t// Two Pointer Algorithm\\n        int len=nums.size();\\n        vector<vector<int>> res;\\n        if(len<3)\\n            return res;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<len; i++){\\n            if(i>0 && nums[i]==nums[i-1])\\n\\t\\t\\t    // Skip the duplicate elements by incrementing the i index.\\n                // \\'continue\\' terminates current iteration and\\n                // begins next iteration of for loop\\n                continue; \\n            // Keeping nums[i] same, check for sum of triplets=0 \\n            // from i+1 till the end of nums vector\\n            int left = i + 1, right = nums.size() - 1; \\n            while(left<right) \\n            {    \\n                if(nums[i] + nums[left] + nums[right] == 0){\\n                    res.push_back(vector<int>{nums[i],nums[left],nums[right]});\\n                    // To skip duplicate elements at left pointer\\n                    while(left<right && nums[left]==nums[left+1]) \\n                        left++;\\n                    // To skip duplicate elements at left pointer\\n                    while(left<right && nums[right]==nums[right-1]) \\n                        right--;\\n                    // One unique triplet has been found.\\n                    // Increment left & decrement right for  \\n                    // next triplet to be unique\\n                    left++;\\n                    right--;\\n                }\\n                // Since nums is sorted, so left will be smallest in \\n                // [nums[left],nums[right]] interval and if triplet sum<0,\\n                // then incrementing left will increase the sum\\n                else if(nums[i]+nums[left]+nums[right]<0) \\n                    left++; \\n                // Since nums is sorted, so right will be largest in \\n                // [nums[left],nums[right]] interval and if triplet sum>0,\\n                // then decrementing right will decrease the sum\\n                else\\n                    right--; \\n            }\\n                \\n        }\\n        return res;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n\\t    // Brute Force Solution Time O(N^3) & Auxiliary Space O(1)\\n        int len=nums.size();\\n        if(len==0 || len<3) // Atleast three elemnets needed for a triplet\\n            return {};\\n        set<vector<int>> s; // Set stores unique elements only(duplicate triplets not added)\\n        sort(nums.begin(),nums.end());\\n        // Compare all cases of group of three elements for their sum=0 in O(N^3) time\\n        for(int i=0;i<len-2;i++){\\n            for(int j=i+1;j<len-1;j++){\\n                for(int k=j+1;k<len;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                }\\n            }\\n        }\\n        // Insert all unique triplets in result vector\\n        vector<vector<int>> ans(s.begin(),s.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums){\\n\\t\\t// Optimal Solution Time O(N^2) & Auxiliary Space O(1)\\n\\t\\t// Two Pointer Algorithm\\n        int len=nums.size();\\n        vector<vector<int>> res;\\n        if(len<3)\\n            return res;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<len; i++){\\n            if(i>0 && nums[i]==nums[i-1])\\n\\t\\t\\t    // Skip the duplicate elements by incrementing the i index.\\n                // \\'continue\\' terminates current iteration and\\n                // begins next iteration of for loop\\n                continue; \\n            // Keeping nums[i] same, check for sum of triplets=0 \\n            // from i+1 till the end of nums vector\\n            int left = i + 1, right = nums.size() - 1; \\n            while(left<right) \\n            {    \\n                if(nums[i] + nums[left] + nums[right] == 0){\\n                    res.push_back(vector<int>{nums[i],nums[left],nums[right]});\\n                    // To skip duplicate elements at left pointer\\n                    while(left<right && nums[left]==nums[left+1]) \\n                        left++;\\n                    // To skip duplicate elements at left pointer\\n                    while(left<right && nums[right]==nums[right-1]) \\n                        right--;\\n                    // One unique triplet has been found.\\n                    // Increment left & decrement right for  \\n                    // next triplet to be unique\\n                    left++;\\n                    right--;\\n                }\\n                // Since nums is sorted, so left will be smallest in \\n                // [nums[left],nums[right]] interval and if triplet sum<0,\\n                // then incrementing left will increase the sum\\n                else if(nums[i]+nums[left]+nums[right]<0) \\n                    left++; \\n                // Since nums is sorted, so right will be largest in \\n                // [nums[left],nums[right]] interval and if triplet sum>0,\\n                // then decrementing right will decrease the sum\\n                else\\n                    right--; \\n            }\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7407,
                "title": "javascript-beat-94-29",
                "content": "    /**\\n     * @param {number[]} nums\\n     * @return {number[][]}\\n     */\\n    var threeSum = function(nums) {\\n    \\tvar rtn = [];\\n    \\tif (nums.length < 3) {\\n    \\t\\treturn rtn;\\n    \\t}\\n    \\tnums = nums.sort(function(a, b) {\\n    \\t\\treturn a - b;\\n    \\t});\\n    \\tfor (var i = 0; i < nums.length - 2; i++) {\\n    \\t\\tif (nums[i] > 0) {\\n    \\t\\t\\treturn rtn;\\n    \\t\\t}\\n    \\t\\tif (i > 0 && nums[i] == nums[i - 1]) {\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\tfor (var j = i + 1, k = nums.length - 1; j < k;) {\\n    \\t\\t\\tif (nums[i] + nums[j] + nums[k] === 0) {\\n    \\t\\t\\t\\trtn.push([nums[i], nums[j], nums[k]]);\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t\\tk--;\\n    \\t\\t\\t\\twhile (j < k && nums[j] == nums[j - 1]) {\\n    \\t\\t\\t\\t\\tj++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\twhile (j < k && nums[k] == nums[k + 1]) {\\n    \\t\\t\\t\\t\\tk--;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t} else if (nums[i] + nums[j] + nums[k] > 0) {\\n    \\t\\t\\t\\tk--;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn rtn;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @param {number[]} nums\\n     * @return {number[][]}\\n     */\\n    var threeSum = function(nums) {\\n    \\tvar rtn = [];\\n    \\tif (nums.length < 3) {\\n    \\t\\treturn rtn;\\n    \\t}\\n    \\tnums = nums.sort(function(a, b) {\\n    \\t\\treturn a - b;\\n    \\t});\\n    \\tfor (var i = 0; i < nums.length - 2; i++) {\\n    \\t\\tif (nums[i] > 0) {\\n    \\t\\t\\treturn rtn;\\n    \\t\\t}\\n    \\t\\tif (i > 0 && nums[i] == nums[i - 1]) {\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\tfor (var j = i + 1, k = nums.length - 1; j < k;) {\\n    \\t\\t\\tif (nums[i] + nums[j] + nums[k] === 0) {\\n    \\t\\t\\t\\trtn.push([nums[i], nums[j], nums[k]]);\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t\\tk--;\\n    \\t\\t\\t\\twhile (j < k && nums[j] == nums[j - 1]) {\\n    \\t\\t\\t\\t\\tj++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\twhile (j < k && nums[k] == nums[k + 1]) {\\n    \\t\\t\\t\\t\\tk--;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t} else if (nums[i] + nums[j] + nums[k] > 0) {\\n    \\t\\t\\t\\tk--;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn rtn;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 725581,
                "title": "python-2-pointers-o-n-2-solution-explained",
                "content": "This problem is similar to **2Sum** problem, but here we need to find sums of three elements. We can use similar idea with hash-tables, but the problem here is that we can have duplicates, and it is a bit painful to deal with them, using hash-tables, we need to count frequencies, make sure, we did not use the same elements and so on.\\n\\nAnother approach is to use **2 Pointers** approach. Let us sort our data first and choose element number `i`. What we need to find now is some elements with indexes `beg` and `end`, such that `i < beg < end` and `nums[beg] + nums[end] = target = -nums[i]`. Here times come to use our **2 Pointers** approach: we start from `beg, end = i + 1, n - 1`, and move `beg` to the right and `end` to the left, comparing `nums[beg] + nums[end]` with our target. If it is equal to `target`, we add it to our result, and move two pointers. However, because we can have equal numbers in `nums`, we still need to check, that we return unique triples, so we apply `set` in the end.\\n\\n**Complexity**: time complexity is `O(n log n + n^2) = O(n^2)`, because we sorted our data, and then we have loop with `n` iterations, inside each of them we use 2 pointers approach with `O(n)` complexity (inside `while beg < end:` each time distance between our pointers reduced by at least `1`). Space complexity is potentially `O(n^2)`, because there can be potentially `O(n^2)` solutions: \\n\\nlet `nums = [-n,-n+1,..., n-1, n]` with `2n+1 = O(n)` numbers, then there will be solutions:\\n`1 2 -3`,   `1 3 -4`, ... , `1 n-1 -n`\\n`2 3 -5`,   `2 4 -6`, ... , `2 n-2 -n`\\n\\nin first group there will be `n-2` solutions, in second `n-4` and so on.\\nSum of arithmetic progression `n-2 + n-4 + ... ` is approximately equalt to `n^2/4`.\\nWe also have more solutions, but we already showed that there is `O(n^2)`.\\n\\n```\\nclass Solution:\\n    def threeSum(self, nums):\\n        nums.sort()\\n        n, result = len(nums), []\\n\\n        for i in range(n):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n\\n            target = -nums[i]\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                if nums[beg] + nums[end] < target:\\n                    beg += 1\\n                elif nums[beg] + nums[end] > target:\\n                    end -= 1\\n                else:\\n                    result.append((nums[i], nums[beg], nums[end]))\\n                    beg += 1\\n                    end -= 1\\n\\n        return set(result)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums):\\n        nums.sort()\\n        n, result = len(nums), []\\n\\n        for i in range(n):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n\\n            target = -nums[i]\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                if nums[beg] + nums[end] < target:\\n                    beg += 1\\n                elif nums[beg] + nums[end] > target:\\n                    end -= 1\\n                else:\\n                    result.append((nums[i], nums[beg], nums[end]))\\n                    beg += 1\\n                    end -= 1\\n\\n        return set(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318565,
                "title": "java-hashmap-based-approach",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<List<Integer>> r=new ArrayList<>();\\n\\t\\tHashMap<Integer,Integer> index=new HashMap<>();\\n\\t\\tfor(int i=0;i<nums.length;i++)\\n\\t\\t\\tindex.put(nums[i], i);\\n\\t\\tfor(int i=0;i<nums.length-2;i++){\\n\\t\\t\\tfor(int j=i+1;j<nums.length-1;j++){\\n\\t\\t\\t\\tint target=0-nums[i]-nums[j];\\n\\t\\t\\t\\tif(index.containsKey(target) && index.get(target)>j){\\n\\t\\t\\t\\t\\tr.add(Arrays.asList(nums[i], nums[j], target));\\n\\t\\t\\t\\t\\tj=index.get(nums[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti=index.get(nums[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<List<Integer>> r=new ArrayList<>();\\n\\t\\tHashMap<Integer,Integer> index=new HashMap<>();\\n\\t\\tfor(int i=0;i<nums.length;i++)\\n\\t\\t\\tindex.put(nums[i], i);\\n\\t\\tfor(int i=0;i<nums.length-2;i++){\\n\\t\\t\\tfor(int j=i+1;j<nums.length-1;j++){\\n\\t\\t\\t\\tint target=0-nums[i]-nums[j];\\n\\t\\t\\t\\tif(index.containsKey(target) && index.get(target)>j){\\n\\t\\t\\t\\t\\tr.add(Arrays.asList(nums[i], nums[j], target));\\n\\t\\t\\t\\t\\tj=index.get(nums[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti=index.get(nums[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184101,
                "title": "easy-java-solution",
                "content": "```\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> set = new HashSet<>();\\n        if(nums.length == 0) return new ArrayList<>(set);\\n        Arrays.sort(nums);\\n        for(int i=0; i< nums.length-2; i++){\\n            int j = i+1;     //j starts at i+1\\n            int k= nums.length-1;  //k starts at the end\\n            while(j<k){\\n                int sum = nums[i]+nums[j]+nums[k];\\n                if(sum == 0)\\n                    set.add(Arrays.asList(nums[i], nums[j++], nums[k--]));\\n                 else if(sum > 0)\\n                    k--;    \\n                 else if(sum <0)\\n                    j++;\\n            }\\n        }\\n        return new ArrayList<>(set);\\n  }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> set = new HashSet<>();\\n        if(nums.length == 0) return new ArrayList<>(set);\\n        Arrays.sort(nums);\\n        for(int i=0; i< nums.length-2; i++){\\n            int j = i+1;     //j starts at i+1\\n            int k= nums.length-1;  //k starts at the end\\n            while(j<k){\\n                int sum = nums[i]+nums[j]+nums[k];\\n                if(sum == 0)\\n                    set.add(Arrays.asList(nums[i], nums[j++], nums[k--]));\\n                 else if(sum > 0)\\n                    k--;    \\n                 else if(sum <0)\\n                    j++;\\n            }\\n        }\\n        return new ArrayList<>(set);\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 2110048,
                "title": "c-easy-solution-all-testcases-passed",
                "content": "```\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;      //to remove any duplicate at the first number\\n            int target=-nums[i];\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target)j++;\\n                else if(sum>target)k--;\\n                else{\\n                    ans.push_back({nums[i],nums[j],nums[k]});\\n                    while(j<nums.size()-1 && nums[j]==nums[j+1])j++;      //remove duplicate in the 2nd number\\n                    while(k>0 && nums[k]==nums[k-1])k--;                        //remove duplicate in the 3rd number\\n                    j++,k--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9d61b3dd-546e-40cf-8d6e-e2848a656c53_1654353026.3972483.png)\\n\\n\\n\\uD83D\\uDE4C\\uD83D\\uDE4C HAPPY CODING !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;      //to remove any duplicate at the first number\\n            int target=-nums[i];\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target)j++;\\n                else if(sum>target)k--;\\n                else{\\n                    ans.push_back({nums[i],nums[j],nums[k]});\\n                    while(j<nums.size()-1 && nums[j]==nums[j+1])j++;      //remove duplicate in the 2nd number\\n                    while(k>0 && nums[k]==nums[k-1])k--;                        //remove duplicate in the 3rd number\\n                    j++,k--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7393,
                "title": "straight-forward-python-ac-o-n-2-solution-with-decent-explanation",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer[][]}\\n        def threeSum(self, nums):\\n            if len(nums) <3: # deal with special input\\n                return []\\n            elif len(nums) == 3:\\n                if sum(nums) == 0:\\n                    return [sorted(nums)]\\n    \\n    \\n            nums = sorted(nums) # sorted, O(nlgn)\\n            ans = []\\n    \\n            for i in range(len(nums) -2):\\n                j = i+1\\n                k = len(nums) -1 # hence i < j < k\\n    \\n                while j<k: # if not cross line\\n                    temp_sum = nums[i] + nums[j] + nums[k]\\n                    if temp_sum == 0:\\n                        ans.append((nums[i], nums[j], nums[k]))\\n    \\n                    if temp_sum > 0: # which means we need smaller sum, move k backward, remember we sort the array\\n                        k -= 1\\n                    else:\\n                        j += 1\\n    \\n            return list(set(tuple(ans))) # I bet this is not the best way to eliminate duplicate solutions",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 1545249,
                "title": "c-shortest-and-simplest-o-n-2-solution-using-hashmap-10-short-lines",
                "content": "Similar approach to my 2Sum solution\\nhttps://leetcode.com/problems/3sum-with-multiplicity/discuss/1123612/C%2B%2B-Super-Simple-7-line-Solution-Without-Sorting\\nWe loop with two pointers - i and j - and check if their complementary - `-(nums[i] + (nums[j])` - is in the map, which means it appears in nums.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        vector<vector<int>> res;\\n       \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < nums.size(); i++) \\n            m[nums[i]] = i;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > 0 && nums[i] == nums[i-1]) continue;\\n            \\n            for (int j = i+1; j < nums.size(); j++) {\\n                if (j != i+1 && nums[j] == nums[j-1]) continue;\\n                \\n                if (m[-(nums[i] + nums[j])] > j) \\n                    res.push_back({nums[i], nums[j], -(nums[i] + nums[j])});\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        vector<vector<int>> res;\\n       \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < nums.size(); i++) \\n            m[nums[i]] = i;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > 0 && nums[i] == nums[i-1]) continue;\\n            \\n            for (int j = i+1; j < nums.size(); j++) {\\n                if (j != i+1 && nums[j] == nums[j-1]) continue;\\n                \\n                if (m[-(nums[i] + nums[j])] > j) \\n                    res.push_back({nums[i], nums[j], -(nums[i] + nums[j])});\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261764,
                "title": "python-solution-faster-than-97",
                "content": "Basic ideas are to separate into three lists and to search each answer type . \\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        ans = set([])\\n        plus = sorted([n for n in nums if n>0])\\n        plus_c = set(plus)\\n        zero = [n for n in nums if n == 0]\\n        minus = sorted([n for n in nums if n<0])\\n        minus_c = set(minus)\\n        # all zero\\n        if len(zero)>2:\\n            ans.add((0,0,0))\\n        # plus zero minus\\n        if len(zero)>0:\\n            for n in minus:\\n                if -n in plus_c:\\n                    ans.add((n,0,-n))\\n        # plus minus minus\\n        n = len(minus)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                diff = -(minus[i]+minus[j])\\n                if diff in plus_c:\\n                    ans.add((minus[i],minus[j],diff))\\n        # plus plus minus\\n        n = len(plus)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                diff = -(plus[i]+plus[j])\\n                if diff in minus_c:\\n                    ans.add((diff,plus[i],plus[j]))\\n        return list(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        ans = set([])\\n        plus = sorted([n for n in nums if n>0])\\n        plus_c = set(plus)\\n        zero = [n for n in nums if n == 0]\\n        minus = sorted([n for n in nums if n<0])\\n        minus_c = set(minus)\\n        # all zero\\n        if len(zero)>2:\\n            ans.add((0,0,0))\\n        # plus zero minus\\n        if len(zero)>0:\\n            for n in minus:\\n                if -n in plus_c:\\n                    ans.add((n,0,-n))\\n        # plus minus minus\\n        n = len(minus)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                diff = -(minus[i]+minus[j])\\n                if diff in plus_c:\\n                    ans.add((minus[i],minus[j],diff))\\n        # plus plus minus\\n        n = len(plus)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                diff = -(plus[i]+plus[j])\\n                if diff in minus_c:\\n                    ans.add((diff,plus[i],plus[j]))\\n        return list(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724777,
                "title": "python-beats-99-binary-search-no-two-pointer",
                "content": "When I followed some of the most votes the solution beats **~ 27%**. So I checked the submissions and found that there\\'s another approach beats **~99%** yet not many posts mention it. After spending some time on it I\\'d like to share it here and add some explanations to it. \\n\\nNote that the following solution is borrowed from others and I only provide explanations if you also want to know a more efficient solution (**272ms vs 1516ms**).\\n\\n**Logic**\\nGenerally speaking, it also selects one element ```num``` at a time and search for the other two ```a``` and ```b``` if they exist. What\\'s different is that, instead of applying two-pointer to check the subarray, it stores the ```collections.Counter``` of the array first, then uses binary search to set a search range, and search through that range.\\n\\n**More details**\\n1. With using ```counter```, it needs to handle different cases separately to avoid redundancy:\\n\\tcase i. three numbers are the same - the only possible solution is ```[0,0,0]```\\n\\tcase ii. two numbers are the same - needs to check against ```counter``` to ensure ```counter[num] > 1 and -2 * num in counter```\\n\\tcase iii. all of them are different\\n2. ```bisect_left```\\nthe leftmost boundary for searching would be the smallest element to the right of ```i+1```, that\\'s why the value is set to ```opposite - nums[-1]```\\n3. ```bisect_right```\\nwe choose ```opposite / 2``` over ```opposite-nums[left]``` to deal with repeated solutions. \\nFor example, given ```[-1,0,1]```, and ```num=-1```, we only wish to search ```[0]``` to get ```[-1,0,1]```, instead of searching ```[0,1]``` which leads to ```[-1,0,1],[-1,1,0]```\\n\\n**Code**\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        counter = collections.Counter(nums)\\n        nums = sorted(counter)\\n        ret = []\\n        for i, num in enumerate(nums):\\n            # case i. three numbers are the same - [0,0,0]\\n            if num==0:\\n                if counter[num] > 2:\\n                    ret.append([0, 0, 0])\\n            # case ii. two numbers are the same\\n            elif counter[num] > 1 and -2 * num in counter:\\n                ret.append([num, num, -2 * num])\\n            # case iii. not any of the three numbers are the same\\n            if num < 0:\\n                opposite = -num\\n                left = bisect_left(nums, opposite - nums[-1], i + 1)\\n                right = bisect_right(nums, opposite / 2, left)\\n                for a in nums[left:right]:\\n                    b = opposite - a\\n                    if b in counter and a!=b:\\n                        ret.append([num, a, b])\\n        return ret\\n```\\n\\nFeel free to leave a comment! Please upvote this post if you like it :p",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```num```\n```a```\n```b```\n```collections.Counter```\n```counter```\n```[0,0,0]```\n```counter```\n```counter[num] > 1 and -2 * num in counter```\n```bisect_left```\n```i+1```\n```opposite - nums[-1]```\n```bisect_right```\n```opposite / 2```\n```opposite-nums[left]```\n```[-1,0,1]```\n```num=-1```\n```[0]```\n```[-1,0,1]```\n```[0,1]```\n```[-1,0,1],[-1,1,0]```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        counter = collections.Counter(nums)\\n        nums = sorted(counter)\\n        ret = []\\n        for i, num in enumerate(nums):\\n            # case i. three numbers are the same - [0,0,0]\\n            if num==0:\\n                if counter[num] > 2:\\n                    ret.append([0, 0, 0])\\n            # case ii. two numbers are the same\\n            elif counter[num] > 1 and -2 * num in counter:\\n                ret.append([num, num, -2 * num])\\n            # case iii. not any of the three numbers are the same\\n            if num < 0:\\n                opposite = -num\\n                left = bisect_left(nums, opposite - nums[-1], i + 1)\\n                right = bisect_right(nums, opposite / 2, left)\\n                for a in nums[left:right]:\\n                    b = opposite - a\\n                    if b in counter and a!=b:\\n                        ret.append([num, a, b])\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373909,
                "title": "javascript-with-clear-comments-beats-99",
                "content": "```javascript\\nvar threeSum = function(nums, target = 0) {\\n    const result = [];\\n    \\n    // we need 3 values for this to work\\n    // so return an empty array if we have less than 3\\n    if (nums.length < 3) {\\n        return result;\\n    }\\n    \\n    // sorting is ok because the function is already O(n^2)\\n    // and sort is O(nlogn)\\n    // this also lets us stop iterating once weve passed the target value\\n    nums = nums.sort((a,b) => a - b );\\n    \\n    // well use i as our anchor as we move through the array\\n    // we stop at nums.length - 2 to prevent undefined for k\\n    for (let i = 0; i < nums.length - 2; i++) {\\n\\t\\n        // because we sorted the array already\\n        // we can stop here if the current iterator is greater than the target value\\n        if (nums[i] > target) {\\n            break;\\n        }\\n\\t\\t\\n        // if our iterator is the same as the previous value\\n        // skip it to prevent duplicate results\\n        if (i > 0 && nums[i] === nums[i - 1]) {\\n            continue;\\n        }\\n\\t\\t\\n        // start j at i + 1\\n        let j = i + 1;\\n\\t\\t\\n        // start k at end of array\\n        let k = nums.length - 1;\\n        \\n        // walking j and k towards each other to find all possible values\\n        // with i as our anchor value\\n        while (j < k) {\\n            let sum = nums[i] + nums[j] + nums[k];\\n            if (sum === target) {\\n                result.push([nums[i], nums[j], nums[k]]);\\n                \\n                // skip duplicate values of j and k\\n                while (nums[j] === nums[j + 1]) j++;\\n                while (nums[k] === nums[k - 1]) k--;\\n                \\n                // move j and k inward\\n                j++;\\n                k--;\\n                continue;\\n            }\\n            if (sum < target) {\\n                j++;\\n                continue;\\n            }\\n            if (sum > target) {\\n                k--;\\n                continue;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar threeSum = function(nums, target = 0) {\\n    const result = [];\\n    \\n    // we need 3 values for this to work\\n    // so return an empty array if we have less than 3\\n    if (nums.length < 3) {\\n        return result;\\n    }\\n    \\n    // sorting is ok because the function is already O(n^2)\\n    // and sort is O(nlogn)\\n    // this also lets us stop iterating once weve passed the target value\\n    nums = nums.sort((a,b) => a - b );\\n    \\n    // well use i as our anchor as we move through the array\\n    // we stop at nums.length - 2 to prevent undefined for k\\n    for (let i = 0; i < nums.length - 2; i++) {\\n\\t\\n        // because we sorted the array already\\n        // we can stop here if the current iterator is greater than the target value\\n        if (nums[i] > target) {\\n            break;\\n        }\\n\\t\\t\\n        // if our iterator is the same as the previous value\\n        // skip it to prevent duplicate results\\n        if (i > 0 && nums[i] === nums[i - 1]) {\\n            continue;\\n        }\\n\\t\\t\\n        // start j at i + 1\\n        let j = i + 1;\\n\\t\\t\\n        // start k at end of array\\n        let k = nums.length - 1;\\n        \\n        // walking j and k towards each other to find all possible values\\n        // with i as our anchor value\\n        while (j < k) {\\n            let sum = nums[i] + nums[j] + nums[k];\\n            if (sum === target) {\\n                result.push([nums[i], nums[j], nums[k]]);\\n                \\n                // skip duplicate values of j and k\\n                while (nums[j] === nums[j + 1]) j++;\\n                while (nums[k] === nums[k - 1]) k--;\\n                \\n                // move j and k inward\\n                j++;\\n                k--;\\n                continue;\\n            }\\n            if (sum < target) {\\n                j++;\\n                continue;\\n            }\\n            if (sum > target) {\\n                k--;\\n                continue;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1030241,
                "title": "2-solutions-simple-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        return self.usingSortingAndTwoPointer(nums)\\n    \\n    def usingSortingAndTwoPointer(self, nums):\\n        nums.sort()\\n        added = set()\\n        out = []\\n        for i in range(len(nums) - 1, -1, -1):\\n            last = nums[i]\\n            start, end = 0, i - 1\\n            while start < end:\\n                s = last + nums[start] + nums[end]\\n                if s == 0:\\n                    if (last, nums[start], nums[end]) not in added: out.append([last, nums[start], nums[end]])\\n                    added.add((last, nums[start], nums[end]))\\n                    start += 1\\n                elif s > 0:\\n                    end -= 1\\n                else: start += 1\\n        return out\\n        \\n    \\n    #TLE, time complexity - o(n^3)\\n    def bruteForce(self, nums):\\n        out = []\\n        nums.sort()\\n        added = set()\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                for k in range(j + 1, len(nums)):\\n                    a, b, c = nums[i], nums[j], nums[k]\\n                    if a + b + c == 0 and (a, b, c) not in added:\\n                        out.append([a, b, c])\\n                        added.add((a, b, c))\\n        return out\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        return self.usingSortingAndTwoPointer(nums)\\n    \\n    def usingSortingAndTwoPointer(self, nums):\\n        nums.sort()\\n        added = set()\\n        out = []\\n        for i in range(len(nums) - 1, -1, -1):\\n            last = nums[i]\\n            start, end = 0, i - 1\\n            while start < end:\\n                s = last + nums[start] + nums[end]\\n                if s == 0:\\n                    if (last, nums[start], nums[end]) not in added: out.append([last, nums[start], nums[end]])\\n                    added.add((last, nums[start], nums[end]))\\n                    start += 1\\n                elif s > 0:\\n                    end -= 1\\n                else: start += 1\\n        return out\\n        \\n    \\n    #TLE, time complexity - o(n^3)\\n    def bruteForce(self, nums):\\n        out = []\\n        nums.sort()\\n        added = set()\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                for k in range(j + 1, len(nums)):\\n                    a, b, c = nums[i], nums[j], nums[k]\\n                    if a + b + c == 0 and (a, b, c) not in added:\\n                        out.append([a, b, c])\\n                        added.add((a, b, c))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544775,
                "title": "easy-solution-using-java-with-comments-18-ms-beats-92-16",
                "content": "```\\n// Space Complexity: O(1)\\n// Time Complexity: O(nlog(n)) + O(n^2)\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        int N = nums.length;\\n        Arrays.sort(nums);\\n        \\n        // If we have less than 3 element there is no valid subset\\n        // If we have min value greater than 0, it\\'s not possible to produce subset where count is zero\\n        // If we have max value less than 0, it\\'s not possible to produce subset where count is zero\\n        if(N < 3 || nums[0] > 0 || nums[N-1] < 0) \\n            return result;\\n        \\n        for(int i = 0; i < N - 2; i++) {\\n            // current i is same as previous, it will create duplicate result\\n            if(i > 0 && nums[i] == nums[i-1])\\n                continue;\\n            \\n            int left = i + 1, right = N - 1;\\n            while(left < right) {\\n                int sum = nums[left] + nums[right] + nums[i];\\n                if(sum == 0) {\\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\\n                    \\n                    // if we have duplicate elements, we need get rid of it so we are moving left and right pointer to a position\\n                    // where there\\'s no duplicate elements.\\n                    while(left < right && nums[left] == nums[left + 1])\\n                        left++;\\n                    while(left < right && nums[right] == nums[right - 1])\\n                        right--;\\n                    left++;\\n                    right--;\\n                }\\n                else if(sum > 0)\\n                    right--;\\n                else\\n                    left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Space Complexity: O(1)\\n// Time Complexity: O(nlog(n)) + O(n^2)\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        int N = nums.length;\\n        Arrays.sort(nums);\\n        \\n        // If we have less than 3 element there is no valid subset\\n        // If we have min value greater than 0, it\\'s not possible to produce subset where count is zero\\n        // If we have max value less than 0, it\\'s not possible to produce subset where count is zero\\n        if(N < 3 || nums[0] > 0 || nums[N-1] < 0) \\n            return result;\\n        \\n        for(int i = 0; i < N - 2; i++) {\\n            // current i is same as previous, it will create duplicate result\\n            if(i > 0 && nums[i] == nums[i-1])\\n                continue;\\n            \\n            int left = i + 1, right = N - 1;\\n            while(left < right) {\\n                int sum = nums[left] + nums[right] + nums[i];\\n                if(sum == 0) {\\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\\n                    \\n                    // if we have duplicate elements, we need get rid of it so we are moving left and right pointer to a position\\n                    // where there\\'s no duplicate elements.\\n                    while(left < right && nums[left] == nums[left + 1])\\n                        left++;\\n                    while(left < right && nums[right] == nums[right - 1])\\n                        right--;\\n                    left++;\\n                    right--;\\n                }\\n                else if(sum > 0)\\n                    right--;\\n                else\\n                    left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508631,
                "title": "simple-o-n-2-java-solution-with-explanations",
                "content": "```\\n    public List<List<Integer>> threeSum(int[] nums) {\\n            \\n        /*\\n        Approach: Sort the array. Have a set of list of integers (threeSumSet), to store three sum cobos.\\n                  Go through each item (i). For each item, have two pointers: one pointing to the next item (j), and another\\n                  one pointing to the end of the array (k). Now, do a 2-way-sweep. While j and k doesn\\'t meet, at each step\\n                  calculate sum = (nums[i]+nums[j]+nums[k]).\\n                  [Starting sweep from next item to prevent duplicate combos because of indexes like ( [i,j,k], [j,i,k]).]\\n                  If sum == 0, we found a three-sum combo! Add it to the threeSumSet. If there is any\\n                  duplicate combo because of different indexes but same items like \\n                  ([i1, j1, k1], [i2, j2, k2], but i1==i2, j1==j2, k1==k2). This will automatically be taken care of by the \\n                  set, as it analyzes the added Lists and makes sure there is no duplicate.                   \\n                  If sum > 0, we should try decreasing the sum value. So we\\'ll decrement k, as this should potentially\\n                  result nums[k] being smaller than previous value, as the array is sorted.\\n                  If sum < 0, because of the same reason, we\\'ll increment j.\\n                  Finally, we\\'ll convert the threeSumSet to ArrayList and return.\\n        \\n        Complexity analysis: Time: O(n^2), Space: O(n)\\n        */\\n        \\n        Set<List<Integer>> threeSumSet  = new HashSet<>();\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length-2;i++){                         //Doing length-2, because we want two elems j and k after i.\\n            int j =i+1;\\n            \\n            int k = nums.length-1;\\n            \\n            while(j<k){\\n                \\n                int sum = nums[i]+nums[j]+nums[k];\\n                \\n                if(sum==0){\\n                    threeSumSet.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    \\n                    j++;\\n                    k--;\\n                }\\n                else if (sum > 0){\\n                    k--;\\n                } \\n                else if (sum < 0){\\n                    j++;\\n                } \\n            }\\n\\n        }\\n        \\n        return new ArrayList<>(threeSumSet);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> threeSum(int[] nums) {\\n            \\n        /*\\n        Approach: Sort the array. Have a set of list of integers (threeSumSet), to store three sum cobos.\\n                  Go through each item (i). For each item, have two pointers: one pointing to the next item (j), and another\\n                  one pointing to the end of the array (k). Now, do a 2-way-sweep. While j and k doesn\\'t meet, at each step\\n                  calculate sum = (nums[i]+nums[j]+nums[k]).\\n                  [Starting sweep from next item to prevent duplicate combos because of indexes like ( [i,j,k], [j,i,k]).]\\n                  If sum == 0, we found a three-sum combo! Add it to the threeSumSet. If there is any\\n                  duplicate combo because of different indexes but same items like \\n                  ([i1, j1, k1], [i2, j2, k2], but i1==i2, j1==j2, k1==k2). This will automatically be taken care of by the \\n                  set, as it analyzes the added Lists and makes sure there is no duplicate.                   \\n                  If sum > 0, we should try decreasing the sum value. So we\\'ll decrement k, as this should potentially\\n                  result nums[k] being smaller than previous value, as the array is sorted.\\n                  If sum < 0, because of the same reason, we\\'ll increment j.\\n                  Finally, we\\'ll convert the threeSumSet to ArrayList and return.\\n        \\n        Complexity analysis: Time: O(n^2), Space: O(n)\\n        */\\n        \\n        Set<List<Integer>> threeSumSet  = new HashSet<>();\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length-2;i++){                         //Doing length-2, because we want two elems j and k after i.\\n            int j =i+1;\\n            \\n            int k = nums.length-1;\\n            \\n            while(j<k){\\n                \\n                int sum = nums[i]+nums[j]+nums[k];\\n                \\n                if(sum==0){\\n                    threeSumSet.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    \\n                    j++;\\n                    k--;\\n                }\\n                else if (sum > 0){\\n                    k--;\\n                } \\n                else if (sum < 0){\\n                    j++;\\n                } \\n            }\\n\\n        }\\n        \\n        return new ArrayList<>(threeSumSet);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144359,
                "title": "two-pointers",
                "content": "We aim to find all possible triplets `a, b, c` such that `a + b + c = 0`.\\n\\nThat is, we aim to find all possible pair `b, c` such that `b + c = -a`, for `a` can be any element of `nums`.\\n\\nWhat are duplicate triplets like? We may assume each triplet `(a, b, c)` is sorted. Then **there shouldn\\'t be duplicated numbers in each position `a`, `b` or `c`**.\\n\\nWe may sort `nums` first, then we may tell the first(non-duplicated) value of `a`, and then look for `b` and `c` where `b + c = -a`. Since `nums` is sorted, we may use two pointers.\\n```py\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        # Looking for a + b + c = 0, that is, b + c = -a\\n\\n        def _next_start(start):  # deduplicate \\'b\\'\\n            start += 1\\n            while start < len(nums) and nums[start] == nums[start - 1]:\\n                start += 1\\n            return start\\n\\n        def _next_end(end):  # deduplicate \\'c\\'\\n            end -= 1\\n            while end >= 0 and nums[end] == nums[end + 1]:\\n                end -= 1       \\n            return end\\n        \\n        nums.sort()\\n        res = []\\n        for i, num in enumerate(nums):\\n            if i > 0 and nums[i] == nums[i - 1]:  # deduplicate \\'a\\'\\n                continue\\n            target_sum = -num\\n            start, end = i + 1, len(nums) - 1\\n            while start < end:\\n                if nums[start] + nums[end] == target_sum:\\n                    res.append([num, nums[start], nums[end]])\\n                    start, end = _next_start(start), _next_end(end)\\n                elif nums[start] + nums[end] < target_sum:\\n                    start = _next_start(start)\\n                else:\\n                    end = _next_end(end)\\n        return res\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```py\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        # Looking for a + b + c = 0, that is, b + c = -a\\n\\n        def _next_start(start):  # deduplicate \\'b\\'\\n            start += 1\\n            while start < len(nums) and nums[start] == nums[start - 1]:\\n                start += 1\\n            return start\\n\\n        def _next_end(end):  # deduplicate \\'c\\'\\n            end -= 1\\n            while end >= 0 and nums[end] == nums[end + 1]:\\n                end -= 1       \\n            return end\\n        \\n        nums.sort()\\n        res = []\\n        for i, num in enumerate(nums):\\n            if i > 0 and nums[i] == nums[i - 1]:  # deduplicate \\'a\\'\\n                continue\\n            target_sum = -num\\n            start, end = i + 1, len(nums) - 1\\n            while start < end:\\n                if nums[start] + nums[end] == target_sum:\\n                    res.append([num, nums[start], nums[end]])\\n                    start, end = _next_start(start), _next_end(end)\\n                elif nums[start] + nums[end] < target_sum:\\n                    start = _next_start(start)\\n                else:\\n                    end = _next_end(end)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865092,
                "title": "python-with-detailed-comments",
                "content": "https://github.com/paulonteri/data-structures-and-algorithms\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n\\n        nums.sort()  # will make spoting of duplicates easy\\n\\n        triplets = []\\n        length = len(nums)\\n\\n        for i in range(length-2):  # ignore last two\\n\\n            # check if element is a duplicate. the first cannot be a duplicate\\n            if i > 0 and nums[i] == nums[i-1]:\\n                # skip handling an element if it\\'s similar to the one before it\\n                # because it is sorted, we effectively skip duplicates\\n                continue\\n\\n            # TWO SUM for a sorted array\\n            # 1. find elements that will add up to 0\\n            # 2. check inner elements\\n            left = i + 1\\n            right = length - 1\\n            while left < right:\\n\\n                # will be used to check if the sum is equal to 0\\n                total = nums[i] + nums[left] + nums[right]\\n\\n                # if total is less than 0 we try to increase it\\'s value\\n                if total < 0:\\n                    left += 1  # moving left to a lerger value\\n\\n                # if total is more than 0 we try to decrease it\\'s value\\n                elif total > 0:\\n                    right -= 1  # moving right to a smaller value\\n\\n                # 1. add list of elements to triplets\\n                # 2. check inner elements\\n                else:\\n                    # add elements to triplets\\n                    triplets.append([nums[i], nums[left], nums[right]])\\n\\n                    # check inner elements\\n                    # 1. skip similar elements\\n                    # 2. move to inner elements\\n\\n                    # skip:\\n                    # no need to continue with an element with the same value as l/r\\n                    # Skip all similar to the current left and right so that,\\n                    # when we are moving to the next element, we dont move to an element with the same value\\n                    while left < right and nums[left] == nums[left+1]:\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:\\n                        right -= 1\\n\\n                    # move to inner elements\\n                    left += 1\\n                    right -= 1\\n\\n        return triplets\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n\\n        nums.sort()  # will make spoting of duplicates easy\\n\\n        triplets = []\\n        length = len(nums)\\n\\n        for i in range(length-2):  # ignore last two\\n\\n            # check if element is a duplicate. the first cannot be a duplicate\\n            if i > 0 and nums[i] == nums[i-1]:\\n                # skip handling an element if it\\'s similar to the one before it\\n                # because it is sorted, we effectively skip duplicates\\n                continue\\n\\n            # TWO SUM for a sorted array\\n            # 1. find elements that will add up to 0\\n            # 2. check inner elements\\n            left = i + 1\\n            right = length - 1\\n            while left < right:\\n\\n                # will be used to check if the sum is equal to 0\\n                total = nums[i] + nums[left] + nums[right]\\n\\n                # if total is less than 0 we try to increase it\\'s value\\n                if total < 0:\\n                    left += 1  # moving left to a lerger value\\n\\n                # if total is more than 0 we try to decrease it\\'s value\\n                elif total > 0:\\n                    right -= 1  # moving right to a smaller value\\n\\n                # 1. add list of elements to triplets\\n                # 2. check inner elements\\n                else:\\n                    # add elements to triplets\\n                    triplets.append([nums[i], nums[left], nums[right]])\\n\\n                    # check inner elements\\n                    # 1. skip similar elements\\n                    # 2. move to inner elements\\n\\n                    # skip:\\n                    # no need to continue with an element with the same value as l/r\\n                    # Skip all similar to the current left and right so that,\\n                    # when we are moving to the next element, we dont move to an element with the same value\\n                    while left < right and nums[left] == nums[left+1]:\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:\\n                        right -= 1\\n\\n                    # move to inner elements\\n                    left += 1\\n                    right -= 1\\n\\n        return triplets\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736561,
                "title": "sum-megapost-python3-solution-with-a-detailed-explanation",
                "content": "If you\\'re a newbie and sometimes have a hard time understanding the logic. Don\\'t worry, you\\'ll catch up after a month of doing Leetcode on a daily basis. Try to do it, even one example per day. It\\'d help. I\\'ve compiled a bunch on `sum` problems here, go ahead and check it out. Also, I think focusing on a subject and do 3-4 problems would help to get the idea behind solution since they mostly follow the same logic. Of course there are other ways to solve each problems but I try to be as uniform as possible. Good luck. \\n\\nIn general, `sum` problems can be categorized into two categories: 1) there is any array and you add some numbers to get to (or close to) a `target`, or 2) you need to return indices of numbers that sum up to a (or close to) a `target` value.  Note that when the problem is looking for a indices, `sort`ing the array is probably NOT a good idea. \\n\\n\\n **[Two Sum:](https://leetcode.com/problems/two-sum/)**  \\n \\n This is the second type of the problems where we\\'re looking for indices, so sorting is not necessary. What you\\'d want to do is to go over the array, and try to find two integers that sum up to  a `target` value. Most of the times, in such a problem, using dictionary (hastable) helps. You try to keep track of you\\'ve observations in a dictionary and use it once you get to the results. \\n\\nNote: try to be comfortable to use `enumerate` as it\\'s sometime out of comfort zone for newbies. `enumerate` comes handy in a lot of problems (I mean if you want to have a cleaner code of course). If I had to choose three built in functions/methods that I wasn\\'t comfortable with at the start and have found them super helpful, I\\'d probably say `enumerate`, `zip` and `set`. \\n \\nSolution: In this problem, you initialize a dictionary (`seen`). This dictionary will keep track of numbers (as `key`) and indices (as `value`). So, you go over your array (line `#1`) using `enumerate` that gives you both index and value of elements in array. As an example, let\\'s do `nums = [2,3,1]` and `target = 3`. Let\\'s say you\\'re at index `i = 0` and `value = 2`, ok? you need to find `value = 1` to finish the problem, meaning, `target - 2 = 1`. 1 here is the `remaining`. Since `remaining + value = target`, you\\'re done once you found it, right? So when going through the array, you calculate the `remaining` and check to see whether `remaining` is in the `seen` dictionary (line `#3`). If it is, you\\'re done! you\\'re current number and the remaining from `seen` would give you the output (line `#4`). Otherwise, you add your current number to the dictionary (line `#5`) since it\\'s going to be a `remaining` for (probably) a number you\\'ll see in the future assuming that there is at least one instance of answer.  \\n \\n \\n ```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\\n \\n \\n\\n **[Two Sum II:](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)**  \\n\\nFor this, you can do exactly as the previous. The only change I made below was to change the order of line `#4`. In the previous example, the order didn\\'t matter. But, here the problem asks for asending order and since the values/indicess in `seen` has always lower indices than your current number, it should come first.  Also, note that the problem says it\\'s not zero based, meaning that indices don\\'t start from zero, that\\'s why I added 1 to both of them. \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\\n\\nAnother approach to solve this problem (probably what Leetcode is looking for) is to treat it as first category of problems. Since the array is already sorted, this works. You see the following approach in a lot of problems. What you want to do is to have two pointer (if it was 3sum, you\\'d need three pointers as you\\'ll see in the future examples). One pointer move from `left` and one from `right`. Let\\'s say you `numbers = [1,3,6,9]` and your `target = 10`. Now, `left` points to 1 at first, and  `right` points to 9. There are three possibilities. If you sum numbers that `left` and `right` are pointing at, you get `temp_sum` (line `#1`). If `temp_sum` is your target, you\\'r done! You\\'re return it (line `#9`). If it\\'s more than your `target`, it means that `right` is poiting to a very large value (line `#5`) and you need to bring it a little bit to the left to a smaller (r maybe equal) value (line `#6`)  by adding one to the index . If the `temp_sum` is less than `target` (line `#7`), then you need to move your `left` to a little bit larger value by adding one to the index (line `#9`). This way, you try to narrow down the range in which you\\'re looking at and will eventually find a couple of number that sum to `target`, then, you\\'ll return this in line `#9`. In this problem, since it says there is only one solution, nothing extra is necessary. However, when a problem asks to return all combinations that sum to `target`, you can\\'t simply return the first instace and you need to collect all the possibilities and return the list altogether (you\\'ll see something like this in the next example). \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\\n\\n\\n\\n\\n[**3Sum**](https://leetcode.com/problems/3sum/)\\n\\nThis is similar to the previous example except that it\\'s looking for three numbers. There are some minor differences in the problem statement. It\\'s looking for all combinations (not just one) of solutions returned as a list. And second, it\\'s looking for unique combination, repeatation is not allowed. \\n\\nHere, instead of looping (line `#1`) to `len(nums) -1`, we loop to `len(nums) -2` since we\\'re looking for three numbers. Since we\\'re returning values, `sort` would be a good idea. Otherwise, if the `nums` is not sorted, you cannot reducing `right` pointer or increasing `left` pointer easily, makes sense? \\n\\nSo, first you `sort` the array and define `res = []` to collect your outputs. In line `#2`, we check wether two consecutive elements are equal or not because if they are, we don\\'t want them (solutions need to be unique) and will skip to the next set of numbers. Also, there is an additional constrain in this line that `i > 0`. This is added to take care of cases like `nums = [1,1,1]` and `target = 3`. If we didn\\'t have `i > 0`, then we\\'d skip the only correct solution and would return `[]` as our answer which is wrong (correct answer is `[[1,1,1]]`.  \\n\\nWe define two additional pointers this time, `left = i + 1` and `right = len(nums) - 1`. For example, if `nums = [-2,-1,0,1,2]`, all the points in the case of `i=1` are looking at: `i` at `-1`, `left` at `0` and `right` at `2`. We then check `temp` variable similar to the previous example. There is only one change with respect to the previous example here between lines `#5` and `#10`.  If we have the `temp = target`, we obviously add this set to the `res` in line `#5`, right? However, we\\'re not done yet. For a fixed `i`, we still need to check and see whether there are other combinations by just changing `left` and `right` pointers. That\\'s what we are doing in lines `#6, 7, 8`. If we still have the condition of `left < right` and `nums[left]` and the number to the right of it are not the same, we move `left` one index to right (line `#6`). Similarly, if `nums[right]` and the value to left of it is not the same, we move `right` one index to left. This way for a fixed `i`, we get rid of repeative cases. For example, if `nums = [-3, 1,1, 3,5]` and `target = 3`, one we get the first `[-3,1,5]`, `left = 1`, but, `nums[2]` is also 1 which we don\\'t want the `left` variable to look at it simply because it\\'d again return `[-3,1,5]`, right? So, we move `left` one index. Finally, if the repeating elements don\\'t exists, lines `#6` to `#8` won\\'t get activated. In this case we still need to move forward by adding 1 to `left` and extracting 1 from `right` (lines `#9, 10`). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\\n\\nAnother way to solve this problem is to change it into a two sum problem. Instead of finding `a+b+c = 0`, you can find `a+b = -c` where we want to find two numbers `a` and `b` that are equal to `-c`, right? This is similar to the first problem. Remember if you wanted to use the exact same as the first code, it\\'d return indices and not numbers. Also, we need to re-arrage this problem in a way that we have `nums` and `target`. This code is not a good code and can be optimipized but you got the idea. For a better version of this, check [this](https://leetcode.com/problems/3sum/discuss/7384/My-Python-solution-based-on-2-sum-200-ms-beat-93.37). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\\n\\n[**4Sum**](https://leetcode.com/problems/4sum/)\\n\\nYou should have gotten the idea, and what you\\'ve seen so far can be generalized to `nSum`. Here, I write the generic code using the same ideas as before. What I\\'ll do is to break down each case to a `2Sum II` problem, and solve them recursively using the approach in `2Sum II` example above. \\n\\nFirst sort `nums`, then I\\'m using two extra functions, `helper` and `twoSum`. The `twoSum` is similar to the `2sum II` example with some modifications. It doesn\\'t return the first instance of results, it check every possible combinations and return all of them now. Basically, now it\\'s more similar to the `3Sum` solution. Understanding this function shouldn\\'t be difficult as it\\'s very similar to `3Sum`. As for `helper` function, it first tries to check for cases that don\\'t work (line `#1`). And later, if the `N` we need to sum to get to a `target` is 2 (line `#2`), then runs the `twoSum` function. For the more than two numbers, it recursively breaks them down to two sum (line `#3`). There are some cases like line `#4` that we don\\'t need to proceed with the algorithm anymore and we can `break`. These cases include if multiplying the lowest number in the list by `N` is more than `target`. Since its sorted array, if this happens, we can\\'t find any result. Also, if the largest array (`nums[-1]`) multiplied by `N` would be less than `target`, we can\\'t find any solution. So, `break`. \\n\\n\\nFor other cases, we run the `helper` function again with new inputs, and we keep doing it until we get to `N=2` in which we use `twoSum` function, and add the results to get the final output. \\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\\n[**Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\nI don\\'t post combination sum here since it\\'s basically this problem a little bit easier. \\nCombination questions can be solved with `dfs` most of the time. if you want to fully understand this concept and [backtracking](https://www.***.org/backtracking-introduction/), try to finish [this](https://leetcode.com/problems/combination-sum/discuss/429538/General-Backtracking-questions-solutions-in-Python-for-reference-%3A) post and do all the examples. \\n\\nRead my older post first [here](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation). This should give you a better idea of what\\'s going on. The solution here also follow the exact same format except for some minor changes. I first made a minor change in the `dfs` function where it doesn\\'t need the `index` parameter anymore. This is taken care of by `candidates[i+1:]` in line `#3`. Note that we had `candidates` here in the previous post. \\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```\\n\\n\\nThe only differences are lines `#1, 2, 3`. The difference in problem statement in this one and `combinations` problem of my previous post is >>>candidates must be used once<<< and lines `#1` and `2` are here to take care of this.  Line `#1` has two components where first `i > 0` and second `candidates[i] == candidates[i-1]`. The second component `candidates[i] == candidates[i-1]` is to take care of duplicates in the `candidates` variable as was instructed in the problem statement. Basically, if the next number in `candidates` is the same as the previous one, it means that it has already been taken care of, so `continue`. The first component takes care of cases like an input  `candidates = [1]` with `target = 1` (try to remove this component and submit your solution. You\\'ll see what I mean). The rest is similar to the previous [post](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation)\\n\\n================================================================\\nFinal note: Please let me know if you found any typo/error/ect. I\\'ll try to fix them.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222015,
                "title": "javascript",
                "content": "```\\nvar threeSum = function(nums) {\\n  nums.sort((a, b) => a - b);\\n  const r = [];\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    if (nums[i] > 0) break;\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n    while (left < right) {\\n      const s = nums[i] + nums[left] + nums[right];\\n      if (s < 0) left += 1;\\n      else if (s > 0) right -= 1;\\n      else {\\n        r.push([nums[i], nums[left], nums[right]]);\\n        while (left < right && nums[left] === nums[left + 1]) left += 1;\\n        while (left < right && nums[right] === nums[right - 1]) right -= 1;\\n        left += 1;\\n        right -= 1;\\n      }\\n    }\\n  }\\n  \\n  return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar threeSum = function(nums) {\\n  nums.sort((a, b) => a - b);\\n  const r = [];\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    if (nums[i] > 0) break;\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n    while (left < right) {\\n      const s = nums[i] + nums[left] + nums[right];\\n      if (s < 0) left += 1;\\n      else if (s > 0) right -= 1;\\n      else {\\n        r.push([nums[i], nums[left], nums[right]]);\\n        while (left < right && nums[left] === nums[left + 1]) left += 1;\\n        while (left < right && nums[right] === nums[right - 1]) right -= 1;\\n        left += 1;\\n        right -= 1;\\n      }\\n    }\\n  }\\n  \\n  return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1544657,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        Set=set()\\n        \\n        nums.sort()\\n        \\n        n=len(nums)\\n        for i in range(n):\\n            j=i+1\\n            k=n-1\\n            while(j<k):\\n                sum=nums[i]+nums[j]+nums[k]\\n                if sum==0:\\n                    Set.add((nums[i],nums[j],nums[k]))\\n                    k=k-1\\n                    j=j+1\\n                        \\n                elif sum>0:\\n                    k=k-1\\n                    \\n                else:\\n                    j=j+1\\n                    \\n        return [list(i) for i in Set]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        Set=set()\\n        \\n        nums.sort()\\n        \\n        n=len(nums)\\n        for i in range(n):\\n            j=i+1\\n            k=n-1\\n            while(j<k):\\n                sum=nums[i]+nums[j]+nums[k]\\n                if sum==0:\\n                    Set.add((nums[i],nums[j],nums[k]))\\n                    k=k-1\\n                    j=j+1\\n                        \\n                elif sum>0:\\n                    k=k-1\\n                    \\n                else:\\n                    j=j+1\\n                    \\n        return [list(i) for i in Set]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278187,
                "title": "c-two-pointers",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) {\\n        Array.Sort(nums);\\n\\n        var result = new List<IList<int>>();\\n\\n        var n = nums.Length;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i - 1] == nums[i]) continue;\\n\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                if (sum == 0) {\\n                    result.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++;\\n                    while (left < right && nums[right] == nums[right - 1]) right--;\\n                    left++;\\n                    right--;\\n                } else if (sum < 0) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) {\\n        Array.Sort(nums);\\n\\n        var result = new List<IList<int>>();\\n\\n        var n = nums.Length;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i - 1] == nums[i]) continue;\\n\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                if (sum == 0) {\\n                    result.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++;\\n                    while (left < right && nums[right] == nums[right - 1]) right--;\\n                    left++;\\n                    right--;\\n                } else if (sum < 0) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310898,
                "title": "easy-to-understand-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& arr) {\\n        int n = arr.size();\\n\\n        if(n < 3)\\n            return {};\\n        vector<vector<int>> res; \\n        sort(arr.begin() , arr.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i > 0 && arr[i] == arr[i-1])\\n                continue;\\n            \\n            int j = i+1, k = n-1;\\n            \\n            while(j < k)\\n            {\\n                int sum = arr[i] + arr[j] + arr[k];\\n                if(sum < 0)\\n                    j++;\\n                else if(sum > 0)\\n                    k--;\\n                else\\n                {\\n                    res.push_back({arr[i] , arr[j] , arr[k]});\\n                    \\n                    while(j < k && arr[j] == arr[j+1]) j++;\\n                    while(j < k && arr[k] == arr[k-1]) k--;\\n                    j++;\\n                    k--;\\n                }\\n            }\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& arr) {\\n        int n = arr.size();\\n\\n        if(n < 3)\\n            return {};\\n        vector<vector<int>> res; \\n        sort(arr.begin() , arr.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i > 0 && arr[i] == arr[i-1])\\n                continue;\\n            \\n            int j = i+1, k = n-1;\\n            \\n            while(j < k)\\n            {\\n                int sum = arr[i] + arr[j] + arr[k];\\n                if(sum < 0)\\n                    j++;\\n                else if(sum > 0)\\n                    k--;\\n                else\\n                {\\n                    res.push_back({arr[i] , arr[j] , arr[k]});\\n                    \\n                    while(j < k && arr[j] == arr[j+1]) j++;\\n                    while(j < k && arr[k] == arr[k-1]) k--;\\n                    j++;\\n                    k--;\\n                }\\n            }\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629926,
                "title": "can-t-understand-the-error",
                "content": "What is the problem with the following code, it runs fine with cusotm testcases ([-1, 0, 1, 2, -1, -4] or [0,0,0,0]) but gives following error upon submission:\\n\\nRuntime Error Message: Line 924: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:933:9\\nLast executed input:[]\\n\\nHow do I interpret the above error message.\\n\\nTIA\\n\\n```\\n\\n vector<vector<int>> threeSum(vector<int>& nums) {\\n\\n    vector<vector<int>> result;\\n    sort(nums.begin(),nums.end());\\n\\n    for(int i=0;i<nums.size()-2;){     \\n        int req = -nums[i];\\n        int l = i+1,r=nums.size()-1;\\n\\n        while(l<r){\\n            int sum = nums[l] + nums[r];\\n            if(sum < req)\\n                l++;\\n            else if(sum > req)\\n                r--;\\n            else{\\n                vector<int> temp = {nums[i],nums[l],nums[r]};\\n                result.push_back(temp);\\n                \\n                while(l+1<r && nums[l]==nums[l+1])\\n                    l++;\\n                l++;\\n                \\n                \\n                \\n                while(l<r-1 && nums[r]==nums[r-1])\\n                    r--;\\n                r--;\\n\\n            }\\n        }\\n\\n        while (i < nums.size() && nums[i] == nums[i+1]) \\n            i++;\\n        i++;\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n vector<vector<int>> threeSum(vector<int>& nums) {\\n\\n    vector<vector<int>> result;\\n    sort(nums.begin(),nums.end());\\n\\n    for(int i=0;i<nums.size()-2;){     \\n        int req = -nums[i];\\n        int l = i+1,r=nums.size()-1;\\n\\n        while(l<r){\\n            int sum = nums[l] + nums[r];\\n            if(sum < req)\\n                l++;\\n            else if(sum > req)\\n                r--;\\n            else{\\n                vector<int> temp = {nums[i],nums[l],nums[r]};\\n                result.push_back(temp);\\n                \\n                while(l+1<r && nums[l]==nums[l+1])\\n                    l++;\\n                l++;\\n                \\n                \\n                \\n                while(l<r-1 && nums[r]==nums[r-1])\\n                    r--;\\n                r--;\\n\\n            }\\n        }\\n\\n        while (i < nums.size() && nums[i] == nums[i+1]) \\n            i++;\\n        i++;\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500428,
                "title": "o-n-2-python-short-solution-uses-2sum-hashmap-solution",
                "content": "```\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        for i,v in enumerate(nums):\\n            self.twoSum(nums[i+1:],-v,ans)\\n        return ans\\n    def twoSum(self,nums,target,ans):\\n        d = {}\\n        for i,v in enumerate(nums):\\n            if target-v in d:\\n                ans.add((v,target-v,-target)) #3sum wants the numbers, while 2sum wanted the indices\\n            d[v] = i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        for i,v in enumerate(nums):\\n            self.twoSum(nums[i+1:],-v,ans)\\n        return ans\\n    def twoSum(self,nums,target,ans):\\n        d = {}\\n        for i,v in enumerate(nums):\\n            if target-v in d:\\n                ans.add((v,target-v,-target)) #3sum wants the numbers, while 2sum wanted the indices\\n            d[v] = i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222521,
                "title": "python-solution",
                "content": "The idea is to first sort `nums`, and iterate over all possible values `nums[i]` for the smallest number in the triple. For each value, we need to find a pair `nums[j], nums[k]` with `i < j < k` such that `nums[j] + nums[k] == -nums[i]`. This is just the twoSum problem, and can be solved in `O(n)` time with two pointers. The overall runtime is thus `O(n**2)`.\\n\\nTricks to avoid duplicates:\\n1. When we iterate `i` over `range(n-2)` to find the smallest number in the triple, if `i > 0` and `nums[i] == nums[i-1]`, it means that we have already consider `nums[i]` to be the smallest number in the triple in the previous iteration. Hence we need to `continue` and jump to the next iteration. Otherwise, it might leads to duplicate triples.\\n2. For each fixed `nums[i]`, we need to use two pointers `k > j > i` to find a **unique** pair `nums[j], nums[k]`, such that `nums[j]+nums[k] == -nums[i]`. We initialize `j = i+1`, `k = len(nums)-1`, and increment `j` by `1` if `nums[j]+nums[k] < -nums[i]` and decrement `k` by `1` if `nums[j]+nums[k] > -nums[i]`. The tricky part is when `nums[j]+nums[k] == -nums[i]`, we first add the triple `[nums[i], nums[j], nums[k]]` to our result. In order to avoid duplicate triples, we increment `j` until `nums[j] != nums[j-1]`, and decrement `k` until `nums[k] != nums[k+1]`. We continue with the above procedure until `j >= k`.\\n\\nTime complexity: `O(n**2)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        n = len(nums)\\n        nums = sorted(nums)\\n        for i in range(n-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            j = i+1\\n            k = n-1\\n            new_target = -nums[i]\\n            while j < k:\\n                summ = nums[j] + nums[k]\\n                if summ < new_target:\\n                    j += 1\\n                elif summ > new_target:\\n                    k -= 1\\n                else:\\n                    res.append([nums[i], nums[j], nums[k]])\\n                    while j < k and nums[j+1] == nums[j]:\\n                        j += 1\\n                    j += 1\\n                    while k > j and nums[k-1] == nums[k]:\\n                        k -= 1\\n                    k -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        n = len(nums)\\n        nums = sorted(nums)\\n        for i in range(n-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            j = i+1\\n            k = n-1\\n            new_target = -nums[i]\\n            while j < k:\\n                summ = nums[j] + nums[k]\\n                if summ < new_target:\\n                    j += 1\\n                elif summ > new_target:\\n                    k -= 1\\n                else:\\n                    res.append([nums[i], nums[j], nums[k]])\\n                    while j < k and nums[j+1] == nums[j]:\\n                        j += 1\\n                    j += 1\\n                    while k > j and nums[k-1] == nums[k]:\\n                        k -= 1\\n                    k -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437982,
                "title": "best-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe approach used in this solution is to first sort the input array in ascending order. Then, the solution iterates through each element of the sorted array. For each element, it attempts to find two other elements in the remaining part of the array that add up to the negative of the current element.\\n\\nTo do this, the solution uses two pointers, `j` and `k`, to traverse the remaining part of the array. Initially, `j` is set to the next element after `i`, and `k` is set to the last element of the array. At each iteration, the solution calculates the `sum` of the three elements pointed to by `i`, `j`, and `k`. If the `sum` is zero, the solution adds the *triplet* to a *set* to ensure uniqueness and moves `j` to the *right* and `k` to the *left*. If the `sum` is less than zero, the solution increments `j` to move to larger values. If the `sum` is greater than zero, the solution decrements `k` to move to smaller values. This process continues until `j` and `k` meet.\\n\\nFinally, the solution returns the unique triplets found in the set as an array. The use of a set ensures that there are no duplicates in the output, as required by the problem statement.\\n\\n# Complexity\\nThe time complexity of this solution is $$O(n^2)$$, where $$n$$ is the length of the input array, due to the nested loop structure used to find the triplets.\\n\\n# Proof\\n\\nTo prove that the minimum asymptotic solution for the problem is $$O(n^2)$$, we need to show that any algorithm that solves the problem must take at least $$O(n^2)$$ time in the worst case.\\n\\nOne way to do this is to consider the number of possible solutions for the problem. Since we are looking for unique triplets that add up to zero, we can think of the problem as selecting three elements from the input array and checking whether their sum is zero. There are $$n$$ choose $$3$$ ($$C_n^3$$) ways to select three elements from an array of length $$n$$. This is equal to $$\\\\dfrac{n(n-1)(n-2)}{6}$$, which is $$O(n^3)$$. Therefore, any algorithm that checks all possible combinations of three elements in the array will take at least $$O(n^3)$$ time in the worst case.\\n\\nTherefore, we can conclude that the minimum asymptotic solution for the problem is $$O(n^2)$$, since any algorithm that solves the problem must take at least $$O(n^2)$$ time in the worst case, and there exists an algorithm that can solve the problem in $$O(n^2)$$ time.\\n\\n# Code\\n```swift\\nclass Solution {\\n    func threeSum(_ nums: [Int]) -> [[Int]] {\\n        let sortedNums = nums.sorted()\\n        var result = Set<[Int]>()\\n\\n        for i in 0 ..< sortedNums.count {\\n            var j = i + 1\\n            var k = sortedNums.count - 1\\n            while j < k {\\n                let sum = sortedNums[i] + sortedNums[j] + sortedNums[k]\\n                if sum == 0 {\\n                    result.insert([sortedNums[i], sortedNums[j], sortedNums[k]])\\n                    j += 1\\n                    k -= 1\\n                } else if sum < 0 {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n            }\\n        }\\n\\n        return Array(result)\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/c173a4aa-649a-4b75-97b7-26686aa4e1ba_1681993736.770489.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```swift\\nclass Solution {\\n    func threeSum(_ nums: [Int]) -> [[Int]] {\\n        let sortedNums = nums.sorted()\\n        var result = Set<[Int]>()\\n\\n        for i in 0 ..< sortedNums.count {\\n            var j = i + 1\\n            var k = sortedNums.count - 1\\n            while j < k {\\n                let sum = sortedNums[i] + sortedNums[j] + sortedNums[k]\\n                if sum == 0 {\\n                    result.insert([sortedNums[i], sortedNums[j], sortedNums[k]])\\n                    j += 1\\n                    k -= 1\\n                } else if sum < 0 {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n            }\\n        }\\n\\n        return Array(result)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066420,
                "title": "java-2-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> set=new HashSet<>();\\n        if(nums.length==0) return new ArrayList<>();\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            int j=i+1;\\n            int k=nums.length-1;\\n            while(j<k)\\n            {\\n                sum=nums[i]+nums[j]+nums[k];\\n                if(sum==0) set.add(Arrays.asList(nums[i],nums[j++],nums[k--]));\\n                if(sum<0) j++;\\n                if(sum>0) k--;\\n\\n            }\\n        }\\n        return new ArrayList<>(set);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> set=new HashSet<>();\\n        if(nums.length==0) return new ArrayList<>();\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            int j=i+1;\\n            int k=nums.length-1;\\n            while(j<k)\\n            {\\n                sum=nums[i]+nums[j]+nums[k];\\n                if(sum==0) set.add(Arrays.asList(nums[i],nums[j++],nums[k--]));\\n                if(sum<0) j++;\\n                if(sum>0) k--;\\n\\n            }\\n        }\\n        return new ArrayList<>(set);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726842,
                "title": "c-two-pointer-easy-explanation",
                "content": "We are fixing 1 number from loop and in the inner loop with the help of two pointer approach we are checking that sum is equal to 0 or not. \\nThe main problem is that we are getting repeated vectors, hence we are sorting the nums array so that we can get sorted vectors and we can add the vector only when that does not matches the last vector of the answer.\\n\\nHere is the code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,n =nums.size();\\n        \\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        for(i=0; i<n-2; ++i)\\n        {\\n            \\n            // cout<<l<<\"-\"<<r<<\" \";\\n            if(i>0)\\n            {\\n\\t\\t\\t//so that we do not get repeated vectors\\n\\t\\t\\t//once we had calculated answer for nums[i] we will not calculate that again\\n                while(i<n && nums[i] == nums[i-1])\\n                    i++;\\n            }\\n            \\n            int l = i+1, r= n-1;\\n            cout<<l<<\"-\"<<r<<\" \";\\n            while(l < r)\\n            {\\n                if((nums[i] + nums[l] + nums[r]) < 0)\\n                    l++;\\n                else if((nums[i] + nums[l] + nums[r]) > 0)\\n                    r--;\\n                else\\n                {\\n                    vector<int> vt(3);\\n                    vt[0] = nums[i];\\n                    vt[1] = nums[l];\\n                    vt[2] = nums[r];\\n                    \\n                    if(ans.size() == 0)\\n                        ans.push_back(vt);\\n                    else if(ans[ans.size() - 1] != vt)\\n                    ans.push_back(vt);\\n                    r--;\\n                    l++;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if this helped.",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,n =nums.size();\\n        \\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        for(i=0; i<n-2; ++i)\\n        {\\n            \\n            // cout<<l<<\"-\"<<r<<\" \";\\n            if(i>0)\\n            {\\n\\t\\t\\t//so that we do not get repeated vectors\\n\\t\\t\\t//once we had calculated answer for nums[i] we will not calculate that again\\n                while(i<n && nums[i] == nums[i-1])\\n                    i++;\\n            }\\n            \\n            int l = i+1, r= n-1;\\n            cout<<l<<\"-\"<<r<<\" \";\\n            while(l < r)\\n            {\\n                if((nums[i] + nums[l] + nums[r]) < 0)\\n                    l++;\\n                else if((nums[i] + nums[l] + nums[r]) > 0)\\n                    r--;\\n                else\\n                {\\n                    vector<int> vt(3);\\n                    vt[0] = nums[i];\\n                    vt[1] = nums[l];\\n                    vt[2] = nums[r];\\n                    \\n                    if(ans.size() == 0)\\n                        ans.push_back(vt);\\n                    else if(ans[ans.size() - 1] != vt)\\n                    ans.push_back(vt);\\n                    r--;\\n                    l++;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 514346,
                "title": "python-95-solution-commented-and-explained",
                "content": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        # Hash maps (dict) to store neg/pos integer counts.\\n        neg = {}\\n        pos = {}\\n        zeros = 0\\n\\n        # Hash set to store tuples of valid solutions.\\n        # Automatically handles duplicate solutions if we add\\n        # sorted tuples to it.\\n        solutions = set()\\n\\n        # Initializing our counter. O(n).\\n        for i in nums:\\n            if i < 0:\\n                neg.setdefault(i, 0)\\n                neg[i] += 1\\n            elif i > 0:\\n                pos.setdefault(i, 0)\\n                pos[i] += 1\\n            else:\\n                zeros += 1\\n\\n        # We iterate through all unique values of nums.\\n        # Note: \\'i\\' and \\'j\\' are always opposite in parity. i.e. \\'i\\'\\n        # and \\'j\\' will never both be positive or both be negative.\\n        for i in {num for num in nums}:\\n            # Seeking positive numbers to offset negative numbers.\\n            if i < 0:\\n                for j in pos:\\n                    # Seek for third number, k = -(i + j) \\n                    k = -i - j\\n                    if k in pos:\\n                        # Invalid solution;\\n                        if k == j and pos[j]-1 < 1:\\n                            continue\\n                        # Valid solution;\\n                        else:\\n                            solutions.add(tuple(sorted((i, j, k))))\\n                    # If third number is \\'0\\' and we have zeros to use.\\n                    elif k == 0 and zeros > 0:\\n                        solutions.add(tuple(sorted((i, j, 0))))\\n\\n            # Logic below is nearly identical logic as above. Kept it verbose for readibility.\\n\\n            # Seeking negative numbers to offset postive numbers.\\n            elif i > 0:\\n                for j in neg:\\n                    k = -i - j\\n                    if k in neg:\\n                        if k == j and neg[j]-1 < 1:\\n                            continue\\n                        else:\\n                            solutions.add(tuple(sorted((i, j, k))))\\n                    elif k == 0 and zeros > 0:\\n                        solutions.add(tuple(sorted((i, j, 0))))\\n\\n            # If we encounter a zero, check to see we have 3 or more.\\n            elif zeros >= 3:\\n                solutions.add((0, 0, 0))\\n\\n        return [list(s) for s in solutions]\\n```\\n\\n# Solution Explanation\\nThis solution approaches the problem by...\\n* Counting all appearances of numbers separated by positives, negatives, and zeros.\\n* Iterate through all distinct numbers -> ***i*** for *i* in nums\\n\\t* Seek possible solutions of opposite parity (i.e. if ***i*** is negative, ***j*** is positive.) -> ***j*** for *j* in pos/neg. \\n\\t* Seek the third number -> ***k*** = -(*i* + *j*)\\n\\t* Valid solutions:\\n\\t\\t* ***i***, ***j***, ***k*** all exist in nums.\\n\\t\\t* Store in as a sorted tuple into our \\'solution\\' set.\\n\\t* Edge cases:\\n\\t\\t* ***i*** = `zero`. We check to see if we have three zeros 0\\'s to use.\\n\\t\\t* ***j*** = ***k***. We use our counter to see if we have two values of ***j*** (or ***k***) to use.\\n\\n\\n\\t* Invalid solutions:\\n\\t\\t* Otherwise, ignore.\\n\\n\\n### Why does this work?\\nSuppose we look at numbers in \\'num\\' one at a time, ***i*** *for i in nums*. To find sums that tend to zero, we only care about offsetting ***i*** with numbers of opposite parity, such that ***j*** and ***k*** are opposite in sign to ***i***.  We consider this for every distinct ***i***, relying on our counter of negatives, postives, and zeros to handle the edge cases bulleted above.\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        # Hash maps (dict) to store neg/pos integer counts.\\n        neg = {}\\n        pos = {}\\n        zeros = 0\\n\\n        # Hash set to store tuples of valid solutions.\\n        # Automatically handles duplicate solutions if we add\\n        # sorted tuples to it.\\n        solutions = set()\\n\\n        # Initializing our counter. O(n).\\n        for i in nums:\\n            if i < 0:\\n                neg.setdefault(i, 0)\\n                neg[i] += 1\\n            elif i > 0:\\n                pos.setdefault(i, 0)\\n                pos[i] += 1\\n            else:\\n                zeros += 1\\n\\n        # We iterate through all unique values of nums.\\n        # Note: \\'i\\' and \\'j\\' are always opposite in parity. i.e. \\'i\\'\\n        # and \\'j\\' will never both be positive or both be negative.\\n        for i in {num for num in nums}:\\n            # Seeking positive numbers to offset negative numbers.\\n            if i < 0:\\n                for j in pos:\\n                    # Seek for third number, k = -(i + j) \\n                    k = -i - j\\n                    if k in pos:\\n                        # Invalid solution;\\n                        if k == j and pos[j]-1 < 1:\\n                            continue\\n                        # Valid solution;\\n                        else:\\n                            solutions.add(tuple(sorted((i, j, k))))\\n                    # If third number is \\'0\\' and we have zeros to use.\\n                    elif k == 0 and zeros > 0:\\n                        solutions.add(tuple(sorted((i, j, 0))))\\n\\n            # Logic below is nearly identical logic as above. Kept it verbose for readibility.\\n\\n            # Seeking negative numbers to offset postive numbers.\\n            elif i > 0:\\n                for j in neg:\\n                    k = -i - j\\n                    if k in neg:\\n                        if k == j and neg[j]-1 < 1:\\n                            continue\\n                        else:\\n                            solutions.add(tuple(sorted((i, j, k))))\\n                    elif k == 0 and zeros > 0:\\n                        solutions.add(tuple(sorted((i, j, 0))))\\n\\n            # If we encounter a zero, check to see we have 3 or more.\\n            elif zeros >= 3:\\n                solutions.add((0, 0, 0))\\n\\n        return [list(s) for s in solutions]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620095,
                "title": "java-solution",
                "content": "Kindly upvote, if it helps you!\\nHappy Coding! :)\\nNote - Please solve Two Sum II prior to this, as the logic is based on that\\nhttps://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\\n\\nIn Three Sum, we are fixing one variable i.e. \\'a\\' and search for \\'b\\' & \\'c\\' using two pointer approach\\nsuch that a+b+c==0\\nIn the question its given that duplicate pair should not added in the List. \\nWe have sorted the array, such that if a is duplicate they would be consecutively placed and we would skip that value.\\n\\n```\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i< nums.length-2; i++){\\n\\t\\t    //if a is duplicate, skip that value\\n            if(i>0 && nums[i] == nums[i-1])\\n                continue;\\n\\t\\t\\t//fixed the a, now will search for b & c from (i+1) index to (nums.length-1) index\\t\\n            int a = nums[i];\\n            int start = i+1, end = nums.length-1;\\n            while(start < end){\\n                int sum = a + nums[start] + nums[end];\\n                if(sum > 0){\\n                    end--;\\n                }else if(sum < 0){\\n                    start++;\\n                }else{\\n\\t\\t\\t\\t\\tresult.add(Arrays.asList(a,nums[start],nums[end]));\\n\\t\\t\\t\\t\\t//if b value is duplicate skip that\\n                    while(start< end && nums[start] == nums[start+1])\\n                        start++;\\n\\t\\t\\t\\t\\t//if c value is duplicate, skip that\\t\\n                    while( start< end && nums[end] == nums[end-1])\\n                        end--;\\n                    start++;\\n                    end--;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "Kindly upvote, if it helps you!\\nHappy Coding! :)\\nNote - Please solve Two Sum II prior to this, as the logic is based on that\\nhttps://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\\n\\nIn Three Sum, we are fixing one variable i.e. \\'a\\' and search for \\'b\\' & \\'c\\' using two pointer approach\\nsuch that a+b+c==0\\nIn the question its given that duplicate pair should not added in the List. \\nWe have sorted the array, such that if a is duplicate they would be consecutively placed and we would skip that value.\\n\\n```\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i< nums.length-2; i++){\\n\\t\\t    //if a is duplicate, skip that value\\n            if(i>0 && nums[i] == nums[i-1])\\n                continue;\\n\\t\\t\\t//fixed the a, now will search for b & c from (i+1) index to (nums.length-1) index\\t\\n            int a = nums[i];\\n            int start = i+1, end = nums.length-1;\\n            while(start < end){\\n                int sum = a + nums[start] + nums[end];\\n                if(sum > 0){\\n                    end--;\\n                }else if(sum < 0){\\n                    start++;\\n                }else{\\n\\t\\t\\t\\t\\tresult.add(Arrays.asList(a,nums[start],nums[end]));\\n\\t\\t\\t\\t\\t//if b value is duplicate skip that\\n                    while(start< end && nums[start] == nums[start+1])\\n                        start++;\\n\\t\\t\\t\\t\\t//if c value is duplicate, skip that\\t\\n                    while( start< end && nums[end] == nums[end-1])\\n                        end--;\\n                    start++;\\n                    end--;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 364847,
                "title": "python-ac-clean-and-straightforward-solution",
                "content": "```\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = set()\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            \\n            while left < right:\\n                if nums[i] + nums[left] + nums[right] < 0:\\n                    left += 1\\n                elif nums[i] + nums[left] + nums[right] > 0:\\n                    right -= 1\\n                else:\\n                    res.add((nums[i], nums[left], nums[right]))\\n                    left += 1\\n                    right -= 1\\n        \\n        return list(res)\\n```\\nTime complexity O(nlg(n))+O(n^2) = O(n^2).",
                "solutionTags": [],
                "code": "```\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = set()\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            \\n            while left < right:\\n                if nums[i] + nums[left] + nums[right] < 0:\\n                    left += 1\\n                elif nums[i] + nums[left] + nums[right] > 0:\\n                    right -= 1\\n                else:\\n                    res.add((nums[i], nums[left], nums[right]))\\n                    left += 1\\n                    right -= 1\\n        \\n        return list(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 295224,
                "title": "go-768-ms-faster-than-100-00",
                "content": "```\\nfunc threeSum(nums []int) [][]int {\\n\\tvar results [][]int\\n\\tsort.Ints(nums)\\n\\tfor i := 0; i < len(nums)-2; i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue//To prevent the repeat\\n\\t\\t}\\n\\t\\ttarget, left, right := -nums[i], i+1, len(nums)-1\\n\\t\\tfor left < right {\\n\\t\\t\\tsum := nums[left] + nums[right]\\n\\t\\t\\tif sum == target {\\n\\t\\t\\t\\tresults = append(results, []int{nums[i], nums[left], nums[right]})\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left-1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right+1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if sum > target {\\n\\t\\t\\t\\tright--\\n\\t\\t\\t} else if sum < target {\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn results\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc threeSum(nums []int) [][]int {\\n\\tvar results [][]int\\n\\tsort.Ints(nums)\\n\\tfor i := 0; i < len(nums)-2; i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue//To prevent the repeat\\n\\t\\t}\\n\\t\\ttarget, left, right := -nums[i], i+1, len(nums)-1\\n\\t\\tfor left < right {\\n\\t\\t\\tsum := nums[left] + nums[right]\\n\\t\\t\\tif sum == target {\\n\\t\\t\\t\\tresults = append(results, []int{nums[i], nums[left], nums[right]})\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left-1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right+1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if sum > target {\\n\\t\\t\\t\\tright--\\n\\t\\t\\t} else if sum < target {\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn results\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168203,
                "title": "best-and-easy-solution-so-far",
                "content": "```\\n\\npublic List<List<Integer>> threeSum(int[] arr) {\\n        \\n        Set<List<Integer>> result  = new HashSet<>();\\n        \\n        if (arr == null || arr.length < 3)\\n            return new ArrayList<>(result);\\n       \\n        Arrays.sort(arr);\\t\\t\\t\\t\\t\\t\\t\\t\\t// Sort the elements\\n\\n        int size = arr.length;\\n        \\n\\t    for (int i = 0; i < size - 2; i++)\\t\\t\\t\\t// Now fix the first element and find the other two elements\\n\\t    {\\n\\t        // To find the other two elements, start two index variables\\n\\t        // from two corners of the array and move them toward each other\\n\\t        int left = i + 1;\\n\\t\\t\\tint right = size - 1;\\n\\t        \\n\\t        while (left < right)\\n\\t        {\\n                int sum =  arr[i] + arr[left] + arr[right];\\n                \\n\\t            if (sum == 0)\\n\\t            {\\n                    result.add(Arrays.asList(arr[i], arr[left], arr[right]));\\n                    left++;\\n                    right--;\\n\\t            }\\n\\t            else if (sum < 0)\\n\\t                left++;\\n\\t            else \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t                right--;\\n\\t        }\\n\\t    }\\n        return new ArrayList<>(result);\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n\\npublic List<List<Integer>> threeSum(int[] arr) {\\n        \\n        Set<List<Integer>> result  = new HashSet<>();\\n        \\n        if (arr == null || arr.length < 3)\\n            return new ArrayList<>(result);\\n       \\n        Arrays.sort(arr);\\t\\t\\t\\t\\t\\t\\t\\t\\t// Sort the elements\\n\\n        int size = arr.length;\\n        \\n\\t    for (int i = 0; i < size - 2; i++)\\t\\t\\t\\t// Now fix the first element and find the other two elements\\n\\t    {\\n\\t        // To find the other two elements, start two index variables\\n\\t        // from two corners of the array and move them toward each other\\n\\t        int left = i + 1;\\n\\t\\t\\tint right = size - 1;\\n\\t        \\n\\t        while (left < right)\\n\\t        {\\n                int sum =  arr[i] + arr[left] + arr[right];\\n                \\n\\t            if (sum == 0)\\n\\t            {\\n                    result.add(Arrays.asList(arr[i], arr[left], arr[right]));\\n                    left++;\\n                    right--;\\n\\t            }\\n\\t            else if (sum < 0)\\n\\t                left++;\\n\\t            else \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t                right--;\\n\\t        }\\n\\t    }\\n        return new ArrayList<>(result);\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 578219,
                "title": "python-with-hash-table",
                "content": "Only need to check if the target value on the right side of (j)\\n```\\n    def threeSum(self, nums):\\n        ht={}\\n        nums.sort()\\n        ans=set()\\n        for i,n in enumerate(nums):\\n            ht[n]=i\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                target=-(nums[i]+nums[j])\\n                if target in ht and ht[target]>j:\\n                    ans.add((nums[i],nums[j],-(nums[i]+nums[j])))\\n                    \\n        return list(ans)\\n```",
                "solutionTags": [],
                "code": "```\\n    def threeSum(self, nums):\\n        ht={}\\n        nums.sort()\\n        ans=set()\\n        for i,n in enumerate(nums):\\n            ht[n]=i\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                target=-(nums[i]+nums[j])\\n                if target in ht and ht[target]>j:\\n                    ans.add((nums[i],nums[j],-(nums[i]+nums[j])))\\n                    \\n        return list(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2344696,
                "title": "python-just-run-original-two-sum-with-a-hashmap-for-each-element",
                "content": "The most intuitive solution for 3sum is just run 2sum for each element. You have to add a few tweaks:\\n1) Skip element if we have already run 2sum for the element with same value (array has duplicates)\\n2) Skip current element when doing 2sum\\n3) Use hashset and sorting to avoid duplicates in the answer.\\n\\nYou can also add a few optimizations here, but the final time complexity will be O(n^2).\\n\\n```\\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        ans = set()\\n        dups = set()\\n        \\n        def two_sum(nums,target,val1,i):\\n            seen = {}\\n            for j, val2 in enumerate(nums):\\n\\t\\t\\t\\t# skip current element we are running 2sum for\\n                if j != i:\\n                    compliment = target - val2\\n                    if compliment in seen:\\n\\t\\t\\t\\t\\t\\t# sort and convert into tuple to get rid of duplicates\\n                        ans.add(tuple(sorted([val1,val2,compliment])))\\n                    seen[val2] = j\\n            \\n        for i, val1 in enumerate(nums):\\n\\t\\t\\t# skip element if we have already run 2sum for it\\n            if val1 not in dups:\\n                dups.add(val1)\\n                target = -val1\\n                two_sum(nums,target,val1,i)\\n        return ans\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        ans = set()\\n        dups = set()\\n        \\n        def two_sum(nums,target,val1,i):\\n            seen = {}\\n            for j, val2 in enumerate(nums):\\n\\t\\t\\t\\t# skip current element we are running 2sum for\\n                if j != i:\\n                    compliment = target - val2\\n                    if compliment in seen:\\n\\t\\t\\t\\t\\t\\t# sort and convert into tuple to get rid of duplicates\\n                        ans.add(tuple(sorted([val1,val2,compliment])))\\n                    seen[val2] = j\\n            \\n        for i, val1 in enumerate(nums):\\n\\t\\t\\t# skip element if we have already run 2sum for it\\n            if val1 not in dups:\\n                dups.add(val1)\\n                target = -val1\\n                two_sum(nums,target,val1,i)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1169670,
                "title": "c-easy-solution",
                "content": "***Do upvote if you found it helpful to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n***Feel free to give suggestions***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> res;\\n       int i,j,k,sum = 0;\\n       int n = nums.size();\\n       if(n <= 2)\\n       return res;\\n       sort(nums.begin(),nums.end());\\n        for(i=0 ; i<n ; i++)\\n        {\\n           if(i > 0 && nums[i] == nums[i-1]) continue; // if same element appears\\n           j=i+1;\\n           k=n-1;\\n           while(j < k)\\n           {\\n               vector<int> v;\\n               sum = nums[j] + nums[k];\\n               if(sum + nums[i] == 0)\\n               {\\n                 v.push_back(nums[i]);\\n                 v.push_back(nums[j]);\\n                 v.push_back(nums[k]);\\n                 res.push_back(v);\\n                 while(j < k && nums[j] == nums[j+1])\\n                       j++;\\n                 while(j < k && nums[k] == nums[k-1])\\n                       k--;\\n                   j++;\\n                   k--;\\n               }\\n               else if(sum + nums[i] < 0)\\n               j++;\\n               else if(sum + nums[i] > 0)\\n               k--;\\n           }\\n        }\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> res;\\n       int i,j,k,sum = 0;\\n       int n = nums.size();\\n       if(n <= 2)\\n       return res;\\n       sort(nums.begin(),nums.end());\\n        for(i=0 ; i<n ; i++)\\n        {\\n           if(i > 0 && nums[i] == nums[i-1]) continue; // if same element appears\\n           j=i+1;\\n           k=n-1;\\n           while(j < k)\\n           {\\n               vector<int> v;\\n               sum = nums[j] + nums[k];\\n               if(sum + nums[i] == 0)\\n               {\\n                 v.push_back(nums[i]);\\n                 v.push_back(nums[j]);\\n                 v.push_back(nums[k]);\\n                 res.push_back(v);\\n                 while(j < k && nums[j] == nums[j+1])\\n                       j++;\\n                 while(j < k && nums[k] == nums[k-1])\\n                       k--;\\n                   j++;\\n                   k--;\\n               }\\n               else if(sum + nums[i] < 0)\\n               j++;\\n               else if(sum + nums[i] > 0)\\n               k--;\\n           }\\n        }\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725326,
                "title": "c-three-pointer-o-n2-time-with-comments-and-explantion",
                "content": "The approach here is to go through all index and then use two pointers tocheck if the sum of all three elements(The one we are currently on, the left pointer and the right pointer) sum equals 0.\\nFor this we need to sort the array first and then iterate through the remaining.\\nFor exampe for the sorted array :\\narr = [-4,-1,-1,0,1,2]\\nFirst we are at -4 (index 0): left = 1 right =  5 \\nsum<0  - > increment left\\nstill sum is less than 0. This continues and we see that for -4 there is no solution\\nNext we continue for -1 i.e the next index and find 2 solutions and so on\\nThis takes O(n2) time and the sorting takes O(nlogn) time.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        vector<vector<int>> ans;\\n\\t\\t//We will use this set to avoid duplicates\\n        set<vector<int>>s;\\n        int n = arr.size();\\n\\t\\t//Loop through all elements one by one till the third last element\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            int val = arr[i];  // The Current element\\n\\t\\t\\tint l = i + 1;   // set left pointer\\n\\t\\t\\tint r = n - 1;   // set the right pointer\\n\\t\\t\\t//Iterate till l and r cross each other\\n            while (l < r)\\n            {\\n                int csum = val + arr[l] + arr[r]; //The current sum of all three elements\\n                if (csum == 0){\\n\\t\\t\\t\\t\\t// if sum is equal to zero add to the set\\n                    s.insert({val,arr[l++],arr[r--]}); \\n                }\\n                else if (csum < 0) {\\n\\t\\t\\t\\t// If sum is less than zero that means we need a larger number to be close to zero so we should increment left pointer as the array is sorted and so the next element will be larger\\n                    l++;\\n                }else{\\n\\t\\t\\t\\t// If sum is greater than zero that means we need a smaller number to be close to zero so we should decrement right pointer as the array is sorted and so the next element will be smaller.\\n                    r--;\\n                }\\n            }\\n        }\\n\\t\\t//Add all elements from the set to ans array\\n        for(auto x: s){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHope this helps! Happy Coding",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        vector<vector<int>> ans;\\n\\t\\t//We will use this set to avoid duplicates\\n        set<vector<int>>s;\\n        int n = arr.size();\\n\\t\\t//Loop through all elements one by one till the third last element\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            int val = arr[i];  // The Current element\\n\\t\\t\\tint l = i + 1;   // set left pointer\\n\\t\\t\\tint r = n - 1;   // set the right pointer\\n\\t\\t\\t//Iterate till l and r cross each other\\n            while (l < r)\\n            {\\n                int csum = val + arr[l] + arr[r]; //The current sum of all three elements\\n                if (csum == 0){\\n\\t\\t\\t\\t\\t// if sum is equal to zero add to the set\\n                    s.insert({val,arr[l++],arr[r--]}); \\n                }\\n                else if (csum < 0) {\\n\\t\\t\\t\\t// If sum is less than zero that means we need a larger number to be close to zero so we should increment left pointer as the array is sorted and so the next element will be larger\\n                    l++;\\n                }else{\\n\\t\\t\\t\\t// If sum is greater than zero that means we need a smaller number to be close to zero so we should decrement right pointer as the array is sorted and so the next element will be smaller.\\n                    r--;\\n                }\\n            }\\n        }\\n\\t\\t//Add all elements from the set to ans array\\n        for(auto x: s){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7482,
                "title": "fastest-python-solution-180-ms",
                "content": "\"Your runtime beats 100.00% of python submissions.\" I might never get that message again when I submit a solution so it seems worth posting about.\\n\\nFirst I made a dictionary to keep track of the number of occurrences of each input value. Observe that no more than two instances of any given nonzero value can ever be used in a sum, so additional instances can be discarded. Three zeros can be used in a sum, but if we only have two zeros to work with, we can't use them together, so if we have only two zeros we can discard one of them.\\n\\nOn a second pass through the dictionary I checked all values x that occur twice to see if -2x also occurs. If not, they can't be used together so discard one of the x's.\\n\\nThen I used the dictionary to build an ordered list of values, with duplicates to represent values that occur twice for nonzero values or three times in the case of zero. Note that the sum of the smallest two entries in the list implies ceiling on the largest useful value, while the sum of the largest two entries implies a floor on the smallest useful value. Values outside those bounds can be removed and this process was repeated until no change needed to be made on the final iteration. Example of successive iterations:\\n[-10,-9,-5,-2,0,1,1,3,6,21,52] floor = -73, ceiling = 19 (remove 21,52)\\n[-10,-9,-5,-2,0,1,1,3,6] floor = -9, ceiling = 19 (remove -10)\\n[-9,-5,-2,0,1,1,3,6] floor = -9, ceiling = 14 (done)\\n\\nFinally I looped through the list of values to find ordered (v1,v2) pairs such that v1 <= v2 and searched the dictionary for corresponding v3 = -(v1+v2). Except for (0,0,0) which I treated as a special case, the ordering requirements imply v1 < 0 so we break out of the outer loop as soon as v1 >= 0. Similarly we break out of the inner loop as soon as we find v3 < v2. Also since the list may have duplicates, we continue past any iterations in both the outer and inner loops where we just looped on the same value.\\n\\n    class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #it's pointless to have more than two instances of any number other than 0, and pointless to have more than three instances of 0. Simplification: delete extraneous instances\\n        instances = {}\\n        for n in nums:\\n            if n in instances:\\n                count = instances[n]\\n                if count == 1 or (n == 0 and count == 2):\\n                    instances[n] += 1\\n            else:\\n                instances[n] = 1\\n                \\n        #remove extraneous duplicate values. Three 0's is always useful, but two 0's isn't because no third value sums with them to 0. When count = 3 the value must be 0, so leave that alone but otherwise 0 gets no exception. For other values n, count = 2 is only useful when the value -2n is available.\\n        for n, count in instances.iteritems():\\n            if count == 2 and (n == 0 or -2 * n not in instances):\\n                instances[n] = 1\\n        \\n        #create an ordered list of values\\n        values = []\\n        for n, count in sorted(instances.iteritems()):\\n            for i in range(count):\\n                values.append(n)\\n        nvalues = len(values)\\n        while nvalues >= 4:\\n            floor = -(values[nvalues-1] + values[nvalues-2])\\n            ceiling = -(values[0] + values[1])\\n            if floor > ceiling:\\n                return []\\n            iLeft = nvalues\\n            iRight = -1\\n            for i in range(nvalues):\\n                if values[i] >= floor:\\n                    iLeft = i\\n                    break\\n            for i in range(nvalues-1, -1, -1):\\n                if values[i] <= ceiling:\\n                    iRight = i\\n                    break\\n            if iLeft == 0 and iRight == nvalues - 1:\\n                break\\n            values = values[iLeft:iRight+1]\\n            nvalues = len(values)\\n        if nvalues < 3:\\n            return []\\n            \\n        result = []\\n        #special case for (0,0,0), otherwise v1 must be negative\\n        if 0 in instances and instances[0] == 3:\\n            result.append([0,0,0])\\n        for i in range(nvalues-2):\\n            v1 = values[i]\\n            if v1 >= 0:\\n                break\\n            if i > 0 and v1 == values[i-1]:\\n                continue\\n            for j in range(i+1,nvalues-1):\\n                v2 = values[j]\\n                if j > i+1 and v2 == values[j-1]:\\n                    continue\\n                v3 = -(v1 + v2)\\n                if v3 < v2:\\n                    break\\n                if v3 in instances:\\n                    if v3 > v2 or instances[v3] > 1:\\n                        result.append([v1,v2,v3])\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #it's pointless to have more than two instances of any number other than 0, and pointless to have more than three instances of 0. Simplification: delete extraneous instances\\n        instances = {}",
                "codeTag": "Java"
            },
            {
                "id": 3469376,
                "title": "c-easy-solution-all-3-approach-sorting",
                "content": "/*question me apko ek array dia h or bola h find kro asse 3 number jinka sum 0 ho to hmne kya kia iska ek \\nbrute force -: approach ye ho skta tha ki hum ek loop ko 3 bar chla de or usme sum krke dekhle kya sum = 0 ha ye hogai n cube vali approach(N^3) jo shi nhi h to abb kya kr skte h ya to ek kam kro do loop chlao or dono ka sum krlo fir check krlo kya 3rd element hmari map me present ha kya ; ye hoga n square log n or space bhi lgega \\n\\nbest part ye kr skte h ji hmne ek sum nikal lia vo kya hoga vhi elemet hoga kyuki chlo example se smjha te h\\n\\nmnlo array dia h jo ki h array 1 =[-1,0,1,2,-1,-4] to hmne kya kia isko sort krdia to vo sort hoke aya \\n[-4,-1,-1,0,1,2] to abhi hmne kya kia apni ek sum variable lia \\nsum = 0-nums[i] first step yani ki -4 ke lai value aai 4 to abhi hmne kya kai ek low pointer lia ek high pointer lia low liaa h i+1 se or high lia h nums.size()-1\\n\\nyani ki hmne kya le lai h ek sum le lai h vo h 4 abb hme do asse number chaiye jinka sum krke 4 aae or agar mil jae to unhe ek vector me store kralo or then ek vector of vector me push krdo ans vali me \\n\\nabb jo do pointer lie ho unke sath kuch iss tarah khelna h tumhe jse agar low or high ki value apke sum ke brabar h to idrectly store krdo ji nhi h to ya to choti hogi ya to bdi hogi \\n\\nagar low or high ki value sum se choti h to apko pta h apki array already sorted h ji sirf low ko agge bdao highko mt chedo \\nagar apki value sum ki bdi h low or high ke sum se to high ko piche lao ji \\nor last me while loww ko low++ krna or \\n\\nhigh ko high-- krna mt bhulna  if condition me hi or ha ek or chiz taki hme repatedly checkna krna pde mnlo sum chaiye 4 or hmara arrah h 2 to hum kya krre h low ko bdare h to low ko asse bdana  taki vapas sum kro to vhi 2 hi na aae yani ki low ko itna agge le jao ki abb low ki value vhi nhi h \\n\\n                        while(low<high && nums[low] == nums[low+1])\\n                            low++; \\n                        while(low<high && nums[high] == nums[high-1])\\n                            high--;\\n*/\\n\\nclass Solution {\\npublic:\\n\\n\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin() , nums.end());\\n        for(int i= 0 ; i<nums.size()-2; i++){\\n             \\n            if(i == 0 || (i>0 && nums[i]!= nums[i-1])){\\n                \\n      //kyuki agar i = 0 ha to hum i-1 nhi lga skte h na boss isleye hmne kya kai hmne condition dal di ha agar i = 0 ha to sidhe chle jao nhi h to check krlo kya i or i-1 eleent same to nhi h kyuki agar vo same h to koi faida nhi h same ke lia bar bar check krne se \\n                \\n                int low = i+1;\\n                int high = nums.size()-1;\\n                int sum = 0 - nums[i];\\n                while(low < high){\\n                     \\n                    if(nums[low] + nums[high] == sum){\\n                          vector<int>x;\\n                        x.push_back(nums[i]);\\n                        x.push_back(nums[low]);\\n                        x.push_back(nums[high]);\\n                        ans.push_back(x);\\n                        \\n                        while(low<high && nums[low] == nums[low+1])\\n                            low++; \\n                        while(low<high && nums[high] == nums[high-1])\\n                            high--;\\n                            \\n                        low++; high--;\\n                    }\\n                    \\n                    else if (nums[low] + nums[high] < sum){\\n                           low++;\\n                    }\\n                    else\\n                        high--;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin() , nums.end());\\n        for(int i= 0 ; i<nums.size()-2; i++){\\n             \\n            if(i == 0 || (i>0 && nums[i]!= nums[i-1])){\\n                \\n      //kyuki agar i = 0 ha to hum i-1 nhi lga skte h na boss isleye hmne kya kai hmne condition dal di ha agar i = 0 ha to sidhe chle jao nhi h to check krlo kya i or i-1 eleent same to nhi h kyuki agar vo same h to koi faida nhi h same ke lia bar bar check krne se \\n                \\n                int low = i+1;\\n                int high = nums.size()-1;\\n                int sum = 0 - nums[i];\\n                while(low < high){\\n                     \\n                    if(nums[low] + nums[high] == sum){\\n                          vector<int>x;\\n                        x.push_back(nums[i]);\\n                        x.push_back(nums[low]);\\n                        x.push_back(nums[high]);\\n                        ans.push_back(x);\\n                        \\n                        while(low<high && nums[low] == nums[low+1])\\n                            low++; \\n                        while(low<high && nums[high] == nums[high-1])\\n                            high--;\\n                            \\n                        low++; high--;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3416585,
                "title": "c-java-python-javascript-fully-explained-two-pointer-array",
                "content": "# Intuition:\\nThe problem asks to find all unique triplets in the array that sum up to zero. One way to approach the problem is to sort the array and use two-pointer approach.\\n\\n# Approach:\\n\\n1. First, sort the input array in non-decreasing order.\\n2. Iterate through the array with a pointer \"i\" from 0 to n-2, where n is the size of the array.\\n3. For each \"i\", initialize two pointers \"lo\" and \"hi\", where \"lo\" starts at i+1 and \"hi\" starts at n-1.\\n4. Calculate the sum of elements at i, lo, and hi. If the sum is equal to zero, add the triplet to the result vector.\\n5. If the sum is less than zero, increment \"lo\" to move towards higher values. If the sum is greater than zero, decrement \"hi\" to move towards lower values.\\n6. To avoid duplicates, if a value has already been considered, skip it in the future iterations.\\n7. Continue the above process until all possible triplets are considered.\\n# Complexity:\\n- Time complexity: The time complexity of this approach is O(n^2), where n is the size of the input array. The sorting operation takes O(nlogn) time, and the nested while loop takes O(n^2) time in the worst case. Therefore, the overall time complexity is O(nlogn + n^2) = O(n^2).\\n- Space complexity: The space complexity is O(1), as we are not using any extra space except the output vector.\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& num) {\\n       vector<vector<int>> res; \\n        sort(num.begin(), num.end()); \\n      \\n        for (int i = 0; i < (int)(num.size())-2; i++) {\\n            \\n            if (i == 0 || (i > 0 && num[i] != num[i-1])) {\\n                \\n                int lo = i+1, hi = (int)(num.size())-1, sum = 0 - num[i];\\n                \\n                while (lo < hi) {\\n                    if (num[lo] + num[hi] == sum) {\\n                        \\n                        vector<int> temp; \\n                        temp.push_back(num[i]); \\n                        temp.push_back(num[lo]); \\n                        temp.push_back(num[hi]); \\n                        res.push_back(temp);\\n                        \\n                        while (lo < hi && num[lo] == num[lo+1]) lo++;\\n                        while (lo < hi && num[hi] == num[hi-1]) hi--;\\n                        \\n                        lo++; hi--;\\n                    } \\n                    else if (num[lo] + num[hi] < sum) lo++;\\n                    else hi--;\\n               }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            if (i == 0 || nums[i] != nums[i-1]) {\\n                int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\\n                while (lo < hi) {\\n                    if (nums[lo] + nums[hi] == sum) {\\n                        res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\\n                        while (lo < hi && nums[lo] == nums[lo+1]) lo++;\\n                        while (lo < hi && nums[hi] == nums[hi-1]) hi--;\\n                        lo++;\\n                        hi--;\\n                    } else if (nums[lo] + nums[hi] < sum) {\\n                        lo++;\\n                    } else {\\n                        hi--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```\\n---\\n# JavaScript\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar threeSum = function(nums) {\\n    const res = [];\\n    nums.sort((a, b) => a - b);\\n    \\n    for (let i = 0; i < nums.length - 2; i++) {\\n        if (i === 0 || nums[i] !== nums[i-1]) {\\n            let lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\\n            while (lo < hi) {\\n                if (nums[lo] + nums[hi] === sum) {\\n                    res.push([nums[i], nums[lo], nums[hi]]);\\n                    while (lo < hi && nums[lo] === nums[lo+1]) lo++;\\n                    while (lo < hi && nums[hi] === nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                } else if (nums[lo] + nums[hi] < sum) {\\n                    lo++;\\n                } else {\\n                    hi--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            if i == 0 or nums[i] != nums[i-1]:\\n                lo, hi, sum = i+1, len(nums)-1, 0-nums[i]\\n                while lo < hi:\\n                    if nums[lo] + nums[hi] == sum:\\n                        res.append([nums[i], nums[lo], nums[hi]])\\n                        while lo < hi and nums[lo] == nums[lo+1]: lo+=1\\n                        while lo < hi and nums[hi] == nums[hi-1]: hi-=1\\n                        lo+=1\\n                        hi-=1\\n                    elif nums[lo] + nums[hi] < sum:\\n                        lo+=1\\n                    else:\\n                        hi-=1\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& num) {\\n       vector<vector<int>> res; \\n        sort(num.begin(), num.end()); \\n      \\n        for (int i = 0; i < (int)(num.size())-2; i++) {\\n            \\n            if (i == 0 || (i > 0 && num[i] != num[i-1])) {\\n                \\n                int lo = i+1, hi = (int)(num.size())-1, sum = 0 - num[i];\\n                \\n                while (lo < hi) {\\n                    if (num[lo] + num[hi] == sum) {\\n                        \\n                        vector<int> temp; \\n                        temp.push_back(num[i]); \\n                        temp.push_back(num[lo]); \\n                        temp.push_back(num[hi]); \\n                        res.push_back(temp);\\n                        \\n                        while (lo < hi && num[lo] == num[lo+1]) lo++;\\n                        while (lo < hi && num[hi] == num[hi-1]) hi--;\\n                        \\n                        lo++; hi--;\\n                    } \\n                    else if (num[lo] + num[hi] < sum) lo++;\\n                    else hi--;\\n               }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            if (i == 0 || nums[i] != nums[i-1]) {\\n                int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\\n                while (lo < hi) {\\n                    if (nums[lo] + nums[hi] == sum) {\\n                        res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\\n                        while (lo < hi && nums[lo] == nums[lo+1]) lo++;\\n                        while (lo < hi && nums[hi] == nums[hi-1]) hi--;\\n                        lo++;\\n                        hi--;\\n                    } else if (nums[lo] + nums[hi] < sum) {\\n                        lo++;\\n                    } else {\\n                        hi--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar threeSum = function(nums) {\\n    const res = [];\\n    nums.sort((a, b) => a - b);\\n    \\n    for (let i = 0; i < nums.length - 2; i++) {\\n        if (i === 0 || nums[i] !== nums[i-1]) {\\n            let lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\\n            while (lo < hi) {\\n                if (nums[lo] + nums[hi] === sum) {\\n                    res.push([nums[i], nums[lo], nums[hi]]);\\n                    while (lo < hi && nums[lo] === nums[lo+1]) lo++;\\n                    while (lo < hi && nums[hi] === nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                } else if (nums[lo] + nums[hi] < sum) {\\n                    lo++;\\n                } else {\\n                    hi--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\n```\n```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            if i == 0 or nums[i] != nums[i-1]:\\n                lo, hi, sum = i+1, len(nums)-1, 0-nums[i]\\n                while lo < hi:\\n                    if nums[lo] + nums[hi] == sum:\\n                        res.append([nums[i], nums[lo], nums[hi]])\\n                        while lo < hi and nums[lo] == nums[lo+1]: lo+=1\\n                        while lo < hi and nums[hi] == nums[hi-1]: hi-=1\\n                        lo+=1\\n                        hi-=1\\n                    elif nums[lo] + nums[hi] < sum:\\n                        lo+=1\\n                    else:\\n                        hi-=1\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566118,
                "title": "c-easy",
                "content": "vector<vector<int>> threeSum(vector<int>& nums) {\\n   \\n        vector<vector<int>> res;\\n\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < nums.size();i++) {\\n\\n            if((i > 0) && nums[i]==nums[i-1])\\n                continue;\\n            \\n            int l = i + 1; \\n            int r = nums.size() - 1; \\n            \\n            while (l < r) {\\n                \\n                int sum = nums[i] + nums[l] + nums[r];\\n                \\n                if(sum < 0)\\n                l++;\\n                else\\n                if(sum > 0)\\n                    r--;\\n                else\\n                if(sum == 0) {\\n                    res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                \\n                    while (l<r && nums[l] == nums[l+1]) \\n                        l++;\\n\\n                    while (l<r && nums[r] == nums[r-1]) \\n                        r--;\\n                    l++;\\n                    r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\npls upvote if u find it helpful, nhi to koi na",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<vector<int>> threeSum(vector<int>& nums) {\\n   \\n        vector<vector<int>> res;\\n\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < nums.size();i++) {\\n\\n            if((i > 0) && nums[i]==nums[i-1])\\n                continue;\\n            \\n            int l = i + 1; \\n            int r = nums.size() - 1; \\n            \\n            while (l < r) {\\n                \\n                int sum = nums[i] + nums[l] + nums[r];\\n                \\n                if(sum < 0)\\n                l++;\\n                else\\n                if(sum > 0)\\n                    r--;\\n                else\\n                if(sum == 0) {\\n                    res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                \\n                    while (l<r && nums[l] == nums[l+1]) \\n                        l++;\\n\\n                    while (l<r && nums[r] == nums[r-1]) \\n                        r--;\\n                    l++;\\n                    r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\npls upvote if u find it helpful, nhi to koi na",
                "codeTag": "Unknown"
            },
            {
                "id": 1203373,
                "title": "c-solution-with-comment",
                "content": "C# solution with comment.\\n\\nBasic idea is that after given array is sorted, start from end of array and calculate the number needed to satisfy a+b+c==0.\\nGiven we get a number a from array then b+c = 0-a, then we search rest of array, we get a number b, we get c = 0-a-b, then just binary search rest of array for c, if exists, we get triplet.\\n\\nTo make sure triplet do not duplicate in result, just keep track a and b make sure it is not the same as previous (because array is sorted, same element is always next to each other).\\n\\n```\\npublic IList<IList<int>> ThreeSum(int[] nums) {\\n            //this is where final result will live.\\n            var reslist = new List<IList<int>>();\\n            //sort the array so search is quicker\\n            Array.Sort(nums);\\n            var pre = 0; //keep track previous number\\n            //start from end of array\\n            for(var i = nums.Length-1; i>1; i--)\\n            {\\n                //if not at the start of loop and previous number equals to current number\\n                //no need to continue, the triplet (if there is one) will be the same\\n                if(i != nums.Length-1 && nums[i] == pre){\\n                    continue;\\n                }\\n                //calculate how many we still need to compose the triplet\\n                var remain = 0 - nums[i];\\n                //update the previous number\\n                pre = nums[i];\\n                //the previous tracking for inner loop\\n                var prev = 0;\\n                for(var j = i-1; j>0; j--){\\n                    //same as outer loop, if number is same\\n                    //would yield same triplet, skip it.\\n                    if(j != i-1 && nums[j] == prev){\\n                        continue;\\n                    }\\n                    //calculate the last number needed\\n                    var last = remain - nums[j];\\n                    //update the previous\\n                    prev = nums[j];\\n                    //binary search the last number\\n                    var exist = Array.BinarySearch<int>(nums, 0, j, last);\\n                    //if found add the triplet\\n                    if(exist >= 0)\\n                    {\\n                        reslist.Add(new List<int>(){nums[i], nums[j], last});\\n                    }\\n                }\\n            }\\n            return reslist;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<IList<int>> ThreeSum(int[] nums) {\\n            //this is where final result will live.\\n            var reslist = new List<IList<int>>();\\n            //sort the array so search is quicker\\n            Array.Sort(nums);\\n            var pre = 0; //keep track previous number\\n            //start from end of array\\n            for(var i = nums.Length-1; i>1; i--)\\n            {\\n                //if not at the start of loop and previous number equals to current number\\n                //no need to continue, the triplet (if there is one) will be the same\\n                if(i != nums.Length-1 && nums[i] == pre){\\n                    continue;\\n                }\\n                //calculate how many we still need to compose the triplet\\n                var remain = 0 - nums[i];\\n                //update the previous number\\n                pre = nums[i];\\n                //the previous tracking for inner loop\\n                var prev = 0;\\n                for(var j = i-1; j>0; j--){\\n                    //same as outer loop, if number is same\\n                    //would yield same triplet, skip it.\\n                    if(j != i-1 && nums[j] == prev){\\n                        continue;\\n                    }\\n                    //calculate the last number needed\\n                    var last = remain - nums[j];\\n                    //update the previous\\n                    prev = nums[j];\\n                    //binary search the last number\\n                    var exist = Array.BinarySearch<int>(nums, 0, j, last);\\n                    //if found add the triplet\\n                    if(exist >= 0)\\n                    {\\n                        reslist.Add(new List<int>(){nums[i], nums[j], last});\\n                    }\\n                }\\n            }\\n            return reslist;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227156,
                "title": "java-o-n-2-using-map",
                "content": "I know the most voted solutions sort the array and use O(1) space. But here is the code using a hashmap (similar to 2sum). When you\\'re stumped on interviews it\\'s always better to get some kind of working solution, so this would be a good start. Which you could then optimize later. \\n\\nThe idea is that a + b = -c. So, store map from -A[i] -> i. Then try all unique pairs i, j such that a + b = -c, and make sure to check that they are 3 different elements in the array. \\n\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> result = new HashSet<>();\\n        Map<Integer, Integer> lookup = new HashMap<>(nums.length);\\n        for (int i = 0; i < nums.length; i++) {\\n            lookup.put(-nums[i], i);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int key = nums[i] + nums[j];\\n                if (lookup.containsKey(key)) {\\n                    int k = lookup.get(key);\\n                    if (k != i && k != j) {\\n                        List<Integer> tuple = Arrays.asList(nums[i], nums[j], nums[k]);\\n                        Collections.sort(tuple);\\n                        result.add(tuple);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList(result);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> result = new HashSet<>();\\n        Map<Integer, Integer> lookup = new HashMap<>(nums.length);\\n        for (int i = 0; i < nums.length; i++) {\\n            lookup.put(-nums[i], i);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int key = nums[i] + nums[j];\\n                if (lookup.containsKey(key)) {\\n                    int k = lookup.get(key);\\n                    if (k != i && k != j) {\\n                        List<Integer> tuple = Arrays.asList(nums[i], nums[j], nums[k]);\\n                        Collections.sort(tuple);\\n                        result.add(tuple);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7739,
                "title": "my-accepted-o-n-2-solution-without-hashmap",
                "content": "    public class Solution {\\n        \\n        int a, b, c;\\n        List<List<Integer>> result = new ArrayList();\\n    \\n        public List<List<Integer>> threeSum(int[] num) {\\n            Arrays.sort(num);\\n            \\n            for (int i = 0 ; i <= num.length - 3; i++) {\\n                a = num[i];\\n                for (int j = i+1, k = num.length - 1; j < k;) {\\n                    b = num[j];\\n                    c = num[k];\\n                    if (b + c == -1*a) {\\n                        List list = new ArrayList<Integer>();\\n                        list.add(a);\\n                        list.add(b);\\n                        list.add(c);\\n                        result.add(list);\\n                        j++;\\n                        k--;\\n                    } else if (b + c < -1*a) {\\n                        j++;\\n                    } else {\\n                        k--;\\n                    }\\n                }\\n            }\\n            \\n            // remove duplicated items.\\n            for (int i = result.size() - 1; i >= 1; i--) {\\n                for (int j = i-1; j >= 0; j--) {\\n                    if (result.get(i).get(0) == result.get(j).get(0)\\n                        && result.get(i).get(1) == result.get(j).get(1)\\n                        && result.get(i).get(2) == result.get(j).get(2)) {\\n                        result.remove(j);\\n                        i--;\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        int a, b, c;\\n        List<List<Integer>> result = new ArrayList();\\n    \\n        public List<List<Integer>> threeSum(int[] num) {\\n            Arrays.sort(num);\\n            \\n            for (int i = 0 ; i <= num.length - 3; i++) {\\n                a = num[i];\\n                for (int j = i+1, k = num.length - 1; j < k;) {\\n                    b = num[j];\\n                    c = num[k];\\n                    if (b + c == -1*a) {\\n                        List list = new ArrayList<Integer>();\\n                        list.add(a);\\n                        list.add(b);\\n                        list.add(c);\\n                        result.add(list);\\n                        j++;\\n                        k--;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1648441,
                "title": "javascript-solution-with-explanation-o-n-n-time-complexity",
                "content": "We will use 2 pointers to solve this problem. \\nWe will sort the array first (you will understand the reason ahead). Then traverse the array, keeping one element fixed and finding out other two possible numbers using left and right pointers.\\n\\nfor example\\nnums = [12, 3, 1, 2, -6, 5, -8, 6];\\n1. Sort array\\n    nums = [-8, -6, 1, 2, 3, 5, 6, 12]\\n2. Start traversing the array. -8 will be fixed. left pointer will be on the -6 and right pointer will be on 12.\\n   ```\\n         left                                  right\\n   -8,    -6 ,    1,    2,    3,    5,    6,    12\\n   fixed\\n   ```\\n   -8+ (-6) + 12 = -2 which is not equal to zero. The sum is less than zero, so one of the number should be increased. As the array is sorted, elements on right side of left pointer are greater, so we will move left pointer to right. Here there is no point moving right pointer to left becase the number will be smaller and the sum will decrease.\\n      ```\\n                    left                           right\\n   -8,    -6 ,    1,    2,    3,    5,    6,    12\\n   fixed\\n   ```\\n   -8 + 1 + 12 = 5. Sum is greater than 0. We need to decrease the number. Move right pointer to right\\n    ```\\n\\t              left                   right\\n   -8,    -6 ,    1,    2,    3,    5,    6,    12\\n   fixed\\n\\t```\\n\\t\\n\\tThis way we can find the pairs for -8 number. In the next iteration, -6 will be fixed, left pointer will be on 1, right on 12. We can follow the same procedure.\\n\\t\\n\\tWhen we get pair (when sum is zero) we can shift both pointers, as shifting one pointer will not find another pair. Shifting one pointer will give sum which will be greater of smaller than zero.\\n   \\n\\n```\\nvar threeSum = function(nums) {\\n    if(nums.length<3) return [];\\n\\t\\n\\tlet result = [];\\n\\tlet sum=0;\\n\\t\\n\\t//sort array\\n\\tnums.sort((a,b)=>(a-b))\\n\\n    for(let i=0; i< nums.length-2; i++){\\n        if(i>0 && nums[i]==nums[i-1]) continue;\\n\\t\\tlet left = i+1;\\n\\t\\tlet right = nums.length-1;\\n\\t\\twhile(left<right){\\n\\t\\t\\tsum = nums[i] + nums[left] + nums[right];\\n\\t\\t\\tif(sum===0){\\n\\t\\t\\t\\tlet tempArr = [];\\n\\t\\t\\t\\ttempArr.push(nums[i]);\\n\\t\\t\\t\\ttempArr.push(nums[left]);\\n\\t\\t\\t\\ttempArr.push(nums[right]);\\n\\t\\t\\t\\tresult.push(tempArr);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t// To avoid duplicates\\n\\t\\t\\t\\t//check the next item for left pointer, if it same then increase left pointer until we get different item\\n                while(nums[left]==nums[left-1] && left<right) {\\n                    left++;\\n                }\\n\\t\\t\\t\\t// above left pointer logic applied here for right pointer\\n                while(nums[right]==nums[right+1] && left<right) {\\n                    right--;\\n                }\\n\\t\\t\\t} else if(sum>0){\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t} else{\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n         left                                  right\\n   -8,    -6 ,    1,    2,    3,    5,    6,    12\\n   fixed\\n   ```\n```\\n                    left                           right\\n   -8,    -6 ,    1,    2,    3,    5,    6,    12\\n   fixed\\n   ```\n```\\n\\t              left                   right\\n   -8,    -6 ,    1,    2,    3,    5,    6,    12\\n   fixed\\n\\t```\n```\\nvar threeSum = function(nums) {\\n    if(nums.length<3) return [];\\n\\t\\n\\tlet result = [];\\n\\tlet sum=0;\\n\\t\\n\\t//sort array\\n\\tnums.sort((a,b)=>(a-b))\\n\\n    for(let i=0; i< nums.length-2; i++){\\n        if(i>0 && nums[i]==nums[i-1]) continue;\\n\\t\\tlet left = i+1;\\n\\t\\tlet right = nums.length-1;\\n\\t\\twhile(left<right){\\n\\t\\t\\tsum = nums[i] + nums[left] + nums[right];\\n\\t\\t\\tif(sum===0){\\n\\t\\t\\t\\tlet tempArr = [];\\n\\t\\t\\t\\ttempArr.push(nums[i]);\\n\\t\\t\\t\\ttempArr.push(nums[left]);\\n\\t\\t\\t\\ttempArr.push(nums[right]);\\n\\t\\t\\t\\tresult.push(tempArr);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t// To avoid duplicates\\n\\t\\t\\t\\t//check the next item for left pointer, if it same then increase left pointer until we get different item\\n                while(nums[left]==nums[left-1] && left<right) {\\n                    left++;\\n                }\\n\\t\\t\\t\\t// above left pointer logic applied here for right pointer\\n                while(nums[right]==nums[right+1] && left<right) {\\n                    right--;\\n                }\\n\\t\\t\\t} else if(sum>0){\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t} else{\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339438,
                "title": "c-shortest-and-simplest-o-n-2-solution-using-hashmap-10-short-lines",
                "content": "Similar approach to my 2Sum solution\\nhttps://leetcode.com/problems/3sum-with-multiplicity/discuss/1123612/C%2B%2B-Super-Simple-7-line-Solution-Without-Sorting\\nWe loop with two pointers - i and j - and check if their complementary - `-(nums[i] + (nums[j])` - is in the map, which means it appears in nums.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        vector<vector<int>> res;\\n       \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < nums.size(); i++) \\n            m[nums[i]] = i;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > 0 && nums[i] == nums[i-1]) continue;\\n            \\n            for (int j = i+1; j < nums.size(); j++) {\\n                if (j != i+1 && nums[j] == nums[j-1]) continue;\\n                \\n                if (m[-(nums[i] + nums[j])] > j) \\n                    res.push_back({nums[i], nums[j], -(nums[i] + nums[j])});\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        vector<vector<int>> res;\\n       \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < nums.size(); i++) \\n            m[nums[i]] = i;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > 0 && nums[i] == nums[i-1]) continue;\\n            \\n            for (int j = i+1; j < nums.size(); j++) {\\n                if (j != i+1 && nums[j] == nums[j-1]) continue;\\n                \\n                if (m[-(nums[i] + nums[j])] > j) \\n                    res.push_back({nums[i], nums[j], -(nums[i] + nums[j])});\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330293,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==0)\\n                {\\n                    ans.push_back({nums[i],nums[j],nums[k]});\\n                    int val=nums[j];\\n                    while(j<n && val==nums[j])\\n                    {\\n                        j++;\\n                    }\\n                    val=nums[k];\\n                    while(k>=0 && val==nums[k])\\n                    {\\n                        k--;\\n                    }\\n                }\\n                else if(sum>0)\\n                {\\n                    k--;\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Time complexity :- O(n^2)**\\n**space complexity :- O(1)**\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==0)\\n                {\\n                    ans.push_back({nums[i],nums[j],nums[k]});\\n                    int val=nums[j];\\n                    while(j<n && val==nums[j])\\n                    {\\n                        j++;\\n                    }\\n                    val=nums[k];\\n                    while(k>=0 && val==nums[k])\\n                    {\\n                        k--;\\n                    }\\n                }\\n                else if(sum>0)\\n                {\\n                    k--;\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322117,
                "title": "easy-c-solution-clean-concise-commented-98-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //sort the array\\n        \\n        //if a+b+c =0 \\n        //then b+c = -a\\n        //so break down the problem to two sum by considering every element as a \\n        //and findout the two pairs which has sum -a\\n        \\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) //we cant\\'t find any more triplets\\n                return res;\\n            if(i>0 && nums[i]==nums[i-1]) //to avoid duplicate triplets\\n                continue;\\n            int sumToFind=-(nums[i]);\\n            findPairs(sumToFind,nums,i+1,nums.size()-1,res);\\n        }\\n        return res;\\n    }\\n    \\n    //find pairs which sum upto the given value\\n    void findPairs(int sumToFind,vector<int>& nums,int start,int end,vector<vector<int>>& res)\\n    {\\n        int sum=0;\\n        while(start<end)\\n        {\\n            sum=nums[start]+nums[end];\\n            if(sum==sumToFind)\\n            {\\n                //add the pair to the result\\n                res.push_back({-sumToFind,nums[start],nums[end]});\\n                //now move the start and end until they found a differnet value\\n                //since we should avoid duplicates\\n                start++;\\n                while(start<nums.size() &&  nums[start]==nums[start-1])\\n                {\\n                    start++;\\n                }\\n                end--;\\n                while(end>= start && nums[end]==nums[end+1])\\n                    end--;\\n            }\\n            else if(sum>sumToFind){\\n                //decrese the value\\n                end--;\\n            }\\n            else{\\n                //increase the value\\n                start++;\\n            }\\n        }\\n    }\\n};\\n```\\n**Upvote if this helps you:)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //sort the array\\n        \\n        //if a+b+c =0 \\n        //then b+c = -a\\n        //so break down the problem to two sum by considering every element as a \\n        //and findout the two pairs which has sum -a\\n        \\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) //we cant\\'t find any more triplets\\n                return res;\\n            if(i>0 && nums[i]==nums[i-1]) //to avoid duplicate triplets\\n                continue;\\n            int sumToFind=-(nums[i]);\\n            findPairs(sumToFind,nums,i+1,nums.size()-1,res);\\n        }\\n        return res;\\n    }\\n    \\n    //find pairs which sum upto the given value\\n    void findPairs(int sumToFind,vector<int>& nums,int start,int end,vector<vector<int>>& res)\\n    {\\n        int sum=0;\\n        while(start<end)\\n        {\\n            sum=nums[start]+nums[end];\\n            if(sum==sumToFind)\\n            {\\n                //add the pair to the result\\n                res.push_back({-sumToFind,nums[start],nums[end]});\\n                //now move the start and end until they found a differnet value\\n                //since we should avoid duplicates\\n                start++;\\n                while(start<nums.size() &&  nums[start]==nums[start-1])\\n                {\\n                    start++;\\n                }\\n                end--;\\n                while(end>= start && nums[end]==nums[end+1])\\n                    end--;\\n            }\\n            else if(sum>sumToFind){\\n                //decrese the value\\n                end--;\\n            }\\n            else{\\n                //increase the value\\n                start++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304382,
                "title": "javascript-15-3sum",
                "content": "====\\n\\n1. Two Sum\\nhttps://leetcode.com/problems/two-sum/solutions/3303105/javascript-1-two-sum/\\n167. Two Sum II - Input Array Is Sorted\\nhttps://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solutions/3303938/javascript-167-two-sum-ii-input-array-is-sorted/\\n15. 3Sum\\n(( See below ))\\n923. 3Sum With Multiplicity\\nhttps://leetcode.com/problems/3sum-with-multiplicity/solutions/3306878/javascript-923-3sum-with-multiplicity/\\n18. 4Sum\\nhttps://leetcode.com/problems/4sum/solutions/3305939/javascript-18-4sum/\\n\\n====\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1 binary search - with visited Set\\n2 binary search - with out visited Set - optimization\\n3 two pointer - with visited Set\\n4 two pointer - with out visited Set - optimization\\n5 All optimizations - two pointer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nfunction binary_search(arr, target, L = 0, R = arr.length - 1) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L === R && arr[L] === target ? L : -Infinity;\\n}\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    let vis = new Set();\\n    for (let i = 0; i < n; i++)\\n        for (let j = i + 1; j < n; j++) {\\n            let sum = a[i] + a[j];\\n            let L = binary_search(a, -sum, j + 1, n - 1);\\n            if (L !== -Infinity) {\\n                let key = `${a[i]} ${a[j]} ${a[L]}`;\\n                if (!vis.has(key)) {\\n                    vis.add(key);\\n                    aa.push([a[i], a[j], a[L]]);\\n                }\\n            }\\n        }\\n    return aa;\\n};\\n```\\n\\n2\\n```\\nfunction binary_search(arr, target, L = 0, R = arr.length - 1) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L === R && arr[L] === target ? L : -Infinity;\\n}\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    for (let i = 0; i < n; i++) {\\n        if (i > 0 && a[i - 1] === a[i]) continue;\\n\\n        for (let L = i + 1; L < n; L++) {\\n            if (L > i + 1 && a[L - 1] === a[L]) continue;\\n\\n            let R = binary_search(a, -(a[i] + a[L]), L + 1, n - 1);\\n            if (R !== -Infinity) {\\n                aa.push([a[i], a[L], a[R]]);\\n            }\\n        }\\n    }\\n    return aa;\\n};\\n```\\n\\n3\\n```\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    let vis = new Set();\\n    for (let i = 0; i < n; i++) {\\n        let t = -a[i]; // target;\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            let sum = a[L] + a[R];\\n            if (sum === t) {\\n                let key = `${a[i]} ${a[L]} ${a[R]}`;\\n                if (!vis.has(key)) {\\n                    vis.add(key);\\n                    aa.push([a[i], a[L], a[R]]);\\n                }\\n                L++;\\n            } else if (sum < t) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n    }\\n    return aa;\\n};\\n```\\n\\n4\\n```\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    for (let i = 0; i < n; i++) {\\n        if (i > 0 && a[i - 1] === a[i]) continue;\\n\\n        let t = -a[i]; // target;\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            if (L > i + 1 && a[L - 1] === a[L]) {\\n                L++;\\n                continue;\\n            }\\n\\n            let sum = a[L] + a[R];\\n            if (sum === t) {\\n                aa.push([a[i], a[L], a[R]]);\\n                L++;\\n            } else if (sum < t) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n    }\\n    return aa;\\n};\\n```\\n\\n5\\n```\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    for (let i = 0; i < n; i++) {\\n        // optimization 1\\n        if (a[i] > 0) break;\\n\\n        let t = -a[i]; // target;\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            let sum = a[L] + a[R];\\n            if (sum === t) {\\n                aa.push([a[i], a[L], a[R]]);\\n                // optimization 2\\n                while (a[L] === a[L + 1]) L++;\\n                L++;\\n            } else if (sum < t) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n\\n        // optimization 3\\n        while (a[i] === a[i + 1]) i++;\\n    }\\n\\n    return aa;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/f5a9d8a2-9aa0-4aad-bc23-b1e6a0c17298_1678984222.1663156.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction binary_search(arr, target, L = 0, R = arr.length - 1) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L === R && arr[L] === target ? L : -Infinity;\\n}\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    let vis = new Set();\\n    for (let i = 0; i < n; i++)\\n        for (let j = i + 1; j < n; j++) {\\n            let sum = a[i] + a[j];\\n            let L = binary_search(a, -sum, j + 1, n - 1);\\n            if (L !== -Infinity) {\\n                let key = `${a[i]} ${a[j]} ${a[L]}`;\\n                if (!vis.has(key)) {\\n                    vis.add(key);\\n                    aa.push([a[i], a[j], a[L]]);\\n                }\\n            }\\n        }\\n    return aa;\\n};\\n```\n```\\nfunction binary_search(arr, target, L = 0, R = arr.length - 1) {\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L === R && arr[L] === target ? L : -Infinity;\\n}\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    for (let i = 0; i < n; i++) {\\n        if (i > 0 && a[i - 1] === a[i]) continue;\\n\\n        for (let L = i + 1; L < n; L++) {\\n            if (L > i + 1 && a[L - 1] === a[L]) continue;\\n\\n            let R = binary_search(a, -(a[i] + a[L]), L + 1, n - 1);\\n            if (R !== -Infinity) {\\n                aa.push([a[i], a[L], a[R]]);\\n            }\\n        }\\n    }\\n    return aa;\\n};\\n```\n```\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    let vis = new Set();\\n    for (let i = 0; i < n; i++) {\\n        let t = -a[i]; // target;\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            let sum = a[L] + a[R];\\n            if (sum === t) {\\n                let key = `${a[i]} ${a[L]} ${a[R]}`;\\n                if (!vis.has(key)) {\\n                    vis.add(key);\\n                    aa.push([a[i], a[L], a[R]]);\\n                }\\n                L++;\\n            } else if (sum < t) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n    }\\n    return aa;\\n};\\n```\n```\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    for (let i = 0; i < n; i++) {\\n        if (i > 0 && a[i - 1] === a[i]) continue;\\n\\n        let t = -a[i]; // target;\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            if (L > i + 1 && a[L - 1] === a[L]) {\\n                L++;\\n                continue;\\n            }\\n\\n            let sum = a[L] + a[R];\\n            if (sum === t) {\\n                aa.push([a[i], a[L], a[R]]);\\n                L++;\\n            } else if (sum < t) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n    }\\n    return aa;\\n};\\n```\n```\\nvar threeSum = function (a) {\\n    let n = a.length;\\n\\n    a.sort((a, b) => a - b);\\n\\n    let aa = [];\\n    for (let i = 0; i < n; i++) {\\n        // optimization 1\\n        if (a[i] > 0) break;\\n\\n        let t = -a[i]; // target;\\n        for (let L = i + 1, R = n - 1; L < R; ) {\\n            let sum = a[L] + a[R];\\n            if (sum === t) {\\n                aa.push([a[i], a[L], a[R]]);\\n                // optimization 2\\n                while (a[L] === a[L + 1]) L++;\\n                L++;\\n            } else if (sum < t) {\\n                L++;\\n            } else {\\n                R--;\\n            }\\n        }\\n\\n        // optimization 3\\n        while (a[i] === a[i + 1]) i++;\\n    }\\n\\n    return aa;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957079,
                "title": "c-naive-tle-two-pointer-a-c-explained-faster-than-92",
                "content": "# Approach: Brute Force (TLE)\\nFirst of all we will try by the naive approach,\\n1. Create a set of vector triplet to make sure all three triplets are unique.\\n2. Run 3 loops of `i, j, k` to iterate over the array.\\n3. The triplet is valid if the values add upto 0.\\n4. Insert the valid triplet in the set.\\n5. After iterating over the array, iterate over the set to push the triplets in the `ans` vector.\\n\\nThis approach results in **TLE**.\\n\\n# Complexity\\n- Time complexity: $$O(n^3 log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n# Code\\n\\n```cpp\\nclass Solution\\n{\\n    bool _(int a, int b, int c)\\n    {\\n        return a + b + c == 0;\\n    }\\n    public:\\n        vector<vector < int>> threeSum(vector<int> &nums)\\n        {\\n            vector<vector < int>> ans;\\n            set<vector < int>> S;\\n            int n = nums.size();\\n\\n            for (int i = 0; i < n; ++i)\\n            {\\n                for (int j = i + 1; j < n; ++j)\\n                {\\n                    for (int k = j + 1; k < n; ++k)\\n                    {\\n                        if (_(nums[i], nums[j], nums[k]))\\n                        {\\n                            vector<int> v(3);\\n                            v[0] = nums[i];\\n                            v[1] = nums[j];\\n                            v[2] = nums[k];\\n                            sort(v.begin(), v.end());\\n                            S.insert(v);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            for (auto v: S) ans.push_back(v);\\n\\n            return ans;\\n        }\\n};\\n```\\n# Approach: Two Pointer (A/C)\\n1. Sort the array `nums`\\n2. Run a loop of `i` to iterate over the array.\\n3. Use `nums[i]` as the pivot element.\\n4. Now create two pointers `low` and `high`, where `low` is positioned at `i+1` and `high` at the end of the array i.e.) `n-1`.\\n5. If the triplet (`nums[i]`, `nums[low]`, `nums[high]`) sums upto 0, sort the triplet and push it in `ans` vector.\\n6. To make sure no duplicate triplet is pushed in the answer vetor, decrease `high` and increase `low` until you have reached another distinct element.\\n7. If the triplet sums to greater than 0, decrease the `high` pointer.\\n8. If the triplet sums to less than 0, increase the `low` pointer.\\n9. To maintain distinct pivot elements, increase `i` till it reaches the next distinct element.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution\\n{\\n    int _(int a, int b, int c)\\n    {\\n        return a + b + c == 0 ? 0 : a + b + c > 0 ? 1 : -1;\\n    }\\n    public:\\n        vector<vector<int>> threeSum(vector<int> &nums)\\n        {\\n            vector<vector<int>> ans;\\n            int n = nums.size();\\n            sort(nums.begin(), nums.end());\\n\\n            for (int i = 0; i < n - 2; ++i)\\n            {\\n                int low = i + 1, high = n - 1;\\n                while (low < high)\\n                {\\n                    int a = nums[i], b = nums[low], c = nums[high];\\n                    if (_(a, b, c) == 0)\\n                    {\\n                        vector<int> v(3);\\n                        v[0] = a, v[1] = b, v[2] = c;\\n                        sort(v.begin(), v.end());\\n                        ans.push_back(v);\\n                        while (high > low && nums[high] == nums[high - 1]) --high;\\n                        while (low < high && nums[low] == nums[low + 1]) ++low;\\n                        --high, ++low;\\n                    }\\n                    else if (_(a, b, c) == 1)\\n                        --high;\\n                    else\\n                        ++low;\\n                }\\n                while (i < n - 1 && nums[i] == nums[i + 1]) ++i;\\n            }\\n\\n            return ans;\\n        }\\n};\\n```\\nPlease upvote if helped \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sort",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution\\n{\\n    bool _(int a, int b, int c)\\n    {\\n        return a + b + c == 0;\\n    }\\n    public:\\n        vector<vector < int>> threeSum(vector<int> &nums)\\n        {\\n            vector<vector < int>> ans;\\n            set<vector < int>> S;\\n            int n = nums.size();\\n\\n            for (int i = 0; i < n; ++i)\\n            {\\n                for (int j = i + 1; j < n; ++j)\\n                {\\n                    for (int k = j + 1; k < n; ++k)\\n                    {\\n                        if (_(nums[i], nums[j], nums[k]))\\n                        {\\n                            vector<int> v(3);\\n                            v[0] = nums[i];\\n                            v[1] = nums[j];\\n                            v[2] = nums[k];\\n                            sort(v.begin(), v.end());\\n                            S.insert(v);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            for (auto v: S) ans.push_back(v);\\n\\n            return ans;\\n        }\\n};\\n```\n```\\nclass Solution\\n{\\n    int _(int a, int b, int c)\\n    {\\n        return a + b + c == 0 ? 0 : a + b + c > 0 ? 1 : -1;\\n    }\\n    public:\\n        vector<vector<int>> threeSum(vector<int> &nums)\\n        {\\n            vector<vector<int>> ans;\\n            int n = nums.size();\\n            sort(nums.begin(), nums.end());\\n\\n            for (int i = 0; i < n - 2; ++i)\\n            {\\n                int low = i + 1, high = n - 1;\\n                while (low < high)\\n                {\\n                    int a = nums[i], b = nums[low], c = nums[high];\\n                    if (_(a, b, c) == 0)\\n                    {\\n                        vector<int> v(3);\\n                        v[0] = a, v[1] = b, v[2] = c;\\n                        sort(v.begin(), v.end());\\n                        ans.push_back(v);\\n                        while (high > low && nums[high] == nums[high - 1]) --high;\\n                        while (low < high && nums[low] == nums[low + 1]) ++low;\\n                        --high, ++low;\\n                    }\\n                    else if (_(a, b, c) == 1)\\n                        --high;\\n                    else\\n                        ++low;\\n                }\\n                while (i < n - 1 && nums[i] == nums[i + 1]) ++i;\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553854,
                "title": "3sum-java-13ms-faster-than-86-of-java-online-submissions",
                "content": "```\\npublic static List<List<Integer>> threeSum(int[] nums){\\n        List<List<Integer>> finallist = new ArrayList<>();\\n\\t\\tSet<List> set = new HashSet <>();\\n        if(nums.length == 0)\\n            return new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            int j=i+1;\\n            int k=nums.length-1;\\n            while(j<k)\\n            {\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==0)\\n                    set.add(Arrays.asList(nums[i],nums[j++],nums[k--]));\\n                else if(sum<0)\\n                    j++;\\n                else if(sum>0)\\n                    k--;\\n            }\\n        }\\n        for(List<Integer> a: set)\\n            finallist.add(a);\\n        return finallist;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic static List<List<Integer>> threeSum(int[] nums){\\n        List<List<Integer>> finallist = new ArrayList<>();\\n\\t\\tSet<List> set = new HashSet <>();\\n        if(nums.length == 0)\\n            return new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            int j=i+1;\\n            int k=nums.length-1;\\n            while(j<k)\\n            {\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==0)\\n                    set.add(Arrays.asList(nums[i],nums[j++],nums[k--]));\\n                else if(sum<0)\\n                    j++;\\n                else if(sum>0)\\n                    k--;\\n            }\\n        }\\n        for(List<Integer> a: set)\\n            finallist.add(a);\\n        return finallist;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762084,
                "title": "2-pointer-s-approach-o-n-2-time-o-1-space-with-comments-c",
                "content": "Implementation\\n\\n**Using 1 for loop & 2 pointer\\'s approach\\nTime Complexity = O(N^2)\\nSpace Complexity = O(1), not assuming vector of vector for result, bcz that\\'s a part of output**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        // store the result\\n        vector<vector<int>> res;\\n        \\n        // if size of nums is less than 3, it means we can\\'t create the triplets\\n        if(nums.size() < 3) return res;\\n        \\n        // sort the nums\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int itr = 0; itr < nums.size()-2; itr++){            \\n            \\n            // skip all continous same element, doing bcz to avoid duplicate triplets\\n            if(itr == 0 || nums[itr-1] != nums[itr]){\\n                \\n                // two pointer\\'s approach\\n                // a + b + c = 0, so we can make the equation like\\n                // b + c = -a;\\n                // low + high = -sum;\\n                int low = itr+1, high = nums.size()-1, sum = -nums[itr];\\n                \\n                while(low < high){\\n                    if(nums[low] + nums[high] == sum){\\n                        \\n                        // add triplet into the result\\n                        res.push_back({nums[itr], nums[low], nums[high]});\\n                        \\n                        // skip all continous same element, doing bcz to avoid duplicate triplets\\n                        while(low < high && nums[low] == nums[low+1]) low++;\\n                        \\n                        // skip all continous same element, doing bcz to avoid duplicate triplets\\n                        while(low < high && nums[high] == nums[high-1]) high--;\\n                                                \\n                        low++;\\n                        high--;\\n                    }\\n                    \\n                    // if our total is less than the sum, then we need to move right, bcz greater elements are on the right side\\n                    else if(nums[low] + nums[high] < sum){\\n                        low++;\\n                    }\\n                    \\n                    // if our total is greater than the sum, then we need to move left, bcz smaller elements are on the left side\\n                    else{\\n                        high--;\\n                    }\\n                }                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        // store the result\\n        vector<vector<int>> res;\\n        \\n        // if size of nums is less than 3, it means we can\\'t create the triplets\\n        if(nums.size() < 3) return res;\\n        \\n        // sort the nums\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int itr = 0; itr < nums.size()-2; itr++){            \\n            \\n            // skip all continous same element, doing bcz to avoid duplicate triplets\\n            if(itr == 0 || nums[itr-1] != nums[itr]){\\n                \\n                // two pointer\\'s approach\\n                // a + b + c = 0, so we can make the equation like\\n                // b + c = -a;\\n                // low + high = -sum;\\n                int low = itr+1, high = nums.size()-1, sum = -nums[itr];\\n                \\n                while(low < high){\\n                    if(nums[low] + nums[high] == sum){\\n                        \\n                        // add triplet into the result\\n                        res.push_back({nums[itr], nums[low], nums[high]});\\n                        \\n                        // skip all continous same element, doing bcz to avoid duplicate triplets\\n                        while(low < high && nums[low] == nums[low+1]) low++;\\n                        \\n                        // skip all continous same element, doing bcz to avoid duplicate triplets\\n                        while(low < high && nums[high] == nums[high-1]) high--;\\n                                                \\n                        low++;\\n                        high--;\\n                    }\\n                    \\n                    // if our total is less than the sum, then we need to move right, bcz greater elements are on the right side\\n                    else if(nums[low] + nums[high] < sum){\\n                        low++;\\n                    }\\n                    \\n                    // if our total is greater than the sum, then we need to move left, bcz smaller elements are on the left side\\n                    else{\\n                        high--;\\n                    }\\n                }                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081749,
                "title": "java-solution",
                "content": "```\\n    public static List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> response = new HashSet<>();\\n        if (nums == null || nums.length < 3) {\\n            return new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int l = i + 1;\\n            int r = nums.length - 1;\\n            if (l == nums.length) break;\\n\\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n\\n                if (sum == 0) {\\n                    List<Integer> list = new ArrayList<>();\\n                    list.add(nums[i]);\\n                    list.add(nums[l]);\\n                    list.add(nums[r]);\\n                    response.add(list);\\n                    l++;\\n                    r--;\\n                } else if (sum < 0) {\\n                    l++;\\n                } else {\\n                    r--;\\n                }\\n            }\\n\\n        }\\n\\n        return new ArrayList<>(response);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n    public static List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> response = new HashSet<>();\\n        if (nums == null || nums.length < 3) {\\n            return new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int l = i + 1;\\n            int r = nums.length - 1;\\n            if (l == nums.length) break;\\n\\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n\\n                if (sum == 0) {\\n                    List<Integer> list = new ArrayList<>();\\n                    list.add(nums[i]);\\n                    list.add(nums[l]);\\n                    list.add(nums[r]);\\n                    response.add(list);\\n                    l++;\\n                    r--;\\n                } else if (sum < 0) {\\n                    l++;\\n                } else {\\n                    r--;\\n                }\\n            }\\n\\n        }\\n\\n        return new ArrayList<>(response);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871577,
                "title": "python-well-commented-easy-understand",
                "content": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        # Sorting the array to make the pointer movement choice obvious\\n        nums.sort()\\n        \\n        # Final result goes here\\n        res = []\\n        \\n        # Go through each element as a candidate\\n        for i in range(len(nums)):\\n            \\n            # Skip away the repeats, prevent duplicates\\n            if i != 0 and nums[i] == nums[i-1]: continue\\n                \\n            # Reducing question to 2Sum\\n            target = -nums[i]\\n            \\n            # Basic 2 pointer approach to find all the elemnts possible\\n            l, r = i+1, len(nums)-1\\n            \\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    \\n                    # You found 1, add it\\n                    res.append((nums[i], nums[l], nums[r]))\\n                    \\n                    # Skip ahead of the same guys both sides\\n                    while l < r and nums[l] == nums[l+1]: l += 1\\n                    while l < r and nums[r] == nums[r-1]: r -= 1\\n                        \\n                    # Mandatory obvious movement\\n                    l += 1\\n                    r -= 1\\n                \\n                # Selective movements\\n                \\n                # We are behind the target, need a greater number than the current l\\n                elif nums[l] + nums[r] < target:  \\n                    l += 1\\n                    \\n                # We have jumped ahead, choose a smaller number for r\\n                else:\\n                    r -= 1\\n        return res\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        # Sorting the array to make the pointer movement choice obvious\\n        nums.sort()\\n        \\n        # Final result goes here\\n        res = []\\n        \\n        # Go through each element as a candidate\\n        for i in range(len(nums)):\\n            \\n            # Skip away the repeats, prevent duplicates\\n            if i != 0 and nums[i] == nums[i-1]: continue\\n                \\n            # Reducing question to 2Sum\\n            target = -nums[i]\\n            \\n            # Basic 2 pointer approach to find all the elemnts possible\\n            l, r = i+1, len(nums)-1\\n            \\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    \\n                    # You found 1, add it\\n                    res.append((nums[i], nums[l], nums[r]))\\n                    \\n                    # Skip ahead of the same guys both sides\\n                    while l < r and nums[l] == nums[l+1]: l += 1\\n                    while l < r and nums[r] == nums[r-1]: r -= 1\\n                        \\n                    # Mandatory obvious movement\\n                    l += 1\\n                    r -= 1\\n                \\n                # Selective movements\\n                \\n                # We are behind the target, need a greater number than the current l\\n                elif nums[l] + nums[r] < target:  \\n                    l += 1\\n                    \\n                # We have jumped ahead, choose a smaller number for r\\n                else:\\n                    r -= 1\\n        return res\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 578188,
                "title": "c-solution",
                "content": "**Intuition**\\nReduce the problem to  2 Sum problem.\\n![image](https://assets.leetcode.com/users/images/5a989b94-3e69-4b28-a04c-ecb7d6ca6ad6_1650319114.6760187.png)\\n\\n\\n\\n**Complexity**\\n- Time: O(n^2): (n-1) + (n-2) + (n-3) + ... + 2\\n- Space: O(n)\\n\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        if(nums == null || nums.Length < 3)\\n            return res;\\n        \\n        Array.Sort(nums);\\n        for(int i = 0; i < nums.Length - 2; i++)\\n        {\\n\\t\\t    // If nums[i] > 0, we can\\'t find a valid triplet, since nums is sorted and nums[i] the smallest number.\\n\\t\\t\\t// To avoid duplicate triplets, we should skip nums[i] if nums[i] == nums[i-1]\\n            if(nums[i] > 0 || (i > 0 && nums[i] == nums[i-1]))\\n                continue;\\n            \\n            int left = i + 1, right = nums.Length -1;\\n            while(left < right)\\n            {\\n                if(nums[i] + nums[left] + nums[right] == 0)\\n                {\\n                    res.Add(new List<int>(){nums[i], nums[left], nums[right]});\\n                    left++;\\n                    right--;\\n                    \\n                    while(left < right && nums[left] == nums[left-1])\\n                        left++;\\n                    while(left < right && nums[right] == nums[right+1])\\n                        right--;\\n                }\\n                else if(nums[i] + nums[left] + nums[right] > 0)\\n                    right--;\\n                else\\n                    left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        if(nums == null || nums.Length < 3)\\n            return res;\\n        \\n        Array.Sort(nums);\\n        for(int i = 0; i < nums.Length - 2; i++)\\n        {\\n\\t\\t    // If nums[i] > 0, we can\\'t find a valid triplet, since nums is sorted and nums[i] the smallest number.\\n\\t\\t\\t// To avoid duplicate triplets, we should skip nums[i] if nums[i] == nums[i-1]\\n            if(nums[i] > 0 || (i > 0 && nums[i] == nums[i-1]))\\n                continue;\\n            \\n            int left = i + 1, right = nums.Length -1;\\n            while(left < right)\\n            {\\n                if(nums[i] + nums[left] + nums[right] == 0)\\n                {\\n                    res.Add(new List<int>(){nums[i], nums[left], nums[right]});\\n                    left++;\\n                    right--;\\n                    \\n                    while(left < right && nums[left] == nums[left-1])\\n                        left++;\\n                    while(left < right && nums[right] == nums[right+1])\\n                        right--;\\n                }\\n                else if(nums[i] + nums[left] + nums[right] > 0)\\n                    right--;\\n                else\\n                    left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339850,
                "title": "java-3-pointers-simple",
                "content": ">**T/S:** O(n\\xB2)/O(n), where n = size(nums)\\nArrays.sort() method uses Dual pivot quick sort, which takes O(n) extra space.\\n```\\npublic List<List<Integer>> threeSum(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tvar triplets = new ArrayList<List<Integer>>();\\n\\n\\tfor (int i = 0, n = nums.length; i < n - 2; i++) {\\n\\t\\tif (i != 0)\\n\\t\\t\\twhile (i < n && nums[i] == nums[i - 1])\\n\\t\\t\\t\\ti++;\\n\\n\\t\\t// if the smallest number is positive, all numbers of triplet will be positive, which can\\'t sum to 0\\n\\t\\tif (i < n && nums[i] > 0)  \\n\\t\\t\\tbreak;\\n\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == 0) {\\n\\t\\t\\t\\ttriplets.add(List.of(nums[i], nums[j++], nums[k--]));\\n\\t\\t\\t\\tfor (; j < k && nums[j] == nums[j - 1]; j++);\\n\\t\\t\\t\\tfor (; j < k && nums[k] == nums[k + 1]; k--);\\n\\t\\t\\t} else if (sum < 0) { // sum too low, increase it\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else { // sum too high, decrease it\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn triplets;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<List<Integer>> threeSum(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tvar triplets = new ArrayList<List<Integer>>();\\n\\n\\tfor (int i = 0, n = nums.length; i < n - 2; i++) {\\n\\t\\tif (i != 0)\\n\\t\\t\\twhile (i < n && nums[i] == nums[i - 1])\\n\\t\\t\\t\\ti++;\\n\\n\\t\\t// if the smallest number is positive, all numbers of triplet will be positive, which can\\'t sum to 0\\n\\t\\tif (i < n && nums[i] > 0)  \\n\\t\\t\\tbreak;\\n\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == 0) {\\n\\t\\t\\t\\ttriplets.add(List.of(nums[i], nums[j++], nums[k--]));\\n\\t\\t\\t\\tfor (; j < k && nums[j] == nums[j - 1]; j++);\\n\\t\\t\\t\\tfor (; j < k && nums[k] == nums[k + 1]; k--);\\n\\t\\t\\t} else if (sum < 0) { // sum too low, increase it\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else { // sum too high, decrease it\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn triplets;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278907,
                "title": "compilation-error",
                "content": "My code compiles and runs correctly in IntelliJ, but won\\'t compile on LeetCode.  Here\\'s the error I get:\\n\\n\\nLine 10: error: cannot find symbol [in __Driver__.java]\\n      List<List<Integer>> ret = new Solution().threeSum(param_1);\\n                                              ^\\n  symbol:   method threeSum(int[])\\n\\nThis is code outside of of my method....  Any suggestions?",
                "solutionTags": [],
                "code": "My code compiles and runs correctly in IntelliJ, but won\\'t compile on LeetCode.  Here\\'s the error I get:\\n\\n\\nLine 10: error: cannot find symbol [in __Driver__.java]\\n      List<List<Integer>> ret = new Solution().threeSum(param_1);\\n                                              ^\\n  symbol:   method threeSum(int[])\\n\\nThis is code outside of of my method....  Any suggestions?",
                "codeTag": "Unknown"
            },
            {
                "id": 257912,
                "title": "python-positive-array-and-negative-array-w-o-sort-beat-98",
                "content": "Since sum of a triplet is 0, there must be one negative number and one positive number.\\n(Except for special case [0,0,0] which we will check at the begin)\\n\\nSo we can seperate array into negative array and non-negative array(I named it as \\'pos\\' for simplifcation) and we know our triplet must have one element from negative array and another from non-negative array. And we used a hash counter to count all number\\'s existence and frequency.\\n\\nThen we start picking (n,p) from neg and pos cartesian product and check whether x=-n-p exists in counter. If it is, we might found a triplet.\\nThere are 2 cases to consider:\\n1. x in one of n and p. And if counter[x] > 1, we found a triplet [n,x,p] ([n,n,p] or [n,p,p]). Otherwise, it\\'s not a triplet (e.g.[-1,1] is not a triplet)\\n2. n < x < p, we found a triplet[n,x,p]\\n \\nWe do not need to consider the case when x < p or x > n to avoid duplication. A valid [x,n,p] (x<0) or [n,p,x] (x>0) will be covered by a [n,x,p] (n<x<p) .\\n```\\ndef threeSum(nums):\\n\\tctr = collections.Counter(nums)\\n\\ttris = [] if counter[0] < 3 else [[0,0,0]]\\n\\tfor x in ctr:\\n\\t\\tif x <= 0: ns.append(x)\\n\\t\\telse: ps.append(x)\\n\\tfor n in ns:\\n\\t\\tfor p in ps:\\n\\t\\t\\tx = -n-p\\n\\t\\t\\tif x in counter:\\n\\t\\t\\t\\tif x in {n, p} and counter[x] > 1 or n < x < p: \\n\\t\\t\\t\\t\\ttris.append([n, x, p])\\n\\treturn tris\\n```\\nThe time complexity will be O(n + nc * pc). nc is distinct count of negative number and pc is distinct count of non-negative number. The worst case is O((n^2)/4) and time will be reduced a lot if nc and/or pc are small.\\n\\nAnd three lines code just for fun.\\n```\\ndef threeSum(nums):\\n\\tctr = collections.Counter(nums)\\n\\tns, ps = [x for x in ctr if x <= 0], [x for x in ctr if x > 0]\\n\\treturn [[n, -n-p, p] for p in ps for n in ns if -n-p in ctr and (-n-p in {n, p} and ctr[-n-p] > 1 or n < -n-p < p)] + ([] if ctr[0] < 3 else [[0, 0, 0]])\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef threeSum(nums):\\n\\tctr = collections.Counter(nums)\\n\\ttris = [] if counter[0] < 3 else [[0,0,0]]\\n\\tfor x in ctr:\\n\\t\\tif x <= 0: ns.append(x)\\n\\t\\telse: ps.append(x)\\n\\tfor n in ns:\\n\\t\\tfor p in ps:\\n\\t\\t\\tx = -n-p\\n\\t\\t\\tif x in counter:\\n\\t\\t\\t\\tif x in {n, p} and counter[x] > 1 or n < x < p: \\n\\t\\t\\t\\t\\ttris.append([n, x, p])\\n\\treturn tris\\n```\n```\\ndef threeSum(nums):\\n\\tctr = collections.Counter(nums)\\n\\tns, ps = [x for x in ctr if x <= 0], [x for x in ctr if x > 0]\\n\\treturn [[n, -n-p, p] for p in ps for n in ns if -n-p in ctr and (-n-p in {n, p} and ctr[-n-p] > 1 or n < -n-p < p)] + ([] if ctr[0] < 3 else [[0, 0, 0]])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4078779,
                "title": "video-visualization-of-o-n-2-solution-two-pointers",
                "content": "https://youtu.be/IIxoo93bmPQ\\n\\nThis problem is similar to Two Sum, but the main differentiator is that there can now be multiple solutions and we must not return duplicate ones.  This requires us to use a different approach, since Two Sum assumes that there is only one solution.\\n\\nThe key is to sort the array first.  We then use an outer loop to fix one of the numbers and use a two pointer approach to find all solutions for that number.  The pointers, `l` and `r`, start at the ends of the array and work themselves inwards.\\n\\nAt each iteration, we calculate the total and compare it to 0.  If the total is less than zero, then since we need to make the total <i>larger</i> and the array is sorted, the only thing we can do is move `l` up (moving `r` down would only make the total <i>smaller</i>).  Similarly, if the total is greater than 0, then we just move `r` down.\\n\\nIf the total is equal to 0, then that means we\\'ve found a solution, so we append the triplet to our answer array and then keep moving `l` and `r` inwards until they both get to different numbers.\\n\\n# Code\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        answer = []\\n        for i in range(len(nums) - 2):\\n            if nums[i] > 0:\\n                break\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i + 1\\n            r = len(nums) - 1\\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if total < 0:\\n                    l += 1\\n                elif total > 0:\\n                    r -= 1\\n                else:\\n                    triplet = [nums[i], nums[l], nums[r]]\\n                    answer.append(triplet)\\n                    while l < r and nums[l] == triplet[1]:\\n                        l += 1\\n                    while l < r and nums[r] == triplet[2]:\\n                        r -= 1\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        answer = []\\n        for i in range(len(nums) - 2):\\n            if nums[i] > 0:\\n                break\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i + 1\\n            r = len(nums) - 1\\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if total < 0:\\n                    l += 1\\n                elif total > 0:\\n                    r -= 1\\n                else:\\n                    triplet = [nums[i], nums[l], nums[r]]\\n                    answer.append(triplet)\\n                    while l < r and nums[l] == triplet[1]:\\n                        l += 1\\n                    while l < r and nums[r] == triplet[2]:\\n                        r -= 1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569580,
                "title": "easy-beginner-friendly-python-solution",
                "content": "If it is helpful, leave a upvote for me.\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n                nums.sort()\\n                res = []\\n                for i in range(len(nums)-1):\\n                    l = i + 1\\n                    r = len(nums) - 1\\n                    while l < r:\\n                        if nums[i] + nums[l] + nums[r] == 0:\\n                            res.append((nums[i], nums[l], nums[r]))\\n                            l += 1\\n                            r -= 1\\n                        elif nums[i] + nums[l] + nums[r] > 0:\\n                            r -= 1\\n                        else:\\n                            l += 1\\n                return set(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n                nums.sort()\\n                res = []\\n                for i in range(len(nums)-1):\\n                    l = i + 1\\n                    r = len(nums) - 1\\n                    while l < r:\\n                        if nums[i] + nums[l] + nums[r] == 0:\\n                            res.append((nums[i], nums[l], nums[r]))\\n                            l += 1\\n                            r -= 1\\n                        elif nums[i] + nums[l] + nums[r] > 0:\\n                            r -= 1\\n                        else:\\n                            l += 1\\n                return set(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755879,
                "title": "100-fastest-solution-explained",
                "content": "Easy to understand, detailed solution with step by step explanation and code in multiple languages:\\n\\nhttps://www.code-recipe.com/post/three-sum\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\n**Kindly upvote if this helps you. Thank You**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1049549,
                "title": "c-clear-easy-understanding-solution-o-n-2",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> threeSum(vector<int>& nums) {\\n\\t\\t\\tvector<vector<int>> ans;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint length = nums.size() - 1, left, right;\\n\\t\\t\\tfor ( int index = 0; index <= length; ++index )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( index > 0 && nums[index - 1] == nums[index] ) continue; \\n\\t\\t\\t\\tleft = index + 1;\\n\\t\\t\\t\\tright = length;\\n\\t\\t\\t\\twhile ( left < right )\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif ( nums[index] + nums[left] + nums[right] < 0 ) ++left;\\n\\t\\t\\t\\t\\telse if ( nums[index] + nums[left] + nums[right] > 0 ) --right;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvector<int> anotherAnswer { nums[index], nums[left], nums[right] };\\n\\t\\t\\t\\t\\t\\tans.push_back(anotherAnswer);\\n\\t\\t\\t\\t\\t\\t++left;\\n\\t\\t\\t\\t\\t\\twhile ( left < right && nums[left] == nums[left - 1] ) ++left;\\n\\t\\t\\t\\t\\t}   \\n\\t\\t\\t\\t}    \\n\\t\\t\\t}     \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> threeSum(vector<int>& nums) {\\n\\t\\t\\tvector<vector<int>> ans;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint length = nums.size() - 1, left, right;\\n\\t\\t\\tfor ( int index = 0; index <= length; ++index )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( index > 0 && nums[index - 1] == nums[index] ) continue; \\n\\t\\t\\t\\tleft = index + 1;\\n\\t\\t\\t\\tright = length;\\n\\t\\t\\t\\twhile ( left < right )\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif ( nums[index] + nums[left] + nums[right] < 0 ) ++left;\\n\\t\\t\\t\\t\\telse if ( nums[index] + nums[left] + nums[right] > 0 ) --right;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvector<int> anotherAnswer { nums[index], nums[left], nums[right] }",
                "codeTag": "Java"
            },
            {
                "id": 1197365,
                "title": "python-3-methods-hashmap-two-pointers-dfs-faster-than-99",
                "content": "Just dfs raise \"Time Limit Exceeded\", need some one to modify it.\\n## hashmap method (340ms+)\\n![image](https://assets.leetcode.com/users/images/9cec25d7-d728-4bc8-92a8-bd80102c6a11_1620464431.8364885.png)\\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        counter = Counter(nums)\\n        nums = list(counter.keys())\\n        \\n        ans = set()\\n        \\n        if counter[0] >= 3: ans.add((0, 0, 0))\\n        pos, neg = [x for x in nums if x > 0], [x for x in nums if x < 0]\\n        \\n        for a in neg:\\n            for b in pos:\\n                c = -(a + b)\\n                if c in counter and ((c != a and c != b) or counter[c] > 1):\\n                    ans.add(tuple(sorted([a, b, c])))\\n        return ans\\n```\\n## double pointer (600ms+)\\n```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        l = len(nums)\\n        if l < 3: return []\\n        \\n        ans = [1]\\n        # double pointer\\n        nums.sort()\\n        for i in range(l):\\n            if nums[i] > 0: break\\n            if i >= 1 and nums[i] == nums[i-1]: continue\\n            p, q = i + 1, l - 1 # left pointer and right pointer\\n            while q > p:\\n                tmp = nums[i] + nums[p] + nums[q]\\n                if tmp > 0:\\n                    q -= 1\\n                elif tmp < 0:\\n                    p += 1\\n                else:\\n                    tmp = [nums[i], nums[p], nums[q]]\\n                    if tmp != ans[-1]:\\n                        ans.append(tmp)\\n                    q -= 1\\n                    p += 1\\n        return ans[1:]\\n```\\n## dfs (Time Limit Exceeded)\\n```\\n# class Solution:\\n#     def threeSum(self, nums: List[int]) -> List[List[int]]:\\n#         # a simple dfs is enough\\n#         l = len(nums)\\n#         if l < 3: return []\\n        \\n#         ans = []\\n#         def dfs(nums, cur, pos, target, d):\\n#             if d == 3:\\n#                 if target == 0:\\n#                     ans.append(cur.copy())\\n#                 return\\n            \\n#             for i in range(pos, l):\\n#                 cur.append(nums[i])\\n#                 dfs(nums, cur, i+1, target-nums[i], d+1)\\n#                 cur.pop()\\n        \\n#         dfs(nums, [], 0, 0, 0) # nums, cur, pos, depth\\n#         ans = set([tuple(sorted(x)) for x in ans])\\n#         return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        counter = Counter(nums)\\n        nums = list(counter.keys())\\n        \\n        ans = set()\\n        \\n        if counter[0] >= 3: ans.add((0, 0, 0))\\n        pos, neg = [x for x in nums if x > 0], [x for x in nums if x < 0]\\n        \\n        for a in neg:\\n            for b in pos:\\n                c = -(a + b)\\n                if c in counter and ((c != a and c != b) or counter[c] > 1):\\n                    ans.add(tuple(sorted([a, b, c])))\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        l = len(nums)\\n        if l < 3: return []\\n        \\n        ans = [1]\\n        # double pointer\\n        nums.sort()\\n        for i in range(l):\\n            if nums[i] > 0: break\\n            if i >= 1 and nums[i] == nums[i-1]: continue\\n            p, q = i + 1, l - 1 # left pointer and right pointer\\n            while q > p:\\n                tmp = nums[i] + nums[p] + nums[q]\\n                if tmp > 0:\\n                    q -= 1\\n                elif tmp < 0:\\n                    p += 1\\n                else:\\n                    tmp = [nums[i], nums[p], nums[q]]\\n                    if tmp != ans[-1]:\\n                        ans.append(tmp)\\n                    q -= 1\\n                    p += 1\\n        return ans[1:]\\n```\n```\\n# class Solution:\\n#     def threeSum(self, nums: List[int]) -> List[List[int]]:\\n#         # a simple dfs is enough\\n#         l = len(nums)\\n#         if l < 3: return []\\n        \\n#         ans = []\\n#         def dfs(nums, cur, pos, target, d):\\n#             if d == 3:\\n#                 if target == 0:\\n#                     ans.append(cur.copy())\\n#                 return\\n            \\n#             for i in range(pos, l):\\n#                 cur.append(nums[i])\\n#                 dfs(nums, cur, i+1, target-nums[i], d+1)\\n#                 cur.pop()\\n        \\n#         dfs(nums, [], 0, 0, 0) # nums, cur, pos, depth\\n#         ans = set([tuple(sorted(x)) for x in ans])\\n#         return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103313,
                "title": "elegant-short-and-fast-solution-316ms-99-6-11-lines",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        counter = Counter(nums)\\n        nums, triplets = list(counter.keys()), set()\\n        if counter[0] >= 3:\\n            triplets.add((0, 0, 0))\\n        positives, negatives = [n for n in nums if n > 0], [n for n in nums if n < 0]\\n        for a in negatives:\\n            for b in positives:\\n                c = -(a + b)\\n                if c in counter and ((c != a and c != b) or counter[c] > 1):\\n                    triplets.add(tuple(sorted([a, b, c])))\\n        return triplets\\n```\\n![image](https://assets.leetcode.com/users/images/5ceda3c9-1e1c-46a5-bb4f-4c328af2f997_1615399941.8446894.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        counter = Counter(nums)\\n        nums, triplets = list(counter.keys()), set()\\n        if counter[0] >= 3:\\n            triplets.add((0, 0, 0))\\n        positives, negatives = [n for n in nums if n > 0], [n for n in nums if n < 0]\\n        for a in negatives:\\n            for b in positives:\\n                c = -(a + b)\\n                if c in counter and ((c != a and c != b) or counter[c] > 1):\\n                    triplets.add(tuple(sorted([a, b, c])))\\n        return triplets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775889,
                "title": "step-by-step-algorithm-explained-in-c",
                "content": "```\\n    vector<vector<int>> threeSum(vector<int>& a) {\\n        \\n        vector<vector<int>> result;\\n        \\n        //step1 : check for edge condtions\\n        if(a.size()<3)\\n            return result;\\n        \\n        //step2 : sort\\n        sort(a.begin(),a.end());\\n        \\n        //step3 : Perform the same two pointer approach as you did in 2sum problem but within a for loop this time \\n\\t\\t//and also skip the duplicates because we need unique triplets only\\n        for(int i=0;i<a.size()-2;i++)\\n        {\\n            int start=i+1;\\n            int end=a.size()-1;\\n            \\n            //skip duplicates\\n            if(i>0 and a[i]==a[i-1])\\n                continue;\\n            \\n            while(start<end)\\n            {\\n                if(a[start]+a[end]==-a[i])\\n                {\\n                    result.push_back({a[start],a[i],a[end]});\\n                    start++;\\n                    end--;\\n                    //check for duplicates again\\n                    while(start<end and a[start]==a[start-1])\\n                        start++;\\n                    while(start<end and a[end]==a[end+1])\\n                        end--;\\n                }\\n                else if(a[start]+a[end]>-a[i])\\n                    end--;\\n                else\\n                    start++;\\n            }\\n                \\n        }\\n            \\n        return result;       \\n    }\\n```\\n**Upvote if this helped**",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> threeSum(vector<int>& a) {\\n        \\n        vector<vector<int>> result;\\n        \\n        //step1 : check for edge condtions\\n        if(a.size()<3)\\n            return result;\\n        \\n        //step2 : sort\\n        sort(a.begin(),a.end());\\n        \\n        //step3 : Perform the same two pointer approach as you did in 2sum problem but within a for loop this time \\n\\t\\t//and also skip the duplicates because we need unique triplets only\\n        for(int i=0;i<a.size()-2;i++)\\n        {\\n            int start=i+1;\\n            int end=a.size()-1;\\n            \\n            //skip duplicates\\n            if(i>0 and a[i]==a[i-1])\\n                continue;\\n            \\n            while(start<end)\\n            {\\n                if(a[start]+a[end]==-a[i])\\n                {\\n                    result.push_back({a[start],a[i],a[end]});\\n                    start++;\\n                    end--;\\n                    //check for duplicates again\\n                    while(start<end and a[start]==a[start-1])\\n                        start++;\\n                    while(start<end and a[end]==a[end+1])\\n                        end--;\\n                }\\n                else if(a[start]+a[end]>-a[i])\\n                    end--;\\n                else\\n                    start++;\\n            }\\n                \\n        }\\n            \\n        return result;       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 439912,
                "title": "c-88ms-98-42-14-5mb-100-00-3-indices-pointers",
                "content": "* Runtime: 88 ms, faster than 98.42% of C++ online submissions for 3Sum.\\n* Memory Usage: 14.5 MB, less than 100.00% of C++ online submissions for 3Sum.\\n\\n```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution{\\npublic:\\n    vector< vector<int> > threeSum(vector<int> &nums)\\n    {   \\n        sort(begin(nums), end(nums));\\n        vector< vector<int> > res;\\n        for (size_t i=0; i<nums.size(); i++) {\\n            if ((i>0) && (nums[i]==nums[i-1]))\\n                continue; // skip repeated digits to avoid repeated combos\\n            size_t j = i+1, k = nums.size()-1;\\n            while (j<k) { // j starts at negative, k at positive\\n                int s = nums[i]+nums[j]+nums[k];\\n                if (s>0) k--; // decrease sum by decrementing k\\n                else if (s<0) j++; // increase sum by incrementing j\\n                else { // sum is 0, store for output\\n                    res.push_back(vector<int> {nums[i], nums[j], nums[k]});\\n                    do {j++;} while (j<k && nums[j-1]==nums[j]); // skip repeated digits\\n                    do {k--;} while (j<k && nums[k+1]==nums[k]);\\n                }\\n            } // loop ends when sum is always positive, k decrements down to j\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution{\\npublic:\\n    vector< vector<int> > threeSum(vector<int> &nums)\\n    {   \\n        sort(begin(nums), end(nums));\\n        vector< vector<int> > res;\\n        for (size_t i=0; i<nums.size(); i++) {\\n            if ((i>0) && (nums[i]==nums[i-1]))\\n                continue; // skip repeated digits to avoid repeated combos\\n            size_t j = i+1, k = nums.size()-1;\\n            while (j<k) { // j starts at negative, k at positive\\n                int s = nums[i]+nums[j]+nums[k];\\n                if (s>0) k--; // decrease sum by decrementing k\\n                else if (s<0) j++; // increase sum by incrementing j\\n                else { // sum is 0, store for output\\n                    res.push_back(vector<int> {nums[i], nums[j], nums[k]});\\n                    do {j++;} while (j<k && nums[j-1]==nums[j]); // skip repeated digits\\n                    do {k--;} while (j<k && nums[k+1]==nums[k]);\\n                }\\n            } // loop ends when sum is always positive, k decrements down to j\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401650,
                "title": "easy-to-understand-c-solution-92ms-beats-93",
                "content": "Runtime: 92 ms, faster than 93.14% of C++ online submissions for 3Sum.\\nMemory Usage: 15.7 MB, less than 50.00% of C++ online submissions for 3Sum.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        \\n        if(nums.size() < 3)\\n            return res;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            int find = -1*nums[i];\\n            \\n            if(i > 0 && nums[i] == nums[i-1]) continue;\\n            while(low < high)\\n            {\\n\\n                if(nums[low]+nums[high] == find)\\n                {\\n                    vector<int> temp = {nums[low], nums[i], nums[high]};\\n                    res.push_back(temp);\\n                    while(low < high && nums[low] == nums[low+1]) low++;\\n                    while(low < high && nums[high] == nums[high-1]) high--;\\n                    low++;\\n                    high--;\\n                }\\n                else if(nums[low]+nums[high] < find)\\n                    low++;\\n                else\\n                    high--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        \\n        if(nums.size() < 3)\\n            return res;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            int find = -1*nums[i];\\n            \\n            if(i > 0 && nums[i] == nums[i-1]) continue;\\n            while(low < high)\\n            {\\n\\n                if(nums[low]+nums[high] == find)\\n                {\\n                    vector<int> temp = {nums[low], nums[i], nums[high]}",
                "codeTag": "Java"
            },
            {
                "id": 302495,
                "title": "share-my-c-solution-runtime-faster-than-99-82-memory-usage-less-than-96-80",
                "content": "int cmp(const void *a, const void *b){\\n    return *(int *)a - *(int *)b;\\n} \\n\\n\\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n\\n    int i,j,k,sum,t,total=64;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    *returnSize=0;\\n    int **q=(int**)malloc(sizeof(int*)*total);\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*total);\\n    for(i=0;i<numsSize-2;i++)\\n    {\\n        if(nums[i]>0||nums[i]+nums[i+1]+nums[i+2]>0)\\n            break;\\n        if(i>0&&nums[i]==nums[i-1])\\n            continue;\\n        j=i+1;\\n        k=numsSize-1;\\n        sum=-nums[i];\\n        while(j<k)\\n        {\\n            t=nums[j]+nums[k];\\n            if(t<sum)\\n                j++;\\n            else if(t>sum)\\n                k--;\\n            else\\n            {\\n                (*returnColumnSizes)[*returnSize]=3;\\n                q[*returnSize]=(int*) malloc(sizeof(int)*3);\\n                q[*returnSize][0]=nums[i];\\n                q[*returnSize][1]=nums[j++];\\n                q[*returnSize][2]=nums[k--];\\n                (*returnSize)++;\\n                while(j<k&&nums[j]==nums[j-1])\\n                    j++;\\n                while(j<k&&nums[k]==nums[k+1])\\n                    k--;\\n                if((*returnSize)==total)\\n                {\\n                    total*=2;\\n                    *returnColumnSizes=(int*)realloc(*returnColumnSizes,sizeof(int)*total);\\n                    q=(int**)realloc(q,sizeof(int*)*total);\\n                }\\n            }\\n        }\\n    }\\n    return q;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "int cmp(const void *a, const void *b){\\n    return *(int *)a - *(int *)b;\\n} \\n\\n\\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n\\n    int i,j,k,sum,t,total=64;\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    *returnSize=0;\\n    int **q=(int**)malloc(sizeof(int*)*total);\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*total);\\n    for(i=0;i<numsSize-2;i++)\\n    {\\n        if(nums[i]>0||nums[i]+nums[i+1]+nums[i+2]>0)\\n            break;\\n        if(i>0&&nums[i]==nums[i-1])\\n            continue;\\n        j=i+1;\\n        k=numsSize-1;\\n        sum=-nums[i];\\n        while(j<k)\\n        {\\n            t=nums[j]+nums[k];\\n            if(t<sum)\\n                j++;\\n            else if(t>sum)\\n                k--;\\n            else\\n            {\\n                (*returnColumnSizes)[*returnSize]=3;\\n                q[*returnSize]=(int*) malloc(sizeof(int)*3);\\n                q[*returnSize][0]=nums[i];\\n                q[*returnSize][1]=nums[j++];\\n                q[*returnSize][2]=nums[k--];\\n                (*returnSize)++;\\n                while(j<k&&nums[j]==nums[j-1])\\n                    j++;\\n                while(j<k&&nums[k]==nums[k+1])\\n                    k--;\\n                if((*returnSize)==total)\\n                {\\n                    total*=2;\\n                    *returnColumnSizes=(int*)realloc(*returnColumnSizes,sizeof(int)*total);\\n                    q=(int**)realloc(q,sizeof(int*)*total);\\n                }\\n            }\\n        }\\n    }\\n    return q;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 290087,
                "title": "3-measures-to-avoid-duplicates-in-3sum",
                "content": "Due to the duplicates number in the input list, one might end up with duplicate tuples in the results of 3sum. \\n\\nAs one might figure, one could use the `set` data structure to hold the results, in order to eliminate the duplicates.\\n\\nAs another more efficient solution proposed by @shpolsky in [his post](https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)-Java-solution), we could adopt 3 measures in the algorithm, which could naturally lead us to the results without duplicates, without using the `set` data structure. \\n\\n**The main idea to find the 3Sum is to iterate over the sorted list, for each number, we reduce the problem down to a 2Sum problem.**\\n\\nFirst, let\\'s see the implementation as following.\\n\\n```python\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # test cases: [], [0], [0, 0]\\n        if len(nums) < 3:\\n            return []\\n        \\n        # Measure #1 to avoid duplicates.\\n        nums.sort()\\n        \\n        # No need to use the set, due to the three measures taken \\n        results = []\\n        \\n        NUM_LEN = len(nums)\\n        \\n        def twoSum(first_num, start_index):\\n            lo = start_index\\n            hi = NUM_LEN - 1\\n            remain_sum = 0 - first_num\\n            while lo < hi:\\n                curr_sum = nums[lo] + nums[hi]\\n                if curr_sum == remain_sum:\\n                    results.append([first_num, nums[lo], nums[hi]])\\n                    \\n                    # Measure #3 to avoid the duplicates\\n                    while lo < hi and nums[lo] == nums[lo+1]:\\n                        lo += 1\\n                    while lo < hi and nums[hi] == nums[hi-1]:\\n                        hi -= 1\\n                    \\n                    # move both pointers instead of one to speed up a bit\\n                    lo += 1\\n                    hi -= 1\\n                \\n                elif curr_sum < remain_sum:\\n                    lo += 1\\n                else:\\n                    hi -= 1\\n        \\n        for index in range(NUM_LEN - 2):\\n            # Measure #2 to avoid the duplicates\\n            if index > 0 and nums[index] == nums[index-1]:\\n                continue\\n            twoSum(nums[index], index+1)\\n        \\n        return results\\n```\\n\\nHere are the ***additional*** 3 measures in the above algorithm: \\n\\n- First we sort the input list. This is an essential step which not only guarantees us to find all the solutions but also paves the way for the following steps in the algorithm. Actually, this step is also mandatory for the 2Sum problem, so technically it is not additional step, but rather essential.\\n\\n- While iterating over the sorted number for 3Sum, we skip the number that is identical with its previous number, since it would lead to duplicates, e.g. `[1, 1, 1, 2... ]`  ->  `[2, ...]`  \\n\\n- Within the step of 2Sum, when we find a solution with the two pointers (*i.e.* low, high), we continue to move these two pointers forwards until we find the new numbers, *i.e.* we fast-forwards the sequence such as `[3, 3, 3, 4, 5, 6, 6, 6]` to `[4, 5]`\\n\\n\\nGiven the above 3 measures, we would make sure that there would be no ***duplicates*** in the solution. \\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # test cases: [], [0], [0, 0]\\n        if len(nums) < 3:\\n            return []\\n        \\n        # Measure #1 to avoid duplicates.\\n        nums.sort()\\n        \\n        # No need to use the set, due to the three measures taken \\n        results = []\\n        \\n        NUM_LEN = len(nums)\\n        \\n        def twoSum(first_num, start_index):\\n            lo = start_index\\n            hi = NUM_LEN - 1\\n            remain_sum = 0 - first_num\\n            while lo < hi:\\n                curr_sum = nums[lo] + nums[hi]\\n                if curr_sum == remain_sum:\\n                    results.append([first_num, nums[lo], nums[hi]])\\n                    \\n                    # Measure #3 to avoid the duplicates\\n                    while lo < hi and nums[lo] == nums[lo+1]:\\n                        lo += 1\\n                    while lo < hi and nums[hi] == nums[hi-1]:\\n                        hi -= 1\\n                    \\n                    # move both pointers instead of one to speed up a bit\\n                    lo += 1\\n                    hi -= 1\\n                \\n                elif curr_sum < remain_sum:\\n                    lo += 1\\n                else:\\n                    hi -= 1\\n        \\n        for index in range(NUM_LEN - 2):\\n            # Measure #2 to avoid the duplicates\\n            if index > 0 and nums[index] == nums[index-1]:\\n                continue\\n            twoSum(nums[index], index+1)\\n        \\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274024,
                "title": "c-93-31-100ms-100-14-5m",
                "content": "Refer to the solution of #18. 4Sum\\n[https://leetcode.com/problems/4sum/discuss/8549/](https://leetcode.com/problems/4sum/discuss/8549/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tvector<vector<int>> threeSum(vector<int>& nums)\\t{\\n\\t\\t\\tstd::sort(nums.begin(), nums.end());\\n\\t\\t\\tvector<vector<int>> ret;\\n\\t\\t\\tint len = nums.size();\\n\\t\\t\\tif(len<3) return ret;\\n\\n\\t\\t\\tfor (int i = 0; i < len - 2; ++i){\\n\\t\\t\\t\\tif (i>0 && nums[i] ==nums[i-1]) continue;//to avoid duplicates through first value\\n\\t\\t\\t\\tif(nums[i]+nums[i+1]+nums[i+2]>0) break;//no solution\\n\\t\\t\\t\\tif(nums[i]+nums[len-2]+nums[len-1]<0) continue;//\"i\" is too small\\n\\n\\t\\t\\t\\tint j = i + 1, k = len - 1;\\n\\t\\t\\t\\twhile(j < k){\\n\\t\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif (sum > 0) --k;\\n\\t\\t\\t\\t\\telse if (sum < 0) ++j;\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tret.push_back({ nums[i], nums[j], nums[k] });\\n\\t\\t\\t\\t\\t\\tdo{ ++j; }while(nums[j] == nums[j-1] && j < k);//to avoid duplicates through second value\\n\\t\\t\\t\\t\\t\\tdo{ --k; }while(nums[k] == nums[k+1] && j < k);//to avoid duplicates through third value\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tvector<vector<int>> threeSum(vector<int>& nums)\\t{\\n\\t\\t\\tstd::sort(nums.begin(), nums.end());\\n\\t\\t\\tvector<vector<int>> ret;\\n\\t\\t\\tint len = nums.size();\\n\\t\\t\\tif(len<3) return ret;\\n\\n\\t\\t\\tfor (int i = 0; i < len - 2; ++i){\\n\\t\\t\\t\\tif (i>0 && nums[i] ==nums[i-1]) continue;//to avoid duplicates through first value\\n\\t\\t\\t\\tif(nums[i]+nums[i+1]+nums[i+2]>0) break;//no solution\\n\\t\\t\\t\\tif(nums[i]+nums[len-2]+nums[len-1]<0) continue;//\"i\" is too small\\n\\n\\t\\t\\t\\tint j = i + 1, k = len - 1;\\n\\t\\t\\t\\twhile(j < k){\\n\\t\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif (sum > 0) --k;\\n\\t\\t\\t\\t\\telse if (sum < 0) ++j;\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tret.push_back({ nums[i], nums[j], nums[k] }",
                "codeTag": "Java"
            },
            {
                "id": 266514,
                "title": "my-solution-kotlin",
                "content": "```\\nfun threeSum(nums: IntArray): List<List<Int>> {\\n        var set = HashSet<List<Int>>()\\n        if(nums.size <= 2) {\\n            return set.toList()\\n        }\\n\\n        nums.sort()\\n        for(i in 0 until nums.size - 2) {\\n            var low = i + 1\\n            var high = nums.size - 1\\n            while (low < high) {\\n                var sum = nums[i] + nums[low] + nums[high]\\n                when {\\n                    sum == 0 -> {\\n                        set.add(listOf(nums[i], nums[low], nums[high]))\\n                        low++\\n                        high--\\n                    }\\n                    sum < 0 -> low++\\n                    else -> high--\\n                }\\n            }\\n        }\\n\\n        return set.toList()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun threeSum(nums: IntArray): List<List<Int>> {\\n        var set = HashSet<List<Int>>()\\n        if(nums.size <= 2) {\\n            return set.toList()\\n        }\\n\\n        nums.sort()\\n        for(i in 0 until nums.size - 2) {\\n            var low = i + 1\\n            var high = nums.size - 1\\n            while (low < high) {\\n                var sum = nums[i] + nums[low] + nums[high]\\n                when {\\n                    sum == 0 -> {\\n                        set.add(listOf(nums[i], nums[low], nums[high]))\\n                        low++\\n                        high--\\n                    }\\n                    sum < 0 -> low++\\n                    else -> high--\\n                }\\n            }\\n        }\\n\\n        return set.toList()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126891,
                "title": "full-discussion-with-pictures-o-n-2-two-pointer-solution-and-o-n-2-hash-set-solution",
                "content": "Full discussion with pictures at: https://fizzbuzzed.com/top-interview-questions-1/#twopointer\\n\\nO(n^2 log n) solution (can be made O(n^2) by replacing set with unordered set but doesn\\'t pass. Avoids duplicates by sorting)\\n```\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n  vector<vector<int>> output;\\n  sort(nums.begin(), nums.end());\\n  for (int i = 0; i < nums.size(); ++i) {\\n    if (i != 0 && nums[i] == nums[i - 1]) continue;\\n    set<int> seen;\\n    for (int j = i + 1; j < nums.size(); ++j) {\\n      if (seen.count(-nums[i] - nums[j])) {\\n        output.push_back({nums[i], nums[j], -nums[i] - nums[j]});\\n        while (nums[j+1] == nums[j] && j + 1 < nums.size()) ++j;\\n      }\\n      seen.insert(nums[j]);\\n    }\\n  }\\n  return output;\\n}\\n```\\n\\nTwo pointer O(n^2) solution:\\n```cpp\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n  vector<vector<int>> output;\\n  sort(nums.begin(), nums.end());\\n  for (int i = 0; i < nums.size(); ++i) {\\n    // Never let i refer to the same value twice to avoid duplicates.\\n    if (i != 0 && nums[i] == nums[i - 1]) continue;\\n    int j = i + 1;\\n    int k = nums.size() - 1;\\n    while (j < k) {\\n      if (nums[i] + nums[j] + nums[k] == 0) {\\n        output.push_back({nums[i], nums[j], nums[k]});\\n        ++j;\\n        // Never let j refer to the same value twice (in an output) to avoid duplicates\\n        while (j < k && nums[j] == nums[j-1]) ++j;\\n      } else if (nums[i] + nums[j] + nums[k] < 0) {\\n        ++j;\\n      } else {\\n        --k;\\n      }\\n    }\\n  }\\n  return output;\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n  vector<vector<int>> output;\\n  sort(nums.begin(), nums.end());\\n  for (int i = 0; i < nums.size(); ++i) {\\n    if (i != 0 && nums[i] == nums[i - 1]) continue;\\n    set<int> seen;\\n    for (int j = i + 1; j < nums.size(); ++j) {\\n      if (seen.count(-nums[i] - nums[j])) {\\n        output.push_back({nums[i], nums[j], -nums[i] - nums[j]});\\n        while (nums[j+1] == nums[j] && j + 1 < nums.size()) ++j;\\n      }\\n      seen.insert(nums[j]);\\n    }\\n  }\\n  return output;\\n}\\n```\n```cpp\\nvector<vector<int>> threeSum(vector<int>& nums) {\\n  vector<vector<int>> output;\\n  sort(nums.begin(), nums.end());\\n  for (int i = 0; i < nums.size(); ++i) {\\n    // Never let i refer to the same value twice to avoid duplicates.\\n    if (i != 0 && nums[i] == nums[i - 1]) continue;\\n    int j = i + 1;\\n    int k = nums.size() - 1;\\n    while (j < k) {\\n      if (nums[i] + nums[j] + nums[k] == 0) {\\n        output.push_back({nums[i], nums[j], nums[k]});\\n        ++j;\\n        // Never let j refer to the same value twice (in an output) to avoid duplicates\\n        while (j < k && nums[j] == nums[j-1]) ++j;\\n      } else if (nums[i] + nums[j] + nums[k] < 0) {\\n        ++j;\\n      } else {\\n        --k;\\n      }\\n    }\\n  }\\n  return output;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7604,
                "title": "python-solution-simple-fast",
                "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if len(nums) < 3: \\n            return []\\n        \\n        if all(num == 0 for num in nums):\\n            return [[0,0,0]]\\n        \\n        found = []\\n        nums = sorted(nums)\\n        rightmost = len(nums)-1\\n        \\n        #Fix the first element, then search for the other two\\n        for index, eachNum in enumerate(nums):\\n            left = index + 1 \\n            right = rightmost\\n            \\n            while left < right: \\n                check_sum = (eachNum + nums[left] + nums[right])\\n                \\n        #Since the list is sorted, we can check whether the leftmost or the rightmost element is causing the sum!=0 \\n                if check_sum == 0:\\n                    new_found = [eachNum, nums[left], nums[right]]\\n                    if new_found not in found: \\n                        found.append(new_found)\\n        \\n        #even if we find the element, we need to decrease right, to find all other pairings with the first number\\n                    right -=1\\n                    \\n        #if the sum is less than 0, then our 2nd number is too low, we check the next highest one in our sorted list\\n                elif check_sum < 0: \\n                    left += 1\\n                \\n        #if the sum is less than 0, then our 3rd number is too high, we check the next lowest one in our sorted list\\n                else: \\n                    right -= 1\\n        \\n        return found",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if len(nums) < 3: \\n            return []\\n        \\n        if all(num == 0 for num in nums):\\n            return [[0,0,0]]\\n        \\n        found = []\\n        nums = sorted(nums)\\n        rightmost = len(nums)-1\\n        \\n        #Fix the first element, then search for the other two\\n        for index, eachNum in enumerate(nums):\\n            left = index + 1 \\n            right = rightmost\\n            \\n            while left < right: \\n                check_sum = (eachNum + nums[left] + nums[right])\\n                \\n        #Since the list is sorted, we can check whether the leftmost or the rightmost element is causing the sum!=0 \\n                if check_sum == 0:\\n                    new_found = [eachNum, nums[left], nums[right]]\\n                    if new_found not in found: \\n                        found.append(new_found)\\n        \\n        #even if we find the element, we need to decrease right, to find all other pairings with the first number\\n                    right -=1\\n                    \\n        #if the sum is less than 0, then our 2nd number is too low, we check the next highest one in our sorted list\\n                elif check_sum < 0: \\n                    left += 1\\n                \\n        #if the sum is less than 0, then our 3rd number is too high, we check the next lowest one in our sorted list\\n                else: \\n                    right -= 1\\n        \\n        return found",
                "codeTag": "Java"
            },
            {
                "id": 3394953,
                "title": "very-understandable-python-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPlease upvote Friends\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        #First of all we have to sort the nums\\n        nums=sorted(nums)\\n        res=set()\\n        for n in range(len(nums)):\\n            #Hold the one digit that is n\\n            i=n+1\\n            #i start with range n+1 onwards and j comes with end of the nums\\n            j=len(nums)-1\\n            while i<j:\\n                #The i will find the one digit and j will find the another digits which sum is equal to zero\\n                summ=nums[n]+nums[i]+nums[j]\\n                if summ==0:\\n                    #Then we have to add thse into the set\\n                    res.add((nums[n],nums[i],nums[j]))\\n                    i=i+1\\n                    j=j-1\\n                    #The three sum is equal to zero then move the two pointers.\\n                elif summ>0:\\n                    #if sum is less than zero we have to decrement the j because the nums is sorted right.\\n                    j=j-1\\n                elif summ<0:\\n                    #As well as i will have to increment\\n                    i=i+1\\n        #Finallt return the re\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        #First of all we have to sort the nums\\n        nums=sorted(nums)\\n        res=set()\\n        for n in range(len(nums)):\\n            #Hold the one digit that is n\\n            i=n+1\\n            #i start with range n+1 onwards and j comes with end of the nums\\n            j=len(nums)-1\\n            while i<j:\\n                #The i will find the one digit and j will find the another digits which sum is equal to zero\\n                summ=nums[n]+nums[i]+nums[j]\\n                if summ==0:\\n                    #Then we have to add thse into the set\\n                    res.add((nums[n],nums[i],nums[j]))\\n                    i=i+1\\n                    j=j-1\\n                    #The three sum is equal to zero then move the two pointers.\\n                elif summ>0:\\n                    #if sum is less than zero we have to decrement the j because the nums is sorted right.\\n                    j=j-1\\n                elif summ<0:\\n                    #As well as i will have to increment\\n                    i=i+1\\n        #Finallt return the re\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014947,
                "title": "javascript-solution-with-explanation-and-code-comments",
                "content": "\\nThis was one of my first medium problems, and as such, I had trouble understanding what would be expected of a solution. After working on Two Sum and Two Sum II, I was expecting to need to find a linear-time solution to this problem. \\n\\nBut when I looked up the solutions, the point was made by multiple authors and instructors that since this has an added dimension for the sums (using three numbers instead of two), a quadratic-time solution here is perfectly acceptable. \\n\\nSince we\\'re allowed to present an O(n^2) solution, we get a really valuable tool: we can sort the input array without impacting the overall runtime. \\n\\nSorting takes O(logn) time, and O(n^2logn) is acceptably fast, since log(n) won\\'t impact the greater, quadratic time in our worst cases. If we can sort the input list, we can solve this problem using a similar technique to the two sum problem. With a sorted list, we can also easily avoid duplicate entries. Here\\'s how it all works out at a high level: \\n\\n1. We sort the input array from low to high\\n1. With a sorted input list, we can iterate through the array and see if each value + a second value + a third value equals zero. We don\\'t have to look backwards, because we will have already checked each preceding value.\\n1. We can also skip duplicates, because we can check if `nums[i - 1] === nums[i]`, which would tell us that we\\'ve already tried with this value\\n1. Once our value at `nums[i]` is greater than 0, we can stop our search, because no three positive integers will ever equal 0. \\n\\nFor each negative value in the sorted array, we check its right-hand side neighbors to see if `value + first number + second number === 0`. If so, we add that to some top-level result array as a triplet that satisfies the condition. \\n\\nWith all that said, let\\'s illustrate this in JavaScript: \\n\\n```js\\nvar threeSum = function(nums) {\\n  // First, let\\'s sort the array. \\n  // This gives us two benefits: \\n  // 1. We can avoid duplicates, because skipping duplicate values in a sorted array is trivial (check if the prior value === current value)\\n  // 2. We can stop once we hit positive values, because no three positive values can be added to reach 0\\n  //\\n  // Finally, it\\'s OK to sort, because we accept a quadratic runtime here,\\n  // and adding an O(logn) sort operation won\\'t make that any worse\\n  nums.sort((a, b) => {\\n    return a - b\\n  })\\n\\n  // With a sorted array, let\\'s initialize a result array, which we\\'ll use to hold our triplets\\n  const result = []\\n\\n  // Now, loop through the sorted input array\\n  for (let i = 0; i < nums.length; i++) {\\n\\n    // And if the number is greater than zero, \\n    // that means the only have positive integers left in the sorted array,\\n    // and three positive integers will never equal 0,\\n    // so we\\'re done with the input and can break.\\n    if (nums[i] > 0) {\\n      break;\\n    }\\n\\n    // At each iteration, we want to make sure we skip duplicates,\\n    // so check that the prior number doesn\\'t equal the current number.\\n    if (i > 0 && nums[i - 1] === nums[i]) {\\n      // If they\\'re the same, skip this iteration\\n      continue;\\n    }\\n\\n    // With the prior conditions satisfied, \\n    // we can be certain we\\'re looking at negative integers.\\n    // In which case, we want to find two integers further down the array, such that all three integers added together equals 0.\\n    //\\n    // Now we solve this with two pointers, which is how we would solve Two Sum II.\\n    // We use the sorted nature of the array to hone in on values that will equal zero.\\n    // \\n    // Start the left pointer at the current index + 1, and the right pointer at the end of the array\\n    let left = i + 1\\n    let right = nums.length - 1\\n\\n    while (left < right) {\\n      // Calculate the sum\\n      const sum = nums[i] + nums[left] + nums[right]\\n\\n      // Check if the sum is equal to 0\\n      // if so, push nums[i], nums[left], and nums[right] to our top level result array\\n      if (sum === 0) {\\n        result.push([nums[i], nums[left], nums[right]])\\n\\n        // Then, increment the left pointer and the right pointer, \\n        // to see if there are any additional triplets that satisfy the conditions.\\n        left++\\n        right--\\n\\n        // Also make sure we increment the left pointer past any possible duplicates\\n        while (left < right && nums[left] === nums[left - 1]) {\\n          left++\\n        }\\n      } else if (sum < 0) {\\n        // If the sum is less than zero, we want to see if we can increase it to hit zero. \\n        // With a sorted input array, we can attempt this by incrementing the left pointer, \\n        // to look at bigger numbers.\\n        left++\\n      } else {\\n        // Otherwise, sum is greater than zero, and we should try decreasing the sum, by decrementing the right pointer\\n        right--\\n      }\\n    }\\n  }\\n\\n  return result\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar threeSum = function(nums) {\\n  // First, let\\'s sort the array. \\n  // This gives us two benefits: \\n  // 1. We can avoid duplicates, because skipping duplicate values in a sorted array is trivial (check if the prior value === current value)\\n  // 2. We can stop once we hit positive values, because no three positive values can be added to reach 0\\n  //\\n  // Finally, it\\'s OK to sort, because we accept a quadratic runtime here,\\n  // and adding an O(logn) sort operation won\\'t make that any worse\\n  nums.sort((a, b) => {\\n    return a - b\\n  })\\n\\n  // With a sorted array, let\\'s initialize a result array, which we\\'ll use to hold our triplets\\n  const result = []\\n\\n  // Now, loop through the sorted input array\\n  for (let i = 0; i < nums.length; i++) {\\n\\n    // And if the number is greater than zero, \\n    // that means the only have positive integers left in the sorted array,\\n    // and three positive integers will never equal 0,\\n    // so we\\'re done with the input and can break.\\n    if (nums[i] > 0) {\\n      break;\\n    }\\n\\n    // At each iteration, we want to make sure we skip duplicates,\\n    // so check that the prior number doesn\\'t equal the current number.\\n    if (i > 0 && nums[i - 1] === nums[i]) {\\n      // If they\\'re the same, skip this iteration\\n      continue;\\n    }\\n\\n    // With the prior conditions satisfied, \\n    // we can be certain we\\'re looking at negative integers.\\n    // In which case, we want to find two integers further down the array, such that all three integers added together equals 0.\\n    //\\n    // Now we solve this with two pointers, which is how we would solve Two Sum II.\\n    // We use the sorted nature of the array to hone in on values that will equal zero.\\n    // \\n    // Start the left pointer at the current index + 1, and the right pointer at the end of the array\\n    let left = i + 1\\n    let right = nums.length - 1\\n\\n    while (left < right) {\\n      // Calculate the sum\\n      const sum = nums[i] + nums[left] + nums[right]\\n\\n      // Check if the sum is equal to 0\\n      // if so, push nums[i], nums[left], and nums[right] to our top level result array\\n      if (sum === 0) {\\n        result.push([nums[i], nums[left], nums[right]])\\n\\n        // Then, increment the left pointer and the right pointer, \\n        // to see if there are any additional triplets that satisfy the conditions.\\n        left++\\n        right--\\n\\n        // Also make sure we increment the left pointer past any possible duplicates\\n        while (left < right && nums[left] === nums[left - 1]) {\\n          left++\\n        }\\n      } else if (sum < 0) {\\n        // If the sum is less than zero, we want to see if we can increase it to hit zero. \\n        // With a sorted input array, we can attempt this by incrementing the left pointer, \\n        // to look at bigger numbers.\\n        left++\\n      } else {\\n        // Otherwise, sum is greater than zero, and we should try decreasing the sum, by decrementing the right pointer\\n        right--\\n      }\\n    }\\n  }\\n\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592368,
                "title": "javascript-95-94",
                "content": "Runtime: 132 ms, faster than 95.94% of JavaScript online submissions for 3Sum.\\nMemory Usage: 49.2 MB, less than 54.33% of JavaScript online submissions for 3Sum.\\n\\n\\tvar threeSum = function(nums) {\\n\\t\\tnums.sort((a,b) => a-b)\\n\\t\\tconst result=[]\\n\\n\\t\\tif(nums.length < 3) return result\\n\\n\\t\\tfor(let i=0; i< nums.length; i++){\\n\\t\\t\\tlet left = i+1\\n\\t\\t\\tlet right = nums.length-1\\n\\t\\t\\tif(i > 0 && nums[i] === nums[i-1]) continue\\n\\t\\t\\twhile(left < right){\\n\\t\\t\\t\\tlet sum = nums[i] + nums[left] + nums[right]\\n\\n\\t\\t\\t\\tif(sum===0){\\n\\t\\t\\t\\t\\tlet arr=[nums[i], nums[left], nums[right]]\\n\\t\\t\\t\\t\\tresult.push(arr)\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t\\twhile(nums[left] === nums[left-1] && left < right) left++\\n\\t\\t\\t\\t}else if(sum > 0){\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result\\n\\t};",
                "solutionTags": [],
                "code": "Runtime: 132 ms, faster than 95.94% of JavaScript online submissions for 3Sum.\\nMemory Usage: 49.2 MB, less than 54.33% of JavaScript online submissions for 3Sum.\\n\\n\\tvar threeSum = function(nums) {\\n\\t\\tnums.sort((a,b) => a-b)\\n\\t\\tconst result=[]\\n\\n\\t\\tif(nums.length < 3) return result\\n\\n\\t\\tfor(let i=0; i< nums.length; i++){\\n\\t\\t\\tlet left = i+1\\n\\t\\t\\tlet right = nums.length-1\\n\\t\\t\\tif(i > 0 && nums[i] === nums[i-1]) continue\\n\\t\\t\\twhile(left < right){\\n\\t\\t\\t\\tlet sum = nums[i] + nums[left] + nums[right]\\n\\n\\t\\t\\t\\tif(sum===0){\\n\\t\\t\\t\\t\\tlet arr=[nums[i], nums[left], nums[right]]\\n\\t\\t\\t\\t\\tresult.push(arr)\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t\\twhile(nums[left] === nums[left-1] && left < right) left++\\n\\t\\t\\t\\t}else if(sum > 0){\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1327190,
                "title": "java-solution-using-two-pointers",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        int target = 0;\\n        ArrayList<List<Integer>> sol = new ArrayList<List<Integer>>();\\n        if(nums == null || nums.length == 0){\\n            return sol;\\n        }\\n        Arrays.sort(nums);\\n        for(int i = 0 ; i<=nums.length-1 ;i++){\\n           \\n                int remaining  = target - nums[i] ;\\n                int front = i+1;\\n                int back = nums.length-1;\\n            \\n                while(front < back){\\n                    int twoSum = nums[front] + nums[back];\\n                    if(twoSum < remaining)front++;\\n                    else if(twoSum >remaining)back--;\\n                    else{\\n                        List<Integer> triplet = new ArrayList<>();\\n                        triplet.add(nums[i]);\\n                        triplet.add(nums[front]);\\n                        triplet.add(nums[back]);\\n                        sol.add(triplet);\\n\\n                        while(front < back && nums[front] == triplet.get(1))front++;\\n                        while(front < back && nums[back] == triplet.get(2))back--;  \\n                    }\\n                }\\n            while( i+1<=nums.length-1 && nums[i] == nums[i+1]) i++;\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        int target = 0;\\n        ArrayList<List<Integer>> sol = new ArrayList<List<Integer>>();\\n        if(nums == null || nums.length == 0){\\n            return sol;\\n        }\\n        Arrays.sort(nums);\\n        for(int i = 0 ; i<=nums.length-1 ;i++){\\n           \\n                int remaining  = target - nums[i] ;\\n                int front = i+1;\\n                int back = nums.length-1;\\n            \\n                while(front < back){\\n                    int twoSum = nums[front] + nums[back];\\n                    if(twoSum < remaining)front++;\\n                    else if(twoSum >remaining)back--;\\n                    else{\\n                        List<Integer> triplet = new ArrayList<>();\\n                        triplet.add(nums[i]);\\n                        triplet.add(nums[front]);\\n                        triplet.add(nums[back]);\\n                        sol.add(triplet);\\n\\n                        while(front < back && nums[front] == triplet.get(1))front++;\\n                        while(front < back && nums[back] == triplet.get(2))back--;  \\n                    }\\n                }\\n            while( i+1<=nums.length-1 && nums[i] == nums[i+1]) i++;\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274364,
                "title": "python-3-easy-10-lines-pretty-much-identical-to-two-sum-648ms-96",
                "content": "```\\nres = set()\\nnums.sort()\\n_set = set()\\nfor i in range(len(nums)):\\n\\tif not(i > 2 and nums[i] == nums[i-2]): \\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tsol = -(nums[i]+nums[j])\\n\\t\\t\\tif sol in _set:\\n\\t\\t\\t\\tres.add((nums[i], nums[j], sol))\\n\\t\\t_set.add(nums[i])\\n        return list(res)\\n```\\n\\nPretty much only the difference here is that we create a set which stores a tuple of the tripplets\\nthat sums to 0. \\n\\nReason we use set is beacuse looking inside a set is O(1) on average I believe. Reason we keep set of tuples and not set of sets, is beacuse the set will\\nremove duplcate values say [-1 -1 2]. \\n\\nAt the end we just convert the set to a list. \\n\\nThis is a very easy to understand way of solving and does not TLE but its pretty slow if anyone have an idea for \\nspeeding up let me know. \\n\\nEdit: Thanks to @amit_369 I added the following line to speed up the code:\\n\\t- if not(i > 2 and nums[i] == nums[i-2]): # This avoids selecting two same number which were selected before\\n\\t\\n\\n\\n\\n\\n\\n.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nres = set()\\nnums.sort()\\n_set = set()\\nfor i in range(len(nums)):\\n\\tif not(i > 2 and nums[i] == nums[i-2]): \\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tsol = -(nums[i]+nums[j])\\n\\t\\t\\tif sol in _set:\\n\\t\\t\\t\\tres.add((nums[i], nums[j], sol))\\n\\t\\t_set.add(nums[i])\\n        return list(res)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762841,
                "title": "c-two-pointers-easy-fast-o-1-space-o-n-2-time",
                "content": "**The idea is to sort the array and convert into 2 sum problem using 2 pointers.**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        if(nums.size() < 3) return {};\\n        vector<vector<int>> ret;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;++i){\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int tar = 0 - nums[i],hi=nums.size()-1,lo=i+1;\\n            while(hi>lo){\\n                int summ = nums[hi]+nums[lo];\\n                if(summ > tar)\\n                    hi--;\\n                else if(summ < tar)\\n                    lo++;\\n                else{\\n                    ret.push_back({nums[i],nums[lo],nums[hi]});\\n                    lo++,hi--;\\n                    while(hi>lo && nums[hi]==nums[hi+1]) hi--;\\n                    while(hi>lo && nums[lo]==nums[lo-1]) lo++;\\n                }    \\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        if(nums.size() < 3) return {};\\n        vector<vector<int>> ret;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;++i){\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int tar = 0 - nums[i],hi=nums.size()-1,lo=i+1;\\n            while(hi>lo){\\n                int summ = nums[hi]+nums[lo];\\n                if(summ > tar)\\n                    hi--;\\n                else if(summ < tar)\\n                    lo++;\\n                else{\\n                    ret.push_back({nums[i],nums[lo],nums[hi]});\\n                    lo++,hi--;\\n                    while(hi>lo && nums[hi]==nums[hi+1]) hi--;\\n                    while(hi>lo && nums[lo]==nums[lo-1]) lo++;\\n                }    \\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550536,
                "title": "python-o-n-2-easy-to-follow-solution-faster-than-91",
                "content": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        triplets = set()\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            if nums[i] > 0:\\n                break\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n                \\n            l = i + 1\\n            r = len(nums) - 1\\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if total > 0:\\n                    r -= 1\\n                elif total < 0:\\n                    l += 1\\n                else:\\n                    triplets.add((nums[i], nums[l], nums[r]))\\n                    l += 1\\n                    r -= 1\\n        \\n        return [list(t) for t in triplets]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        triplets = set()\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            if nums[i] > 0:\\n                break\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n                \\n            l = i + 1\\n            r = len(nums) - 1\\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if total > 0:\\n                    r -= 1\\n                elif total < 0:\\n                    l += 1\\n                else:\\n                    triplets.add((nums[i], nums[l], nums[r]))\\n                    l += 1\\n                    r -= 1\\n        \\n        return [list(t) for t in triplets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415500,
                "title": "c-very-descriptive-answer-86-faster",
                "content": "I\\'m currently preparing for an interview so I tried to make my answer as descriptive as possible and include notes on what normally do on interviews as well as what I would say out loud as part of my \"thought process\"... if you have any suggestions, feel free to chime in.\\n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) {\\n        // goals => sort through an array finding all unique triplets which gives a zero sum\\n        // inputs => nums (array to be searched)\\n        // output => List of triplets (triplets stored in lists)\\n        \\n        // questions to ask during interview (sum are answered based off of the example, but if an example isn\\'t provided, these are good questions to ask): \\n            // are all numbers in the array unique?\\n            // is there a guarantee that the nums array is not null and has a length of 3 or greater\\n            // is the nums array sorted? (means you will not have to sort it from the start)\\n                // this is important because it determines how we might be solving the problem\\n            // what to return if there is no solution found or nums is null/less than 3? \\n                // normally you can make this assumption based off of the method signature, but keep in mind that sometimes on LC\\n                // they ask you to just return the original array if no solutions are found so on\\n        \\n        // it\\'s also a good idea to state your assumptions and thought process out loud instead of sitting there in silence during the interview... \\n        // assumptions made from the example are that:\\n            // the elements in nums are not unique\\n            // it\\'s possible for the solution set to be equal to an empty List\\n            // nums is unsorted\\n        \\n        // look at past problems on leetcode such as two-sum, can you leverage previous experience/knowledge to solve this problem? \\n            // normally I go to this if I\\'m a little stumped or if I\\'m looking at ways of optimizing the solution after I have found a brute force solution\\n        \\n        // \"edge cases\" => nums is null or length is less than three... \\n            // in the case of both, return an empty list\\n            // nums contains only 0\\'s\\n        \\n        List<IList<int>> result = new List<IList<int>>(); \\n        \\n        if(nums == null || nums.Length < 3) return result; \\n        \\n        if(nums.Length == 3 && nums.ToList().Sum() == 0) {\\n            result.Add(nums.ToList());\\n            return result; \\n        }\\n        \\n        Array.Sort(nums);  \\n        \\n        for (int i = 0; i < nums.Length - 3; i++) {\\n            // array is sorted so any values for nums[i] means that there are no further solutions\\n            if(nums[i] > 0) break; \\n            \\n            // some people would disagree with making a \"target\" variable but I feel like it helps with the readability\\n            // you could just include this in the if statements by doing something like if(nums[i] + nums[start] + nums[end] == 0)\\n            var target = 0 - nums[i]; \\n            \\n            // to avoid duplicates\\n            if(i ==0 || nums[i] > nums[i - 1]) {\\n                int start = i + 1; \\n                int end = nums.Length - 1; \\n                \\n                while(start < end) {\\n                    if(nums[start] + nums[end] == target) {\\n                        result.Add(new List<int>() {nums[i], nums[start], nums[end]}); \\n                    }\\n                    \\n                    if(nums[start] + nums[end] < target) {\\n                        int currStart = start; \\n                        \\n                        // avoid duplicates => if nums[start] and nums[start + 1] are the same... they will be duplicate solutions\\n                        while(nums[start] == nums[currStart] && start < end) {\\n                            start++; \\n                        }\\n                    } else {\\n                        int currEnd = end;\\n                        \\n                        // again, avoiding duplicates\\n                        while(nums[end] == nums[currEnd] && start < end) {\\n                            end--; \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result; \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) {\\n        // goals => sort through an array finding all unique triplets which gives a zero sum\\n        // inputs => nums (array to be searched)\\n        // output => List of triplets (triplets stored in lists)\\n        \\n        // questions to ask during interview (sum are answered based off of the example, but if an example isn\\'t provided, these are good questions to ask): \\n            // are all numbers in the array unique?\\n            // is there a guarantee that the nums array is not null and has a length of 3 or greater\\n            // is the nums array sorted? (means you will not have to sort it from the start)\\n                // this is important because it determines how we might be solving the problem\\n            // what to return if there is no solution found or nums is null/less than 3? \\n                // normally you can make this assumption based off of the method signature, but keep in mind that sometimes on LC\\n                // they ask you to just return the original array if no solutions are found so on\\n        \\n        // it\\'s also a good idea to state your assumptions and thought process out loud instead of sitting there in silence during the interview... \\n        // assumptions made from the example are that:\\n            // the elements in nums are not unique\\n            // it\\'s possible for the solution set to be equal to an empty List\\n            // nums is unsorted\\n        \\n        // look at past problems on leetcode such as two-sum, can you leverage previous experience/knowledge to solve this problem? \\n            // normally I go to this if I\\'m a little stumped or if I\\'m looking at ways of optimizing the solution after I have found a brute force solution\\n        \\n        // \"edge cases\" => nums is null or length is less than three... \\n            // in the case of both, return an empty list\\n            // nums contains only 0\\'s\\n        \\n        List<IList<int>> result = new List<IList<int>>(); \\n        \\n        if(nums == null || nums.Length < 3) return result; \\n        \\n        if(nums.Length == 3 && nums.ToList().Sum() == 0) {\\n            result.Add(nums.ToList());\\n            return result; \\n        }\\n        \\n        Array.Sort(nums);  \\n        \\n        for (int i = 0; i < nums.Length - 3; i++) {\\n            // array is sorted so any values for nums[i] means that there are no further solutions\\n            if(nums[i] > 0) break; \\n            \\n            // some people would disagree with making a \"target\" variable but I feel like it helps with the readability\\n            // you could just include this in the if statements by doing something like if(nums[i] + nums[start] + nums[end] == 0)\\n            var target = 0 - nums[i]; \\n            \\n            // to avoid duplicates\\n            if(i ==0 || nums[i] > nums[i - 1]) {\\n                int start = i + 1; \\n                int end = nums.Length - 1; \\n                \\n                while(start < end) {\\n                    if(nums[start] + nums[end] == target) {\\n                        result.Add(new List<int>() {nums[i], nums[start], nums[end]}); \\n                    }\\n                    \\n                    if(nums[start] + nums[end] < target) {\\n                        int currStart = start; \\n                        \\n                        // avoid duplicates => if nums[start] and nums[start + 1] are the same... they will be duplicate solutions\\n                        while(nums[start] == nums[currStart] && start < end) {\\n                            start++; \\n                        }\\n                    } else {\\n                        int currEnd = end;\\n                        \\n                        // again, avoiding duplicates\\n                        while(nums[end] == nums[currEnd] && start < end) {\\n                            end--; \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result; \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110497,
                "title": "c-o-n-2-solution-easy-to-understand-with-explanation-accepted",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        //Sorting will bring same numbers in the array next to each other.\\n        Array.Sort(nums);\\n\\n        IList<IList<int>> res = new List<IList<int>>();\\n        for (int pivot = 0; pivot < nums.Length; pivot++)\\n        {\\n            //No need to pivot on the same number as the one previously used.\\n            if (pivot > 0 && nums[pivot] == nums[pivot - 1])\\n            {\\n                continue;\\n            }\\n\\n            //Since we have to find triplets whose sum is 0.\\n            int targetSum = -(nums[pivot]);\\n\\n            int startIndex = pivot + 1;\\n            int endIndex = nums.Length - 1;\\n            while (startIndex < endIndex)\\n            {\\n                int sumOfValuesAtStartAndEndIndex = nums[startIndex] + nums[endIndex];\\n                if (sumOfValuesAtStartAndEndIndex == targetSum)\\n                {\\n                    res.Add(new int[] { nums[pivot], nums[startIndex], nums[endIndex] });\\n\\n                    //No need to look at the same number if its already is in the result.\\n                    while (startIndex < endIndex && nums[startIndex] == nums[startIndex + 1])\\n                    {\\n                        startIndex++;\\n                    }\\n\\n                    //No need to look at the same number if its already is in the result.\\n                    while (startIndex < endIndex && nums[endIndex] == nums[endIndex - 1])\\n                    {\\n                        endIndex--;\\n                    }\\n\\n                    startIndex++;\\n                    endIndex--;\\n                }\\n                else \\n                {\\n                    //If sumOfValuesAtStartAndEndIndex is less than the targetSum,\\n                    //we need to increase the sumOfValuesAtStartAndEndIndex\\n                    //by taking the next big number.\\n                    if (sumOfValuesAtStartAndEndIndex < targetSum)\\n                    {\\n                        startIndex++;\\n                    }\\n                    //Else we need to decrease the sumOfValuesAtStartAndEndIndex,\\n                    //by taking the next smaller number.\\n                    else\\n                    {\\n                        endIndex--;\\n                    }                        \\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        //Sorting will bring same numbers in the array next to each other.\\n        Array.Sort(nums);\\n\\n        IList<IList<int>> res = new List<IList<int>>();\\n        for (int pivot = 0; pivot < nums.Length; pivot++)\\n        {\\n            //No need to pivot on the same number as the one previously used.\\n            if (pivot > 0 && nums[pivot] == nums[pivot - 1])\\n            {\\n                continue;\\n            }\\n\\n            //Since we have to find triplets whose sum is 0.\\n            int targetSum = -(nums[pivot]);\\n\\n            int startIndex = pivot + 1;\\n            int endIndex = nums.Length - 1;\\n            while (startIndex < endIndex)\\n            {\\n                int sumOfValuesAtStartAndEndIndex = nums[startIndex] + nums[endIndex];\\n                if (sumOfValuesAtStartAndEndIndex == targetSum)\\n                {\\n                    res.Add(new int[] { nums[pivot], nums[startIndex], nums[endIndex] });\\n\\n                    //No need to look at the same number if its already is in the result.\\n                    while (startIndex < endIndex && nums[startIndex] == nums[startIndex + 1])\\n                    {\\n                        startIndex++;\\n                    }\\n\\n                    //No need to look at the same number if its already is in the result.\\n                    while (startIndex < endIndex && nums[endIndex] == nums[endIndex - 1])\\n                    {\\n                        endIndex--;\\n                    }\\n\\n                    startIndex++;\\n                    endIndex--;\\n                }\\n                else \\n                {\\n                    //If sumOfValuesAtStartAndEndIndex is less than the targetSum,\\n                    //we need to increase the sumOfValuesAtStartAndEndIndex\\n                    //by taking the next big number.\\n                    if (sumOfValuesAtStartAndEndIndex < targetSum)\\n                    {\\n                        startIndex++;\\n                    }\\n                    //Else we need to decrease the sumOfValuesAtStartAndEndIndex,\\n                    //by taking the next smaller number.\\n                    else\\n                    {\\n                        endIndex--;\\n                    }                        \\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7718,
                "title": "a-c-implementation-o-n-2-around-52ms",
                "content": "    vector<vector<int>> threeSum(vector<int>& nums)\\n        {\\n            if (nums.size() < 3)\\n                return {};\\n            \\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> result;\\n            int k = 0;\\n    \\n            // not necessary to check positive integers\\n            while (k < nums.size() && nums[k] <= 0)\\n            {\\n                int i = k + 1;\\n                int j = nums.size() - 1;\\n                \\n                while (i < j)\\n                {\\n                    int sum = nums[i] + nums[j];\\n                    if (sum < -nums[k])\\n                    {\\n                        i++;\\n                        while (i < j && nums[i] == nums[i-1]) i++; // remove duplicates\\n                    }\\n                    else if (sum > -nums[k])\\n                    {\\n                        j--;\\n                        while (i < j && nums[j] == nums[j+1]) j--;\\n                    }\\n                    else\\n                    {\\n                        result.push_back({nums[k], nums[i], nums[j]});\\n                        i++;\\n                        while (i < j && nums[i] == nums[i-1]) i++;\\n                        j--;\\n                        while (i < j && nums[j] == nums[j+1]) j--;\\n                    }\\n                }\\n                \\n                k++;\\n                while (k < i && nums[k] == nums[k-1]) k++;\\n            }\\n            \\n            return result;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<vector<int>> threeSum(vector<int>& nums)\\n        {\\n            if (nums.size() < 3)\\n                return {};\\n            \\n            sort(nums.begin(), nums.end());\\n            vector<vector<int>> result;\\n            int k = 0;\\n    \\n            // not necessary to check positive integers\\n            while (k < nums.size() && nums[k] <= 0)\\n            {\\n                int i = k + 1;\\n                int j = nums.size() - 1;\\n                \\n                while (i < j)\\n                {\\n                    int sum = nums[i] + nums[j];\\n                    if (sum < -nums[k])\\n                    {\\n                        i++;\\n                        while (i < j && nums[i] == nums[i-1]) i++; // remove duplicates\\n                    }\\n                    else if (sum > -nums[k])\\n                    {\\n                        j--;\\n                        while (i < j && nums[j] == nums[j+1]) j--;\\n                    }\\n                    else\\n                    {\\n                        result.push_back({nums[k], nums[i], nums[j]});\\n                        i++;\\n                        while (i < j && nums[i] == nums[i-1]) i++;\\n                        j--;\\n                        while (i < j && nums[j] == nums[j+1]) j--;\\n                    }\\n                }\\n                \\n                k++;\\n                while (k < i && nums[k] == nums[k-1]) k++;\\n            }\\n            \\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3223429,
                "title": "pure-c-solution",
                "content": "# Why?\\nWas bored so wanted to try doing some C programming when I realized how badly optimized this leetcode question is for the C langauge. For example, you need to attribute a constant sizing of $$3$$ for each element in `returnColumnSize`.\\n\\n# Approach\\nWe advance a integer pointer called `i` from $$0 \\\\rightarrow n-2$$. This represents the first number of our sum. Then we use two pointers `l` and `r`. `l` is incremented when the sum of the three pointers is too low, and `r` is decremented when the sum is too high. Eventually `l` and `r` converge to a point where `nums[i] + nums[l] + nums[r] == 0`. At this point we come across a solution. Afterward, we keep incrementing `l` in case another solution comes up which is possible:\\n\\ne.g `[-3,-2,-1,0,4,5]` we have a solution `[-3,-2,5]` but `[-3,-1,4]` also works.\\n\\nBut to avoid duplicates we need to increment further `l` in the case that there are duplicates of `nums[l]`. We also skip `nums[i]` using `continue` if we come across a duplicate for the `i` pointer also. It\\'s not possible for `r` to have a duplicate because assuming `i` and `l` are unique there can only be a unique `r` that sums to $$0$$.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^{2})$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```C\\n#include <stdlib.h>\\n\\nint cmp(const void *a,const void *b) {\\n    return *((int*) a) - *((int*) b);\\n}\\n\\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    (*returnSize) = 0;\\n    (*returnColumnSizes) = (int*) malloc(sizeof(int) * numsSize * numsSize);\\n    int **ret = (int**) malloc(sizeof(int*) * numsSize * numsSize);\\n    for (int i = 0; i < numsSize - 2; i++) {\\n        if (i == 0 || nums[i] != nums[i-1]) {\\n            int l = i + 1;\\n            int r = numsSize - 1;\\n            while (l < r) {\\n                if (nums[i] + nums[l] + nums[r] < 0) {\\n                    l++;\\n                } else if (nums[i] + nums[l] + nums[r] > 0) {\\n                    r--;\\n                } else {\\n                    ret[(*returnSize)] = (int*) malloc(sizeof(int) * 3);\\n                    (*returnColumnSizes)[(*returnSize)] = 3;\\n                    ret[(*returnSize)][0] = nums[i];\\n                    ret[(*returnSize)][1] = nums[l];\\n                    ret[(*returnSize)][2] = nums[r];\\n                    (*returnSize)++;\\n                    l++;\\n                    while (l < r && nums[l] == nums[l-1])\\n                        l++;\\n                }\\n            }\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C\\n#include <stdlib.h>\\n\\nint cmp(const void *a,const void *b) {\\n    return *((int*) a) - *((int*) b);\\n}\\n\\nint** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    (*returnSize) = 0;\\n    (*returnColumnSizes) = (int*) malloc(sizeof(int) * numsSize * numsSize);\\n    int **ret = (int**) malloc(sizeof(int*) * numsSize * numsSize);\\n    for (int i = 0; i < numsSize - 2; i++) {\\n        if (i == 0 || nums[i] != nums[i-1]) {\\n            int l = i + 1;\\n            int r = numsSize - 1;\\n            while (l < r) {\\n                if (nums[i] + nums[l] + nums[r] < 0) {\\n                    l++;\\n                } else if (nums[i] + nums[l] + nums[r] > 0) {\\n                    r--;\\n                } else {\\n                    ret[(*returnSize)] = (int*) malloc(sizeof(int) * 3);\\n                    (*returnColumnSizes)[(*returnSize)] = 3;\\n                    ret[(*returnSize)][0] = nums[i];\\n                    ret[(*returnSize)][1] = nums[l];\\n                    ret[(*returnSize)][2] = nums[r];\\n                    (*returnSize)++;\\n                    l++;\\n                    while (l < r && nums[l] == nums[l-1])\\n                        l++;\\n                }\\n            }\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1960506,
                "title": "three-methods-easy-to-understand-python",
                "content": "#### Method 1 (shows TLE) :\\nJust traverse the array with three nested loop and maintain a set of selected triplet so that it is not repeated again.\\n\\nPython Code:\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        s=set()\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                for k in range(j+1,n):\\n                    if nums[i]+nums[j]+nums[k]==0:\\n                        a=[nums[i],nums[j],nums[k]]\\n                        a.sort()\\n                        t=tuple(a)\\n                        \\n                        if t not in s:\\n                            ans.append([nums[i],nums[j],nums[k]])\\n                            s.add(t)\\n        return ans\\n```\\n\\n#### Method 2 (using dictionary(map), without sorting || accepted):\\nWe\\'ll insert all the elements in dictionary(map) as key and value as list of indexes at which it present.\\nAnd then two nested \\'for loop \\' for two elements and for third element we\\'ll check whether it is available in dictionary and also maintain a set of selected triplet so that it is not repeated again.\\n\\nPython Code:\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        s=set()\\n        d={}\\n        for i in range(n):\\n            if nums[i] not in d:\\n                d[nums[i]]=[i]\\n            else:\\n                d[nums[i]].append(i)\\n            \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                target=0-nums[i]-nums[j]\\n                if target in d:\\n                    if nums[i]==0 and nums[j]==0: \\n                        if len(d[target])>=3 :\\n                            a=[nums[i],nums[j],target]\\n                            a.sort()\\n                            t=tuple(a)\\n                            if t not in s:\\n                                ans.append(a)\\n                                s.add(tuple(a))\\n                        else:\\n                            continue\\n                            \\n                        \\n                    elif (nums[i]==target or nums[j]==target) and len(d[target])>=2 :\\n                        \\n                        a=[nums[i],nums[j],target]\\n                        \\n                        a.sort()\\n                        t=tuple(a)\\n                        if t not in s:\\n                            ans.append(a)\\n                            s.add(tuple(a))\\n                    elif d[target][0]!=i and d[target][0]!=j:\\n                        \\n                        a=[nums[i],nums[j],target]\\n                        a.sort()\\n                        t=tuple(a)\\n                        if t not in s:\\n                            ans.append(a)\\n                            s.add(tuple(a))\\n                        \\n                    \\n        return ans\\n```\\n\\n#### Method 3 (using sorting and two pointer method):\\nFirstly sort the array.\\nFor first element we\\'ll run for loop then, use two pointer method to sorted array to meet the target such that sum of all three elements become  zero and maintain a set of selected triplet so that it is not repeated again.\\n\\nPython Code:\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans=[]\\n        s=set()\\n        n=len(nums)\\n        for i in range(n):\\n            target=0-nums[i]\\n            j=i+1\\n            k=n-1\\n            while j<k:\\n                summ=nums[j]+nums[k]\\n                if summ==target:\\n                    a=[nums[i],nums[j],nums[k]]\\n                    a.sort()\\n                    t=tuple(a)\\n                    if t not in s:\\n                        ans.append(a)\\n                        s.add(t)\\n                    j+=1\\n                    k-=1\\n                elif summ>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n        return ans \\n```\\n\\n**Please Upvote, if you find it helpful  :)**\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        s=set()\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                for k in range(j+1,n):\\n                    if nums[i]+nums[j]+nums[k]==0:\\n                        a=[nums[i],nums[j],nums[k]]\\n                        a.sort()\\n                        t=tuple(a)\\n                        \\n                        if t not in s:\\n                            ans.append([nums[i],nums[j],nums[k]])\\n                            s.add(t)\\n        return ans\\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        s=set()\\n        d={}\\n        for i in range(n):\\n            if nums[i] not in d:\\n                d[nums[i]]=[i]\\n            else:\\n                d[nums[i]].append(i)\\n            \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                target=0-nums[i]-nums[j]\\n                if target in d:\\n                    if nums[i]==0 and nums[j]==0: \\n                        if len(d[target])>=3 :\\n                            a=[nums[i],nums[j],target]\\n                            a.sort()\\n                            t=tuple(a)\\n                            if t not in s:\\n                                ans.append(a)\\n                                s.add(tuple(a))\\n                        else:\\n                            continue\\n                            \\n                        \\n                    elif (nums[i]==target or nums[j]==target) and len(d[target])>=2 :\\n                        \\n                        a=[nums[i],nums[j],target]\\n                        \\n                        a.sort()\\n                        t=tuple(a)\\n                        if t not in s:\\n                            ans.append(a)\\n                            s.add(tuple(a))\\n                    elif d[target][0]!=i and d[target][0]!=j:\\n                        \\n                        a=[nums[i],nums[j],target]\\n                        a.sort()\\n                        t=tuple(a)\\n                        if t not in s:\\n                            ans.append(a)\\n                            s.add(tuple(a))\\n                        \\n                    \\n        return ans\\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        ans=[]\\n        s=set()\\n        n=len(nums)\\n        for i in range(n):\\n            target=0-nums[i]\\n            j=i+1\\n            k=n-1\\n            while j<k:\\n                summ=nums[j]+nums[k]\\n                if summ==target:\\n                    a=[nums[i],nums[j],nums[k]]\\n                    a.sort()\\n                    t=tuple(a)\\n                    if t not in s:\\n                        ans.append(a)\\n                        s.add(t)\\n                    j+=1\\n                    k-=1\\n                elif summ>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603431,
                "title": "java-solution-using-hashset-and-2-pointer",
                "content": "**Upvote if you LIKE** \\uD83D\\uDE42 \\n\\nclass Solution {\\n\\n    public List<List<Integer>> threeSum(int[] nums) {\\n\\n        HashSet<List<Integer>> ans = new HashSet<>();\\n        if(nums.length<3)\\n            return new ArrayList(ans);\\n        else{\\n            Arrays.sort(nums);\\n            for(int i=0;i<nums.length-2;i++){\\n                int l = i+1,r = nums.length-1;\\n                while(l<r){\\n                    int sum = nums[l]+nums[r]+nums[i];\\n                    if(sum==0)\\n                        ans.add(Arrays.asList(nums[i], nums[l], nums[r]));\\n                    if(sum<0)\\n                        l++;\\n                    else\\n                        r--;\\n                }\\n            }\\n        }\\n        return new ArrayList(ans);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public List<List<Integer>> threeSum(int[] nums) {\\n\\n        HashSet<List<Integer>> ans = new HashSet<>();\\n        if(nums.length<3)\\n            return new ArrayList(ans);\\n        else{\\n            Arrays.sort(nums);\\n            for(int i=0;i<nums.length-2;i++){\\n                int l = i+1,r = nums.length-1;\\n                while(l<r){\\n                    int sum = nums[l]+nums[r]+nums[i];\\n                    if(sum==0)\\n                        ans.add(Arrays.asList(nums[i], nums[l], nums[r]));\\n                    if(sum<0)\\n                        l++;\\n                    else\\n                        r--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1541269,
                "title": "c-simple-solution-beats-80",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        if(n<3) return result;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                int sum = 0 - nums[i];\\n                \\n                while(low < high)\\n                {\\n                    if((nums[low] + nums[high]) == sum)\\n                    {\\n                        result.push_back({nums[i],nums[low],nums[high]});\\n                        while(low<high && nums[low]==nums[low+1]) low++;\\n                        while(low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    }\\n                    else if((nums[low] + nums[high]) > sum)\\n                    {\\n                        high--;\\n                    }\\n                    else low++;\\n                }\\n            }\\n            }\\n        return result;\\n        }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        if(n<3) return result;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                int sum = 0 - nums[i];\\n                \\n                while(low < high)\\n                {\\n                    if((nums[low] + nums[high]) == sum)\\n                    {\\n                        result.push_back({nums[i],nums[low],nums[high]}",
                "codeTag": "Java"
            },
            {
                "id": 975552,
                "title": "javascript-three-sum-with-sort-with-helpful-comments",
                "content": "This problem is pretty insane, but it gets a lot easier if you sort from smallest to largest number beforehand (**this takes O(n log(n)) time**). After that, it\\'s easy to skip over the duplicate numbers to avoid duplicate results in our output array. \\n\\nI did not get this answer by myself. I gave myself 30 minutes to try to understand. My original plan was to do twoSum, and instead of two numbers equaling zero, two numbers would equal to a fixed target negative target. I ran into many problems this way, so I decided to just look at the answers.\\n\\nI\\'ve come to realize this stuff is not intuitive, and it\\'s okay to learn this way at times.\\n\\n```\\nconst threeSum = (nums) => {\\n\\tnums.sort(); // O(n log(n)) time\\n\\tlet result = [];\\n\\t// This `i` will be our FIXED value, while the left and right pointers move around\\n\\tfor (let i = 0; i <= nums.length - 3; i++) {\\n\\t\\t// if index > 0 and current number equals previous number\\n\\t\\t// We do not want duplicates, and already taken the previous answer\\n\\t\\t// Skip this iteration with `continue`\\n\\t\\tif (i > 0 && nums[i] === nums[i - 1]) continue;\\n\\t\\t// nums[i] is fixed, left and right are moving\\n\\t\\tlet left = i + 1;\\n\\t\\tlet right = nums.length - 1;\\n\\t\\twhile (left < right) {\\n\\t\\t\\tconst s = nums[i] + nums[left] + nums[right];\\n\\t\\t\\t// When sorted, moving from left to right increased sum\\n\\t\\t\\tif (s < 0) left += 1;\\n\\t\\t\\t// When sorted, moving from right to left decreases sum\\n\\t\\t\\telse if (s > 0) right -= 1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// We found three numbers that sum up to target\\n\\t\\t\\t\\tresult.push([nums[i], nums[left], nums[right]]);\\n\\t\\t\\t\\t// Get rid of duplicates\\n\\t\\t\\t\\twhile (left < right && nums[left] === nums[left + 1]) left += 1;\\n\\t\\t\\t\\t// Get rid of duplicates\\n\\t\\t\\t\\twhile (left < right && nums[right] === nums[right - 1])\\n\\t\\t\\t\\t\\tright -= 1;\\n\\t\\t\\t\\t// Our left and right pointers are still on a duplicate , so move one more time\\n\\t\\t\\t\\tleft += 1;\\n\\t\\t\\t\\tright -= 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nconst threeSum = (nums) => {\\n\\tnums.sort(); // O(n log(n)) time\\n\\tlet result = [];\\n\\t// This `i` will be our FIXED value, while the left and right pointers move around\\n\\tfor (let i = 0; i <= nums.length - 3; i++) {\\n\\t\\t// if index > 0 and current number equals previous number\\n\\t\\t// We do not want duplicates, and already taken the previous answer\\n\\t\\t// Skip this iteration with `continue`\\n\\t\\tif (i > 0 && nums[i] === nums[i - 1]) continue;\\n\\t\\t// nums[i] is fixed, left and right are moving\\n\\t\\tlet left = i + 1;\\n\\t\\tlet right = nums.length - 1;\\n\\t\\twhile (left < right) {\\n\\t\\t\\tconst s = nums[i] + nums[left] + nums[right];\\n\\t\\t\\t// When sorted, moving from left to right increased sum\\n\\t\\t\\tif (s < 0) left += 1;\\n\\t\\t\\t// When sorted, moving from right to left decreases sum\\n\\t\\t\\telse if (s > 0) right -= 1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// We found three numbers that sum up to target\\n\\t\\t\\t\\tresult.push([nums[i], nums[left], nums[right]]);\\n\\t\\t\\t\\t// Get rid of duplicates\\n\\t\\t\\t\\twhile (left < right && nums[left] === nums[left + 1]) left += 1;\\n\\t\\t\\t\\t// Get rid of duplicates\\n\\t\\t\\t\\twhile (left < right && nums[right] === nums[right - 1])\\n\\t\\t\\t\\t\\tright -= 1;\\n\\t\\t\\t\\t// Our left and right pointers are still on a duplicate , so move one more time\\n\\t\\t\\t\\tleft += 1;\\n\\t\\t\\t\\tright -= 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909839,
                "title": "c-using-set-and-two-pointers-and-inline-comments",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums)\\n    {\\n        int i, j, k, size = nums.size();\\n        vector<vector<int>> result;\\n        set<vector<int>> triplets;\\n        i = 0;\\n\\n        if (size >= 3) {\\n            sort(nums.begin(), nums.end());\\n            \\n            while (i < size - 2) {\\n                j = i + 1, k = size - 1;\\n                while (j < k) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    \\n                    //if sum is less than 0, then number to be added is to the right of j\\n                    if (sum < 0) {\\n                        j++;\\n                    }\\n                    //if sum is greater than 0, then number to be added is to the left of k\\n                    else if (sum > 0) {\\n                        k--;\\n                    }\\n                    //sum is 0, check if similar triplet are present, if not add it to the semi result. \\n                    //set datastruture handles duplicates for us\\n                    else {\\n                        triplets.insert({ nums[i], nums[j], nums[k] });\\n                        j++, k--;\\n                    }\\n                }\\n                i++;\\n            }\\n\\t\\t\\t//copy list of unique triplets to final return value\\n\\t\\t\\tresult.assign(triplets.begin(), triplets.end());\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums)\\n    {\\n        int i, j, k, size = nums.size();\\n        vector<vector<int>> result;\\n        set<vector<int>> triplets;\\n        i = 0;\\n\\n        if (size >= 3) {\\n            sort(nums.begin(), nums.end());\\n            \\n            while (i < size - 2) {\\n                j = i + 1, k = size - 1;\\n                while (j < k) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    \\n                    //if sum is less than 0, then number to be added is to the right of j\\n                    if (sum < 0) {\\n                        j++;\\n                    }\\n                    //if sum is greater than 0, then number to be added is to the left of k\\n                    else if (sum > 0) {\\n                        k--;\\n                    }\\n                    //sum is 0, check if similar triplet are present, if not add it to the semi result. \\n                    //set datastruture handles duplicates for us\\n                    else {\\n                        triplets.insert({ nums[i], nums[j], nums[k] });\\n                        j++, k--;\\n                    }\\n                }\\n                i++;\\n            }\\n\\t\\t\\t//copy list of unique triplets to final return value\\n\\t\\t\\tresult.assign(triplets.begin(), triplets.end());\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448642,
                "title": "c-neat-commented-sort-two-pointer-solution-beats-90-runtime-100-memory",
                "content": "```\\n// sort + 2 pointer.\\nvector<vector<int>> threeSum(vector<int>& nums) \\n{\\n\\tvector <vector <int>> ret;\\n\\n\\t// sort\\n\\tsort (nums.begin (), nums.end ());\\n\\n\\t// seg1\\n\\tfor (int i = 0; i < nums.size (); i++) \\n\\t{\\n\\t\\t// eliminate duplicate i-s in seg1.\\n\\t\\tif (i > 0 && nums [i] == nums [i-1])  \\n\\t\\t\\tcontinue;\\n\\n\\t\\t// seg2, seg3\\n\\t\\tint left = i + 1, right = nums.size () - 1; \\n\\t\\twhile (left < right)\\n\\t\\t{\\n\\t\\t\\tint sum = nums [i] + nums [left] + nums [right];\\n\\t\\t\\tif (sum == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// match.\\n\\t\\t\\t\\tret.push_back ({nums[i], nums[left], nums[right]});\\n\\n\\t\\t\\t\\t// progress seg2, seg3. nums[left], nums[right] has to be unique.\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\n\\t\\t\\t\\t// eliminate duplicates in seg2, 3.\\n\\t\\t\\t\\t// and continue as there may be more answers with the same nums[i].\\n\\t\\t\\t\\twhile (left < right)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (nums [left] == nums [left-1])\\n\\t\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t\\telse if (nums [right] == nums [right+1])\\n\\t\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// seek.\\n\\t\\t\\t\\tif (sum > 0)\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// sort + 2 pointer.\\nvector<vector<int>> threeSum(vector<int>& nums) \\n{\\n\\tvector <vector <int>> ret;\\n\\n\\t// sort\\n\\tsort (nums.begin (), nums.end ());\\n\\n\\t// seg1\\n\\tfor (int i = 0; i < nums.size (); i++) \\n\\t{\\n\\t\\t// eliminate duplicate i-s in seg1.\\n\\t\\tif (i > 0 && nums [i] == nums [i-1])  \\n\\t\\t\\tcontinue;\\n\\n\\t\\t// seg2, seg3\\n\\t\\tint left = i + 1, right = nums.size () - 1; \\n\\t\\twhile (left < right)\\n\\t\\t{\\n\\t\\t\\tint sum = nums [i] + nums [left] + nums [right];\\n\\t\\t\\tif (sum == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// match.\\n\\t\\t\\t\\tret.push_back ({nums[i], nums[left], nums[right]});\\n\\n\\t\\t\\t\\t// progress seg2, seg3. nums[left], nums[right] has to be unique.\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\n\\t\\t\\t\\t// eliminate duplicates in seg2, 3.\\n\\t\\t\\t\\t// and continue as there may be more answers with the same nums[i].\\n\\t\\t\\t\\twhile (left < right)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (nums [left] == nums [left-1])\\n\\t\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t\\telse if (nums [right] == nums [right+1])\\n\\t\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// seek.\\n\\t\\t\\t\\tif (sum > 0)\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432389,
                "title": "simple-and-optimal-c-solution-faster-than-98-28-with-explanation-and-tips",
                "content": "**Tips:**\\n* Solving a 2-sum version of this problem will help clarify a 3-sum solution\\n* Some sliding window problems are easier to solve if the array is sorted\\n* When working with sorted arrays, there\\'s usually no need for a hash to keep track of uniques\\n\\n**Solution + explanation:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        \\n        // edge-case, return an empty vector if nums is empty\\n        if (nums.empty()) return res;\\n        \\n        int len = nums.size();\\n        \\n        // sort numbers, n log n\\n        sort(begin(nums), end(nums));\\n        \\n        for (int i = 0; i < len; i++) {\\n            // if nums[i] is larger than zero, we\\'re out of potential combinations\\n            if (nums[i] > 0) return res;\\n\\n            // skip if we already processed this number\\n            if (i > 0 and nums[i] == nums[i - 1]) continue;\\n            \\n            // now that one of the numbers is fixed (nums[i])\\n            // we can find matches using a sliding window\\n            int left = i + 1;\\n            int right = len - 1;\\n            \\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum > 0) {\\n                    right--;\\n                } else if (sum < 0) {\\n                    left++;\\n                } else {\\n                    // we\\'ve got a match\\n                    res.push_back({nums[i], nums[left], nums[right]});\\n                    \\n                    // to avoid duplicates, we need to skip numbers\\n                    // we already processed\\n                    while (left < right && nums[left] == nums[left + 1]) left++;\\n                    while (left < right && nums[right] == nums[right - 1]) right--;\\n                    left++, right--;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        \\n        // edge-case, return an empty vector if nums is empty\\n        if (nums.empty()) return res;\\n        \\n        int len = nums.size();\\n        \\n        // sort numbers, n log n\\n        sort(begin(nums), end(nums));\\n        \\n        for (int i = 0; i < len; i++) {\\n            // if nums[i] is larger than zero, we\\'re out of potential combinations\\n            if (nums[i] > 0) return res;\\n\\n            // skip if we already processed this number\\n            if (i > 0 and nums[i] == nums[i - 1]) continue;\\n            \\n            // now that one of the numbers is fixed (nums[i])\\n            // we can find matches using a sliding window\\n            int left = i + 1;\\n            int right = len - 1;\\n            \\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum > 0) {\\n                    right--;\\n                } else if (sum < 0) {\\n                    left++;\\n                } else {\\n                    // we\\'ve got a match\\n                    res.push_back({nums[i], nums[left], nums[right]});\\n                    \\n                    // to avoid duplicates, we need to skip numbers\\n                    // we already processed\\n                    while (left < right && nums[left] == nums[left + 1]) left++;\\n                    while (left < right && nums[right] == nums[right - 1]) right--;\\n                    left++, right--;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430122,
                "title": "accepted-o-n-2-python-solution-with-explanation-how-to-avoid-tle-time-limit-exceeded",
                "content": "Here are some things to consider when breaking down this problem:\\n* In order to make a zero sum, you need a positive and a negative number, or all zeros. You can\\'t make a zero sum with 3 positive numbers or 3 negative numbers. \\n* How can we avoid repeated combinations?\\n* What are some ways to create the combination of three numbers?\\n\\t* What are some efficient search methods?\\n\\t\\t* If we start with one number, how do we find the two remaining numbers which create a zero sum?\\n\\t\\t* Alternatively, if we start with two numbers, how do we find the remaining number to create a zero sum?\\n\\nThe intuitive solution you may come up with might look something like this:\\n```\\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\\n\\tans = set()\\n\\tcount = collections.Counter(nums) # O(N)\\n\\tfor i in range(len(nums)):\\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tx, y = nums[i], nums[j]\\n\\t\\t\\tcount[x] -= 1\\n\\t\\t\\tcount[y] -= 1\\n\\t\\t\\tkey = -(x+y)\\n\\t\\t\\tif key in count and count[key] > 0:\\n\\t\\t\\t\\tans.add(tuple(sorted([x, y, key])))\\n\\t\\t\\tcount[x] += 1\\n\\t\\t\\tcount[y] += 1\\n\\treturn list(ans) #O(N)\\n```\\nThis solution runs in O(N^2) and takes O(N) space, so why does it exceed the time limit upon submission? It\\'s probably because the question wants us to think more critically about the cases where this solution is inefficient. For example:\\n* In the worst case we have array of all postive numbers which could never add to zero\\n* We have a large array of all repeated elements.\\n\\nFor these two cases, our algorithm still runs in O(N^2) and tries to create all unique combinations, even though there is only one or zero combinations in the result. We can get better results for those two edge cases if we sort the list first and add some conditions that would avoid trying to create unique combinations when we know it\\'s pointless. If our list is sorted and we start with a positive integer, then we know that there are no possible zero sum combinations remaining because in order to make a zero sum, we need a positive and negative number or all zeros. Similarly, if we have an input with many repeated elements, we can create combinations starting from the first unique element, then skip all the following repeated elements.\\n\\nWith that in mind our solution would look something like this:\\n\\n```\\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\\n\\tans = []\\n\\tnums.sort()\\n\\tfor i in range(len(nums)-2):\\n\\t\\tif nums[i] > 0: # once we reach positive nums, we can never make a zero sum\\n\\t\\t\\tbreak\\n\\t\\tif i > 0 and nums[i] == nums[i-1]: # avoid duplicates\\n\\t\\t\\tcontinue\\n\\t\\tl, r = i+1, len(nums)-1\\n\\t\\twhile l < r:\\n\\t\\t\\tcurr = nums[l] + nums[r]\\n\\t\\t\\tif curr == -nums[i]:\\n\\t\\t\\t\\tans.append([nums[i], nums[l], nums[r]])\\n\\t\\t\\t\\twhile l < r and nums[l] == nums[l+1]:\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\twhile l < r and nums[r] == nums[r-1]:\\n\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\tr -=1\\n\\t\\t\\telif curr > -nums[i]:\\n\\t\\t\\t\\tr -=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tl += 1\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\\n\\tans = set()\\n\\tcount = collections.Counter(nums) # O(N)\\n\\tfor i in range(len(nums)):\\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tx, y = nums[i], nums[j]\\n\\t\\t\\tcount[x] -= 1\\n\\t\\t\\tcount[y] -= 1\\n\\t\\t\\tkey = -(x+y)\\n\\t\\t\\tif key in count and count[key] > 0:\\n\\t\\t\\t\\tans.add(tuple(sorted([x, y, key])))\\n\\t\\t\\tcount[x] += 1\\n\\t\\t\\tcount[y] += 1\\n\\treturn list(ans) #O(N)\\n```\n```\\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\\n\\tans = []\\n\\tnums.sort()\\n\\tfor i in range(len(nums)-2):\\n\\t\\tif nums[i] > 0: # once we reach positive nums, we can never make a zero sum\\n\\t\\t\\tbreak\\n\\t\\tif i > 0 and nums[i] == nums[i-1]: # avoid duplicates\\n\\t\\t\\tcontinue\\n\\t\\tl, r = i+1, len(nums)-1\\n\\t\\twhile l < r:\\n\\t\\t\\tcurr = nums[l] + nums[r]\\n\\t\\t\\tif curr == -nums[i]:\\n\\t\\t\\t\\tans.append([nums[i], nums[l], nums[r]])\\n\\t\\t\\t\\twhile l < r and nums[l] == nums[l+1]:\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\twhile l < r and nums[r] == nums[r-1]:\\n\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\tr -=1\\n\\t\\t\\telif curr > -nums[i]:\\n\\t\\t\\t\\tr -=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tl += 1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 346895,
                "title": "java-o-n-2-solution-using-hashmap-and-set",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> ts = new HashSet();\\n        HashMap<Integer, Integer> map = new HashMap();\\n        Arrays.sort(nums);\\n        for(int i = 0 ; i < nums.length;i++){\\n            map.put(nums[i], i);\\n        }\\n        for(int i = 0 ; i < nums.length; i++){\\n            int f = nums[i];\\n            for(int j = i+1; j< nums.length; j++){\\n                List<Integer> l = new ArrayList();\\n                int s = nums[j];\\n                int t = 0 - f - s;\\n                if(map.containsKey(t) && map.get(t)>j){\\n                    l.add(f);\\n                    l.add(s);\\n                    l.add(t);\\n                    ts.add(l);\\n                }\\n            }\\n        }\\n        return new ArrayList(ts);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Set<List<Integer>> ts = new HashSet();\\n        HashMap<Integer, Integer> map = new HashMap();\\n        Arrays.sort(nums);\\n        for(int i = 0 ; i < nums.length;i++){\\n            map.put(nums[i], i);\\n        }\\n        for(int i = 0 ; i < nums.length; i++){\\n            int f = nums[i];\\n            for(int j = i+1; j< nums.length; j++){\\n                List<Integer> l = new ArrayList();\\n                int s = nums[j];\\n                int t = 0 - f - s;\\n                if(map.containsKey(t) && map.get(t)>j){\\n                    l.add(f);\\n                    l.add(s);\\n                    l.add(t);\\n                    ts.add(l);\\n                }\\n            }\\n        }\\n        return new ArrayList(ts);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278589,
                "title": "easy-to-understand-javascript-solution-with-notes-beats-90",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar threeSum = function(nums) {\\n    \\n    // This is going to be a two pointers problem\\n    let left, right; \\n    let answers = []; \\n    \\n    // Here are your edge case, just return out of the problem if true;\\n    if (nums.length < 3) return answers;\\n\\n    // By sorting the problem, we can avoid 0(n^3) search when looking for \\n    // matchs. The reasoning is that since we are sorted, we can later use \\n    // a selected index and move our pointers left/right to test for matches\\n    nums = nums.sort((a,b) => { return a - b});\\n    \\n    // Here is the pointer theory\\n    // Lets iterate the array and then start with the pointers with left being one ahead\\n    // of the current i, while our right is the last index\\n    // then keep moving the pointers accordingly depending if we are larger or smaller than 0\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        // This is for repeats, lets exit out of the iteration if we have repeats\\n\\t\\t// We know if I is larger than zero since this is sorted, no other solution can make 0\\n        if (i > 0 && nums[i] === nums[i-1]) continue;\\n        \\n        //set your left and rights for each iteration\\n        left = i + 1; \\n        right = nums.length - 1; \\n        \\n        // Here is your pointers check\\n        // Lets keep on moving until the pointers come together\\n        while (left < right) {\\n            if (nums[i] + nums[left] + nums[right] === 0) {\\n                answers.push([nums[i], nums[left], nums[right]]);\\n                \\n                // Here is a tricky part. \\n                // To avoid repeats lets check for repeats again so we can avoid the same matches\\n                // for example if your next 3 \\'lefts++\\' are 2,2,2 then you would get the same match \\n                // in this iteration\\n                while (left < right && nums[left] === nums[left+1]) left++;\\n                while (left < right && nums[left] === nums[right-1]) right--;\\n                left++;\\n                right--;\\n            } \\n            \\n            // Move your pointers depending on the sum. \\n            // If your sum is less than 0 your left side must be too small. \\n            else if (nums[i] + nums[left] + nums[right] < 0) {\\n                left++;\\n            } \\n            else {\\n                right--;    \\n            }\\n        }\\n    }\\n    \\n    return answers;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar threeSum = function(nums) {\\n    \\n    // This is going to be a two pointers problem\\n    let left, right; \\n    let answers = []; \\n    \\n    // Here are your edge case, just return out of the problem if true;\\n    if (nums.length < 3) return answers;\\n\\n    // By sorting the problem, we can avoid 0(n^3) search when looking for \\n    // matchs. The reasoning is that since we are sorted, we can later use \\n    // a selected index and move our pointers left/right to test for matches\\n    nums = nums.sort((a,b) => { return a - b});\\n    \\n    // Here is the pointer theory\\n    // Lets iterate the array and then start with the pointers with left being one ahead\\n    // of the current i, while our right is the last index\\n    // then keep moving the pointers accordingly depending if we are larger or smaller than 0\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        // This is for repeats, lets exit out of the iteration if we have repeats\\n\\t\\t// We know if I is larger than zero since this is sorted, no other solution can make 0\\n        if (i > 0 && nums[i] === nums[i-1]) continue;\\n        \\n        //set your left and rights for each iteration\\n        left = i + 1; \\n        right = nums.length - 1; \\n        \\n        // Here is your pointers check\\n        // Lets keep on moving until the pointers come together\\n        while (left < right) {\\n            if (nums[i] + nums[left] + nums[right] === 0) {\\n                answers.push([nums[i], nums[left], nums[right]]);\\n                \\n                // Here is a tricky part. \\n                // To avoid repeats lets check for repeats again so we can avoid the same matches\\n                // for example if your next 3 \\'lefts++\\' are 2,2,2 then you would get the same match \\n                // in this iteration\\n                while (left < right && nums[left] === nums[left+1]) left++;\\n                while (left < right && nums[left] === nums[right-1]) right--;\\n                left++;\\n                right--;\\n            } \\n            \\n            // Move your pointers depending on the sum. \\n            // If your sum is less than 0 your left side must be too small. \\n            else if (nums[i] + nums[left] + nums[right] < 0) {\\n                left++;\\n            } \\n            else {\\n                right--;    \\n            }\\n        }\\n    }\\n    \\n    return answers;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142616,
                "title": "clean-c-solution",
                "content": "```\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nint comparator(const void *a, const void *b)\\n{\\n    int l = *(const int*)a;\\n    int r = *(const int*)b;\\n    return l-r;\\n}\\nint** threeSum(int* arr, int size, int* returnSize) \\n{\\n    if(arr == NULL || size == 0)\\n        return NULL;\\n \\n    qsort((void *)arr, size, sizeof(arr[0]),comparator );\\n    int count = 0;\\n    int **res = NULL;\\n\\n    for(int i = 0; i < size; i++)\\n    {\\n\\n        int start = i + 1;\\n        int end = size - 1;\\n        int sum;\\n  \\n\\t// handles duplicates for i position\\n        if(i > 0 && arr[i] == arr[i - 1])\\n            continue;\\n\\n        while(start < end )\\n        {\\n            \\n            sum = arr[i] + arr[start] + arr[end];\\n            if(sum == 0)\\n            {\\n                count++;\\n                res = (int **)realloc(res, sizeof(int *) * count);\\n                res[count - 1] = (int *) malloc(sizeof(int)*3);\\n                res[count - 1][0] = arr[i];\\n                res[count - 1][1] = arr[start];\\n                res[count - 1][2] = arr[end];\\n                //handle duplicates for start index\\n                while(start < end && arr[start] == arr[start + 1])\\n                    start++;\\n                //handle duplicates for end index\\n                while(start < end && arr[end] == arr[end -1])\\n                    end--;\\n                \\n                start++;\\n                end--;\\n            }\\n            else if(sum > 0)\\n                end--;\\n            else\\n                start++;\\n        }\\n    }\\n    *returnSize = count;\\n    return res;\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nint comparator(const void *a, const void *b)\\n{\\n    int l = *(const int*)a;\\n    int r = *(const int*)b;\\n    return l-r;\\n}\\nint** threeSum(int* arr, int size, int* returnSize) \\n{\\n    if(arr == NULL || size == 0)\\n        return NULL;\\n \\n    qsort((void *)arr, size, sizeof(arr[0]),comparator );\\n    int count = 0;\\n    int **res = NULL;\\n\\n    for(int i = 0; i < size; i++)\\n    {\\n\\n        int start = i + 1;\\n        int end = size - 1;\\n        int sum;\\n  \\n\\t// handles duplicates for i position\\n        if(i > 0 && arr[i] == arr[i - 1])\\n            continue;\\n\\n        while(start < end )\\n        {\\n            \\n            sum = arr[i] + arr[start] + arr[end];\\n            if(sum == 0)\\n            {\\n                count++;\\n                res = (int **)realloc(res, sizeof(int *) * count);\\n                res[count - 1] = (int *) malloc(sizeof(int)*3);\\n                res[count - 1][0] = arr[i];\\n                res[count - 1][1] = arr[start];\\n                res[count - 1][2] = arr[end];\\n                //handle duplicates for start index\\n                while(start < end && arr[start] == arr[start + 1])\\n                    start++;\\n                //handle duplicates for end index\\n                while(start < end && arr[end] == arr[end -1])\\n                    end--;\\n                \\n                start++;\\n                end--;\\n            }\\n            else if(sum > 0)\\n                end--;\\n            else\\n                start++;\\n        }\\n    }\\n    *returnSize = count;\\n    return res;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2980593,
                "title": "python-easy-beats-80",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the array. use a for loop to iterate one index and then use **two pointers approach** intilise l=i+1 and r = last then use while and check if the numbers at indices i+l+r ==0 , if they are then append them to the result and increment l and then check if nums[l] == nums[l-1] then increment l till condition fails this is done to **skip the duplicates** and check if sum >0 then decrement r else increment l and then return result. Always check if i>0 and nums[i] == nums[i-1] , if it is then skip the iteration to **skip the duplicates**.\\n\\n# Complexity\\n- Time complexity: $$O(n2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ **if we assume that the result array\\'s space doesn\\'t count.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        res = []\\n\\n        nums.sort()\\n\\n        for i in range(len(nums)):\\n\\n            if i>0 and nums[i]==nums[i-1]:\\n                continue\\n\\n            l = i+1\\n            r = len(nums)-1\\n\\n            while(l<r):\\n                if nums[i]+nums[l]+nums[r]==0:\\n                    res.append([nums[i],nums[l],nums[r]])\\n                    l+=1\\n                    while nums[l]==nums[l-1] and l<r:\\n                        l+=1\\n\\n                elif nums[i]+nums[l]+nums[r]>0:\\n                    r-=1\\n\\n                else:\\n                    l+=1\\n        return res                            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        res = []\\n\\n        nums.sort()\\n\\n        for i in range(len(nums)):\\n\\n            if i>0 and nums[i]==nums[i-1]:\\n                continue\\n\\n            l = i+1\\n            r = len(nums)-1\\n\\n            while(l<r):\\n                if nums[i]+nums[l]+nums[r]==0:\\n                    res.append([nums[i],nums[l],nums[r]])\\n                    l+=1\\n                    while nums[l]==nums[l-1] and l<r:\\n                        l+=1\\n\\n                elif nums[i]+nums[l]+nums[r]>0:\\n                    r-=1\\n\\n                else:\\n                    l+=1\\n        return res                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810009,
                "title": "very-easy-js-solution-with-the-use-of-two-loop-and-js-object-to-remove-duplicate-triplets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnly used two loops and for removeing dublicate triplets used simple javaScript objects.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar threeSum = function(nums) {\\n    \\n    let obj={}\\n    nums=nums.sort((a,b)=>a-b)\\n    // console.log(nums)\\n    for(let start=0;start<nums.length;start++){\\n        let right=nums.length-1\\n        let left=start+1\\n        while(left<right){\\n            if(nums[left]+nums[right]+nums[start]==0){\\n                // console.log(start,left,right)\\n                // arr.push([nums[start],nums[left],nums[right]])\\n                obj[[nums[start],nums[left],nums[right]]]=[nums[start],nums[left],nums[right]]\\n                left++\\n                right--\\n            }else if(nums[left]+nums[right]+nums[start]>0){\\n                right--\\n            }else if(nums[left]+nums[right]+nums[start]<0){\\n                left++\\n            }\\n        }\\n    }\\n     return (Object.values(obj))\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar threeSum = function(nums) {\\n    \\n    let obj={}\\n    nums=nums.sort((a,b)=>a-b)\\n    // console.log(nums)\\n    for(let start=0;start<nums.length;start++){\\n        let right=nums.length-1\\n        let left=start+1\\n        while(left<right){\\n            if(nums[left]+nums[right]+nums[start]==0){\\n                // console.log(start,left,right)\\n                // arr.push([nums[start],nums[left],nums[right]])\\n                obj[[nums[start],nums[left],nums[right]]]=[nums[start],nums[left],nums[right]]\\n                left++\\n                right--\\n            }else if(nums[left]+nums[right]+nums[start]>0){\\n                right--\\n            }else if(nums[left]+nums[right]+nums[start]<0){\\n                left++\\n            }\\n        }\\n    }\\n     return (Object.values(obj))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2688472,
                "title": "js-two-ways-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/3sum.html\\nIt is very useful, and I just wanted to share it with you.\\n\\n```\\nfunction threeSum(nums) {\\n    // If less than 3 elements then we can\\'t have 3 numbers that add to 0\\n    if(nums.length < 3) return []\\n    const output = []\\n\\n    // Sort the array in descending order. Must add order function to sort. If not we will not get the right order. Sort converts everything to a string and sorts the array by charCode. Adding the order function to sort guarantees we will get the array in the proper descending order.\\n    nums.sort((a,b) => a - b)\\n\\n    for(let i = 0; i < nums.length - 2;i++) {\\n        // we don\\'t want repeats, so skip numbers we\\'ve already seen\\n        if (i > 0 && nums[i] === nums[i - 1]) continue\\n\\n        let left = i+1\\n        let right = nums.length-1\\n\\n        // Current number at i will be added to the current sum. We will move a left and a right pointer in the subarray of elements to the right of i to try and get a sum that will equal 0\\n        while (left < right) {\\n            // Get the current sum with with number at i and numbers at the left and right pointers\\n            const sum = nums[i] + nums[right] + nums[left]\\n            // If we get 0 then we add all the numbers to output and move our left and right pointers to look for more numbers that will add to 0 with the current number at i\\n            if(sum===0) {\\n                output.push([nums[i], nums[left], nums[right]])\\n                // We will move the pointers until we find a number that is not equal to each pointers current number\\n                while(nums[left]===nums[left+1]) left++\\n                while(nums[right]===nums[right-1]) right--\\n                left++\\n                right--\\n            } else if (sum > 0) {\\n                // If the sum is greater than 0 that means we need smaller numbers to get 0 so we move the right pointer to the left\\n               right--\\n            } else {\\n                // If the sum is less than 0 that means we need higher numbers to get 0 so we move the left pointer to the right\\n                left++\\n            }\\n        }\\n    }\\n\\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction threeSum(nums) {\\n    // If less than 3 elements then we can\\'t have 3 numbers that add to 0\\n    if(nums.length < 3) return []\\n    const output = []\\n\\n    // Sort the array in descending order. Must add order function to sort. If not we will not get the right order. Sort converts everything to a string and sorts the array by charCode. Adding the order function to sort guarantees we will get the array in the proper descending order.\\n    nums.sort((a,b) => a - b)\\n\\n    for(let i = 0; i < nums.length - 2;i++) {\\n        // we don\\'t want repeats, so skip numbers we\\'ve already seen\\n        if (i > 0 && nums[i] === nums[i - 1]) continue\\n\\n        let left = i+1\\n        let right = nums.length-1\\n\\n        // Current number at i will be added to the current sum. We will move a left and a right pointer in the subarray of elements to the right of i to try and get a sum that will equal 0\\n        while (left < right) {\\n            // Get the current sum with with number at i and numbers at the left and right pointers\\n            const sum = nums[i] + nums[right] + nums[left]\\n            // If we get 0 then we add all the numbers to output and move our left and right pointers to look for more numbers that will add to 0 with the current number at i\\n            if(sum===0) {\\n                output.push([nums[i], nums[left], nums[right]])\\n                // We will move the pointers until we find a number that is not equal to each pointers current number\\n                while(nums[left]===nums[left+1]) left++\\n                while(nums[right]===nums[right-1]) right--\\n                left++\\n                right--\\n            } else if (sum > 0) {\\n                // If the sum is greater than 0 that means we need smaller numbers to get 0 so we move the right pointer to the left\\n               right--\\n            } else {\\n                // If the sum is less than 0 that means we need higher numbers to get 0 so we move the left pointer to the right\\n                left++\\n            }\\n        }\\n    }\\n\\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621896,
                "title": "c-solution-3sum-two-pointer-approach-o-n-2-using-two-sum",
                "content": "**1. Using Two Pointer Approach**\\n* Pre-requisites : [Two Sum](https://leetcode.com/problems/two-sum/) , [Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) (For Better Understanding)\\n* Time Complexity : O(N^2)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // initializing start, end and sum\\n        int s, e, sum = 0;\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        \\n        // for loop to fix the first element of the triplet\\n        for(int i = 0; i < n; i++){\\n            //if the very first element of the array is greater than 0(which is smallest element after sorting), then triplet cannot be formed\\n            if(nums[i] > 0){\\n                break;\\n            }\\n            \\n            // to avoid duplicacy skip the iteration if to adjacent element are equal\\n            if(i > 0 && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            \\n            //After fixing first element, we are left with TWO SUM problem\\n            s = i + 1; \\n            e = n - 1;\\n            while(s < e){\\n                sum = nums[i] + nums[s] + nums[e];\\n                if(sum < 0){\\n                    s++;\\n                }\\n                else if(sum > 0){\\n                    e--;\\n                }\\n                else{\\n                    ans.push_back({nums[i], nums[s], nums[e]});\\n                    s++, e--;\\n                    \\n                    //increment s and e, to the new positions\\n                    while(s < e && nums[s] == nums[s-1])\\n                        s++;\\n                    while(s < e && nums[e] == nums[e+1])\\n                        e--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if it helps you :)\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // initializing start, end and sum\\n        int s, e, sum = 0;\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        \\n        // for loop to fix the first element of the triplet\\n        for(int i = 0; i < n; i++){\\n            //if the very first element of the array is greater than 0(which is smallest element after sorting), then triplet cannot be formed\\n            if(nums[i] > 0){\\n                break;\\n            }\\n            \\n            // to avoid duplicacy skip the iteration if to adjacent element are equal\\n            if(i > 0 && nums[i] == nums[i-1]){\\n                continue;\\n            }\\n            \\n            //After fixing first element, we are left with TWO SUM problem\\n            s = i + 1; \\n            e = n - 1;\\n            while(s < e){\\n                sum = nums[i] + nums[s] + nums[e];\\n                if(sum < 0){\\n                    s++;\\n                }\\n                else if(sum > 0){\\n                    e--;\\n                }\\n                else{\\n                    ans.push_back({nums[i], nums[s], nums[e]});\\n                    s++, e--;\\n                    \\n                    //increment s and e, to the new positions\\n                    while(s < e && nums[s] == nums[s-1])\\n                        s++;\\n                    while(s < e && nums[e] == nums[e+1])\\n                        e--;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668432,
                "title": "2types-of-solution-using-2pointer-hashmap-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n- As the array has both -ve and +ve numbers, firstly we sort the array. The sorted array would have -ve numbers together and +ve numbers together in increasing order. This will make it easy for searching the required numbers to make a 0 sum.\\n- Base cases after sorting:\\n    1. If array size is < 3, means no triplet would exist from that array. Return an empty vector of vectors.\\n    2. If the first element is +ve, that means there is no -ve number by which we can make a 0 triplet sum. Return an empty vector of vectors.\\n\\n### Solution 01\\n\\n- Using ***Two pointer approach.***\\n- Traverse the array and fix a number at every iteration.\\n- If number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\n- If the number is getting repeated, ignore the lower loop and continue. This is for unique triplets. We want the last instance of the fixed number if it is repeated.\\n- Make two pointers high and low, and initialize the sum as 0.\\n- Search between two pointers, just similiar to binary search. ***Sum = num[i] + num[low] + num[high].***\\n- If the sum is -ve, means, we need more +ve numbers to make it 0, increment low (low++).\\n- If the sum is +ve, means, we need more -ve numbers to make it 0, decrement high (high--).\\n- If the sum is 0, that means we have found the required triplet, push it in the answer vector.\\n- Now again, to avoid duplicate triplets, we have to navigate to the last occurrences of num[low] and num[high] respectively. Update the low and high with the last occurrences of low and high.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- Using ***Hashmap.***\\n- We will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurrence index would be stored in hashMap.\\n- Here also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave the last two indices. These last two indices would be covered by the nested loop.\\n- If the number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\n- Make a nested loop to fix a number after the first fixed number. (num[j])\\n- To make sum 0, we would require the -ve sum of both fixed numbers. Let us say this is required.\\n- Now, we will find this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in the answer vector.\\n- Update j to last occurrence of 2nd fixed number to avoid duplicate triplets.\\n- Update i to last occurrence of 1st fixed number to avoid duplicate triplets.\\n- Return answer vector.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;  \\n        int n=nums.size();\\n         \\n\\t\\t\\t\\tif(n<3 || nums[0]>0)\\n            return ans;\\n        \\n\\t\\t\\t\\tint i=0, low=1, high=n-1, a=nums[0], b=0, c=0, x=0;\\n        \\n\\t\\t\\t\\twhile(i<n){\\n\\t\\t\\t\\t\\t\\tif(nums[i]>0) //we can\\'t get 0 from here on\\n                break;\\n\\n           if(nums[i]!=a){\\n                a= nums[i];\\n                high = n-1;\\n                low = i+1;\\n           }\\n           if(nums[i]==a && low<high){\\n                x=0-a;\\n                b=nums[low];\\n                c=nums[high];\\n\\n                if(b+c==x)\\n                {\\n                    ans.push_back({a,b,c});\\n                    low++;\\n                    high--;\\n                    \\n                    while(low<n && b==nums[low]) low++;\\n                    while(high>=0 && b==nums[high]) high--;\\n                                \\n                    continue;\\n                }\\n                else if(b+c<x && low<n){ low++;continue;}\\n                else if(b+c>x && high>=0){ high--;continue;}\\n            }\\n            if(low>=high || (nums[i]==a && i>0)) i++;\\n        }\\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        if(n<3 || nums[0]>0)\\n            return {};\\n        \\n        vector<vector<int>>ans;  \\n        unordered_map<int, int> mp;\\n\\n        for(int i=0; i<n; i++)\\n            mp[nums[i]]=i;\\n\\n        for(int i=0; i<n-2; i++){\\n            if(nums[i]>0) //we can\\'t get 0 from here on\\n                break;\\n            \\n            for(int j=i+1; j<n-1; j++){\\n              \\n                if(mp.count(-(nums[i]+nums[j])) && mp.find(-(nums[i]+nums[j]))->second > j)\\n                    ans.push_back({nums[i],nums[j],-(nums[i]+nums[j])});\\n                \\n                j = mp.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = mp.find(nums[i])->second; //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n         \\n        return ans;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;  \\n        int n=nums.size();\\n         \\n\\t\\t\\t\\tif(n<3 || nums[0]>0)\\n            return ans;\\n        \\n\\t\\t\\t\\tint i=0, low=1, high=n-1, a=nums[0], b=0, c=0, x=0;\\n        \\n\\t\\t\\t\\twhile(i<n){\\n\\t\\t\\t\\t\\t\\tif(nums[i]>0) //we can\\'t get 0 from here on\\n                break;\\n\\n           if(nums[i]!=a){\\n                a= nums[i];\\n                high = n-1;\\n                low = i+1;\\n           }\\n           if(nums[i]==a && low<high){\\n                x=0-a;\\n                b=nums[low];\\n                c=nums[high];\\n\\n                if(b+c==x)\\n                {\\n                    ans.push_back({a,b,c});\\n                    low++;\\n                    high--;\\n                    \\n                    while(low<n && b==nums[low]) low++;\\n                    while(high>=0 && b==nums[high]) high--;\\n                                \\n                    continue;\\n                }\\n                else if(b+c<x && low<n){ low++;continue;}\\n                else if(b+c>x && high>=0){ high--;continue;}\\n            }\\n            if(low>=high || (nums[i]==a && i>0)) i++;\\n        }\\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        if(n<3 || nums[0]>0)\\n            return {};\\n        \\n        vector<vector<int>>ans;  \\n        unordered_map<int, int> mp;\\n\\n        for(int i=0; i<n; i++)\\n            mp[nums[i]]=i;\\n\\n        for(int i=0; i<n-2; i++){\\n            if(nums[i]>0) //we can\\'t get 0 from here on\\n                break;\\n            \\n            for(int j=i+1; j<n-1; j++){\\n              \\n                if(mp.count(-(nums[i]+nums[j])) && mp.find(-(nums[i]+nums[j]))->second > j)\\n                    ans.push_back({nums[i],nums[j],-(nums[i]+nums[j])});\\n                \\n                j = mp.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = mp.find(nums[i])->second; //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n         \\n        return ans;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958695,
                "title": "c-84-ms-faster-than-77-66-two-pointers-heavily-documented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3) return {}; // no triplets if size < 3\\n         vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++) { // since high will be the last  element, we will iterate till n-1\\n            if(i!=0 && nums[i]==nums[i-1]) continue; // same elements, so keep on moving left\\n            int low=i+1,high=n-1; // always look at the gap from the current number +1\\n            while(low<high) {\\n                int sum=nums[i]+nums[low]+nums[high];\\n                if(sum==0) {\\n                    res.push_back({nums[i],nums[low],nums[high]});\\n                    int last_left=nums[low]; // store the current left\\n                    while(low<high && last_left == nums[low]) low++; // keep on increasing low untill the last left and nums[low] are not equal Anymore \\n                    int last_right=nums[high];\\n                    while(low<high && last_right == nums[high]) high--; //keep on decreasig high untill the last high and enums[high] are not equal anymor\\n                } else if(sum>0) { // since its a sorted array, decrease the high\\n                    high--; \\n                } else {\\n                    low++; // since its a sorted array, increase the low\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3) return {}; // no triplets if size < 3\\n         vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++) { // since high will be the last  element, we will iterate till n-1\\n            if(i!=0 && nums[i]==nums[i-1]) continue; // same elements, so keep on moving left\\n            int low=i+1,high=n-1; // always look at the gap from the current number +1\\n            while(low<high) {\\n                int sum=nums[i]+nums[low]+nums[high];\\n                if(sum==0) {\\n                    res.push_back({nums[i],nums[low],nums[high]});\\n                    int last_left=nums[low]; // store the current left\\n                    while(low<high && last_left == nums[low]) low++; // keep on increasing low untill the last left and nums[low] are not equal Anymore \\n                    int last_right=nums[high];\\n                    while(low<high && last_right == nums[high]) high--; //keep on decreasig high untill the last high and enums[high] are not equal anymor\\n                } else if(sum>0) { // since its a sorted array, decrease the high\\n                    high--; \\n                } else {\\n                    low++; // since its a sorted array, increase the low\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910892,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<List<Integer>> threeSum(int[] nums) {\\n\\t\\t\\tSet<List<Integer>> list = new HashSet<>();\\n\\t\\t\\tif (nums.length > 2) {\\n\\t\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\t\\t\\tint l = i + 1, r = nums.length - 1, sum;\\n\\t\\t\\t\\t\\twhile (l < r) {\\n\\t\\t\\t\\t\\t\\tsum = nums[i] + nums[l] + nums[r];\\n\\t\\t\\t\\t\\t\\tif (sum == 0) {\\n\\t\\t\\t\\t\\t\\t\\tlist.add(Arrays.asList(nums[i], nums[l], nums[r]));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (sum < 0)\\n\\t\\t\\t\\t\\t\\t\\tl++;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tr--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn new ArrayList<>(list);\\n\\t\\t\\t} else\\n\\t\\t\\t\\treturn new ArrayList<>(list);\\n\\t\\t}\\n\\t}//HashSet used to get unique entries\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<List<Integer>> threeSum(int[] nums) {\\n\\t\\t\\tSet<List<Integer>> list = new HashSet<>();\\n\\t\\t\\tif (nums.length > 2) {\\n\\t\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\t\\t\\tint l = i + 1, r = nums.length - 1, sum;\\n\\t\\t\\t\\t\\twhile (l < r) {\\n\\t\\t\\t\\t\\t\\tsum = nums[i] + nums[l] + nums[r];\\n\\t\\t\\t\\t\\t\\tif (sum == 0) {\\n\\t\\t\\t\\t\\t\\t\\tlist.add(Arrays.asList(nums[i], nums[l], nums[r]));\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 643423,
                "title": "simple-python-o-n-2-solution",
                "content": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        length = len(nums)\\n        result = set()\\n        for i in range(length-2):\\n            left = i+1\\n            right = length-1\\n            while left < right:\\n                sum_value = nums[i]+nums[left]+nums[right]\\n                if sum_value == 0:\\n                    result.add((nums[i],nums[left],nums[right]))\\n                    left += 1\\n                    right -= 1\\n                elif sum_value < 0:\\n                    left +=1\\n                else:\\n                    right -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        length = len(nums)\\n        result = set()\\n        for i in range(length-2):\\n            left = i+1\\n            right = length-1\\n            while left < right:\\n                sum_value = nums[i]+nums[left]+nums[right]\\n                if sum_value == 0:\\n                    result.add((nums[i],nums[left],nums[right]))\\n                    left += 1\\n                    right -= 1\\n                elif sum_value < 0:\\n                    left +=1\\n                else:\\n                    right -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577114,
                "title": "java-solution-with-explanation",
                "content": "Aim: find unique triplets s.t. a + b + c = 0\\nIdea: Sort the array, then fix (one number), and find other two equals -(one number)\\n\\nRemove duplication: \\n1. while iteration, if current number equals previous number, skip\\n2. once find a triplet, skip duplicate numbers\\n                \\n```\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0 && nums[i] == nums[i - 1]) continue;\\n            int l = i + 1, r = n - 1, target = -nums[i];\\n            while (l < r) {\\n                if (nums[l] + nums[r] == target) {\\n                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));\\n                    l++;\\n                    r--;\\n                    while (l < r && nums[l] == nums[l - 1]) l++;\\n                    while (l < r && nums[r] == nums[r + 1]) r--;\\n                } else if (nums[l] + nums[r] < target) {\\n                    l++;\\n                } else {\\n                    r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0 && nums[i] == nums[i - 1]) continue;\\n            int l = i + 1, r = n - 1, target = -nums[i];\\n            while (l < r) {\\n                if (nums[l] + nums[r] == target) {\\n                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));\\n                    l++;\\n                    r--;\\n                    while (l < r && nums[l] == nums[l - 1]) l++;\\n                    while (l < r && nums[r] == nums[r + 1]) r--;\\n                } else if (nums[l] + nums[r] < target) {\\n                    l++;\\n                } else {\\n                    r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 576608,
                "title": "java-two-pointer-solution-and-how-you-would-explain-to-your-interviewer-verbally",
                "content": "### Approaching the problem\\nWe can approach this problem by holding on one number and find the pair that can saitisfy the zero sum, which breaks down the problem into a for-loop wrapped *Two-Sum* problem. We can approach the *Two-Sum* problem similarily by holidng on to one number and finding the other one that can satisfy the sum to the target, which essentially another for-loop wrapping a search algorithm. We can shrink the range for the inner for-loop and search input to exclude the numbers that are already been examinated or held. \\n\\n```\\n// Pseudo Code\\n\\nfor i in range(0, len(nums)):\\n  target = 0 - nums[i];\\n  for (j in range(i, len(nums))):\\n    subTarget = target - nums[j];\\n\\tfinalNumberIdx = search(subTarget, nums[j+1, len(nums)])\\n```\\n\\nThe double for-loop has already made the time complexity `O(N^2)`, so economically it makes sense to spend `O(N lg N)` to sort the array for faster search.\\n\\nTo avoid duplicated answers, we will need to skip duplicate numbers in the first for-loop.\\n\\nSince the array is already sorted, the sub-array can also be assumed sorted, so a binary search algorithm is proper for searching for the final number;\\n\\n```\\n// Pseudo Code\\n\\nsort(nums)\\nfor i in range(0, len(nums)):\\n  if (i != 0 && nums[i] == nums[i-1]): continue\\n  \\n  target = 0 - nums[i];\\n  for (j in range(i + 1, len(nums))):\\n    subTarget = 0 - target\\n\\tfinalNumberIdx = binarySearch(subTarget, nums[j+1, len(nums)])\\n```\\n\\nThis should be functional. \\n\\n### Optimization\\n\\nNote that there might be multiple answers within the same sub-array for the inner for-loop. For example, `target = 5` and sub-array `[1, 2, 3, 4]`. After we found `[1, 4]`, we still search in `[2, 3, 4]` while we clearly know that we don\\'t need `4` any more. In another word, we can optimize this by finding the a *tighter* upper bound, which can be achieved by excluding the previous answers and duplicated numbers. Taking this idea a step forward, we can also shrink the lower bound by skipping previous answers and duplicated numbers. To make the code more readable, we will switch the inner *for-loop* to a *while-loop* to represent the shrinking of the array. And naturally, instead of *\"searching\"* for the answer we examine a pair of numbers at both ends of the ever shrinking range to determine if they are the answer, which is of `O(N)` time complexity. \\n\\n### Java Implementation\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> results = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums.length - 2; ++i) {\\n            // skips duplicates that\\'s been evaluated\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            // get the target for two sum\\n            int target = 0 - nums[i];\\n            // sets two pointers\\n            int loPtr = i + 1;\\n            int hiPtr = nums.length - 1;\\n            \\n            while(loPtr < hiPtr) {\\n                // shrink the inner range by skipping duplicated elements on both ends\\n                if (loPtr != i + 1 && nums[loPtr] == nums[loPtr - 1]) {\\n                    ++loPtr;\\n                    continue;\\n                }\\n                \\n                if (hiPtr != nums.length - 1 && nums[hiPtr] == nums[hiPtr + 1]) {\\n                    --hiPtr;\\n                    continue;\\n                }\\n                \\n                int tmpSum = nums[loPtr] + nums[hiPtr];\\n\\t\\t\\t\\t\\n                // shrink the inner range by skipping the data we\\'ve evaluated\\n                if (tmpSum == target) {\\n                    results.add(Arrays.asList(nums[i], nums[loPtr], nums[hiPtr]));\\n                    ++loPtr;\\n                    --hiPtr;\\n                } else if (tmpSum < target) {\\n                    ++loPtr;\\n                } else {\\n                    --hiPtr;\\n                }\\n            }\\n        }\\n        \\n        return results;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Pseudo Code\\n\\nfor i in range(0, len(nums)):\\n  target = 0 - nums[i];\\n  for (j in range(i, len(nums))):\\n    subTarget = target - nums[j];\\n\\tfinalNumberIdx = search(subTarget, nums[j+1, len(nums)])\\n```\n```\\n// Pseudo Code\\n\\nsort(nums)\\nfor i in range(0, len(nums)):\\n  if (i != 0 && nums[i] == nums[i-1]): continue\\n  \\n  target = 0 - nums[i];\\n  for (j in range(i + 1, len(nums))):\\n    subTarget = 0 - target\\n\\tfinalNumberIdx = binarySearch(subTarget, nums[j+1, len(nums)])\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> results = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums.length - 2; ++i) {\\n            // skips duplicates that\\'s been evaluated\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            // get the target for two sum\\n            int target = 0 - nums[i];\\n            // sets two pointers\\n            int loPtr = i + 1;\\n            int hiPtr = nums.length - 1;\\n            \\n            while(loPtr < hiPtr) {\\n                // shrink the inner range by skipping duplicated elements on both ends\\n                if (loPtr != i + 1 && nums[loPtr] == nums[loPtr - 1]) {\\n                    ++loPtr;\\n                    continue;\\n                }\\n                \\n                if (hiPtr != nums.length - 1 && nums[hiPtr] == nums[hiPtr + 1]) {\\n                    --hiPtr;\\n                    continue;\\n                }\\n                \\n                int tmpSum = nums[loPtr] + nums[hiPtr];\\n\\t\\t\\t\\t\\n                // shrink the inner range by skipping the data we\\'ve evaluated\\n                if (tmpSum == target) {\\n                    results.add(Arrays.asList(nums[i], nums[loPtr], nums[hiPtr]));\\n                    ++loPtr;\\n                    --hiPtr;\\n                } else if (tmpSum < target) {\\n                    ++loPtr;\\n                } else {\\n                    --hiPtr;\\n                }\\n            }\\n        }\\n        \\n        return results;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432592,
                "title": "simple-and-short-java-solution",
                "content": "1. Sort the nums array\\n2. For each element in nums, start with two pointers b and c and the beggining and end of the array.\\n3. Is the sum is less than 0, increment b because that will lead to a larger sum, and opposite if the sum is greater than 0.\\n4. Check for duplicates at each step.\\n\\n```\\nclass Solution {\\n    \\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> solutionSet = new ArrayList<List<Integer>>();        \\n        Arrays.sort(nums);\\n        \\n        for(int a = 0; a < nums.length - 2; a++) {\\n            if(a != 0 && nums[a] == nums[a - 1]) continue;\\n            int b = a + 1;\\n            int c = nums.length - 1;\\n            while (b < c) {\\n                if(nums[a] + nums[b] + nums[c] == 0) {\\n                    solutionSet.add(Arrays.asList(nums[a], nums[b], nums[c]));\\n                    b++;\\n                    while(b < c && nums[b] == nums[b - 1]) b++;\\n                } else if(nums[a] + nums[b] + nums[c] < 0) {\\n                    b++;\\n                } else {\\n                    c--;\\n                }\\n            }\\n        }\\n\\n        return solutionSet;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> solutionSet = new ArrayList<List<Integer>>();        \\n        Arrays.sort(nums);\\n        \\n        for(int a = 0; a < nums.length - 2; a++) {\\n            if(a != 0 && nums[a] == nums[a - 1]) continue;\\n            int b = a + 1;\\n            int c = nums.length - 1;\\n            while (b < c) {\\n                if(nums[a] + nums[b] + nums[c] == 0) {\\n                    solutionSet.add(Arrays.asList(nums[a], nums[b], nums[c]));\\n                    b++;\\n                    while(b < c && nums[b] == nums[b - 1]) b++;\\n                } else if(nums[a] + nums[b] + nums[c] < 0) {\\n                    b++;\\n                } else {\\n                    c--;\\n                }\\n            }\\n        }\\n\\n        return solutionSet;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423536,
                "title": "simple-java-sol-100-time",
                "content": "\\n\\tclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i!=0&&nums[i]==nums[i-1])continue;\\n            int j=i+1;\\n            int k=nums.length-1;\\n            while(j<k){\\n                if(nums[i]+nums[j]+nums[k]>0)k--;\\n                else if(nums[i]+nums[j]+nums[k]<0)j++;\\n                else{\\n                    res.add(Arrays.asList(nums[i],nums[j],nums[k]));\\n                    j++;k--;\\n                    while(j<k&&nums[j]==nums[j-1])j++;\\n                    while(k>j&&nums[k]==nums[k+1])k--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i!=0&&nums[i]==nums[i-1])continue;\\n            int j=i+1;\\n            int k=nums.length-1;\\n            while(j<k){\\n                if(nums[i]+nums[j]+nums[k]>0)k--;\\n                else if(nums[i]+nums[j]+nums[k]<0)j++;\\n                else{\\n                    res.add(Arrays.asList(nums[i],nums[j],nums[k]));\\n                    j++;k--;\\n                    while(j<k&&nums[j]==nums[j-1])j++;\\n                    while(k>j&&nums[k]==nums[k+1])k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 415468,
                "title": "python-hashmap-solution-13-lines-900-ms-with-explanations",
                "content": "\\n```\\ndef threeSum(nums):\\n\\tnums, i, result = sorted(nums), 0, []\\n\\twhile i < len(nums) and nums[i] <= 0:   \\n\\t\\tdic, target, j = {}, - nums[i], i+1\\n\\t\\twhile j < len(nums):\\n\\t\\t\\tif nums[j] in dic:\\n\\t\\t\\t\\tidx = dic[nums[j]]\\n\\t\\t\\t\\tresult.append([nums[i], nums[idx], nums[j]])\\n\\t\\t\\t\\twhile i < len(nums) - 1 and nums[i] == nums[i+1]:  i += 1\\n\\t\\t\\t\\twhile j < len(nums) - 1 and nums[j] == nums[j+1]:  j += 1\\n\\t\\t\\telse: dic[target - nums[j]] = j\\n\\t\\t\\tj += 1\\n\\t\\ti += 1\\n\\treturn result\\n```\\nRuntime: 908 ms, faster than 63.14% of Python3 online submissions for 3Sum.\\nMemory Usage: 17 MB, less than 25.00% of Python3 online submissions for 3Sum.\\n\\n\\n# **Explanations**\\nThe main idea is to fix one element [i] as a target like in [Two Sum](https://leetcode.com/problems/two-sum/), \\nAnd then compare two other elements with hashmap:\\n```\\ntarget = - nums[i]\\nif nums[j] in dic:\\n\\tidx = dic[nums[j]]\\n\\tresult.append([nums[i], nums[idx], nums[j]])\\nelse: dic[target - nums[j]] = j\\n```\\n\\n# Other tips\\nIn the first while loop we use `nums[i] <= 0` condition to save an extra 200 ms. The first element should always be minus or zero.\\n`while i < len(nums) and nums[i] <= 0: `\\n\\nThese while loops saves x2 time:\\n```\\nwhile i < len(nums) - 1 and nums[i] == nums[i+1]:  i += 1\\nwhile j < len(nums) - 1 and nums[j] == nums[j+1]:  j += 1\\n```\\nOtherway it will run 2100 ms instead of 900. These loops prevents duplicates and save extra moves.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef threeSum(nums):\\n\\tnums, i, result = sorted(nums), 0, []\\n\\twhile i < len(nums) and nums[i] <= 0:   \\n\\t\\tdic, target, j = {}, - nums[i], i+1\\n\\t\\twhile j < len(nums):\\n\\t\\t\\tif nums[j] in dic:\\n\\t\\t\\t\\tidx = dic[nums[j]]\\n\\t\\t\\t\\tresult.append([nums[i], nums[idx], nums[j]])\\n\\t\\t\\t\\twhile i < len(nums) - 1 and nums[i] == nums[i+1]:  i += 1\\n\\t\\t\\t\\twhile j < len(nums) - 1 and nums[j] == nums[j+1]:  j += 1\\n\\t\\t\\telse: dic[target - nums[j]] = j\\n\\t\\t\\tj += 1\\n\\t\\ti += 1\\n\\treturn result\\n```\n```\\ntarget = - nums[i]\\nif nums[j] in dic:\\n\\tidx = dic[nums[j]]\\n\\tresult.append([nums[i], nums[idx], nums[j]])\\nelse: dic[target - nums[j]] = j\\n```\n```\\nwhile i < len(nums) - 1 and nums[i] == nums[i+1]:  i += 1\\nwhile j < len(nums) - 1 and nums[j] == nums[j+1]:  j += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 394384,
                "title": "java-o-n-2-not-a-two-pointer-but-using-hash-map",
                "content": "Two-pointers is a steight forward solution, but I desided to solve it with something else with the same O of time. Memory complexity is not so good, so, it\\'s just for fun\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] num) {\\n        List<List<Integer>> out = new ArrayList();\\n        \\n        if(num.length < 3) {\\n            return out;    \\n        }\\n\\n\\t\\t// Sort an array. It will hepl us to get the same triplets in the future\\n        Arrays.sort(num);\\n\\n\\t\\t// store intergers here to fast access\\n        Set<Integer> cache = new HashSet();\\n\\t\\t\\n\\t\\t// store resut here to check duplicates\\n        Set<List<Integer>> cacheTriplets = new HashSet();\\n        \\n        for(int i = 0; i < num.length; i++) {\\n            for(int j = i + 1; j < num.length; j++) {\\n                \\n                int v1 = num[i];\\n                int v2 = num[j];\\n                int sum = v1 + v2;\\n                \\n\\t\\t\\t\\t// if there is a number that we can add and get summ equal zero\\n                if(cache.contains(-sum)) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// create result triplet\\n                    List<Integer> triplet = new ArrayList();\\n                    triplet.add(v1);\\n                    triplet.add(v2);\\n                    triplet.add(-sum);  \\n                    \\n\\t\\t\\t\\t\\t// check duplicates\\n                    if(!cacheTriplets.contains(triplet)) {\\n                        out.add(triplet);\\n                        cacheTriplets.add(triplet);\\n                    }\\n                }\\n            }\\n            cache.add(num[i]);\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] num) {\\n        List<List<Integer>> out = new ArrayList();\\n        \\n        if(num.length < 3) {\\n            return out;    \\n        }\\n\\n\\t\\t// Sort an array. It will hepl us to get the same triplets in the future\\n        Arrays.sort(num);\\n\\n\\t\\t// store intergers here to fast access\\n        Set<Integer> cache = new HashSet();\\n\\t\\t\\n\\t\\t// store resut here to check duplicates\\n        Set<List<Integer>> cacheTriplets = new HashSet();\\n        \\n        for(int i = 0; i < num.length; i++) {\\n            for(int j = i + 1; j < num.length; j++) {\\n                \\n                int v1 = num[i];\\n                int v2 = num[j];\\n                int sum = v1 + v2;\\n                \\n\\t\\t\\t\\t// if there is a number that we can add and get summ equal zero\\n                if(cache.contains(-sum)) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// create result triplet\\n                    List<Integer> triplet = new ArrayList();\\n                    triplet.add(v1);\\n                    triplet.add(v2);\\n                    triplet.add(-sum);  \\n                    \\n\\t\\t\\t\\t\\t// check duplicates\\n                    if(!cacheTriplets.contains(triplet)) {\\n                        out.add(triplet);\\n                        cacheTriplets.add(triplet);\\n                    }\\n                }\\n            }\\n            cache.add(num[i]);\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324127,
                "title": "cpp-with-explanation",
                "content": "1) sort the list in ascending order\\n2) find the complement i.e. the target value that we need the remaining two numbers to sum up\\n3) do a two pointer approach with a front and rear pointer to find the target value and add the numbers result vector\\n4) ensure there are no duplicates by: check if the the number is already in our list, if so move the pointers\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> triplet(3);\\n        int front, rear;\\n        \\n        sort(nums.begin(), nums.end());\\n        // [-1, 0, 1, 2, -1, -4] --> [-4, -1, -1. 0. 1, 2]\\n        \\n        // three pointer: one at current (the one we\\'re trying to pair), one ahead slightly, one at end.\\n        \\n        for (int i = 0; i<nums.size(); i++){\\n            int target = -nums[i]; // 4\\n            front = i+1; \\n            rear = nums.size() - 1;\\n            while(front < rear){\\n                int sum = nums[front] + nums[rear];\\n                \\n                if (sum < target){\\n                    front++; // target not found sum too low so increase front\\n                } else if(sum > target){\\n                    rear--; // target not found sum too high so decrease rear\\n                } else{\\n                    //found\\n                    triplet[0] = nums[i];\\n                    triplet[1] = nums[front];\\n                    triplet[2] = nums[rear];\\n                    result.push_back(triplet);\\n                    \\n                    // we don\\'t want duplicates for the front or back since if either of these are the same \\n                    // since for [a,b,c] --> = -b -c so if -b is repeated and then -c is also repeated\\n                    while(front < rear && nums[front] == triplet[1])\\n                        front++;\\n                    while(front < rear && nums[rear] == triplet[2])\\n                        rear--;\\n                }\\n            }\\n            while (i+1 < nums.size() && nums[i+1] == nums[i])\\n                i++; // repeated first digit\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> triplet(3);\\n        int front, rear;\\n        \\n        sort(nums.begin(), nums.end());\\n        // [-1, 0, 1, 2, -1, -4] --> [-4, -1, -1. 0. 1, 2]\\n        \\n        // three pointer: one at current (the one we\\'re trying to pair), one ahead slightly, one at end.\\n        \\n        for (int i = 0; i<nums.size(); i++){\\n            int target = -nums[i]; // 4\\n            front = i+1; \\n            rear = nums.size() - 1;\\n            while(front < rear){\\n                int sum = nums[front] + nums[rear];\\n                \\n                if (sum < target){\\n                    front++; // target not found sum too low so increase front\\n                } else if(sum > target){\\n                    rear--; // target not found sum too high so decrease rear\\n                } else{\\n                    //found\\n                    triplet[0] = nums[i];\\n                    triplet[1] = nums[front];\\n                    triplet[2] = nums[rear];\\n                    result.push_back(triplet);\\n                    \\n                    // we don\\'t want duplicates for the front or back since if either of these are the same \\n                    // since for [a,b,c] --> = -b -c so if -b is repeated and then -c is also repeated\\n                    while(front < rear && nums[front] == triplet[1])\\n                        front++;\\n                    while(front < rear && nums[rear] == triplet[2])\\n                        rear--;\\n                }\\n            }\\n            while (i+1 < nums.size() && nums[i+1] == nums[i])\\n                i++; // repeated first digit\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257535,
                "title": "golang",
                "content": "```\\nfunc threeSum(nums []int) [][]int {\\n\\tvar result [][]int\\n\\tif len(nums) < 3 {\\n\\t\\treturn result\\n\\t}\\n\\n\\tsort.Ints(nums)\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif i != 0 && nums[i-1] == nums[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor k, j := i+1, len(nums)-1; k < j; {\\n\\t\\t\\tn := nums[i] + nums[k] + nums[j]\\n\\t\\t\\tif n == 0 {\\n\\t\\t\\t\\tresult = append(result, []int{nums[i], nums[k], nums[j]})\\n\\t\\t\\t\\tl := k\\n\\t\\t\\t\\tfor l < j && nums[l] == nums[k] {\\n\\t\\t\\t\\t\\tl++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tk = l\\n\\t\\t\\t} else if n > 0 {\\n\\t\\t\\t\\tj--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tk++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc threeSum(nums []int) [][]int {\\n\\tvar result [][]int\\n\\tif len(nums) < 3 {\\n\\t\\treturn result\\n\\t}\\n\\n\\tsort.Ints(nums)\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif i != 0 && nums[i-1] == nums[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor k, j := i+1, len(nums)-1; k < j; {\\n\\t\\t\\tn := nums[i] + nums[k] + nums[j]\\n\\t\\t\\tif n == 0 {\\n\\t\\t\\t\\tresult = append(result, []int{nums[i], nums[k], nums[j]})\\n\\t\\t\\t\\tl := k\\n\\t\\t\\t\\tfor l < j && nums[l] == nums[k] {\\n\\t\\t\\t\\t\\tl++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tk = l\\n\\t\\t\\t} else if n > 0 {\\n\\t\\t\\t\\tj--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tk++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233496,
                "title": "go-98-26-848ms",
                "content": "```\\nfunc threeSum(nums []int) [][]int {\\n\\tresults := [][]int{}\\n\\tn := len(nums)\\n\\tif n == 0 || n < 3 {\\n\\t\\treturn results\\n\\t}\\n\\tsort.Ints(nums)\\n\\tfor i := 0; i < n-2; i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ttarget := -nums[i]\\n\\t\\tleft := i + 1\\n\\t\\tright := n - 1\\n\\t\\tfor left < right {\\n\\t\\t\\tsum := nums[left] + nums[right]\\n\\t\\t\\tif sum == target {\\n\\t\\t\\t\\tresults = append(results, []int{nums[left], nums[right], nums[i]})\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left-1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right+1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if sum > target {\\n\\t\\t\\t\\tright--\\n\\t\\t\\t} else if sum < target {\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn results\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc threeSum(nums []int) [][]int {\\n\\tresults := [][]int{}\\n\\tn := len(nums)\\n\\tif n == 0 || n < 3 {\\n\\t\\treturn results\\n\\t}\\n\\tsort.Ints(nums)\\n\\tfor i := 0; i < n-2; i++ {\\n\\t\\tif i > 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\ttarget := -nums[i]\\n\\t\\tleft := i + 1\\n\\t\\tright := n - 1\\n\\t\\tfor left < right {\\n\\t\\t\\tsum := nums[left] + nums[right]\\n\\t\\t\\tif sum == target {\\n\\t\\t\\t\\tresults = append(results, []int{nums[left], nums[right], nums[i]})\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left-1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right+1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if sum > target {\\n\\t\\t\\t\\tright--\\n\\t\\t\\t} else if sum < target {\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn results\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226064,
                "title": "3sum-solution-using-2sum-hash-table-solution-not-bidirectional-sweep-like-so-many-here",
                "content": "It\\'s really cool that you can do most of the heavy lifting for 3Sum by solving [2Sum](https://leetcode.com/problems/two-sum/). But when I realized that and saw popular posts on here discussing the fact (like [this one](https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)-Java-solution) and [that one](https://leetcode.com/problems/3sum/discuss/7498/Python-solution-with-detailed-explanation)) I was confused. Why? They don\\'t solve 2Sum the way [LeetCode\\'s official solutions do](https://leetcode.com/problems/two-sum/solution/), using a hash table (both Approach 2 and Approach 3 there use a hash table).  They use a a bidirectional sweep instead, searching inward from both sides of the array to find complements.\\n\\nI wanted to try solving the 2Sum component of 3Sum LeetCode\\'s way, using a two-pass hash table (their Approach 2). For me this makes it easier to see how 2Sum is a subproblem of 3Sum. There are a few tweaks we have to make here because this 3Sum problem requires only unique solution triplets to be returned, so we sort the array and have to skip some elements in order to avoid duplicates ([good explanation about dulicates handling](https://leetcode.com/problems/3sum/discuss/7498/Python-solution-with-detailed-explanation)).\\n\\nI implemented this in JavaScript and added some code comments to help explain what\\'s going on. I used a [JavaScript Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) for the hash table data structure, but you could easily use a plain JavaScript object as well. LeetCode accepted this as a valid submission:\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n *\\n * Time complexity: n*lg(n) sort + n^2 => O(n^2)\\n * Space complexity: O(n) for the hash table (note that it is recreated O(n) times)\\n */\\nfunction threeSum(nums) {\\n    const res = [];\\n\\n    nums.sort((a, b) => a - b);\\n\\n    for (let i = 0; i < nums.length - 2; i++) {\\n        // Skip duplicates\\n        if (i > 0 && nums[i] === nums[i - 1])\\n            continue;\\n        \\n        const target = nums[i] * -1;\\n\\n        twoSum(nums, i, target, res);\\n    }\\n\\n    return res;\\n}\\n\\n// Helper function for 3Sum that solves 2Sum but unlike a\\n// standalone 2Sum function pushes solution triplets onto the\\n// given result array (res) using the given index (i)\\nfunction twoSum(nums, i, target, res) {\\n    // Hash table mapping nums to counts remaining of that num\\n    // in the nums array\\n    const counts = new Map();\\n    \\n    // Go through remaining nums (after i), populating\\n    // the remaining counts hash table\\n    for (let j = i + 1; j < nums.length; j++) {\\n        if (counts.has(nums[j]))\\n            counts.set(nums[j], counts.get(nums[j]) + 1);\\n        else\\n            counts.set(nums[j], 1);\\n    }\\n\\n    // Go through remaining nums (after i), using the\\n    // hash table to look up whether each num\\'s complement\\n    // exists (and updating counts table/hash map along the way)\\n    for (let j = i + 1; j < nums.length; j++) {\\n        // Decrement the remaining count\\n        counts.set(nums[j], counts.get(nums[j]) - 1);\\n\\n        // Skip duplicates\\n        if (j > i + 1 && nums[j] === nums[j - 1])\\n            continue;\\n\\n        const comp = target - nums[j];\\n        \\n        if (counts.has(comp) && counts.get(comp) > 0)\\n            res.push([nums[i], nums[j], comp]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n *\\n * Time complexity: n*lg(n) sort + n^2 => O(n^2)\\n * Space complexity: O(n) for the hash table (note that it is recreated O(n) times)\\n */\\nfunction threeSum(nums) {\\n    const res = [];\\n\\n    nums.sort((a, b) => a - b);\\n\\n    for (let i = 0; i < nums.length - 2; i++) {\\n        // Skip duplicates\\n        if (i > 0 && nums[i] === nums[i - 1])\\n            continue;\\n        \\n        const target = nums[i] * -1;\\n\\n        twoSum(nums, i, target, res);\\n    }\\n\\n    return res;\\n}\\n\\n// Helper function for 3Sum that solves 2Sum but unlike a\\n// standalone 2Sum function pushes solution triplets onto the\\n// given result array (res) using the given index (i)\\nfunction twoSum(nums, i, target, res) {\\n    // Hash table mapping nums to counts remaining of that num\\n    // in the nums array\\n    const counts = new Map();\\n    \\n    // Go through remaining nums (after i), populating\\n    // the remaining counts hash table\\n    for (let j = i + 1; j < nums.length; j++) {\\n        if (counts.has(nums[j]))\\n            counts.set(nums[j], counts.get(nums[j]) + 1);\\n        else\\n            counts.set(nums[j], 1);\\n    }\\n\\n    // Go through remaining nums (after i), using the\\n    // hash table to look up whether each num\\'s complement\\n    // exists (and updating counts table/hash map along the way)\\n    for (let j = i + 1; j < nums.length; j++) {\\n        // Decrement the remaining count\\n        counts.set(nums[j], counts.get(nums[j]) - 1);\\n\\n        // Skip duplicates\\n        if (j > i + 1 && nums[j] === nums[j - 1])\\n            continue;\\n\\n        const comp = target - nums[j];\\n        \\n        if (counts.has(comp) && counts.get(comp) > 0)\\n            res.push([nums[i], nums[j], comp]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 110507,
                "title": "golang-n-2-n-worst-case-no-sort-no-deduplication-o-n-2-beats-50",
                "content": "I haven't seen this solution in the top posts so I thought I'd share it.\\nThe basic strategy for 3Sum is the same as everywhere: for each (i, j) pair find a k such that\\nk = -(i+j)\\n\\nThe no-dedupe strategy is:\\n* get unique numbers using a map (number -> duplicates of that number)\\n* find all pairs of numbers, but on each pair the left has to be smaller than the right, unless there are 2 of them\\n* when you find the third number, it has to be larger than the other two, or it can be equal to exactly one of them (if there are 2 of them in the list), or exactly two of them (if there are 3 of them in the list)\\n\\nThis strategy guarantees no need for deduping, but there are quite a few no-op iterations that could be avoided with different strategies. It did beat 50% of other submissions.\\n\\n```\\nfunc threeSum(nums []int) [][]int {\\n\\tif len(nums) <= 2 {\\n\\t\\treturn make([][]int, 0)\\n\\t}\\n\\tvar (\\n\\t\\tm   = make(map[int]int, 0)\\n\\t\\tres = make([][]int, 0)\\n\\t)\\n\\tfor _, n := range nums {\\n\\t\\tm[n]++\\n\\t}\\n\\tfor i := range m {\\n\\t\\tfor j := range m {\\n\\t\\t\\tif i > j || (i == j && m[i] == 1) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tk := -(i + j)\\n\\t\\t\\tif k < i || k < j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif n, ok := m[k]; ok {\\n\\t\\t\\t\\tif (k == i && n == 1) || (k == j && n == 1) || (i == j && j == k && n == 2) {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = append(res, []int{i, j, k})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc threeSum(nums []int) [][]int {\\n\\tif len(nums) <= 2 {\\n\\t\\treturn make([][]int, 0)\\n\\t}\\n\\tvar (\\n\\t\\tm   = make(map[int]int, 0)\\n\\t\\tres = make([][]int, 0)\\n\\t)\\n\\tfor _, n := range nums {\\n\\t\\tm[n]++\\n\\t}\\n\\tfor i := range m {\\n\\t\\tfor j := range m {\\n\\t\\t\\tif i > j || (i == j && m[i] == 1) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tk := -(i + j)\\n\\t\\t\\tif k < i || k < j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif n, ok := m[k]; ok {\\n\\t\\t\\t\\tif (k == i && n == 1) || (k == j && n == 1) || (i == j && j == k && n == 2) {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = append(res, []int{i, j, k})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7817,
                "title": "my-o-n-2-ac-code",
                "content": "two real problems .\\n\\n - 1.how to find the sum?\\n\\nchange it to a 2 sum problem. when you have one value, the sum of the other two is -value.\\n2 sum problem has a O(n) solution. so the final is O(n^2).\\n \\n\\n - how to remove the duplicate?\\n\\nfor same values, we only use the first one and pass the rest.  \\n\\n\\n    vector<vector<int> > threeSum(vector<int> &num) {\\n\\tvector<vector<int> > result;\\n\\tvector<int> tempResult;\\n\\tsort( num.begin(),num.end() );\\n\\n\\tint p,q,temp;\\n\\tfor(int i=0;i<num.size();i++){\\n\\t\\tif( i!=0 && num[i]==num[i-1] )continue;\\t\\t//num 1\\uff1aonly reserve first of all same values  \\n\\t    \\tint current=num[i];\\n    \\t\\tp=i+1,q=num.size()-1;\\n    \\t\\t\\n\\t\\twhile(p<q){\\n\\t\\t\\tif(p!=i+1 && num[p]==num[p-1] ){\\t    //num 2\\uff1aonly reserve first of all same values \\n\\t\\t\\t\\tp++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\ttemp=num[p]+num[q];\\n\\n\\t\\t\\tif(temp==-current){                 //find\\n\\t\\t\\t\\ttempResult.push_back(current);tempResult.push_back(num[p]);tempResult.push_back(num[q]);\\n\\t\\t\\t\\tresult.push_back(tempResult);\\n\\t\\t\\t\\ttempResult.clear();\\n\\t\\t\\t\\tp++;q--;\\n\\t\\t\\t}else if(temp>-current)q--;       //larger, go left\\n\\t\\t\\telse p++;                         //smaller, go right\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}",
                "solutionTags": [],
                "code": "two real problems .\\n\\n - 1.how to find the sum?\\n\\nchange it to a 2 sum problem. when you have one value, the sum of the other two is -value.\\n2 sum problem has a O(n) solution. so the final is O(n^2).\\n \\n\\n - how to remove the duplicate?\\n\\nfor same values, we only use the first one and pass the rest.  \\n\\n\\n    vector<vector<int> > threeSum(vector<int> &num) {\\n\\tvector<vector<int> > result;\\n\\tvector<int> tempResult;\\n\\tsort( num.begin(),num.end() );\\n\\n\\tint p,q,temp;\\n\\tfor(int i=0;i<num.size();i++){\\n\\t\\tif( i!=0 && num[i]==num[i-1] )continue;\\t\\t//num 1\\uff1aonly reserve first of all same values  \\n\\t    \\tint current=num[i];\\n    \\t\\tp=i+1,q=num.size()-1;\\n    \\t\\t\\n\\t\\twhile(p<q){\\n\\t\\t\\tif(p!=i+1 && num[p]==num[p-1] ){\\t    //num 2\\uff1aonly reserve first of all same values \\n\\t\\t\\t\\tp++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\ttemp=num[p]+num[q];\\n\\n\\t\\t\\tif(temp==-current){                 //find\\n\\t\\t\\t\\ttempResult.push_back(current);tempResult.push_back(num[p]);tempResult.push_back(num[q]);\\n\\t\\t\\t\\tresult.push_back(tempResult);\\n\\t\\t\\t\\ttempResult.clear();\\n\\t\\t\\t\\tp++;q--;\\n\\t\\t\\t}else if(temp>-current)q--;       //larger, go left\\n\\t\\t\\telse p++;                         //smaller, go right\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3839733,
                "title": "like-2-sum",
                "content": "# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(i!=j&&mp.find(-nums[i]-nums[j])!=mp.end()&&mp[-nums[i]-nums[j]]!=i&&mp[-nums[i]-nums[j]]!=j)\\n                {\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(-nums[i]-nums[j]);\\n                    sort(v.begin(),v.end());\\n                    st.insert(v);\\n                    v.clear();\\n                }\\n                mp[nums[j]]=j;\\n            }\\n        }\\n        for(auto i:st)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(i!=j&&mp.find(-nums[i]-nums[j])!=mp.end()&&mp[-nums[i]-nums[j]]!=i&&mp[-nums[i]-nums[j]]!=j)\\n                {\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(-nums[i]-nums[j]);\\n                    sort(v.begin(),v.end());\\n                    st.insert(v);\\n                    v.clear();\\n                }\\n                mp[nums[j]]=j;\\n            }\\n        }\\n        for(auto i:st)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001527,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());    //Sorted Array\\n        if(nums.size() < 3){    //Base case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){        //Base case 2\\n            return {};\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            if(i > 0 && nums[i] == nums[i - 1]){    //If number is getting repeated, ignore the lower loop and continue.\\n                continue;\\n            }\\n            int low = i + 1 , high = nums.size() - 1;   //Make two pointers high and low, and initialize sum as 0.\\n            int sum = 0;\\n            while(low < high){                          //Search between two pointers, just similiar to binary search.\\n                sum = nums[i] + nums[low] + nums[high];\\n                if(sum > 0){   //If sum is +ve, means, we need more -ve numbers to make it 0, decreament high (high--).\\n                    high--;\\n                } else if(sum < 0){ //If sum is -ve, means, we need more +ve numbers to make it 0, increament low (low++).\\n                    low++;\\n                } else {\\n                    answer.push_back({nums[i] , nums[low] , nums[high]});  //we have found the required triplet, push it in answer vector\\n                    int last_low_occurence = nums[low] , last_high_occurence = nums[high];  //Now again, to avoid duplicate triplets, we have to navigate to last occurences of num[low] and num[high] respectively\\n                    while(low < high && nums[low] == last_low_occurence){   // Update the low and high with last occurences of low and high.\\n                        low++;\\n                    }\\n                    while(low < high && nums[high] == last_high_occurence){\\n                        high--;\\n                    }\\n                }\\n            }\\n        }\\n        return answer;      //Return the answer vector.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());    //Sorted Array\\n        if(nums.size() < 3){    //Base case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){        //Base case 2\\n            return {};\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            if(i > 0 && nums[i] == nums[i - 1]){    //If number is getting repeated, ignore the lower loop and continue.\\n                continue;\\n            }\\n            int low = i + 1 , high = nums.size() - 1;   //Make two pointers high and low, and initialize sum as 0.\\n            int sum = 0;\\n            while(low < high){                          //Search between two pointers, just similiar to binary search.\\n                sum = nums[i] + nums[low] + nums[high];\\n                if(sum > 0){   //If sum is +ve, means, we need more -ve numbers to make it 0, decreament high (high--).\\n                    high--;\\n                } else if(sum < 0){ //If sum is -ve, means, we need more +ve numbers to make it 0, increament low (low++).\\n                    low++;\\n                } else {\\n                    answer.push_back({nums[i] , nums[low] , nums[high]});  //we have found the required triplet, push it in answer vector\\n                    int last_low_occurence = nums[low] , last_high_occurence = nums[high];  //Now again, to avoid duplicate triplets, we have to navigate to last occurences of num[low] and num[high] respectively\\n                    while(low < high && nums[low] == last_low_occurence){   // Update the low and high with last occurences of low and high.\\n                        low++;\\n                    }\\n                    while(low < high && nums[high] == last_high_occurence){\\n                        high--;\\n                    }\\n                }\\n            }\\n        }\\n        return answer;      //Return the answer vector.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624163,
                "title": "java-solution-using-hashset-and-arraylist-o-n-2-two-pointer",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        HashSet<ArrayList<Integer>> res=new HashSet<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int target=0-nums[i];\\n            \\n            int j=i+1;\\n            int k=nums.length-1;\\n            \\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==target)\\n                {\\n                    ArrayList<Integer> list=new ArrayList<>();\\n                    list.add(nums[i]);\\n                    list.add(nums[j]);\\n                    list.add(nums[k]);\\n                    res.add(list);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>target)\\n                {\\n                    k--;\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n                    \\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        HashSet<ArrayList<Integer>> res=new HashSet<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int target=0-nums[i];\\n            \\n            int j=i+1;\\n            int k=nums.length-1;\\n            \\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==target)\\n                {\\n                    ArrayList<Integer> list=new ArrayList<>();\\n                    list.add(nums[i]);\\n                    list.add(nums[j]);\\n                    list.add(nums[k]);\\n                    res.add(list);\\n                    j++;\\n                    k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2227967,
                "title": "java-solution-26-ms-faster-than-90",
                "content": "***Upvote this if it helps you***\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n\\n       int left, right, i, sum;\\n       List<List<Integer>> rt = new ArrayList<List<Integer>>();\\n       if(nums.length<3) return rt;\\n       Arrays.sort(nums);\\n       for(i = 0; i < nums.length-2 ; i++){\\n           sum = 0 - nums[i];left = i+1;right = nums.length-1;\\n           while(left<right){\\n               if(nums[left]+nums[right] == sum ){\\n                   rt.add(Arrays.asList(nums[i],nums[left],nums[right]));\\n                   while(left<right && nums[left]==nums[1+left]) left++;\\n                   while(left<right && nums[right]==nums[right-1]) right--;\\n                   left++;right--;\\n               } \\n               else if(nums[left]+nums[right] < sum){\\n                   left++;\\n               }\\n               else{\\n                   right--;\\n               }\\n           }\\n\\n           while(i < nums.length-2 && nums[i] == nums[i+1]) i++;\\n       }\\n       return rt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n\\n       int left, right, i, sum;\\n       List<List<Integer>> rt = new ArrayList<List<Integer>>();\\n       if(nums.length<3) return rt;\\n       Arrays.sort(nums);\\n       for(i = 0; i < nums.length-2 ; i++){\\n           sum = 0 - nums[i];left = i+1;right = nums.length-1;\\n           while(left<right){\\n               if(nums[left]+nums[right] == sum ){\\n                   rt.add(Arrays.asList(nums[i],nums[left],nums[right]));\\n                   while(left<right && nums[left]==nums[1+left]) left++;\\n                   while(left<right && nums[right]==nums[right-1]) right--;\\n                   left++;right--;\\n               } \\n               else if(nums[left]+nums[right] < sum){\\n                   left++;\\n               }\\n               else{\\n                   right--;\\n               }\\n           }\\n\\n           while(i < nums.length-2 && nums[i] == nums[i+1]) i++;\\n       }\\n       return rt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565621,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1570762,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1721036,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1571042,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1565852,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1572000,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1812137,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1576431,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1565478,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1876495,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1565621,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1570762,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1721036,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1571042,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1565852,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1572000,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1812137,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1576431,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1565478,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1876495,
                "content": [
                    {
                        "username": "hz9423",
                        "content": "I like the pronunciation of this question\\'s title."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What\\'s wrong with it? I don\\'t get it??"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "I Couldn\\'t even understand the question to even start..."
                    },
                    {
                        "username": "user2588J",
                        "content": "lmao"
                    },
                    {
                        "username": "AdamGold",
                        "content": "it\\'s better in kotlin. The function is called \\'fun threeSum\\'.  yes."
                    },
                    {
                        "username": "Fful",
                        "content": "Has anyone had 3Sum for an interview?"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys, don\\'t lose focus"
                    },
                    {
                        "username": "shubhampr10",
                        "content": "Time Limit Exceeding with a Brute Force is what we want in this problem."
                    },
                    {
                        "username": "nekromantie",
                        "content": "emm... Maybe that is the only place we can play 3sum"
                    },
                    {
                        "username": "circlechange99",
                        "content": "[@MrHamed](/MrHamed) You came to the title of question? That\\'s kind of weird."
                    },
                    {
                        "username": "MrHamed",
                        "content": "i literally came to say the same thing"
                    },
                    {
                        "username": "gliu11551",
                        "content": "[@AlirezaShk](/AlirezaShk) Mee too HuhHuh"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Came to find this in the comments, not disappointed."
                    },
                    {
                        "username": "munenndragaur",
                        "content": "this is best opportunity give by leetcode to do threesum in multiple way par bete limited time me karna he"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Leetcode giving us 3sum lmao"
                    },
                    {
                        "username": "0pacman0",
                        "content": "my man!!!\\n"
                    },
                    {
                        "username": "pravesh2408",
                        "content": "Bhut HARD"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "My 3Sum is TLE"
                    },
                    {
                        "username": "shivanigam",
                        "content": "It should categorised in the HARD core."
                    },
                    {
                        "username": "pratyushchauhan62",
                        "content": "hehe boi"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "I wasn\\'t expecting to laugh from leetcode discussion but here we are"
                    },
                    {
                        "username": "PhilLeotardo",
                        "content": "This is the closest threesome I can get. "
                    },
                    {
                        "username": "Rishil96",
                        "content": "[@Bobzero](/Bobzero) me too lol. Seems the creator of this problem did it on purpose XD"
                    },
                    {
                        "username": "ulmas_ulmas",
                        "content": "Me: I am done for today with leetcode, lets have some rest.\nLeetcode: What about 3sum?\nMe: you got me mf, I can't say no to that, let's do it."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Bruh I lost my serious mode \\uD83D\\uDE02"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Just a rant.\\nThere are so many top posts about \"Concise solution\". \"Short Solution\". That is not helpful. The goal is to understand. Self documenting code is better than short code. Descriptive variable names are better than short variable names. \\nThanks for reading!"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Because most people posting these solutions have no work experience. If you name all your variables single letter at work...."
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Those python fanatic would be mad if they could read (i am a python user XD)"
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Can\\'t agree more on this!"
                    },
                    {
                        "username": "mauro23",
                        "content": "If we upvote clear, descriptive solutions and we downvote those \"quick 1-liner python solutions\", they\\'ll stop doing it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "A hundred percent. I\\'m sick of the one-liners because I have done this with my proper apps and only God knows what the code is intended to do when I look at it after a couple months, I dont."
                    },
                    {
                        "username": "kursdragon",
                        "content": "Completely agree, all these solutions using awful variable names gives me a headache trying to read and understand. Some of these people were clearly not taught good coding practices haha "
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "i\\'m tired"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes bro?"
                    },
                    {
                        "username": "HavercodeAccount1",
                        "content": "fr fr"
                    },
                    {
                        "username": "countdankula",
                        "content": "You still have to do 4 sum"
                    },
                    {
                        "username": "neptuno",
                        "content": "for real just dumb brain gymnastics "
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "[@Tusharrr_Sharmaaa](/Tusharrr_Sharmaaa) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Tusharrr_Sharmaaa",
                        "content": "3Sum is often tiring my friend"
                    },
                    {
                        "username": "dragon1105",
                        "content": "[@victorpichugov](/victorpichugov) same"
                    },
                    {
                        "username": "victorpichugov",
                        "content": "[@ipsita04](/ipsita04) 308/312 testcases passed :((("
                    },
                    {
                        "username": "ipsita04",
                        "content": "me2"
                    },
                    {
                        "username": "alpon",
                        "content": "Question about test case:\\n[-1,0,1,2,-1,-4]\\nIt is said that the right answer for this case will be\\n[[-1,-1,2],[-1,0,1]]\\nThat is confusing, because if we say that elements '-1' (first in array) and '-1'(5th in array) are different( that is why we have sub array[-1,-1,2] in the answer) the real answer must be the following\\n[[-1,0,1],[-1,0, 1],[-1,2,-1]]\\nbecause we have different \"-1\" in array.\\nPlease correct test cases or refine problem description to avoid ambiguity."
                    },
                    {
                        "username": "arnoldupdev",
                        "content": "[@bilik](/bilik) the following should be a valid answer, and guess what, it\\'s not.\\n\\n[[0,1,-1], [-1,0,1], [-1,2,-1]]\\n\\n`the solution set must not contain duplicate triplets.`\\nAnd\\n`i != j, i != k, and j != k`"
                    },
                    {
                        "username": "neptuno",
                        "content": "[@Electron1997](/Electron1997) Feels like is the same attitude like douchebags that interview with this example"
                    },
                    {
                        "username": "rongon",
                        "content": "It also said, solution must not contain duplicate triplets. That means, your first two triplets have duplicate items. You can think it as a identical combinations of triplets."
                    },
                    {
                        "username": "debashish47",
                        "content": "[@smlrwd](/smlrwd) triplets, by default, mean unordered triplets."
                    },
                    {
                        "username": "klaca",
                        "content": "[@vschaitu](/vschaitu) It also says \"Notice that the solution set must not contain duplicate triplets.\\' which would be completely unnecessary if more triplets with same values would be separate answers, as the lines you cited would cover this case. So implicitly all the needed information is there, especially if we examine the examples, but I understand your frustration."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@smlrwd](/smlrwd) The problem description of this top 20 problem is completely broken and they obviously don\\'t give a ****. I\\'ve reported the several ambiguities more than a month ago (describing them precisly and providing some examples), and I\\'m sure many other users did. It\\'s not the only thing I\\'ve reported. My suggestion: never report anything because you just waste your time, they literally don\\'t care. And never ever buy a subscription, there are plenty of free alternatives"
                    },
                    {
                        "username": "smlrwd",
                        "content": "[@bilik](/bilik) It doesn\\'t explain why [-1, 0, 1] and [0, 1, -1] are considered the same answer. Of course exact duplicates should be ignored, but this question seems to completely ignore it\\'s own instructions. "
                    },
                    {
                        "username": "prakeerthi",
                        "content": "answer itself shouldnt have duplicates.\\n"
                    },
                    {
                        "username": "pranjal_prince",
                        "content": "\"Notice that the solution set must not contain duplicate triplets.\" This condition is given so naturally you can\\'t have two [-1,0,1]"
                    },
                    {
                        "username": "vschaitu",
                        "content": "[@sandagolcea](/sandagolcea)  the problem says this return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, here i j k are unique indexs. there are 2 unique indexs for -1"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "As per problem description \"Notice that the solution set must not contain duplicate triplets.\"\\nSo in your response: `[[-1,0,1],[-1,0, 1],[-1,2,-1]]` , the triplet `[-1,0, 1]` appears twice, so that\\'s not a valid response; regardless of the input, the triplet is duplicated here."
                    },
                    {
                        "username": "hrishavratan",
                        "content": "[@RabinMallick](/RabinMallick)  have u got the solution of it ?"
                    },
                    {
                        "username": "bilik",
                        "content": "[@RabinMallick](/RabinMallick) I got hit by this ambiguity also, but the way I understood it is there shouldn\\'t be duplicate triplets in the sense that even if there\\'s an array of [-1, 0, 1, -1, 0 1] the triplet [-1, 0, 1] can be produced twice but is still the same triplet."
                    },
                    {
                        "username": "RabinMallick",
                        "content": "Yes, my code is giving this answer which is failing test cased"
                    },
                    {
                        "username": "Somian",
                        "content": "Your answer\\n\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\n[[-1,-1,2],[-1,0,1]]\\n\\nThe description doens\\'t say anything about the order the values shold be returned in.\\n\\nThis means that my solution isn\\'t correct, even though it returns the correct numbers (just in a different order).\\n\\nBecause it doens\\'t say anything about how the order needs to be, there is also no way to fix it other than trying different algorithms."
                    },
                    {
                        "username": "andrezabona",
                        "content": "I was trying to print answer instead of return the answer.... maybe it is your problem!"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) Just sort it before writing it in final state"
                    },
                    {
                        "username": "shreeshyla-hanasoge",
                        "content": "It doesn\\'t matter if it is sorted or not, it will accept either ways, but the example shows the sorted order within which is a hint! If you do not sort it how can we know whether we want to add a new found combination to the result or not.  "
                    },
                    {
                        "username": "MALIK225",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  sort your vector using sort () function\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "My test of your result:\\u2014\\n\\nInput:\\n[-1,0,1,2,-1,-4]\\n\\nOutput:\\n[[1,0,-1],[-1,2,-1]]\\nExpected answer\\n\\nVerdict:\\nAccepted\\n\\nMaybe they changed something, because when I run your output as the example code for that given input, that test passes."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "It looks like sorted order to me "
                    },
                    {
                        "username": "quantized",
                        "content": "The same solution that ran in less than 28ms 1.5 years ago takes 80 ms now. I wonder how they calculate the percentile when they are not consistent with computes.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quantized/image_1529815142.png)\\n"
                    },
                    {
                        "username": "user6520Ky",
                        "content": "[@dinesh_ar](/dinesh_ar) It does not explain why my code goes up from 45% to 93% after resubmitting immediately."
                    },
                    {
                        "username": "user2588J",
                        "content": "I have noticed since long time ago inconsistencies with the runtimes."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Arbitrarily. You can often get 20% swings or more resubmitting back to back. It\\u2019s a useless metric and people on LC need to drop it. It proves nothing"
                    },
                    {
                        "username": "santiagobenfatto",
                        "content": "Click two times in Run without any changes and see the diference.  68ms, 88ms, 104ms xD "
                    },
                    {
                        "username": "aashu320",
                        "content": "And then you find that they are taking average of percentiles!! "
                    },
                    {
                        "username": "dinesh_ar",
                        "content": "May be they have updated java version or switched from Oracle."
                    },
                    {
                        "username": "madhavth",
                        "content": "they added more testcases maybe"
                    },
                    {
                        "username": "Xlaton",
                        "content": "\\n1.\\tSort the given array in non-decreasing order.\\n2.\\tLoop through the array from index 0 to n-1.\\n3.\\tFor each iteration, set the target as -nums[i].\\n4.\\tSet two pointers, j=i+1 and k=n-1.\\n5.\\tWhile j<k, check if nums[j]+nums[k]==target.\\n6.\\tIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\n7.\\tIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\n8.\\tTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1].\\n\\n"
                    },
                    {
                        "username": "tuanvu17mta",
                        "content": "[@boakyeokyere96](/boakyeokyere96) Can u explain for me about 8th step? "
                    },
                    {
                        "username": "lembolovo9",
                        "content": "[@moud900](/moud900) Do not mislead people. Very efficient solution. Checked it by myself: more than 90% for both memory and time"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "in the 8th step, you have to make sure i != j-1. Great algorithm"
                    },
                    {
                        "username": "kapilkoushik0217",
                        "content": "I worked with it but its showing time limit exceeded\\nhere is my code:\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>A;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n       for(int i=0;i<n;i++){\\n           int target=-nums[i];\\n           int l=i+1,r=n-1;\\n           while(l<=r){\\n               if(nums[l]+nums[r]==target){\\n                   vector<int>a;\\n                   a.push_back(nums[i]);\\n                   a.push_back(nums[l]);\\n                   a.push_back(nums[r]);\\n                   if(!(binary_search(A.begin(),A.end(),a)))\\n                   A.push_back(a);\\n               }\\n               else if((nums[l]+nums[r])<target){\\n                   l++;\\n               }\\n               else if((nums[l]+nums[r])>target)\\n               {\\n                   r--;\\n               }\\n           }\\n       }\\n        return A;\\n    }\\n};\\n\\ncould you make the changes?\\n"
                    },
                    {
                        "username": "stridemann",
                        "content": "Thank you. This do the job. Also complexity is good, or best.. ( n*n ? )"
                    },
                    {
                        "username": "moud900",
                        "content": "it works but it\\'s not very efficient. beats only 6%"
                    },
                    {
                        "username": "susmitpy",
                        "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\\nExample given:\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nFor the first triplet, i is -1 and j is also -1 but in the probem statement it is clearly mentioned that i != j"
                    },
                    {
                        "username": "ashwinshri219",
                        "content": "i!=j implies index  should be different, not the values"
                    },
                    {
                        "username": "vishakhaas544",
                        "content": "here i!=j condition is already fulfilled i = 0 and j = 4 , but nums[i] and nums[j] can be equal"
                    },
                    {
                        "username": "mehulcode12",
                        "content": "here the value \\'-1\\' is repeated, and they are talking about the index not the value"
                    },
                    {
                        "username": "bansaladitya150",
                        "content": "They are taking about the index not the values"
                    },
                    {
                        "username": "Isaac-Dong",
                        "content": "having the same value is different from using the same number in the triplet. meaning you can have num[0],num[0],num[0] as a triplet"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "i != j, i != k,  j != k is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "sumantdharkar",
                        "content": "[@Rafters](/Rafters) I think its about index, not values\\n"
                    },
                    {
                        "username": "Rafters",
                        "content": "you\\'re confusing i and j with nums[i] and nums[j]"
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "there are two -1 values so both are different if we see the indexs"
                    },
                    {
                        "username": "eshaandevgan6",
                        "content": "No comments written where j<k, j here refers to 4th index."
                    },
                    {
                        "username": "forainychen",
                        "content": "For example, nlog(n)? since we have sort the array, it seems like we might able to do better."
                    },
                    {
                        "username": "jkig",
                        "content": "i don\\'t think sorting this makes it nlogn, because the list to sort is always of size 3, so its technically constant time, no matter how much you scale the nums list, this doesn\\'t make time scale faster\\n"
                    },
                    {
                        "username": "SfSf",
                        "content": "this is fucking retarded."
                    }
                ]
            },
            {
                "id": 1568160,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1913491,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1568191,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1572474,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1573721,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1565591,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1738215,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1570249,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1567804,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 2043121,
                "content": [
                    {
                        "username": "Johnny-Cui",
                        "content": "It said the shuold return unique triple ,then in the following example what is the uique example?\\n\\xB7\\xB7\\xB7\\nInput = [-1,0,1,2,-1]\\n\\xB7\\xB7\\xB7\\n\\nNote that there are two -1, so  corresponding to the result triple (-1,0,1) there are two result with diffrent indexes,  they are [-1.0,1] and [0,1,-1],\\nin this case are there the same triple or not ?  This is the reason why I think this question is not clear"
                    },
                    {
                        "username": "yifeidesu",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) thanks for this commnet. I suddently get what does it mean \\'duplicate triplets\\'. I thought it means the triplet in a triplets should not duplicate but it means the triplets as a whole can\\'t duplicate.\\uD83D\\uDE44"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "sort them (triplets) in ascending order than check if they are equal , if equal include only one of those in the answer."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "This is not the 3sum I wanted"
                    },
                    {
                        "username": "archersmind",
                        "content": "\\n- Return an array of arrays of size *returnSize.\\n   This is how many answers we find out, number of the triplets. Right ?\\n- The sizes of the arrays are returned as *returnColumnSizes array.\\n   Why ? Sizes of the arrays are always 3, right ?"
                    },
                    {
                        "username": "casablanca2020",
                        "content": "Looks like one test case is wrong: [82597,-9243,62390,83030,-97960,-26521,-61011,83390,-38677,12333,75987,46091,83794,19355,-71037,-6242,-28801,324,1202,-90885,-2989,-95597,-34333,35528,5680,89093,-90606,50360,-29393,-27012,53313,65213,99818,-82405,-41661,-3333,-51952,72135,-1523,26377,74685,96992,92263,15929,5467,-99555,-43348,-41689,-60383,-3990,32165,65265,-72973,-58372,12741,-48568,-46596,72419,-1859,34153,62937,81310,-61823,-96770,-54944,8845,-91184,24208,-29078,31495,65258,14198,85395,70506,-40908,56740,-12228,-40072,32429,93001,68445,-73927,25731,-91859,-24150,10093,-60271,-81683,-18126,51055,48189,-6468,25057,81194,-58628,74042,66158,-14452,-49851,-43667,11092,39189,-17025,-79173,13606,83172,92647,-59741,19343,-26644,-57607,82908,-20655,1637,80060,98994,39331,-31274,-61523,91225,-72953,13211,-75116,-98421,-41571,-69074,99587,39345,42151,-2460,98236,15690,-52507,-95803,-48935,-46492,-45606,-79254,-99851,52533,73486,39948,-7240,71815,-585,-96252,90990,-93815,93340,-71848,58733,-14859,-83082,-75794,-82082,-24871,-15206,91207,-56469,-93618,67131,-8682,75719,87429,-98757,-7535,-24890,-94160,85003,33928,75538,97456,-66424,-60074,-8527,-28697,-22308,2246,-70134,-82319,-10184,87081,-34949,-28645,-47352,-83966,-60418,-15293,-53067,-25921,55172,75064,95859,48049,34311,-86931,-38586,33686,-36714,96922,76713,-22165,-80585,-34503,-44516,39217,-28457,47227,-94036,43457,24626,-87359,26898,-70819,30528,-32397,-69486,84912,-1187,-98986,-32958,4280,-79129,-65604,9344,58964,50584,71128,-55480,24986,15086,-62360,-42977,-49482,-77256,-36895,-74818,20,3063,-49426,28152,-97329,6086,86035,-88743,35241,44249,19927,-10660,89404,24179,-26621,-6511,57745,-28750,96340,-97160,-97822,-49979,52307,79462,94273,-24808,77104,9255,-83057,77655,21361,55956,-9096,48599,-40490,-55107,2689,29608,20497,66834,-34678,23553,-81400,-66630,-96321,-34499,-12957,-20564,25610,-4322,-58462,20801,53700,71527,24669,-54534,57879,-3221,33636,3900,97832,-27688,-98715,5992,24520,-55401,-57613,-69926,57377,-77610,20123,52174,860,60429,-91994,-62403,-6218,-90610,-37263,-15052,62069,-96465,44254,89892,-3406,19121,-41842,-87783,-64125,-56120,73904,-22797,-58118,-4866,5356,75318,46119,21276,-19246,-9241,-97425,57333,-15802,93149,25689,-5532,95716,39209,-87672,-29470,-16324,-15331,27632,-39454,56530,-16000,29853,46475,78242,-46602,83192,-73440,-15816,50964,-36601,89758,38375,-40007,-36675,-94030,67576,46811,-64919,45595,76530,40398,35845,41791,67697,-30439,-82944,63115,33447,-36046,-50122,-34789,43003,-78947,-38763,-89210,32756,-20389,-31358,-90526,-81607,88741,86643,98422,47389,-75189,13091,95993,-15501,94260,-25584,-1483,-67261,-70753,25160,89614,-90620,-48542,83889,-12388,-9642,-37043,-67663,28794,-8801,13621,12241,55379,84290,21692,-95906,-85617,-17341,-63767,80183,-4942,-51478,30997,-13658,8838,17452,-82869,-39897,68449,31964,98158,-49489,62283,-62209,-92792,-59342,55146,-38533,20496,62667,62593,36095,-12470,5453,-50451,74716,-17902,3302,-16760,-71642,-34819,96459,-72860,21638,47342,-69897,-40180,44466,76496,84659,13848,-91600,-90887,-63742,-2156,-84981,-99280,94326,-33854,92029,-50811,98711,-36459,-75555,79110,-88164,-97397,-84217,97457,64387,30513,-53190,-83215,252,2344,-27177,-92945,-89010,82662,-11670,86069,53417,42702,97082,3695,-14530,-46334,17910,77999,28009,-12374,15498,-46941,97088,-35030,95040,92095,-59469,-24761,46491,67357,-66658,37446,-65130,-50416,99197,30925,27308,54122,-44719,12582,-99525,-38446,-69050,-22352,94757,-56062,33684,-40199,-46399,96842,-50881,-22380,-65021,40582,53623,-76034,77018,-97074,-84838,-22953,-74205,79715,-33920,-35794,-91369,73421,-82492,63680,-14915,-33295,37145,76852,-69442,60125,-74166,74308,-1900,-30195,-16267,-60781,-27760,5852,38917,25742,-3765,49097,-63541,98612,-92865,-30248,9612,-8798,53262,95781,-42278,-36529,7252,-27394,-5021,59178,80934,-48480,-75131,-54439,-19145,-48140,98457,-6601,-51616,-89730,78028,32083,-48904,16822,-81153,-8832,48720,-80728,-45133,-86647,-4259,-40453,2590,28613,50523,-4105,-27790,-74579,-17223,63721,33489,-47921,97628,-97691,-14782,-65644,18008,-93651,-71266,80990,-76732,-47104,35368,28632,59818,-86269,-89753,34557,-92230,-5933,-3487,-73557,-13174,-43981,-43630,-55171,30254,-83710,-99583,-13500,71787,5017,-25117,-78586,86941,-3251,-23867,-36315,75973,86272,-45575,77462,-98836,-10859,70168,-32971,-38739,-12761,93410,14014,-30706,-77356,-85965,-62316,63918,-59914,-64088,1591,-10957,38004,15129,-83602,-51791,34381,-89382,-26056,8942,5465,71458,-73805,-87445,-19921,-80784,69150,-34168,28301,-68955,18041,6059,82342,9947,39795,44047,-57313,48569,81936,-2863,-80932,32976,-86454,-84207,33033,32867,9104,-16580,-25727,80157,-70169,53741,86522,84651,68480,84018,61932,7332,-61322,-69663,76370,41206,12326,-34689,17016,82975,-23386,39417,72793,44774,-96259,3213,79952,29265,-61492,-49337,14162,65886,3342,-41622,-62659,-90402,-24751,88511,54739,-21383,-40161,-96610,-24944,-602,-76842,-21856,69964,43994,-15121,-85530,12718,13170,-13547,69222,62417,-75305,-81446,-38786,-52075,-23110,97681,-82800,-53178,11474,35857,94197,-58148,-23689,32506,92154,-64536,-73930,-77138,97446,-83459,70963,22452,68472,-3728,-25059,-49405,95129,-6167,12808,99918,30113,-12641,-26665,86362,-33505,50661,26714,33701,89012,-91540,40517,-12716,-57185,-87230,29914,-59560,13200,-72723,58272,23913,-45586,-96593,-26265,-2141,31087,81399,92511,-34049,20577,2803,26003,8940,42117,40887,-82715,38269,40969,-50022,72088,21291,-67280,-16523,90535,18669,94342,-39568,-88080,-99486,-20716,23108,-28037,63342,36863,-29420,-44016,75135,73415,16059,-4899,86893,43136,-7041,33483,-67612,25327,40830,6184,61805,4247,81119,-22854,-26104,-63466,63093,-63685,60369,51023,51644,-16350,74438,-83514,99083,10079,-58451,-79621,48471,67131,-86940,99093,11855,-22272,-67683,-44371,9541,18123,37766,-70922,80385,-57513,-76021,-47890,36154,72935,84387,-92681,-88303,-7810,59902,-90,-64704,-28396,-66403,8860,13343,33882,85680,7228,28160,-14003,54369,-58893,92606,-63492,-10101,64714,58486,29948,-44679,-22763,10151,-56695,4031,-18242,-36232,86168,-14263,9883,47124,47271,92761,-24958,-73263,-79661,-69147,-18874,29546,-92588,-85771,26451,-86650,-43306,-59094,-47492,-34821,-91763,-47670,33537,22843,67417,-759,92159,63075,94065,-26988,55276,65903,30414,-67129,-99508,-83092,-91493,-50426,14349,-83216,-76090,32742,-5306,-93310,-60750,-60620,-45484,-21108,-58341,-28048,-52803,69735,78906,81649,32565,-86804,-83202,-65688,-1760,89707,93322,-72750,84134,71900,-37720,19450,-78018,22001,-23604,26276,-21498,65892,-72117,-89834,-23867,55817,-77963,42518,93123,-83916,63260,-2243,-97108,85442,-36775,17984,-58810,99664,-19082,93075,-69329,87061,79713,16296,70996,13483,-74582,49900,-27669,-40562,1209,-20572,34660,83193,75579,7344,64925,88361,60969,3114,44611,-27445,53049,-16085,-92851,-53306,13859,-33532,86622,-75666,-18159,-98256,51875,-42251,-27977,-18080,23772,38160,41779,9147,94175,99905,-85755,62535,-88412,-52038,-68171,93255,-44684,-11242,-104,31796,62346,-54931,-55790,-70032,46221,56541,-91947,90592,93503,4071,20646,4856,-63598,15396,-50708,32138,-85164,38528,-89959,53852,57915,-42421,-88916,-75072,67030,-29066,49542,-71591,61708,-53985,-43051,28483,46991,-83216,80991,-46254,-48716,39356,-8270,-47763,-34410,874,-1186,-7049,28846,11276,21960,-13304,-11433,-4913,55754,79616,70423,-27523,64803,49277,14906,-97401,-92390,91075,70736,21971,-3303,55333,-93996,76538,54603,-75899,98801,46887,35041,48302,-52318,55439,24574,14079,-24889,83440,14961,34312,-89260,-22293,-81271,-2586,-71059,-10640,-93095,-5453,-70041,66543,74012,-11662,-52477,-37597,-70919,92971,-17452,-67306,-80418,7225,-89296,24296,86547,37154,-10696,74436,-63959,58860,33590,-88925,-97814,-83664,85484,-8385,-50879,57729,-74728,-87852,-15524,-91120,22062,28134,80917,32026,49707,-54252,-44319,-35139,13777,44660,85274,25043,58781,-89035,-76274,6364,-63625,72855,43242,-35033,12820,-27460,77372,-47578,-61162,-70758,-1343,-4159,64935,56024,-2151,43770,19758,-30186,-86040,24666,-62332,-67542,73180,-25821,-27826,-45504,-36858,-12041,20017,-24066,-56625,-52097,-47239,-90694,8959,7712,-14258,-5860,55349,61808,-4423,-93703,64681,-98641,-25222,46999,-83831,-54714,19997,-68477,66073,51801,-66491,52061,-52866,79907,-39736,-68331,68937,91464,98892,910,93501,31295,-85873,27036,-57340,50412,21,-2445,29471,71317,82093,-94823,-54458,-97410,39560,-7628,66452,39701,54029,37906,46773,58296,60370,-61090,85501,-86874,71443,-72702,-72047,14848,34102,77975,-66294,-36576,31349,52493,-70833,-80287,94435,39745,-98291,84524,-18942,10236,93448,50846,94023,-6939,47999,14740,30165,81048,84935,-19177,-13594,32289,62628,-90612,-542,-66627,64255,71199,-83841,-82943,-73885,8623,-67214,-9474,-35249,62254,-14087,-90969,21515,-83303,94377,-91619,19956,-98810,96727,-91939,29119,-85473,-82153,-69008,44850,74299,-76459,-86464,8315,-49912,-28665,59052,-69708,76024,-92738,50098,18683,-91438,18096,-19335,35659,91826,15779,-73070,67873,-12458,-71440,-46721,54856,97212,-81875,35805,36952,68498,81627,-34231,81712,27100,-9741,-82612,18766,-36392,2759,41728,69743,26825,48355,-17790,17165,56558,3295,-24375,55669,-16109,24079,73414,48990,-11931,-78214,90745,19878,35673,-15317,-89086,94675,-92513,88410,-93248,-19475,-74041,-19165,32329,-26266,-46828,-18747,45328,8990,-78219,-25874,-74801,-44956,-54577,-29756,-99822,-35731,-18348,-68915,-83518,-53451,95471,-2954,-13706,-8763,-21642,-37210,16814,-60070,-42743,27697,-36333,-42362,11576,85742,-82536,68767,-56103,-63012,71396,-78464,-68101,-15917,-11113,-3596,77626,-60191,-30585,-73584,6214,-84303,18403,23618,-15619,-89755,-59515,-59103,-74308,-63725,-29364,-52376,-96130,70894,-12609,50845,-2314,42264,-70825,64481,55752,4460,-68603,-88701,4713,-50441,-51333,-77907,97412,-66616,-49430,60489,-85262,-97621,-18980,44727,-69321,-57730,66287,-92566,-64427,-14270,11515,-92612,-87645,61557,24197,-81923,-39831,-10301,-23640,-76219,-68025,92761,-76493,68554,-77734,-95620,-11753,-51700,98234,-68544,-61838,29467,46603,-18221,-35441,74537,40327,-58293,75755,-57301,-7532,-94163,18179,-14388,-22258,-46417,-48285,18242,-77551,82620,250,-20060,-79568,-77259,82052,-98897,-75464,48773,-79040,-11293,45941,-67876,-69204,-46477,-46107,792,60546,-34573,-12879,-94562,20356,-48004,-62429,96242,40594,2099,99494,25724,-39394,-2388,-18563,-56510,-83570,-29214,3015,74454,74197,76678,-46597,60630,-76093,37578,-82045,-24077,62082,-87787,-74936,58687,12200,-98952,70155,-77370,21710,-84625,-60556,-84128,925,65474,-15741,-94619,88377,89334,44749,22002,-45750,-93081,-14600,-83447,46691,85040,-66447,-80085,56308,44310,24979,-29694,57991,4675,-71273,-44508,13615,-54710,23552,-78253,-34637,50497,68706,81543,-88408,-21405,6001,-33834,-21570,-46692,-25344,20310,71258,-97680,11721,59977,59247,-48949,98955,-50276,-80844,-27935,-76102,55858,-33492,40680,66691,-33188,8284,64893,-7528,6019,-85523,8434,-64366,-56663,26862,30008,-7611,-12179,-70076,21426,-11261,-36864,-61937,-59677,929,-21052,3848,-20888,-16065,98995,-32293,-86121,-54564,77831,68602,74977,31658,40699,29755,98424,80358,-69337,26339,13213,-46016,-18331,64713,-46883,-58451,-70024,-92393,-4088,70628,-51185,71164,-75791,-1636,-29102,-16929,-87650,-84589,-24229,-42137,-15653,94825,13042,88499,-47100,-90358,-7180,29754,-65727,-42659,-85560,-9037,-52459,20997,-47425,17318,21122,20472,-23037,65216,-63625,-7877,-91907,24100,-72516,22903,-85247,-8938,73878,54953,87480,-31466,-99524,35369,-78376,89984,-15982,94045,-7269,23319,-80456,-37653,-76756,2909,81936,54958,-12393,60560,-84664,-82413,66941,-26573,-97532,64460,18593,-85789,-38820,-92575,-43663,-89435,83272,-50585,13616,-71541,-53156,727,-27644,16538,34049,57745,34348,35009,16634,-18791,23271,-63844,95817,21781,16590,59669,15966,-6864,48050,-36143,97427,-59390,96931,78939,-1958,50777,43338,-51149,39235,-27054,-43492,67457,-83616,37179,10390,85818,2391,73635,87579,-49127,-81264,-79023,-81590,53554,-74972,-83940,-13726,-39095,29174,78072,76104,47778,25797,-29515,-6493,-92793,22481,-36197,-65560,42342,15750,97556,99634,-56048,-35688,13501,63969,-74291,50911,39225,93702,-3490,-59461,-30105,-46761,-80113,92906,-68487,50742,36152,-90240,-83631,24597,-50566,-15477,18470,77038,40223,-80364,-98676,70957,-63647,99537,13041,31679,86631,37633,-16866,13686,-71565,21652,-46053,-80578,-61382,68487,-6417,4656,20811,67013,-30868,-11219,46,74944,14627,56965,42275,-52480,52162,-84883,-52579,-90331,92792,42184,-73422,-58440,65308,-25069,5475,-57996,59557,-17561,2826,-56939,14996,-94855,-53707,99159,43645,-67719,-1331,21412,41704,31612,32622,1919,-69333,-69828,22422,-78842,57896,-17363,27979,-76897,35008,46482,-75289,65799,20057,7170,41326,-76069,90840,-81253,-50749,3649,-42315,45238,-33924,62101,96906,58884,-7617,-28689,-66578,62458,50876,-57553,6739,41014,-64040,-34916,37940,13048,-97478,-11318,-89440,-31933,-40357,-59737,-76718,-14104,-31774,28001,4103,41702,-25120,-31654,63085,-3642,84870,-83896,-76422,-61520,12900,88678,85547,33132,-88627,52820,63915,-27472,78867,-51439,33005,-23447,-3271,-39308,39726,-74260,-31874,-36893,93656,910,-98362,60450,-88048,99308,13947,83996,-90415,-35117,70858,-55332,-31721,97528,82982,-86218,6822,25227,36946,97077,-4257,-41526,56795,89870,75860,-70802,21779,14184,-16511,-89156,-31422,71470,69600,-78498,74079,-19410,40311,28501,26397,-67574,-32518,68510,38615,19355,-6088,-97159,-29255,-92523,3023,-42536,-88681,64255,41206,44119,52208,39522,-52108,91276,-70514,83436,63289,-79741,9623,99559,12642,85950,83735,-21156,-67208,98088,-7341,-27763,-30048,-44099,-14866,-45504,-91704,19369,13700,10481,-49344,-85686,33994,19672,36028,60842,66564,-24919,33950,-93616,-47430,-35391,-28279,56806,74690,39284,-96683,-7642,-75232,37657,-14531,-86870,-9274,-26173,98640,88652,64257,46457,37814,-19370,9337,-22556,-41525,39105,-28719,51611,-93252,98044,-90996,21710,-47605,-64259,-32727,53611,-31918,-3555,33316,-66472,21274,-37731,-2919,15016,48779,-88868,1897,41728,46344,-89667,37848,68092,-44011,85354,-43776,38739,-31423,-66330,65167,-22016,59405,34328,-60042,87660,-67698,-59174,-1408,-46809,-43485,-88807,-60489,13974,22319,55836,-62995,-37375,-4185,32687,-36551,-75237,58280,26942,-73756,71756,78775,-40573,14367,-71622,-77338,24112,23414,-7679,-51721,87492,85066,-21612,57045,10673,-96836,52461,-62218,-9310,65862,-22748,89906,-96987,-98698,26956,-43428,46141,47456,28095,55952,67323,-36455,-60202,-43302,-82932,42020,77036,10142,60406,70331,63836,58850,-66752,52109,21395,-10238,-98647,-41962,27778,69060,98535,-28680,-52263,-56679,66103,-42426,27203,80021,10153,58678,36398,63112,34911,20515,62082,-15659,-40785,27054,43767,-20289,65838,-6954,-60228,-72226,52236,-35464,25209,-15462,-79617,-41668,-84083,62404,-69062,18913,46545,20757,13805,24717,-18461,-47009,-25779,68834,64824,34473,39576,31570,14861,-15114,-41233,95509,68232,67846,84902,-83060,17642,-18422,73688,77671,-26930,64484,-99637,73875,6428,21034,-73471,19664,-68031,15922,-27028,48137,54955,-82793,-41144,-10218,-24921,-28299,-2288,68518,-54452,15686,-41814,66165,-72207,-61986,80020,50544,-99500,16244,78998,40989,14525,-56061,-24692,-94790,21111,37296,-90794,72100,70550,-31757,17708,-74290,61910,78039,-78629,-25033,73172,-91953,10052,64502,99585,-1741,90324,-73723,68942,28149,30218,24422,16659,10710,-62594,94249,96588,46192,34251,73500,-65995,-81168,41412,-98724,-63710,-54696,-52407,19746,45869,27821,-94866,-76705,-13417,-61995,-71560,43450,67384,-8838,-80293,-28937,23330,-89694,-40586,46918,80429,-5475,78013,25309,-34162,37236,-77577,86744,26281,-29033,-91813,35347,13033,-13631,-24459,3325,-71078,-75359,81311,19700,47678,-74680,-84113,45192,35502,37675,19553,76522,-51098,-18211,89717,4508,-82946,27749,85995,89912,-53678,-64727,-14778,32075,-63412,-40524,86440,-2707,-36821,63850,-30883,67294,-99468,-23708,34932,34386,98899,29239,-23385,5897,54882,98660,49098,70275,17718,88533,52161,63340,50061,-89457,19491,-99156,24873,-17008,64610,-55543,50495,17056,-10400,-56678,-29073,-42960,-76418,98562,-88104,-96255,10159,-90724,54011,12052,45871,-90933,-69420,67039,37202,78051,-52197,-40278,-58425,65414,-23394,-1415,6912,-53447,7352,17307,-78147,63727,98905,55412,-57658,-32884,-44878,22755,39730,3638,35111,39777,74193,38736,-11829,-61188,-92757,55946,-71232,-63032,-83947,39147,-96684,-99233,25131,-32197,24406,-55428,-61941,25874,-69453,64483,-19644,-68441,12783,87338,-48676,66451,-447,-61590,50932,-11270,29035,65698,-63544,10029,80499,-9461,86368,91365,-81810,-71914,-52056,-13782,44240,-30093,-2437,24007,67581,-17365,-69164,-8420,-69289,-29370,48010,90439,13141,69243,50668,39328,61731,78266,-81313,17921,-38196,55261,9948,-24970,75712,-72106,28696,7461,31621,61047,51476,56512,11839,-96916,-82739,28924,-99927,58449,37280,69357,11219,-32119,-62050,-48745,-83486,-52376,42668,82659,68882,38773,46269,-96005,97630,25009,-2951,-67811,99801,81587,-79793,-18547,-83086,69512,33127,-92145,-88497,47703,59527,1909,88785,-88882,69188,-46131,-5589,-15086,36255,-53238,-33009,82664,53901,35939,-42946,-25571,33298,69291,53199,74746,-40127,-39050,91033,51717,-98048,87240,36172,65453,-94425,-63694,-30027,59004,88660,3649,-20267,-52565,-67321,34037,4320,91515,-56753,60115,27134,68617,-61395,-26503,-98929,-8849,-63318,10709,-16151,61905,-95785,5262,23670,-25277,90206,-19391,45735,37208,-31992,-92450,18516,-90452,-58870,-58602,93383,14333,17994,82411,-54126,-32576,35440,-60526,-78764,-25069,-9022,-394,92186,-38057,55328,-61569,67780,77169,19546,-92664,-94948,44484,-13439,83529,27518,-48333,72998,38342,-90553,-98578,-76906,81515,-16464,78439,92529,35225,-39968,-10130,-7845,-32245,-74955,-74996,67731,-13897,-82493,33407,93619,59560,-24404,-57553,19486,-45341,34098,-24978,-33612,79058,71847,76713,-95422,6421,-96075,-59130,-28976,-16922,-62203,69970,68331,21874,40551,89650,51908,58181,66480,-68177,34323,-3046,-49656,-59758,43564,-10960,-30796,15473,-20216,46085,-85355,41515,-30669,-87498,57711,56067,63199,-83805,62042,91213,-14606,4394,-562,74913,10406,96810,-61595,32564,31640,-9732,42058,98052,-7908,-72330,1558,-80301,34878,32900,3939,-8824,88316,20937,21566,-3218,-66080,-31620,86859,54289,90476,-42889,-15016,-18838,75456,30159,-67101,42328,-92703,85850,-5475,23470,-80806,68206,17764,88235,46421,-41578,74005,-81142,80545,20868,-1560,64017,83784,68863,-97516,-13016,-72223,79630,-55692,82255,88467,28007,-34686,-69049,-41677,88535,-8217,68060,-51280,28971,49088,49235,26905,-81117,-44888,40623,74337,-24662,97476,79542,-72082,-35093,98175,-61761,-68169,59697,-62542,-72965,59883,-64026,-37656,-92392,-12113,-73495,98258,68379,-21545,64607,-70957,-92254,-97460,-63436,-8853,-19357,-51965,-76582,12687,-49712,45413,-60043,33496,31539,-57347,41837,67280,-68813,52088,-13155,-86430,-15239,-45030,96041,18749,-23992,46048,35243,-79450,85425,-58524,88781,-39454,53073,-48864,-82289,39086,82540,-11555,25014,-5431,-39585,-89526,2705,31953,-81611,36985,-56022,68684,-27101,11422,64655,-26965,-63081,-13840,-91003,-78147,-8966,41488,1988,99021,-61575,-47060,65260,-23844,-21781,-91865,-19607,44808,2890,63692,-88663,-58272,15970,-65195,-45416,-48444,-78226,-65332,-24568,42833,-1806,-71595,80002,-52250,30952,48452,-90106,31015,-22073,62339,63318,78391,28699,77900,-4026,-76870,-45943,33665,9174,-84360,-22684,-16832,-67949,-38077,-38987,-32847,51443,-53580,-13505,9344,-92337,26585,70458,-52764,-67471,-68411,-1119,-2072,-93476,67981,40887,-89304,-12235,41488,1454,5355,-34855,-72080,24514,-58305,3340,34331,8731,77451,-64983,-57876,82874,62481,-32754,-39902,22451,-79095,-23904,78409,-7418,77916]\\n\\nAnyone get the same problem?"
                    },
                    {
                        "username": "leonardo_po",
                        "content": "same for me, my solution is O(n^2) which should be accepted, but i\\'m getting TLE in this testcase\\n"
                    },
                    {
                        "username": "cwwu97",
                        "content": "I think the problem here is when you hit the target, you should keep iterating through the rest of the values between the 2 pointers instead of break the loop.\\ne.g., nums=[-4,-2,-1,0,2,2,4], \\nif you break the while loop when [-4,0,4] is found, then [-4,2,2] will never be included in the answer."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@alexandruDobrin93](/alexandruDobrin93) same, this test case(case 308) is not letting me proceed. idk if its a time complexity issue or something but i just do not know how to wrap my head around this."
                    },
                    {
                        "username": "HudsonL",
                        "content": "That same exact test case fails on me. In my solution I piggy back on the two-sum and remove duplicates"
                    },
                    {
                        "username": "alexandruDobrin93",
                        "content": "I have the same problem. Does anyone managed to solve it? I use one iteration and the two pointer solution"
                    },
                    {
                        "username": "himanshugullaiya",
                        "content": "<p><b>Testcase : </b> [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]</p>\\n<p> <b>Leetcode Expected Output :</b>[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,0,2]]</p>\\n<p><b>My Output : </b> [[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]<b>,[-2,-2,4]</b>,[-2,0,2]] </p>\\n<p> I think <b>[-2,-2,4]</b>should also be in the answer as it is <b> not duplicate</b> and is missing in expected output. \\nWhat are your thoughts guys?\\n\\n"
                    },
                    {
                        "username": "DalJeanis",
                        "content": "Yours looks right to me.  It doesn\\'t make sense for it to be deduping [-4,2,2] against [-2,-2,4]."
                    },
                    {
                        "username": "likkiii",
                        "content": "[@elmort](/elmort) It has to be sorted ig. Atleast that\\'s how the expected output looks like."
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) Doing what is mentioned here helped (however, it makes no sense to sort the resulting array before comparing for duplications) : https://leetcode.com/problems/3sum/description/comments/1920411 "
                    },
                    {
                        "username": "elmort",
                        "content": "[@NunOfIt](/NunOfIt) I got the same issue, I do not understand why `[-1, 1, 0]` is a wrong output (since order inside the output does not matter) :s "
                    },
                    {
                        "username": "NunOfIt",
                        "content": "I have the same question!\\nInput: [-1, 0, 1, 0]\\nOutput: [[-1, 0, 1], [-1, 1, 0]]\\nExpected: [[-1, 0, 1]]\\n\\nDid you figure out what was wrong?"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "I wrote the same solution for this problem in C++ and Java and the C++ version takes 50ms while Java only 7ms.\\n\\nJava is also the fastest in the distribution chart, even faster than C.\\nI wonder if Jave code is compiled to native code on Leetcode?\\n\\nAny ideas?\\n\\nThanks,\\nYunzhu"
                    },
                    {
                        "username": "aysknt_02",
                        "content": "[@anmolverma075](/anmolverma075) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "anmolverma075",
                        "content": "This comment is 8 years old , cool!\\n\\n"
                    },
                    {
                        "username": "Educatque",
                        "content": "How to make this time limit exceeded work"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "[@DrewBruggman](/DrewBruggman) same dude same, case 308 is eating me up and ive been up on this problem since the entire evening\\n"
                    },
                    {
                        "username": "HLi111",
                        "content": "[@DrewBruggman](/DrewBruggman) Same"
                    },
                    {
                        "username": "DrewBruggman",
                        "content": "Yeah I don\\'t get it... I get to 308/312 cleared, then that data set comes and ruins everything... I even have a clever algorithm to (I think) cut off any unnecessary cacluations... idk how to make this work."
                    },
                    {
                        "username": "arpit2136",
                        "content": "why it is exceeding time limit in last test case and why we need to update left pointer till consecutive matches(it was eventually going to match anyway)"
                    },
                    {
                        "username": "Naruto14",
                        "content": "Sorry but I do not understand the use of int* returnSize. In \"C\", why is this given and for a given array what its value will be? Please explain it using some example."
                    },
                    {
                        "username": "michaeldraga",
                        "content": "This question is very old, but just in case anyone should stumble upon this in the future:\\nThe C standard library doesn\\'t contain some sort of \"managed\" array like you would be used to from languages such as Java. A basic array in C is just a pointer to the location in memory where the array *starts*. When you pass an array to a function or return one from a function, all you are returning is a pointer to the location in memory the array starts. As you might have noticed already, this doesn\\'t give you any information about where the array *ends*, or in other words, its length. While there are multiple ways to solve this issue, one of the most widely used conventions in the C community is to pass an int pointer to a function that will return an array of unknown length. The function will then write the length of the allocated array to the memory address the int pointer points to, so that the calling function can know the length of the returned array.\\n\\nSorry for the long answer; didn\\'t have time to write a short one."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization and explanation of O(n^2) solution\\n\\nhttps://youtu.be/IIxoo93bmPQ?si=imQAzyiKFE_ixT3Q"
                    }
                ]
            },
            {
                "id": 1836431,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1636825,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1576957,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1574604,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1569368,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1791955,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1782764,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1574994,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1572315,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1941148,
                "content": [
                    {
                        "username": "wastebin",
                        "content": "I\\'m having a weird issue where when I go to submit the problem, it shows the following:\\n![leetcode](https://i.imgur.com/oicc3z2.png)Can someone pls explain this anomaly?"
                    },
                    {
                        "username": "Mishradeepanshu",
                        "content": "you code is working well but you have to give an optimized way to do that."
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "[@ak_is_here](/ak_is_here) But what\\'s the test case #312 contains of? I cannot evaluate it as it appears to be an empty test case. Please advise."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) Makes sense. Thanks. That is just not obvious from the given submission output for someone who hasn\\'t faced it. UI would probably be better and clearer if something pointed to exceeding an overall execution time threshold for all test cases like \"your solution is correct, but too slow\" :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@itisevgeny1](/itisevgeny1) A compiler can show a \"Time Limit Exceeded\" error even if all the test cases are passed. This occurs when the program takes longer than the specified time limit to complete its execution, regardless of whether it produced the correct output or not.\\n\\nIn other words, passing the test cases alone does not guarantee that the program will be accepted. The program must also execute within the given time limit. Therefore, it is essential to optimize the program\\'s efficiency and avoid unnecessary computations to ensure it runs within the specified time limit.\\nKeep Coding :)"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "[@wastebin](/wastebin) Please share link to your solution. Will try to find the issue. Most probably it will require only a bit of optimisation so that it can run faster and TLE doesn't occur."
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "[@ak_is_here](/ak_is_here) If there was a certain test case that didn't pass, it would be presented as a failed test case with respective input parameters, right? Also, 312 out of 312 are shown. Seems correct."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\nWhen solving coding problems, it's always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\n\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I've also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\n\nAlso in your case, TLE may be because of an infinite loop because of a certain test case or program is taking more time for execution.\n\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\n\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "itisevgeny1",
                        "content": "Seems like a bug. Even previously accepted solution does not work and the issue is exactly the same."
                    },
                    {
                        "username": "Sandy01",
                        "content": "So, \\nAfter wrapping my head around for hours on this and trying to solve this problems along the similar lines I did Two sum one. But I hit a block when I try to solve this question with hashing in JS. So basically I figure out the triplets but then realize that I need to remove the duplicates from my results. Just wanted to check is there any easy and efficient way to do that? \\n\\n- First hash the given array and their occurrence\\n- Using the nested loop and then check the - ( nums[i] + nums[j] ) in the hash object\\n- Then stuck on the duplicate issue. "
                    },
                    {
                        "username": "yogendrabagoriya",
                        "content": "In this question they provided below exmple with input and output.\\n\\nInput: [-1,0,1,2,-1,-4]\\nExpected: [[-1,-1,2],[-1,0,1]]\\n\\n**But In my openion out put shoud be** : [[-1,0,1],[-1,2,-1],[0,1,-1]]\\nhere is postional values **i, j, k from input array** for above 3 output **[[0, 1, 2], [0, 3, 4], [2, 3, 4]]**"
                    },
                    {
                        "username": "jsaha437",
                        "content": "iterate ur array and sort each array then convert the whole lot to a set and get duplicay removed"
                    },
                    {
                        "username": "dob2086",
                        "content": "The output should not contain duplicate values of the array. [-1,0,1] is same as [0,1,-1]"
                    },
                    {
                        "username": "DrWolf",
                        "content": "Could somebody comment on this?"
                    },
                    {
                        "username": "alanwj",
                        "content": "To reduce the number of reallocations, it would be convenient to know the number of possible solutions up front.\\n\\nBecause we have algorithms that execute O(n^2) iterations, and can produce at most one solution per iteration, we expect any bound on the number of solutions to be O(n^2).  However, for memory allocation purposes, we want actual bounds, rather than asymptotic bounds.\\n\\nHere is the best bound I have found.\\n\\nLet us assume we first sort the array, and then proceed as follows.  For each number `x` in the array, we create a target `T = 0 - x`, and then run a two-sum on all elements greater than `x` to find all pairs summing to `T`.  We exclude the last two elements in the array from this process since there can be no solutions with fewer than three elements.\\n\\nWhen doing a two-sum with `k` elements, at most `k/2` pairs can sum to `T`.  Our first two-sum step operates on `n-1` elements.  The next on `n-2`, etc.  The last operates on 2 elements.  Then the total possible number of solutions is `sum(k/2) from k=2 to k=n-1`, which is equal to `(n^2 - n - 2) / 4`.\\n\\nThis last expression is an upper bound on the total number of possible solutions.\\n\\nIntuitively, I feel like we should be able to make this bound significantly tighter, as it ignores any relationship between iterations.  For example, if you actually found `(n-1)/2` solutions on the first iteration, would it then be possible to find `(n-2)/2` solutions on the second iteration?\\n"
                    },
                    {
                        "username": "bluecloud",
                        "content": "I\\'m thinking O(n^3) because possibly all combinations of triplets can sum to 0."
                    },
                    {
                        "username": "Hashmael",
                        "content": "[@Hashmael](/Hashmael) You can also throw some function caching in to remove redundant computation. It\\'s a time-space tradeoff. Super easy in python3, which is my primary language"
                    },
                    {
                        "username": "Hashmael",
                        "content": "If you sort the list and look at the extrema, you can cut down n by quite a bit.\\ni.e. if the sorted list starts with a positive number, you can immediately return an empty list. If the sorted list starts with 0 and has less than 3 zeros, you can immediately return an empty list.\\nIf the sorted list starts with 3 zeros, you can return a list containing only [0, 0, 0].\\nYou can trim any number greater than -1 * the sum of the two lowest numbers; similarly, you can trim any number less than -1 * the sum of the two highest numbers."
                    },
                    {
                        "username": "fadarko",
                        "content": "Time Limit Exceeded - 312 / 312 testcases passed\\nHow is that?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "it means that the leetcode question need to be solved in less time complexity and      your solution is correct but with larger time complexity"
                    },
                    {
                        "username": "updownuper",
                        "content": "I also faced this problem. I don\\'t know what to do."
                    },
                    {
                        "username": "vienhuynhemc",
                        "content": "Currently, the last testcase 312/312 is missing the input. Please fix it. Thanks"
                    },
                    {
                        "username": "bernards",
                        "content": "same here :)"
                    },
                    {
                        "username": "noisyninja",
                        "content": "I understand that we can use one value as the index and do two sum on the rest of the array.\\n\\n* But what\\'s the reason for sorting the array first, specially for a hashset based 2sum implementation which doesn\\'t required sorting?\\n\\n* Also, why is 3sum closest not possible on hashmap based 2sum approach? Won\\'t the min = (min, compliment+value) work?"
                    },
                    {
                        "username": "haliluysal",
                        "content": "Hi everybody,\\nI am getting \"wrong answer\" with the test case 309. but when I tested the input using \"console\" I do not see any difference between the expected out and the my output. What might be the problem here?\\nI am attaching the screenshot to visualize the problem.\\n![image](https://assets.leetcode.com/users/haliluysal/image_1544117646.png)\\n"
                    },
                    {
                        "username": "congvu",
                        "content": "You can refer at https://www.youtube.com/watch?v=EGVpKCEL1W8"
                    }
                ]
            },
            {
                "id": 1940219,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 1819269,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 1748902,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 1576110,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 1574555,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 1573714,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 1566306,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 2050062,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 2044550,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 2043693,
                "content": [
                    {
                        "username": "U2jwal",
                        "content": "One day, ill be mature enough xD\\n"
                    },
                    {
                        "username": "updownuper",
                        "content": "312 / 312 testcases passed\nTime Limit Exceeded\nnums = \n\nWhat it means?\nNo values, why can't I pass this test?\n( java )"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity and it has passed all the test cases as well.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "user1259wX",
                        "content": "Seems like python O(n^2) solutions tend to still fail some of the test cases at the end. Anyone else have that problem?"
                    },
                    {
                        "username": "sttaq2",
                        "content": "[-1,0,1,0]\\n\\nshould return two arrays:\\n\\n[-1 , 0, 1] for indexes [0, 1, 2]\\nand\\n[-1, 1, 0] for indexes [0, 2, 3]\\n\\nhowever the expected output is\\n\\n[-1 , 0, 1]\\n\\nhow is that possible?"
                    },
                    {
                        "username": "None2023",
                        "content": "same question here"
                    },
                    {
                        "username": "sourabhb",
                        "content": "Is it a term to denote time complexity ?"
                    },
                    {
                        "username": "takahiro2",
                        "content": "It says runtime complexity is `O(n^2)` which derives from `nlog(n) + n^2`. But I don\\'t understand why where and how it costs `n^2`. Anybody can help to explain this?\\nThanks"
                    },
                    {
                        "username": "ri12",
                        "content": "This solution is similar to the solution of finding two numbers in a array whose sum is x. We have to first find if -a, -b or -c exist in the array. If none of these are there then solution is not possible. If anyone is there then find the two numbers whose sum is equal to -a, -b or -c. \\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Uhmm.. three sum"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "minecraft lofi music"
                    },
                    {
                        "username": "theycallmecoder",
                        "content": "I tried with 2 approaches which are having time complexity - O(n^2) , but only one got submitted. \\nApproach 1 - What if we use two for loops and then do a binary search for the third number. This is also having time complexity of O(n^2). \\n\\nApproach 2 - Use 1 for loop and then find the two numbers whose sum is equal to the number we got from the \"for loop\". Finding the sum is an O(n) operation , which make the time complexity - O(n^2).\\n\\nWhy Approach 1 is not getting submitted?\\n\\nMy solution is here - https://leetcode.com/problems/3sum/solutions/4003447/c-how-is-apporach-3-selected-but-not-approach-2/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Because"
                    },
                    {
                        "username": "Itsover12",
                        "content": "I think the key to solving this problem is understanding that the optimal solution is probably not going to be faster than O(n^2). I spent way too much time stupidly trying to come up with an O(n) solution."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Tom_Dev](/Tom_Dev) Only GigaChads know truth for such information"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@DamianIvanochko](/DamianIvanochko) Can you explain it?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well there is a way to O(n)"
                    }
                ]
            },
            {
                "id": 2043582,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 2042487,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 2038494,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 2007471,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 1955625,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 1941567,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 1902482,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 1883039,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 1869238,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 1869057,
                "content": [
                    {
                        "username": "ganeshmal",
                        "content": "can we use library function \"void qsort(void *base, size_t nitems, size_t size, int (*compare)(const void *, const void*))\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno, prolly yeah"
                    },
                    {
                        "username": "toanngo",
                        "content": "I immediately jumped into the discussion to see if anyone is wondering about the title like me..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Yep, strange title, but they still made 4sum\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "omeirr13",
                        "content": "if we use a map...how would we avoid duplicates?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@omeirr13](/omeirr13) well, no. All you have to do is make for loop to put elements inside and check if map.containsKey(nums[i]) continue; that\\'s it. But if you want it simpler you can also you hashset, cause hashset can\\'t contain duplicate elements, it\\'s the same process for loop and write mySet.add(nums[i]), if element is already in hashset it will just pass it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@DamianIvanochko](/DamianIvanochko)  But i would have to sort to do this right?\nfor example:\n[1,0,-1] and [-1,0,1]...these two would become different entries i the map if the nums array wasnt sorted..\nis there a way to remove dupliactes without sorting?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you can put in map element from array as key and something as value, if you want to check for duplicates you can you map.containsKey(element), hope this answers your question"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "how can someone dislike a question with this title"
                    },
                    {
                        "username": "user4119D",
                        "content": "After trying so many times, still can\\'t figure out a solution!"
                    },
                    {
                        "username": "user4119D",
                        "content": "[@neptuno](/neptuno) Did ! Solved after going through some of solutions. I was so close! \\nWill try to resolve after some months again!"
                    },
                    {
                        "username": "neptuno",
                        "content": "You need to do it in paper first to understand "
                    },
                    {
                        "username": "congvu",
                        "content": "If you feel difficult, you can refer at: https://www.youtube.com/watch?v=EGVpKCEL1W8\\n"
                    },
                    {
                        "username": "user0806tg",
                        "content": "var threeSum = function(nums) {\\n    const A=[];\\n    for (let i = 0; i < nums.length - 2; i++)\\n    {\\n        for (let j = i + 1; j < nums.length - 1; j++)\\n        {\\n            for (let k = j + 1; k < nums.length; k++)\\n            {\\n                \\n                if (nums[i] + nums[j] + nums[k] == 0)\\n                {\\n                    A.push([nums[i],nums[j],nums[k]])\\n                    \\n                }else ;       \\n\\n                //console.log(A)  \\n            }\\n        }\\n    }\\n    console.log(A);\\n};\\n\\ncan anyone suggest whats wrong here although the case 2 and 3 shows correct Std output but output says undefined. case 1 is still to be figured out as i dont know how to keep distinct ones. i am just a beginner i dont know array i just attempted based on my loops knowledge :( please help. much needed"
                    },
                    {
                        "username": "tagrawal1339",
                        "content": "My solution has passed all the testcases 312 / 312 but still it is saying time limit exceeded. Last Executed Input is empty  [leetcode](https://drive.google.com/file/d/15xcBdHWMf43ah9Ejd7Ky8K359ifCrScm/view?usp=sharing)"
                    },
                    {
                        "username": "timven74",
                        "content": "Time Limit Exceeded\\n312 / 312 testcases passed\\nWhat I need to do?"
                    },
                    {
                        "username": "vyomverma",
                        "content": "my 312/312 testcases got passed but but my code is not getting submitted it shows TIME LIMIT EXCEEDED . stuck what to do?"
                    }
                ]
            },
            {
                "id": 1864138,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1863261,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1857205,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1853308,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1763198,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1692406,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1576647,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1576595,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1574213,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1573957,
                "content": [
                    {
                        "username": "Moonbeam8773",
                        "content": "Does anyone know wtf is up with the last test case? It passes in nil, I return and empty array and it says it\\'s wrong. I return nil and it\\'s still wrong."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) Sometimes I\\'d get 311/312 tests passed. When I copy the last test case into my testcase tab, it passes. This is 3sum bullshit."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "[@klaca](/klaca) I'm seeing 312/312 test cases passed. Then nothing happens. Just a test case with an empty input."
                    },
                    {
                        "username": "klaca",
                        "content": "Hi. How does it pass nil? The description explicitly says 3 <= nums.length. What is the Input for that test case?"
                    },
                    {
                        "username": "Watermelon_Lichy",
                        "content": "My code might be inefficient but it has passed 312/312 cases and still I\\'m getting TLE. I didn\\'t face the scenario before where all test cases are passed still not getting AC. Does anyone know why is this happened and how to resolve?"
                    },
                    {
                        "username": "nathanel80",
                        "content": "test 312 \"Time Limit Exceeded\" for an empty array in c.\\nI tried to add if (nums == NULL) return arr, but didn\\'t work. \\nAny ideas?"
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "What does testcase 312 contain of? I received a time limit exceeded error, I use it as testcase (using button \\'Use Testcase\"), still, I cannot evaluate it as it appears to be an empty test case. Can someone please advise me? Thank you."
                    },
                    {
                        "username": "easonteong",
                        "content": "This code would help you in debugging.\\n\\nFor C programmers though...\\n```\\nint main(int argc, const char * argv[]) {\\n    const int numSize = 4;\\n    int nums[numSize] = {1,2,-2,-1};\\n    int** returnColumnSizes = (int**)calloc(1, sizeof(int*));\\n    int* returnSize = (int*)calloc(1,sizeof(int));\\n    \\n    int** solution;\\n    solution = threeSum(nums,numSize,returnSize,returnColumnSizes);\\n    for(int i = 0; i < *returnSize; i++)\\n    {\\n        printf(\"Solution %d\\\\n\",i);\\n        for(int j = 0; j < **returnColumnSizes; j++)\\n        {\\n            printf(\"%d. %d\\\\n\",j+1, solution[i][j]);\\n        }\\n    }\\n    \\n}\\n```"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Using hash map function\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());     //Sorted Array\\n        if(nums.size() < 3){                // Base Case 1\\n            return {};\\n        }\\n        if(nums[0] > 0){                    // Base Case 2\\n            return {};\\n        }\\n        unordered_map<int , int> hashMap;\\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\\n            hashMap[nums[i]] = i;\\n        }\\n        vector<vector<int>> answer;\\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can\\'t make it zero by searching after it.\\n                break;\\n            }\\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\\n                    answer.push_back({nums[i] , nums[j] , required});\\n                }\\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\\n            }\\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\\n        }\\n        return answer;  //Return answer vector.\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "chikmid",
                        "content": "I got the aaay by implementing an extension of 2 sum problem, but how to remove duplicates?\\n"
                    },
                    {
                        "username": "RahulSoni0",
                        "content": "use HashSet when storing the indices first and then store it to list / vector and return"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e65eca47-0c9f-4c94-8729-2dc9ef209cd5_1597413855.8060977.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e8dbb5b-cb07-42a1-9162-36cbfe939444_1597413807.8859184.png)\\n"
                    },
                    {
                        "username": "locky5",
                        "content": "Here\\'s the link:\\n\\nhttps://github.com/kevindai777/3Sum-Leetcode-15/blob/master/threesum.js\\n\\n\\nHope you enjoy!"
                    }
                ]
            },
            {
                "id": 1573833,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1572937,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1572793,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1572560,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1571823,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1566990,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1576604,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1576523,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1575974,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1575482,
                "content": [
                    {
                        "username": "nikash",
                        "content": "Try this simple solution here: https://youtu.be/zawL0Hin8AA\\n\\nFollow this playlist for all solutions : https://youtu.be/5fNSfQ5wLbw\\n\\nDo let me know if you want me to solve any particular problem :) \\n\\nGood luck guys"
                    },
                    {
                        "username": "Timothy_hom",
                        "content": "As per the task description the triplets should be unique. What does it mean?\\nDoes the elemetns order Matter? So for example, [-1, 0, 1] should be considered equal to [1, 0 -1] or not?"
                    },
                    {
                        "username": "Jaeben",
                        "content": "EDIT: I shouldn\\'t be doing this at 1am lol. There was no duplicate of 1. It was 1 and -1. I got 2 +1 somehow.\\n\\nInput: [1,2,-2,-1]\\nOutput: [[-2,1,1]]\\nExpected: []\\n\\nWhy is it empty? -2 + 1 + 1 = 0 so shouldn\\'t this be in the set?\\n\\nIf it is bc 1 has a duplicate, the example also has a duplicate:\\n\\nA solution set is:\\n[\\n  [-1, 0, 1],\\n  [-1, -1, 2] <- two -1 here.\\n]\\n\\nCan someone please explain what I\\'m missing?"
                    },
                    {
                        "username": "arnoldYesiid",
                        "content": "Bro, You are doing -2 + 1 + 1 =0 but, where is the another 1 positive number in your array  [1,2,-2,-1] ?, \\n\\n-2 + 1 + (-1) = -2"
                    },
                    {
                        "username": "doubleJump",
                        "content": "I\\'ve solve the problem before. But when I came back to this problem, there are several corner cases still lying in my blind zone, so I would like to list them as below:\\n\\n1. **Not enough input size**. Note that in `Two Sum` and `Two Sum Related` problem, there is a guarantee that there will always be at least one answer, and thus we don\\'t need to check the input size of our array. In this problem, however, we cannot make this assumption, and so we should check the input size before we process through the array.\\n2. **Boundary test in subproblem `two sum `.** In my approach, I first sort the array to avoid duplicate results. Then I reduce the 3Sum problem to Two Sum problem. In the sub `Two Sum` problem, I use two pointer technique as before, but one thing is different: we need to gather all different results. So the pointer need to move around even after they find one solution. But I forget to check if the pointer is out of boundary."
                    },
                    {
                        "username": "WXia",
                        "content": "So I was using C++ and I passed 309 tests. The submission failed at [1,0,-4] as it returns [[-4, 1, 3]]. However if I input [1,0,-4] as the test case manually, the code works as expected, Anyone has a clue?"
                    },
                    {
                        "username": "noisrucer",
                        "content": "Hereby I officially refuse to solve this question asking for threesome.\\n\\nI solemnly refuse to answer to this question.\\n\\nI don\\'t know wtf I\\'m sayin...SKLFJLSjdljfjfljsfjflkfajfljfjflfjflfj\\n\\nLove ya Leetcode as always.....\\n\\n\\n\\nno foursome?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/ \\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/3sum-closest-leetcode-solution-leetcode-python/"
                    },
                    {
                        "username": "masterprompt",
                        "content": "My output contains the same \"triplets\" as the expected output, just in a different order.  The requirements state nothing about ordering of output, merely that you can\\'t have duplicate triplets.  No way to solve this without having to reverse engineer the \"expected\" outputs."
                    },
                    {
                        "username": "codejunkie",
                        "content": "In the problem statement I am clear about how this can be the solution for this array:\\n\\n\\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\nIn the output very clearly there is one more triplet 0,1,-1(5th position in input array) that can combine with 0 and 1."
                    }
                ]
            },
            {
                "id": 1574375,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 1571043,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2059321,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2059057,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2057929,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2051902,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2041411,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2032090,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2028949,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2025436,
                "content": [
                    {
                        "username": "swingle8",
                        "content": "https://github.com/swingle8/Hashing/blob/master/3Sum.java"
                    },
                    {
                        "username": "jzh08",
                        "content": "I submit a solution six month ago for 3sum problem with a time complexity of O(n^2log(n)), and got an AC. But i got TLE when i resubmit the same code just today. \\nAny changes to the OJ judging rules during this period?!\\n\\nthanks!"
                    },
                    {
                        "username": "samejima",
                        "content": "this problem needs to be more descriptive. The problem talks about i j and k as if they are referencing the element that it will be pointing at however it really means the indexs must be distinct\\n\\nso when it says  \"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k,\"\\n\\nit is not referencing nums[i] nums[j] and num[k] being different its literally talking about the INDEX i j and k being different. needs to be more explicit in what it means."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I don\\'t know what you\\'re talking about, it\\'s literally saying: \"such that i != j, i != k, and j != k\""
                    },
                    {
                        "username": "Gauravesh_Sharma",
                        "content": "import itertools\\n\\nclass Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n  \\n        nums.sort()\\n        all_list = list(itertools.combinations(nums,3))\\n     \\n        final_list=[]\\n        for i in all_list:\\n            if sum(i) == 0 and list(i) not in final_list:\\n                final_list.append(list(i))\\n        return (final_list)\\n\\nthe memory limit exceeds in this solution although it is really helpful for begineers \\n        "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I\\'m beginner, solved 171 problems, no idea what this code is about"
                    },
                    {
                        "username": "user3719nk",
                        "content": "[0000]\\nit should have 2 subarrays [000],[000] technically, but the expected is [000] how come, we know i,j,k are not equal so it shoul have 2 subarrays, no?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "uayushi73",
                        "content": "How to avoid Time limit exceeded error in this code, my 308/312 test cases passed."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "By using a morre efficient algorithm."
                    },
                    {
                        "username": "i0Ta07",
                        "content": "I am tired guys HELP............No output \n\n#delete element in lisi as soon as assiningn in abc\ndef elim(a,digit):\n    for i in range(0,len(a)):\n        if(a[i]==digit):\n            a.remove(a[i])\n    return a\n    \ndef max(a):\n    large=a[0]\n    for i in range(1,len(a)):\n            if(a[i]>large):\n                large=a[i] #abc[0]=a[i] not assinging here willl assign in threeSum when Sum is 0\n    return large\ndef threeSum(a):\n    abc=[[0,0,0],[0,0,0],[0,0,0]]\n    count=len(a)//3\n    while(count!=0):\n        l_no=max(a)\n        for i in range(0,len(a)):\n            for j in range(i+1,len(a)):\n                Sum=a[i]+a[j]\n                if(Sum+l_no==0): #assignment and removal\n                    abc[count][0]=l_no\n                    abc[count][1]=a[i]\n                    abc[count][2]=a[j]\n                    a=elim(a,l_no)\n                    a=elim(a,a[i])\n                    a=elim(a,a[i])\n                    for i in range(3):\n                        for j in range(3):\n                            print(abc[i][j])\n                \n        count=count-1\n    return abc\ndef main():\n    a=[1,0,-1,-1,2,-1]\n    ab=[[0,0,0],[0,0,0],[0,0,0]]\n    ab=threeSum(a)\n\n"
                    },
                    {
                        "username": "TenzinDelek",
                        "content": "they have mention distinct so why it is taking same value in [-1,2,-1]"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Sort the given array in non-decreasing order.\\nLoop through the array from index 0 to n-1.\\nFor each iteration, set the target as -nums[i].\\nSet two pointers, j=i+1 and k=n-1.\\nWhile j<k, check if nums[j]+nums[k]==target.\\nIf yes, add the triplet {nums[i], nums[j], nums[k]} to the result and move j to the right and k to the left.\\nIf no, move either j or k based on the comparison of nums[j]+nums[k] with target.\\nTo avoid duplicate triplets, skip the iterations where nums[i]==nums[i-1] and also skip the iterations where nums[j]==nums[j-1] or nums[k]==nums[k+1]"
                    },
                    {
                        "username": "devhindo",
                        "content": "why is this so hard"
                    }
                ]
            },
            {
                "id": 2016787,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 2015221,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 2014009,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 2005948,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 2001197,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 2000997,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 2000326,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 1995368,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 1994281,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 1988704,
                "content": [
                    {
                        "username": "sam_cee",
                        "content": "Anyone have any suggestions or can see something wrong with the code below?\\n\\nMy code works but when it get\\'s to the larger Testcases, I get MLE but I\\'m only storing the results and column sizes ?? \\n\\nrcols = realloc(rcols, (sizeof(int) * (*returnSize + 1)));\\nrcols[*returnSize] = 3;\\nres = realloc(res, sizeof(int *) * (*returnSize + 1));\\nres[*returnSize] = malloc(sizeof(int) * 3);\\nres[*returnSize][0] = nums[base];\\nres[*returnSize][1] = nums[left];\\nres[*returnSize][2] = nums[right];\\n(*returnSize)++; "
                    },
                    {
                        "username": "sr_saad",
                        "content": "Can anyone tell me why I am getting TLE here?\\nCode: \\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        set<vector<int>> ret;\\n        int a,b,c;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    a=min(nums[i],min(nums[j],nums[k]));\\n                    c=max(nums[i],max(nums[j],nums[k]));\\n                    b=nums[i]+nums[j]+nums[k]-(a+c);\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        ret.insert({a,b,c});}\\n                }\\n            }\\n        }\\n        return vector<vector<int>>(ret.begin(),ret.end());\\n    }\\n};"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "oops i guess they don\\'t accept O(n^3)"
                    },
                    {
                        "username": "grabber",
                        "content": "If you just wondering what is the optimal time complexity, it is O(n^2), not n*logn)"
                    },
                    {
                        "username": "WonderMilk",
                        "content": "nooooo I got my code working but it\\'s too slow to finish all the testcases"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "My JAVA solution :\\n\\n public List<List<Integer>> threeSum(int[] nums) {\\n        \\n        List<List<Integer>> al = new ArrayList<>();\\n        Arrays.sort(nums);\\n\\n        for(int i=0; i<nums.length; i++) {\\n\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            int j = i+1;\\n            int k = nums.length-1;\\n\\n            while(j<k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if(sum<0) {\\n                    j++;\\n                }\\n\\n                else if(sum>0) {\\n                    k--;\\n                }\\n\\n                else{\\n                    al.add(Arrays.asList(nums[i], nums[j], nums[k]));\\n                    j++;\\n                    k--;\\n\\n                    while(j<k && nums[j] == nums[j-1]) j++;\\n                    while(j<k && nums[k] == nums[k+1]) k--;\\n                }\\n            }\\n        }\\n        return al;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rum_2k",
                        "content": "Oh no I googled the wrong 3sum"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication2\\n{\\n    class Program\\n    {\\n        public static void th_sum(int[] arr)\\n        {\\n            \\n            List<int[]> listArray = new List<int[]>();\\n            int arr_Len = arr.Length;\\n            for (int i = 0; i < arr_Len - 2; i++) \\n            {\\n                int[] arr1_storage = new int[3];\\n                for (int j = i + 1; j < arr_Len - 1; j++) \\n                {\\n                    for (int k = j + 1; k < arr_Len; k++) \\n                    {\\n                        if (arr[i] + arr[j] + arr[k] == 0) \\n                        {\\n                            arr1_storage[0] = arr[i];\\n                            arr1_storage[1] = arr[j];\\n                            arr1_storage[2] = arr[k];\\n                            Array.Sort(arr1_storage);\\n                            listArray.Add(arr1_storage);\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n\\n            if (listArray.Count == 1) \\n            {\\n                foreach (var item in listArray[0])\\n                {\\n                    Console.Write(item + \" \");\\n                }\\n                Console.WriteLine(\"\");\\n                return;\\n            }\\n\\n            for (int i = 1; i < listArray.Count; i++) \\n            {\\n                int check = 0;\\n                for(int j = i - 1; j > 0; j--) \\n                {\\n                    if (listArray[i].SequenceEqual(listArray[j]) == true) \\n                    {\\n                        check = 1;\\n                    }\\n                }\\n                if (check == 0) \\n                {\\n                    foreach (var item in listArray[i])\\n                        {\\n                            Console.Write(item + \" \");\\n                        }\\n                    Console.WriteLine(\"\");\\n                }\\n            }\\n            \\n        }\\n        static void Main(string[] args)\\n        {\\n            int[] arr = { 1, 3, 4, -1, 0 ,7 ,3, -10 , 6, -1 ,1 };\\n            th_sum(arr);\\n            Console.ReadKey();\\n        }\\n\\n\\n    }\\n}\\n\\nThis is not answer , use can reference ."
                    },
                    {
                        "username": "avy20016",
                        "content": "public class Solution {\\n    public IList<IList<int>> ThreeSum(int[] nums) \\n    {\\n        if (nums.Length < 3) return new List<IList<int>>();\\n\\n        Array.Sort(nums);\\n        var triplets = new List<IList<int>>();\\n\\n        for (int i = 0; i < nums.Length - 2; i++)\\n        {\\n            if (nums[i] > 0) break; // if the first number is greater than 0, then the sum cannot be 0\\n\\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // skipping repeated numbers to avoid repeating triples\\n\\n            int left = i + 1;\\n            int right = nums.Length - 1;\\n\\n            while (left < right)\\n            {\\n                int sum = nums[i] + nums[left] + nums[right];\\n\\n                if (sum == 0)\\n                {\\n                    triplets.Add(new List<int>() { nums[i], nums[left], nums[right] });\\n                    while (left < right && nums[left] == nums[left + 1]) left++; // skipping repeated numbers to avoid repeating triples\\n                    while (left < right && nums[right] == nums[right - 1]) right--; // skipping repeated numbers to avoid repeating triples\\n                    left++;\\n                    right--;\\n                }\\n                else if (sum < 0)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n        }\\n\\n        return triplets;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SANCTVSAMOR",
                        "content": "So if we are not allowed to sort the array, we cannot get solution with time complexity better than o(n^3)?"
                    }
                ]
            },
            {
                "id": 1983591,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1980010,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1979883,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1978764,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1975569,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1973802,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1972807,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1969912,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1969653,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1969100,
                "content": [
                    {
                        "username": "koushikjavvaji2004",
                        "content": "in this type of questions I am able to get hash maps idea firstly then two pointers."
                    },
                    {
                        "username": "christianchenn",
                        "content": "I thought threesome was supposed to be enjoyable.. oh well"
                    },
                    {
                        "username": "JoshuaDRose",
                        "content": "Name funny. Much like."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Here are some of the key points of the solution:\\n\\n1. The array is sorted first to improve the performance of the solution.\\n2. A set can be used to store the results to avoid duplicates.\\n3. The solution iterates through the array only once, which makes it efficient.\\n\\nI hope this helps! "
                    },
                    {
                        "username": "anantverma711",
                        "content": "Testcase 310 runs perfectly when I include it in testcase but gives tle when I submit. Why\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Anantashayana",
                        "content": "How can we use HashMap? If repetition is there, how can we store index values?"
                    },
                    {
                        "username": "sanchit1417",
                        "content": "Just wanted the opinions , i get the way for finding the solution sort the array then fix one value and then do the two sum for the sorted part. but for the TLE . is it for the interviews? like it will only fail for those kind of cases."
                    },
                    {
                        "username": "AKSaurav",
                        "content": "I am so dump!"
                    },
                    {
                        "username": "avi_coder",
                        "content": "hii"
                    },
                    {
                        "username": "iamgabrielsoft",
                        "content": "why am i getting time limit exceeded"
                    }
                ]
            },
            {
                "id": 1969044,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1966826,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1965786,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1965256,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1964763,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1963711,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1963170,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1962856,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1962783,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1960452,
                "content": [
                    {
                        "username": "anand2569",
                        "content": "I am confused with this testcase:\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4] \\nWhy [-1,-1,2] is not a part of solution ? \\nbut in this testcase [-1,0,1,2,-1,-4] , [-1,-1,2] is a part of solution.\\nAny help here ?"
                    },
                    {
                        "username": "dimult22",
                        "content": "stupid subscription! what mean \"The distinct triplets are [-1,0,1] and [-1,-1,2].\" ? "
                    },
                    {
                        "username": "xyang234",
                        "content": "Why the question told us we need to remove the duplicates but the third example return [[0, 0, 0]]? I think it should return []."
                    },
                    {
                        "username": "user4551wd",
                        "content": "The Description saying that i!j,  i!=k,  j!=k means there number if distict number than how [0,0,0] consider has triplet . For [0,0,0] output must be Empty([]) list right?"
                    },
                    {
                        "username": "Be-Goku",
                        "content": "from that 3sum to this 3sum we all grew up"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "312/312 cases passed but tle??"
                    },
                    {
                        "username": "overbound",
                        "content": "Mine passes 308 tests but fails on:\\n\\n<--- Last few GCs --->\\n[22:0x68a6180]     4756 ms: Scavenge 140.2 (159.1) -> 127.3 (160.9) MB, 7.8 / 0.0 ms  (average mu = 0.922, current mu = 0.922) allocation failure\\n[22:0x68a6180]     4836 ms: Scavenge 141.9 (160.9) -> 129.0 (162.6) MB, 7.6 / 0.0 ms  (average mu = 0.922, current mu = 0.922) all"
                    },
                    {
                        "username": "nazibtalukdar29",
                        "content": "I am getting TLE error but when i see the testcase it\\'s showing empty? "
                    },
                    {
                        "username": "karthik1836",
                        "content": "Hows is 000 an answer, i see its not unique"
                    },
                    {
                        "username": "liamchoi",
                        "content": "i dont know why my answer is wrong. I run it ok on my laptop with the test case nums = [3,0,-2,-1,1,2]\n\n \n\n        output = []\n        seen={}\n\n        for i in range(len(nums)-2):\n            if nums[i] not in seen:\n                a = 0 - nums[i]\n                inner = nums[i+1:]\n                \n                for j in range(len(inner)):\n                    b = a - inner[j]\n                    print([nums[i],inner[j],b])\n                    if b in inner[j+1:]:\n                        two_sum = [nums[i],inner[j],b]\n                        two_sum.sort()\n                        if two_sum not in output:\n                            output.append(two_sum)\n            \n            return(output)"
                    }
                ]
            },
            {
                "id": 1958009,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1955262,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1952187,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1949760,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1946577,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1945468,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1941836,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1940849,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1939049,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1938860,
                "content": [
                    {
                        "username": "spookie886",
                        "content": "No matter how many times i revisit this problem, i can\\'t solve it in one go......."
                    },
                    {
                        "username": "Leet_aman",
                        "content": "In the first example why \\n-1  -1  2\\nis not taken as possible solution??\\n\\nI\\'m getting 4 possible solution without repetition,\\n\\ninput -1 0 1 2 -1 -4\\n\\n\\n-1  0  1\\n-1  2  -1\\n-1  -1  2\\n0  1  -1\\n"
                    },
                    {
                        "username": "abualhasan",
                        "content": "No duplicates. \n\"The distinct triplets\"\n\"Notice that the order of the output and the order of the triplets does not matter.\""
                    },
                    {
                        "username": "abualhasan",
                        "content": "I have solved this problem with 3 different algorithms using JavaScript.\nAll of them is successfully ran, but when submitting it passes almost 80% of the cases. \nOne of them passed 250 cases, another one 267 cases, the best result was 268 cases. from 312 total cases.\nThe same error in all of them: Time Limit Exceeded\n\nI enhanced the solution as possible as I could, but there is always a limit where the algoritim breaks the allowed time limit!\n\nFirst algoritim: 250 cases\n- loop through numbers three nested loops.\n- check conditions of index and sum value\n- add to array if not added.\n- return result\n\nSecond algorithm: 267 cases\n- As the first one with little modification to loop the second and third loops not from beginning but from the first loop current index.\n\nThird one: 268 cases\n- Changed the algoritim to use functional programming using .map(), .filter() and .flatMap\n\nThe result was enhanced in third one by one test case only comparing to the second one! I think functional programming here doesn't enhance the final result, becuse fundemantally it has internal loops inside these methods used .map, .filter and .flatMap.\n\nWhat do you suggest to enhance the solution?\nIs the programming language matters according to the time limit?"
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "There are honestly so many moving parts in the solution. One slight mistake will get your the wrong answer. "
                    },
                    {
                        "username": "_Alive",
                        "content": "311/312 test cases passed :(((((("
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand why using only 2 pointers (i, k) does not work.\\nThe normal solution puts a boundary from i to k, while iterating j until it reaches k-1. However, why create another pointer if we can check j just by doing \"diff in nums[i+1: k]\"\\n\\n `` while left <= right:\\n\\n            diff = 0 - (nums[left] + nums[right])\\n            if diff in nums[left+1:right]:\\n                out.append([nums[left], nums[right], diff])\\n                left+=1\\n            \\n            elif diff > 0:\\n                right-=1\\n            \\n            elif diff < 0:\\n                left+=1``\\n\\n"
                    },
                    {
                        "username": "javen09",
                        "content": "class Solution(object):\\n    def threeSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        temp_list = []\\n        my_list = []\\n\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] + nums[j] + nums[k] == 0 and i!=j and j!=k and k!= i:\\n                        temp_list = []\\n                        temp_list.append(nums[i])\\n                        temp_list.append(nums[j])\\n                        temp_list.append(nums[k])\\n                        my_list.append(temp_list)\\n                    else: \\n                        continue\\n        \\n        #for i in range(len(my_list)):\\n            #duplicates = my_list[i] + my_list[j] + my_list[k]\\n            #if duplicates = \\n\\n        result = []\\n        seen = set()    \\n        for sublist in my_list:\\n            sorted_tuples = tuple(sorted(sublist)) \\n            if sorted_tuples not in seen:\\n                seen.add(sorted_tuples)\\n                result.append(sorted_tuples)\\n\\n\\n        final_result = list(map(list, result))\\n        print(final_result)\\n\\n\\n\\n\\nsoln = Solution()\\nsoln.threeSum([-1, 0, 1, 2, -1, -4])\\n\\n\\ni dont get what leetcode means by the output vs expected is wrong. where is the output and what part of this code is wrong??\\n"
                    },
                    {
                        "username": "greensignal",
                        "content": "What\\'s wrong with 312th (last test case??)\\nIt\\'s an emprty array, I\\'ve written conditions for it, but it is giving TLE on that always."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "If you want to solve this problem is efficient way. Before going to solve this problem we should know 2 pointer technique. We can use 2 pointer technique to identify the values in sorted array whose sum = x in O(n) . By using 2 pointer technique we get 2 values in an array whose sum = x now we need to understand x+y = z , z is the result 0, and x = sum of 2 values in an array. so here you need to use brute force to get each value in an array and inside the loop you need to implement 2 pointer technique. make sure your result doesn\\'t contains duplicate values so use HashSet."
                    },
                    {
                        "username": "UtkarshRawat",
                        "content": " Arrays.sort(nums);\\n      List<List<Integer>> ans=new ArrayList<>();\\n       for(int i=nums.length-1;i>=2;i--)\\n       { int a=0;\\n        int b=i-1;\\n        if(i!=nums.length-1 && nums[i]==nums[i+1])\\n        continue;\\n        while(a<b) {\\n              if(nums[a]+nums[b]+nums[i]==0)\\n              {\\n                  ArrayList<Integer> x=new ArrayList<>();\\n                  x.add(nums[a]);\\n                  x.add(nums[b]);\\n                  x.add(nums[i]);\\n                  if(!ans.contains(x))\\n                  ans.add(new ArrayList<>(x));\\n                  a++;\\n                  b--;\\n                  while( a<b && a!=0 && nums[a]==nums[a-1])\\n                  a++;\\n                  while(a<b && b!=nums.length && nums[b]==nums[b+1])\\n                  b--;\\n              }\\n              else if(nums[a]+nums[b]+nums[i]<0)\\n              a++;\\n              else b--;\\n          }\\n           }\\n  return ans;\\\\\\ncan someone please help me out to find why this code is only able to pass 311 case not the last one whats wrong in my code \\n"
                    }
                ]
            },
            {
                "id": 1937483,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1933327,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1932260,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1930637,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1929942,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1929089,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1921464,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1920380,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1918968,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1918013,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "I don\\'t know what\\'s wrong but I have passes 312/312 test cases but still am getting TLE \\uD83D\\uDE42.Can someone pls help\\uD83D\\uDE2D\\nMy Code:\\n vector<vector<int>> threeSum(vector<int>& nums)\\n {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        set<pair<int,int>> s;\\n        bool nozero=0;\\n        sort(nums.begin(),nums.end());\\n        int zero1=lower_bound(nums.begin(),nums.end(),0)-nums.begin();\\n        int posv=lower_bound(nums.begin(),nums.end(),1)-nums.begin();\\n        if(zero1==posv)\\n            nozero=1;\\n        int zeroes=posv-zero1;\\n        if(zeroes>=3)\\n            ans.push_back({0,0,0});\\n        if(!nozero)\\n        {\\n            int i=posv;\\n            while(i<n)\\n            {\\n                int tofind=-nums[i];\\n                if(binary_search(nums.begin(),nums.begin()+zero1,tofind))\\n                ans.push_back({-nums[i],0,nums[i]});\\n\\n                while(i<n-1 && nums[i+1]==nums[i])\\n                    i++;\\n                i++;\\n            }\\n        }\\n        unordered_set<int> positive;\\n        unordered_set<int> negative;\\n        for(int i=0;i<zero1;i++)\\n            negative.insert(nums[i]);\\n        for(int i=posv;i<n;i++)\\n            positive.insert(nums[i]);\\n            for(int i=0;i<zero1-1;i++)\\n            {\\n                for(int j=i+1;j<zero1;j++)\\n                {\\n                    if(s.find({nums[i],nums[j]})==s.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(positive.find(tofind)!=positive.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s.insert({nums[i],nums[j]});\\n                    }\\n                }\\n            }\\n            set<pair<int,int>> s2;\\n            for(int i=posv;i<n-1;i++)\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(s2.find({nums[i],nums[j]})==s2.end())\\n                    {\\n                    int tofind=-(nums[i]+nums[j]);\\n                    if(negative.find(tofind)!=negative.end())\\n                        ans.push_back({nums[i],nums[j],tofind});\\n                    s2.insert({nums[i],nums[j]});\\n                    }\\n                }\\n        }\\nreturn ans;\\n}"
                    },
                    {
                        "username": "berrami",
                        "content": "why this test don\\'t work:\\n[3,0,-2,-1,1,2]\\nmy output [[-1,-2,3],[-2,0,2],[-1,0,1],[-2,1,1]]\\nthe Expected : [[-2,-1,3],[-2,0,2],[-1,0,1]]"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "ngl, I don\\'t think this problem is specific enough in what it\\'s asking for. In the first example, [0, 1, -1] is just as valid since i != j, i != k, & j != k."
                    },
                    {
                        "username": "congvu",
                        "content": "Testcase and limit length is not same. I pass 309/312 testcase, but at 309 case. I checked length of array is 40000, its greater than 3000.\\nWhat\\'s happen ?"
                    },
                    {
                        "username": "prasoon_rit",
                        "content": "I don\\'t understand why my code is wrong. It\\'s giving TLE even after optimizing it. \\n### **My thought process:**\\n- I create a vector to store the solutions called *soln*\\n- Iterate through whole array with variable *i* to fix first number so the problem can be solved similar to 2Sum on leetcode.\\n- For the 2Sum, I create an unordered_set to store which numbers has the algo seen yet in the remaining array and iterate using *j*.\\n- For each iteration, the target will be *-(nums[i] + nums[j])*, which can be search in the set.\\n- If present, we add to \\n*soln*, if not we move on after adding *nums[j]* to set.\\n\\n### **Code:**\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> soln;\\n\\n        for(int i=0; i<nums.size()-1; i++){\\n\\n            unordered_set<int> s;\\n            for(int j=i+1; j<nums.size(); j++){\\n                int reqd = -(nums[i] + nums[j]);\\n                if(s.find(reqd) == s.end()){\\n                    s.insert(nums[j]);\\n                } else {\\n                    vector<int> v = {nums[i], nums[j], reqd};\\n                    sort(v.begin(), v.end());\\n                    if(find(soln.begin(), soln.end(), v) == soln.end())\\n                        soln.push_back(v);\\n                }\\n            }\\n        }\\n\\n        return soln;\\n    } };"
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I am getting TLE after I submitted 312/312 solutions, why is that, anyone?\\n"
                    },
                    {
                        "username": "MrBulldog25",
                        "content": "Passing every test case but it says runtime error on a test case that does not exist..."
                    },
                    {
                        "username": "shmoe",
                        "content": "The condition states: i != j, i != k, and j != k. Therefore, all three numbers must be different.\nBut if the input [0,0,0] output must be [[0,0,0]]. Why? In that case we have i == j && i == k && j == k. This is completely against the condition. And in first example output: [-1,-1,2].\nI don't understand why in testcase when input = [1,1,-2], that is i == j, the output must be [[-2,1,1]]. And the same in many other testcases, but with other values. I have to guess in what cases to ignore the condition of this task? The essence of this task is to substitute the correct solution for each testcase?"
                    },
                    {
                        "username": "shmoe",
                        "content": "Well, correct solution is to ignore that task condition."
                    },
                    {
                        "username": "smvitayush",
                        "content": "Hello Everyone, \\n\\nProblem Statement: I am facing trouble to format the answer as list of list. \\nAny suggestions?\\nI am able to print the answer as below:\\n[-1, 0, 1, -1, 2, -1]"
                    },
                    {
                        "username": "Deep_down",
                        "content": "Laga do brute force approach.."
                    }
                ]
            },
            {
                "id": 1914852,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1913132,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1912252,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1910096,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1902751,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1898380,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1897733,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1894198,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1889157,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1882398,
                "content": [
                    {
                        "username": "imran03",
                        "content": "Don\\'t know how leetcode calculate the runtime. Everytime consecutive submission gives a new runtime. It\\'s totally useless."
                    },
                    {
                        "username": "R0hit_Sharma",
                        "content": "HOW CAN I MODIFY MY CODE SO IT WILL RUN ?\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int t=0;t<size(nums)-2;t++){\\n            for(int i=t+1;i<size(nums)-1;i++){\\n                int sum=nums[t]+nums[i]+nums[i+1];\\n                if(sum==0 )\\n                ans.push_back({nums[t],nums[i],nums[i+1]});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "Bro go and see my solution. I solve this question before 2day"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "please help me............\\uD83D\\uDC4F\\uD83D\\uDC4F\\ni am beggener stage now so what should be do whenever i go solve medium level  or hard level question that time i never be solve i can only solve easy level of question even i complete  DSA course but whenever go for problem solving that time i fetch these problem please anyone suggest  me i really want to solve problem of dsa and want to improve problem solving skill."
                    },
                    {
                        "username": "andtey99399",
                        "content": "f****ing 308 test, i try a lot of variants and always \"time limit exceeded\"(((((((((("
                    },
                    {
                        "username": "vcb007",
                        "content": "is this considered as duplicates, [-2,0,2] and [2,0,-2] if we return this output array?"
                    },
                    {
                        "username": "klaca",
                        "content": "Yes, they are duplicates, order doesn\\'t count."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This question needs to be revised such that the requirement for triplets being unique IS IN THE QUESTION, not in one of the examples. They arent asking for a triple here, they are asking for sets of length three. Triplet implies order. (1,0,-1) IS unique from (1,-1,0) if it is a triplet. "
                    },
                    {
                        "username": "faraznaeem1998",
                        "content": "i am getting \\nLine 5: error: cannot find symbol\\n        int x = nums.size();\\n\\nsize is valid java function to get the length of list. but im getting run time error.\\nis there anything im missing ? anyone ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[[-1, -1, 2], [-1, 0, 1], [-1, 2, -1]] my output does not understand this mistake, the result seems meaningful"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@wwond124](/wwond124)  thanks a lot "
                    },
                    {
                        "username": "wwond124",
                        "content": "every triplet must be sorted. if you are sort the third element - you`ll get the same result as the first one. But output must not contain duplicates triplets. So, final result is [[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "gshashwat24",
                        "content": "2 pointer is not enough, we need 10 pointer methods now"
                    },
                    {
                        "username": "Sicx0",
                        "content": "[-1,0,1,2,-1,-4]\\nMy output:\\n[[-1,0,1],[-1,2,-1],[0,1,-1]]\\nExpected:\\n[[-1,-1,2],[-1,0,1]]\\n\\nI don\\'t understand why my output is wrong, my triplets are made all with different i,j,k. So why it\\'s wrong?"
                    },
                    {
                        "username": "shmoe",
                        "content": "bacause triplets must be sorted and in that case [-1,0,1] the same as [0,1,-1]"
                    }
                ]
            },
            {
                "id": 1879607,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1878008,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1875150,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1864597,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1859941,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1851868,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1844626,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1843555,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1834583,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1824269,
                "content": [
                    {
                        "username": "fdeleonm",
                        "content": "It is so annoying that every time I submit the code I get a time limit, whereas when running the specific test case where the time limit happens is fine. Sometimes happens for test cases 292-295, others for 300... I am using python3 and I initialize the variables as suggested by Leetcode. Anyone with the same problem? How do you bypass this?"
                    },
                    {
                        "username": "odivan1804",
                        "content": "Im solving this problem with C an totally confused with (int** returnColumnSizes) arg. Even if this is array of '3' sized (returnSize) I dont understand how to fill it. But then why it is ouble pointer (**) not just a pointer (*), which I can alloc as I want? Hint says its \"sizes of the arrays\" of triplet returned but this ont lead me any feather I declared before. Runtime throws error by AddressSanitizer"
                    },
                    {
                        "username": "easonyang914",
                        "content": "Why does the output of the first one does not return [0,1,-1]???"
                    },
                    {
                        "username": "klaca",
                        "content": "it does, it\\'s the same as [-1, 0, 1]. they are considered duplicates, so returning only one of them is enough. Doesn\\'t matter, which one."
                    },
                    {
                        "username": "gramster",
                        "content": "Funny how regardless of my solution, submission always times out at 308/312 cases with \\'time limit exceeded\\'. Upsell much?"
                    },
                    {
                        "username": "gramster",
                        "content": "[@klaca](/klaca) ha ha"
                    },
                    {
                        "username": "klaca",
                        "content": "That\\'s perfectly possible. Test Case 308 may be the first one where brute force solutions result in very long runtime."
                    },
                    {
                        "username": "shivam_1110",
                        "content": "Upvote for title of question :-)"
                    },
                    {
                        "username": "happYF33t",
                        "content": "for input ```[0,0,0]``` how is ```[ [0,0,0] ]``` a valid output? Does it not violate ```i != j, i != k, and j != k``` rule?"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "i, j and k are the indices of the array, not the element value. It means you cannot reuse the same element to make up the output.\\n\\nFor [0,0,0], you basically output [ [nums[0], nums[1], nums[2]] ]"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Folks !\\nDo checkout my solution to this problem with detailed comments, approach steps, time and space complexity explanation. \\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/\\nKeep Coding :)\\n\\n"
                    },
                    {
                        "username": "code_Pranab19",
                        "content": "vector< vector <int>> ans;\\n       vector <int> s;\\n       sort(nums.begin(),nums.end());\\n\\n    for(int i=0 ; i < nums.size()-2 ; i++){\\n         int element = nums[i];\\n        for(int j=i+1 ; j<nums.size()-1 ; j++){\\n            int metal = nums[j];\\n            for(int k= j+1; k<nums.size();k++){\\n                int plastic = nums[k];\\n            if(element+metal+plastic==0){\\n                s.push_back(element);\\n                s.push_back(metal);\\n                s.push_back(plastic);\\n                 ans.push_back(s);\\n                \\n                break ;\\n            }\\n            }\\n            \\n        }\\n    }\\n  \\n    \\n    return ans;\\n        \\nthis show some error plz help!!"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \\nThere is an error in the code block you provided. The declaration of the \"vector\" data type is incomplete, which causes a syntax error.\\nTo fix this error, you should specify the data type of the vector. For example, if you want to create a 2D vector of integers, you should declare it as follows: vector< vector<int> > ans;"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nWhen solving coding problems, it\\'s always helpful to see different approaches to the same problem. I highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "aytacgenc1",
                        "content": "[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\n\\nthis expects [0,0,0] as output. There is only 2 zeros in array. How come we return 3 zero if there is 2 of them? It\\'s case 140."
                    },
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1824267,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1821457,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1821401,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1817685,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1817101,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1817012,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1815674,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1813943,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1812617,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1812142,
                "content": [
                    {
                        "username": "RASMI-RANJAN_NAYAK",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "how we can return a triplet in vector. can anyone help?\\n "
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nI highly recommend checking out my solution which provides a detailed explanation of each step, along with the time and space complexity.\\n\\nIn my solution, I have used a two-pointer approach to solve the problem, which involves sorting the input array and then scanning it with two pointers from both sides to find all possible triplets that satisfy the conditions. I\\'ve also included checks to skip over duplicates, which helps to reduce the time complexity of the solution.\\n\\nIf you found my solution helpful, please consider upvoting it on LeetCode to help others find it too. You can access my solution by following the URL below:\\n\\nhttps://leetcode.com/problems/3sum/solutions/3345120/solution-with-detailed-explanation-of-each-step-time-and-space-complexity-explained-c/"
                    },
                    {
                        "username": "furkan94",
                        "content": "308/312 and Time Limit Exceeded... this is amazing :/"
                    },
                    {
                        "username": "abror2142",
                        "content": "Same problem. Do you find the way?"
                    },
                    {
                        "username": "aakashuniyal",
                        "content": "I see people getting confused of `i != j, i != k, j != k` statement in the question.\\n\\nIt is just a fancier way to say you cannot use the same element more than once in a singular triplet, nothing more."
                    },
                    {
                        "username": "Beefyclock_07",
                        "content": "class Solution {\npublic:\n    void subSequence(int i,int s,int n,vector<int>& \n nums,vector<vector<int>> &ans,vector<int> &v)\n    {\n        if(i==n)\n        {\n            if(s==0 && v.size()==3)\n            {\n                ans.push_back(v);\n            }\n        }\n\n        v.push_back(nums[i]);\n        s += nums[i];\n        subSequence(i+1,s,n,nums,ans,v);\n\n        s -= nums[i];\n        v.pop_back();\n        subSequence(i+1,s,n,nums,ans,v);\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        int n = nums.size();\n        vector<int> v;\n        vector<vector<int>> ans;\n        int s = 0;\n        subSequence(0,s,n,nums,ans,v);\n\n        return ans;\n    }\n};\n\nThis is giving Runtime Error (at s += nums [ i ] ).\nCan anyone help me out?\nThanks for any kind help."
                    },
                    {
                        "username": "saumyajeetd",
                        "content": "Nice question."
                    },
                    {
                        "username": "pradumankumar9079",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int target = 0;\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i<n; i++){\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n                while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if (sum == target) {\\n                    s.insert({nums[i], nums[j], nums[k]});\\n                    j++;\\n                    k--;\\n                } else if (sum < target) {\\n                    j++;\\n                } else {\\n                    k--;\\n                }\\n            }\\n        }\\n        for(auto v: s){\\n            output.push_back(v);\\n        }\\n        return output;\\n    }\\n};"
                    },
                    {
                        "username": "Rithik_Suthan_S",
                        "content": "Please try to optimize this  code it is passing 308/312 cases\\n\\n        from itertools import combinations\\n        ls=list(combinations(nums,3))\\n        ans1=[]\\n        for i in ls:\\n            if(sum(i)==0 and sorted(i) not in ans1):\\n                    ans1.append(sorted(i))\\n        if(len(ans1)!=0):\\n            return ans1\\n        return []"
                    },
                    {
                        "username": "igormarquezani",
                        "content": "i did 3 fors one inside another so i could test every combination possible in a arrangement, but it takes too long to process big integer arrays, i think this is being caused by the fact that the algorithm has cubic complexity O(n^3), so what data structure or changes should be done to make it faster?"
                    },
                    {
                        "username": "vcodesup",
                        "content": "use a map or two pointer approach\\n"
                    },
                    {
                        "username": "abhinawnandn",
                        "content": "EASY SOLUTION\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int target=0-nums[i];\\n            int j= i+1;\\n            int k= nums.size()-1;\\n            while(j<k){\\n                int sum=nums[j]+nums[k];\\n                if(sum<target){\\n                    j++;\\n                }\\n                else if(sum>target){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>temp={nums[i],nums[j],nums[k]};\\n                    ans.push_back(temp);\\n                    while(j<k && temp[1]==nums[j]){\\n                        j++;\\n                    }\\n                    while(j<k && temp[2]==nums[k]){\\n                        k--;\\n                    }\\n                }\\n            }\\n            while(i+1<nums.size() && nums[i]==nums[i+1]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810552,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1808518,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1807409,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1804871,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1803994,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1802389,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1802192,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1798333,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1794767,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1794313,
                "content": [
                    {
                        "username": "cibo005",
                        "content": "What is the max time limit accepted here ? \n3 sec !!!"
                    },
                    {
                        "username": "Harshil_D31",
                        "content": "Why do I get a Time limit exceeded error.\\nI am Running a JS code. Is it Possible to solve this with time complexity of less than O(n^3)\\n"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This problem is quite confusing because,there are two different ones in the given array .So the possible outcome must be [[-1,-1,2],[0,1,-1],[0,1,-1]].Because there are two different ones having different adresses...please anyone reply for my problem."
                    },
                    {
                        "username": "cibo005",
                        "content": "it\\'s not about the possible outcome, but the required expected result, so you must remove the duplicates, or develop solution without them"
                    },
                    {
                        "username": "dldlzssdf",
                        "content": "Can anyone tell how to handle the case which has a bunch of inputs? My code was in time limit exceeded."
                    },
                    {
                        "username": "klu_2100032355",
                        "content": "code  \\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] n) {\\n        Arrays.sort(n);\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0 ; i<n.length-2; i++)\\n        {\\n            if(i==0 ||(i>0 && n[i]!=n[i-1]))\\n            {\\n                int j = i+1;\\n                int k = n.length -1;\\n                while(j < k)\\n                {\\n                    if((n[j] + n[k]) == -(n[i]) )\\n                    {\\n                       ArrayList<Integer> inside = new ArrayList<>();\\n                       inside.add(n[i]);\\n                       inside.add(n[j]);\\n                       inside.add(n[k]);\\n                       list.add(inside);\\n                        while (j < k && n[j] == n[j+1])\\n                        {\\n                          j++;\\n                        }\\n                        while(j < k && n[k] == n[k-1])\\n                        {\\n                          k--;\\n                        }\\n                        k--;\\n                        j++;\\n                    }\\n                    else if((n[j] + n[k]) > -(n[i]))\\n                    {\\n                       k--;\\n                    }\\n                    else if((n[j] + n[k]) < -(n[i]))\\n                    {\\n                       j++;\\n                    }\\n                }\\n            }\\n        }\\n        return list;\\n            \\n    }\\n        \\n}"
                    },
                    {
                        "username": "semip",
                        "content": "Hi everybody! \nMy algorithm runs for about 14 seconds on a 3000-element data set  (profiler VisualVM in Eclipse ).\nPasses 308 out of 312 test cases and gets\nTime Limit Exceeded.\n\nHow long is this time limit?\n\np.s. java."
                    },
                    {
                        "username": "sparshyadav",
                        "content": "Line 19: Char 9: error: no viable conversion from returned value of type \\'vector<int>\\' to function return type \\'vector<vector<int>>\\'\\n        return ans;"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> v1;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1,k=n-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]==-nums[i])\\n                {\\n                    vector<int>v;\\n                    v.push_back(nums[i]);\\n                    v.push_back(nums[j]);\\n                    v.push_back(nums[k]);\\n                    v1.push_back(v);\\n                    j++;\\n                    k--;\\n                }\\n                else if(nums[j]+nums[k]>-nums[i])\\n                k--;\\n                else\\n                j++;\\n            }\\n        }\\n       \\n    sort(v1.begin(), v1.end());\\n    v1.erase(unique(v1.begin(), v1.end()), v1.end());\\n       \\n        return v1;\\n    }\\n};\\n\\n\\n\\nTime Limit exceed after 309/312 tescase passed "
                    },
                    {
                        "username": "Nikhilsomisetty",
                        "content": "i have used three for loops, i have got an error of time limit exceeded. Can someone  suggest alternate method to reduce for loops"
                    },
                    {
                        "username": "ammu678",
                        "content": "You can reduce one for loop by sorting the array once then one for loop to iterate all elements and another with two pointers ,since its sorted, you can follow the logic for 2Sum"
                    },
                    {
                        "username": "bouraine",
                        "content": "In this use case : [0,0,0,0] \\nWe expect theses indices to match : 0,1,2 and 0,2,3 (for both i != j, i != k, and j != k and the sum nums[i] + nums[j] + nums[k] == 0, \\nBut the officiel solution suggest that there is only one match. \\nI don\\'t understand why. Am i missing something here ?   \\n"
                    },
                    {
                        "username": "ammu678",
                        "content": "There must not be duplicate triplets, its a question condition"
                    }
                ]
            },
            {
                "id": 1794138,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1794054,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1792928,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1790735,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1790546,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1789543,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1788105,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1784927,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1784612,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1782403,
                "content": [
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to convert that array into tuple "
                    },
                    {
                        "username": "danishmithani",
                        "content": "please help, [0,0,0] not getting read:\n\n class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums)-3):\n            if i>0 and nums[i-1] == nums[i]: continue\n            j = i+1\n            k = len(nums)-1\n            while j<k:\n                unit = nums[i]+nums[j]+nums[k]\n                if unit>0: k-=1\n                elif unit<0: j+=1\n                else: \n                    result.append([nums[i], nums[j], nums[k]])\n                    j+=1\n                    while nums[j]==nums[j-1] and j<k: j+=1\n        return result\ninput: [0,0,0]\nOutput: []\nexpected output: [[0,0,0]]"
                    },
                    {
                        "username": "shivambit",
                        "content": "please give me hints to solve this question"
                    },
                    {
                        "username": "sachin2000",
                        "content": "this is the only 3sum which I done ....lol"
                    },
                    {
                        "username": "nagendrapasala",
                        "content": "Only One test case is failing so pls look in this my code once and suggest best solution\\npublic List<List<Integer>> threeSum(int[] nums) {\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int f1 = nums[i];\\n            int j = i+1;\\n            int z = n-1;\\n            while(j<z)\\n             {\\n                 if((f1+nums[j]+nums[z])==0)\\n                 {\\n                     ArrayList<Integer> arr = new ArrayList<Integer>();\\n                            arr.add(f1);\\n                            arr.add(nums[j]);\\n                            arr.add(nums[z]);\\n                            if(!array.contains(arr))\\n                            {\\n                            array.add(arr);    \\n                            }\\n                            j++;\\n                 }else if((f1+nums[j]+nums[z])>0)\\n                 {\\n                     z--;\\n                 }else\\n                 {\\n                     j++;\\n                 }\\n                \\n             }\\n        }\\n        return array;\\n        \\n    }"
                    },
                    {
                        "username": "shubhamjaglan506",
                        "content": "This code is not passing [0,0,0,0] test case the ans coming is [[0,0,0,] , [0,0,0,0]] and it should be [[0,0,0]]\\ncan anyone help\\n\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n      nums.sort()\\n      res = []\\n\\n      for i in range(0,len(nums)-2):\\n          if nums[i]!=0 and nums[i]==nums[i-1]:\\n              continue\\n          l =  i+1\\n          r =  len(nums)-1\\n          target = 0 - nums[i]\\n\\n          while r > l:\\n              total = nums[l]+nums[r]\\n\\n              if total == target:\\n                 res.append([nums[i],nums[l],nums[r]])\\n                 while r > l and nums[l]==nums[l+1]:\\n                     l += 1\\n                 while r > l and nums[r]==nums[r-1]:\\n                     r -= 1       \\n                 l += 1\\n                 r -= 1\\n\\n              if total > target:\\n                  r -=1\\n\\n              if total < target:\\n                   l += 1 \\n      return res               \\n          "
                    },
                    {
                        "username": "drametoid",
                        "content": "I have understood the code and it passes the 3 test cases but I can't submit because it fails for these inputs (test case #29 I think): `[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]` with a runtime error. First line is: `==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x606000000d20 at pc 0x000000347595 bp 0x7ffecd2565b0 sp 0x7ffecd2565a8`\nCan somebody help?"
                    },
                    {
                        "username": "karan_____787",
                        "content": "I am writing the analysis part if we have n numbers in an array we divide it by three then the result is stored in lets say k, if k<1 no group of 3 , k>1 one group , k>2 two group so for six elements cases can be 13 if the condition is that group of three sum = 0 for both 3 , 3 groups and if out of six only one group satisfies the condition total cases will be 6C3 . So for 6 elements possible combination of grouping will be 6C3(out of six elements one group satisifies the condition)+13(group of 2 (each consisting 3 elements)) = 20+13 = 33 cases for if else ladder"
                    },
                    {
                        "username": "korakagaj",
                        "content": "TLE help?? when using the mid point binary search condition , LC gives tle , while removing it does\\'nt,\\nShouldnt this reduce TC?\\n`\\n\\n                class Solution {\\n                    public List<List<Integer>> threeSum(int[] nums) {\\n                        // [-4,-1,-1,0,1,2]\\n                        Arrays.sort(nums);\\n                        List<List<Integer>>ans = new ArrayList<>();\\n                        if(nums[0]>0) return ans;\\n\\n                        for(int i=0;i<nums.length;i++)\\n                        {\\n                            if(i-1>=0&&nums[i]==nums[i-1])continue;\\n                            int x=nums[i];\\n                            int tar=-x;\\n                            int l=i+1; int r=nums.length-1;\\n                            while(l<nums.length&&l<r)\\n                            {   int sum=nums[l]+nums[r];\\n                                int mid=l+(r-l)/2;\\n                                if(sum==tar){\\n                                    ans.add(Arrays.asList(nums[i],nums[l],nums[r]));\\n                                    while(l<r && nums[l]==nums[l+1])l++;\\n                                    while(l<r && nums[r]==nums[r-1])r--;\\n                                    l++;r--;\\n                                }\\n                                \\n                                else if(sum>tar)\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if (nums[l]+nums[mid]>tar)r=mid;//why is this giving tle? \\n                                    else r--;\\n                                }\\n                                else\\n                                {\\n                                    // ***when removing this condition, tle not there\\n                                    if(nums[r]+nums[mid]<tar)l=mid;//why is this giving tle? \\n\\n                                    else l++;\\n\\n                                }\\n                            }            \\n                        }\\n\\n                        return ans;\\n                        \\n                    }\\n                }\\n`"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "I really hate it that they have added time limits. These time limits make it so that you never know if your solution was correct or not. I implemented a solution using set which was not present on google. It is doing this in O(n^2) but the time limit is exceeding for the last test case. This sucks."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Navigate to your failed submission. Copy the failing testcase. Navigate back to your code. Create a new testcase and paste the value of the failed testcase into that new testcase\\'s value."
                    }
                ]
            },
            {
                "id": 1782291,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1781753,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1779600,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1776760,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1776299,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1775427,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1775388,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1775278,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1775158,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1771606,
                "content": [
                    {
                        "username": "Noobster_777",
                        "content": "Continously getting TLE, Please do help me out as I\\'m a newbiee :)\\n\\nMy approach was to use a hashmap to store the frequency of each element and calculate x as the sum of left and right pointer. Take x as the -ve of x ( as x+(-x) = 0). I then searched for this element in the Hash table.\\n\\nPlease do give me some recommendations as well. I have just started leetcoding\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        \\n       List<List<Integer>> list = new ArrayList<>();\\n       HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n\\n       for(int i=0;i<nums.length;i++)\\n        {\\n            if(hm.containsKey(nums[i]))\\n            {\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n       int left=0;\\n       int right=nums.length-1;\\n       Arrays.sort(nums);\\n       while(left<=right)\\n       {\\n           int x=-(nums[left]+nums[right]);\\n           if(hm.containsKey(x))\\n           {\\n               ArrayList<Integer> list1 = new ArrayList<Integer>();\\n               if(hm.get(x)>1)\\n               {\\n                //    list1.add(nums[left]);\\n                //    list1.add(x);\\n                //    list1.add(nums[right]);\\n                //    list.add(list1);\\n                   list.add(Arrays.asList(nums[left], x, nums[right]));\\n                   hm.replace(x,hm.get(x)-1);\\n               }\\n               else\\n               continue;\\n           }\\n           if((x*=-1)<0)\\n           left++;\\n           else if((x*=-1)>0)\\n           right--;\\n       }\\n       return list;\\n    }\\n}"
                    },
                    {
                        "username": "0404-suchet",
                        "content": "My submission is giving a time limit exceeded for a particularly long input, but running the code through that input as my 4th case works just fine. I am not sure of what to do"
                    },
                    {
                        "username": "ankush920",
                        "content": "use  S.C. =O(1)   T.C. =O(N2)\\nEasy and best solution \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       \\n        vector<vector<int>>ans;\\n        \\n        int n =nums.size();  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n         \\n     if(i==0||(nums[i]!=nums[i-1]))  /// for avoid reputation \\n     {\\n          \\n     \\n          \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n           if(p1>(i+1)&&(nums[p1]==nums[p1-1]))  /// for avoid reputation  and use alteast one time \\n     { \\n            {\\n                p1++;\\n                continue;\\n            }\\n\\n            if(p2<(n-1)&&(nums[p2]==nums[p2+1]))  /// for avoid reputation and use alteast one time \\n     {\\n            {\\n                p2--;\\n                continue;\\n            }\\n\\n             sum =nums[i]+nums[p1] +nums[p2];\\n\\n            if(sum > 0)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum<0 )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n            \\n        vector<int>check ={nums[i] ,nums[p1] ,nums[p2]};\\n               p1++;\\n            p2--;\\n\\n\\n\\n               \\n                   ans.push_back(check);\\n               \\n           \\n          }\\n     }\\n      }\\n\\n        return ans;\\n     \\n    }\\n};"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "I think title gives feel to solve question.\\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "luanct",
                        "content": "bro what a title@@"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        //brute force approach\n        vector<int> ans;\n        vector<vector<int>> sol;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int i,j,k;\n        for(i=0;i<n;i++){\n            for(j=i+1;j<n;j++){\n                for(k=j+1;k<n;k++){\n                    if(nums[i]+nums[j]+nums[k]==0){\n                    ans.push_back(nums[i]);\n                    ans.push_back(nums[j]);\n                    ans.push_back(nums[k]);\n                    sol.push_back(ans);\n                    ans.clear();\n                }\n                }\n            }\n            \n        }\n        sort(sol.begin(),sol.end());\n        sol.erase(unique(sol.begin(), sol.end()), sol.end());\n       // sol.pop_back();\n        return sol;\n    }\n};\n\nlove or hate brute force makes me feel happy even we dont get our solution submitted"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Nice 3Sum \\uD83D\\uDC4D."
                    },
                    {
                        "username": "dot_lasher001",
                        "content": "here is my code can you point any mistake  if i do not sort the array then my example test case are passing but this eg. wont [-1,0,1,0] ans when i do the sorting then this eg. [-1,0,1,2,-1,-4]  do not give the correct answer                                                                                                                                               public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            int a = nums[i];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                int b=nums[j];\\n                int c=nums[j+1];\\n            int total_sum = a+b+c;\\n            if(total_sum==0){\\n                List<Integer>triplet = Arrays.asList(a,b,c); \\n                if(set.contains(triplet)==false){\\n                    ans.add(triplet);\\n                    set.add(triplet);\\n                } \\n            }\\n        }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "MR7Mohammad",
                        "content": "nice\\n"
                    },
                    {
                        "username": "Uvah",
                        "content": "Can someone help me understant the time complexity of this code, I think its O(nlogn). And I believe the only thing verify for duplicates in the output.\\n\\n `class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        left_ptr1 = 0\\n        left_ptr2 = 1\\n        right_ptr = len(nums)-1\\n        output = []\\n\\n        while left_ptr2 < right_ptr:\\n            triplets = [nums[left_ptr1],nums[left_ptr2], nums[right_ptr]]\\n            if sum(triplets) == 0:\\n                output.append(triplets)\\n                right_ptr -= 1\\n            \\n            elif sum(triplets) > 0:\\n                right_ptr -= 1\\n            elif sum(triplets) < 0:\\n                left_ptr1 += 1\\n                left_ptr2 += 1              \\n\\n        return output        \\n        # [-4,-1,-1,0,1,2]`"
                    }
                ]
            },
            {
                "id": 1770921,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1769987,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1769806,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1768531,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1763420,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1761782,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1761626,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1759541,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1752583,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1746837,
                "content": [
                    {
                        "username": "rsx129",
                        "content": "Seems something wrong.\\nThe condition nums [ i ] != nums[ j ] or nums[ k ] and nums[ j ] != nums[ k ] is not getting satisfied in the  given examples. "
                    },
                    {
                        "username": "cvollrath97",
                        "content": "I feel like this solution is a little too strict on the time complexity. It skews the solutions to a very small corner. I wish there was a categorical grade for solutions that beat most of the test cases. It would help with analytics and seeing other viable solutions that may not be the fastest.  "
                    },
                    {
                        "username": "boss9631",
                        "content": "I feel like it is unfair to beginners because beginners will try their brute force solution first and they want to know if they even understood the problem right. My submit seems to do 302/312 but I get Time Limit Exceeded.\n\nEdit: nvm, just ran the last list that I stopped at because of time limit. Took my pc like 2 minutes."
                    },
                    {
                        "username": "cvollrath97",
                        "content": "Have not solved yet, but wanted to come on here and just express that this is hard. \\uD83E\\uDD14"
                    },
                    {
                        "username": "Ayan_codes",
                        "content": "[https://ayan-s.medium.com/15-3sum-89556b528622](https://ayan-s.medium.com/15-3sum-89556b528622)\\ncheck all possible complexity and approach"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "# Kindly help me to correct where i am wrong ? \\nProblem : -  Giving heap buffer overflow while submiting each time\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        //firstly, sort the array in non-decreasing form, here, with nlogn;\\n        sort(nums.begin(), nums.end()); // will not preserve the physical order\\n        int n = nums.size();\\n        vector<vector<int> > res;\\n        // edge cases\\n        if(n<3) return res;\\n        if(nums[0]>0) return res;   // edge case (if no any negative value)\\n        for(int i=0; i<n-2; i++){\\n            // we have to ignore the duplicate ones            \\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            int lo = i+1 , hi = n-1;\\n            int temp = nums[i];\\n            while(lo<hi){\\n                if((nums[lo]+nums[hi])+temp>0) hi--;\\n                else if((nums[lo]+nums[hi])+temp<0) lo++;\\n                else {\\n                    res.push_back({temp,nums[lo],nums[hi]});\\n                    // ignoring Duplicates (as per the problem statement)\\n                    while(lo<n && nums[lo]==nums[lo+1]) lo++;\\n                    while(hi>0 && nums[hi]==nums[hi-1]) hi--;\\n                    lo++;\\n                    hi--;\\n                }\\n            }\\n        } return res;\\n    }\\n};"
                    },
                    {
                        "username": "niketkumar3007",
                        "content": "why this solution shows time limit exceeded ....i think this is abetter solution than brute force \\nof time complexity O(n^2)\\n\\n\\nclass Solution {\\n    public List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> arr = new ArrayList<List<Integer>>();\\n        for(int i =0;i<nums.length -2;i++){\\n            int l =i+1;\\n            int r = nums.length-1;\\n            \\n            while(l<r){\\n                if(nums[l]+nums[r]+nums[i]==0){\\n                    arr.add(Arrays.asList(nums[i], nums[l], nums[r])); \\n                    \\n                }\\n                else if(nums[l]+nums[r]+nums[i]>0){\\n                    l++;\\n                }\\n                else{\\n                    r--;\\n                }\\n            }\\n                \\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "trancememes",
                        "content": "What is the point of this question? How can it make one a better SWE?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "EgorFortov",
                        "content": "Hello everyone!\\nI have a problem - my code does not pass a 11th test (the input is \"0 0 0 0\"), gives me big red description about my problem: https://paste.pics/7b0c7cb84fb457517136792b82f09176\\nHOWEVER, on my local machine code works fine and gives correct output! \\nAny thoughts?"
                    }
                ]
            },
            {
                "id": 1745066,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1742859,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1741399,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1740400,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1737965,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1737951,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1733187,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1730141,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1729754,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1729442,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "There is a TLE in my code even after passing all the cases. Here is my code:\\n```vector<vector<int>> optimized(vector<int> arr)\\n{\\n    vector<vector<int>> ans;\\n    sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr.size()-2;i++)\\n    {\\n        int j=i+1;\\n        int k=arr.size()-1;\\n        while(j<k)\\n        {\\n            int sum=arr[i]+ arr[j] + arr[k];\\n            if(sum==0)\\n                {ans.push_back({arr[i],arr[j], arr[k]}); j++; k--;}\\n            else if(sum<0)\\n                j++;\\n            else \\n                k--;\\n        }\\n    }\\n\\n    std::sort(ans.begin(), ans.end());\\nans.erase(std::unique(ans.begin(), ans.end()), ans.end());\\n    return ans;\\n}\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        \\n       // brute force approach\\n    //  return brute(nums);\\n     return optimized(nums);\\n\\n    }\\n\\nPlease help me out!"
                    },
                    {
                        "username": "abhiraj80027",
                        "content": "why the console says runtime error. Someone help i\\'m not getting it even though my solution is correct"
                    },
                    {
                        "username": "d3vSDK",
                        "content": "In such case I try to run the code locally and see what\\'s the problem exactly is."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "hey guys, just a quick question, is any \\'time limitation\\' considered while judging one\\'s solution ? I see no constraint on anything like \\'time limit\\'."
                    },
                    {
                        "username": "saravanakkumarta",
                        "content": "they give you 10s(10000ms) time I think."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "I always get \"Time Limit Exceeded\" on testcase 308. Rewrited the algorithm from naive to 2 pointers - all the same. Is it a problem with my code, or it is some not obvious feature with leetcode/problem/testcase? I\\'m a beginner, but the code runs locally just fine."
                    },
                    {
                        "username": "d3vSDK",
                        "content": "[@Robinson_prevailer](/Robinson_prevailer) Thanks. Don\\'t know how to apply this knowledge yet, but thanks for the direction."
                    },
                    {
                        "username": "Robinson_prevailer",
                        "content": "you need a solution that works in O (n2)"
                    },
                    {
                        "username": "TheOpposite",
                        "content": "I fail to understand why the following code snippet fails. Could someone help me understand. It passes few test cases but fail for others.\n\n``` \ndef threeSum(self, nums: List[int]) -> List[List[int]]:\n        triplets = list()\n        seen = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i]+nums[j]+nums[k] == 0 and i!=j!=k:\n                        if tuple(set({nums[i],nums[j],nums[k]})) not in seen:\n                            seen.add(tuple(set({nums[i],nums[j],nums[k]})))\n                            triplets.append([nums[i]]+[nums[j]]+[nums[k]]) \n        return triplets\n```"
                    },
                    {
                        "username": "alfraz1",
                        "content": "because this code is running at complexity of O(n3)."
                    },
                    {
                        "username": "Ananya_21s",
                        "content": "what\\'s the error here in this c language solution, it is not working properly giving an runtime error???\\nint* threeSum(int* nums, int numsSize, int* returnSize, int* returnColumnSizes){\\n   int i,j,k;\\n    *returnSize=3;\\n       returnColumnSizes=(int*)malloc(3*sizeof(int));\\n    for(i=0;i<numsSize-2;i++){\\n        for(j=i+1;j<numsSize-1;j++){\\n            for(k=j+1;k<numsSize;k++){\\n                if(nums[i]+nums[j]+nums[k]==0){\\n                printf(\"[%d,%d,%d],\",nums[i],nums[j],nums[k]);\\n                returnColumnSizes[0]=nums[i];\\n                returnColumnSizes[1]=nums[j];\\n                returnColumnSizes[2]=nums[k];\\n                }\\n            }\\n        }\\n        break;\\n    } \\n    return returnColumnSizes;\\n}"
                    },
                    {
                        "username": "Skumarsingh",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n       vector<vector<int>> ans;\\n       set<vector<int>> st;\\n       sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int sum=nums[i];\\n            int left=i+1;\\n            int right=nums.size()-1;\\n            while(left<right)\\n            {\\n                sum+=nums[left]+nums[right];\\n                if(sum==0)\\n                {\\n                    vector<int> temp;\\n                    temp.push_back(nums[i]);\\n                    temp.push_back(nums[left]);\\n                    temp.push_back(nums[right]);\\n                    if(st.find(temp)==st.end())\\n                    {\\n                        st.insert(temp);\\n                        ans.push_back(temp);\\n                    }\\n                }\\n            \\n                if(sum<0)\\n                {\\n                    left++;\\n                    while(nums[left]==nums[left-1] && left<right)\\n                    {\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right--;\\n                    while(nums[right]==nums[right+1] && left<right)\\n                    {\\n                        right--;\\n                    }\\n                }\\n                sum=nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n\\n\\nIs there any optimal solution for this problem ."
                    },
                    {
                        "username": "franpontrelli07",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n    unordered_set<int> starts;\\n    unordered_map<int,int> dictionary;\\n    vector<vector<int>> possible_triplets;\\n    for(int i=0; i<nums.size();i++){\\n        if (starts.find(nums.at(i)) != starts.end()){\\n            dictionary[nums.at(i)]++;\\n        }\\n        else{\\n            dictionary.insert(make_pair(nums.at(i),1));\\n        }\\n        starts.insert(nums.at(i));\\n    }\\n    for(auto& p : starts){\\n        unordered_map<int,int> appoggio_dic = dictionary;\\n        int appoggio = p;\\n        appoggio_dic[appoggio]--;\\n        for( pair<int,int> s : appoggio_dic){\\n            if (s.second >=1){\\n                appoggio_dic[s.first]--;\\n                if(appoggio_dic.find(-appoggio-s.first) != appoggio_dic.end()){\\n                    if(appoggio_dic[-appoggio-s.first] > 0){\\n                        appoggio_dic[-appoggio-s.first]--;\\n                        int counter=0;\\n                        vector<int> vet{appoggio,s.first,-s.first-appoggio};\\n                        //Trovare un modo per escludere la ripetizione\\n                        sort(vet.begin(),vet.end());\\n                        for(vector v : possible_triplets){\\n                            if(v == vet){\\n                                counter++;\\n                                break;\\n                            }\\n                        }\\n                        if (counter == 0){\\n                            possible_triplets.push_back(vet);\\n                        }\\n                    }\\n                }\\n                else{\\n                    appoggio_dic[s.first]++;\\n                }\\n            }    \\n        }\\n    }\\n    return possible_triplets;\\n    }\\n};\\n\\n\\nCould someone please tell me how can I better my program, since it succeeds 308/311 testcases ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "Getting timed out by last test case even though my T.C = O(N^2log(N)). I think the runtime limit is too strict."
                    },
                    {
                        "username": "watermelon8",
                        "content": "When the problem statement says to not contain duplicate triplets, is the duplicate referring to the value or the index? \\n\\nIn the given example \\nInput: nums = [-1,0,1,2,-1,-4]\\nOutput: [[-1,-1,2],[-1,0,1]]\\n\\ntriplet [-1, 0, 1] is a solution at indices [0, 1, 2]\\nhowever triplet [0, 1, -10 would have also been a solution at indicdes [1, 2, 4]. \\n\\nWhich seems to hint the duplicate is value rather than index based. "
                    }
                ]
            },
            {
                "id": 1728467,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1723445,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1723404,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1723325,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1722602,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1722257,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1722043,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1719884,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1719621,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1719307,
                "content": [
                    {
                        "username": "bjoshi95",
                        "content": "Help me understand the Time Complexity of this approch\\ni saw people discussing that the time complexity of this approch is N^2, im not able to get it how is it N^2 not N^3 we clearly using 3 nested loops at line 4,10,14 or 4,10,13; \\n \\npublic List<List<Integer>> threeSum(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<nums.length-2;i++){\\n            if(i==0 || (i>0 && nums[i]!=nums[i-1])){\\n                List<Integer> al =new ArrayList<>();\\n                int low=i+1;\\n                int high=nums.length-1;\\n                int sum = nums[i]*-1;\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        result.add(Arrays.asList(nums[i],nums[low],nums[high]));\\n                        while (low<high && nums[low]==nums[low+1]) low++;\\n                        while (low<high && nums[high]==nums[high-1]) high--;\\n                        low++;\\n                        high--;\\n                    } else if (nums[low]+nums[high]>sum) {\\n                        high--;\\n                    } else{\\n                        low++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }"
                    },
                    {
                        "username": "Traaayz",
                        "content": "I am so mad with this solution... I finally have a solution that works but exceed the time...."
                    },
                    {
                        "username": "Tungdz",
                        "content": "help me \\nI don\\'t know why I have a runtime error.\\nI try the same test case on another compiler and it returns the true output expect."
                    },
                    {
                        "username": "Tungdz",
                        "content": "pls help me\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Brings back the memories when me and my buddy started Leetcoding, and one day he came in the class, all excited and shouted **\"I finally understand the 3Sum (threesome) algorithm\"**. \n\nImagine a whole class of non cs people looking at him ;)"
                    },
                    {
                        "username": "IcedRhino",
                        "content": "[[-1,0,1],[-1,2,-1],[0,1,-1]]\nHow can I avoid the repetition? \nedit: bruteforce approach im trying"
                    },
                    {
                        "username": "VafoTagoyev",
                        "content": "Hi, guys! I\\'ve solved the problem but the result is with duplicate triplets. Any idea how to delete duplicate row from 2D Array in Java?"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Can anybody help me solve this issue? I still got the time limit exceeded after I tried to reduce the time complexity from O(n^3) to O(n^2) with hashmap and two for loops. I got confused  when I still have one testcase not passed.\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "My process-\\n1. Sort the array\\n2. iterate the array from left to right\\n       For each number nums[i] we need to find two numbers such that \\n        their sum = -1 * nums[i]\\n        Use two pointers. l = i+1, r = array_size-1.\\n        \\n        if nums[l] + nums[r] == -1 * sum: \\n            add to result\\n            l++; r--;\\n       elif nums[l] + nums[r] > -1 * sum:\\n            r--;\\n       else:\\n           l++;\\n3. Handle duplicay with some additional conditions\\n"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "is there someone else who gets the error \"Unknown network error. Please try reloading page.\"\\n `class Solution {\\npublic:\\n    vector<vector<int>> result;\\n\\n    void twosum(vector<int>& nums, int target, int i, int j)\\n    {\\n        while( i < j)\\n        {\\n            if( nums[i] + nums[j] > target ) j--;\\n\\n            else if( nums[i] + nums[j] < target ) i++;\\n           \\n            else\\n            {\\n\\n                while( i < j && nums[i] == nums[i+1] ) i++;\\n                \\n                while( i < j && nums[j] == nums[j-1] ) j--;   \\n              \\n                result.push_back({-target, nums[i],nums[j]});\\n\\n                i++;\\n                j--;\\n            \\n            }\\n        }\\n    }\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3) return {};\\n\\n        result.clear();\\n\\n        sort(begin(nums), end(nums));\\n\\n        for( int i = 0; i < n-2 ; i++)\\n        {\\n            if( i > 0 && nums[i] == nums[i-1]) continue;\\n\\n            int n1 = nums[i];\\n            int target = -n1;\\n            twosum( nums, target, i+1, n-1 );\\n        }\\n    return result;\\n    }\\n};`"
                    },
                    {
                        "username": "b210396",
                        "content": "i am duplicate sets, please help me. I have done everything \\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE12\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D. Help Meeeeeeee !!!!!!!! "
                    }
                ]
            },
            {
                "id": 1719109,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1718731,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1717591,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1714648,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1711176,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1710954,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1710523,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1709920,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1708317,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1706027,
                "content": [
                    {
                        "username": "kb_2002",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int i,j,k,sum=0,count=0,m=0,p,q;\\n        vector<vector<int>> arr;\\n        for(i=0;i<nums.size()-2;i++)\\n        {\\n            for(j=i+1;j<nums.size()-1;j++)\\n            {\\n                for(k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]+nums[j]+nums[k]==0)\\n                    { \\n                        if(arr.empty())\\n                        arr.push_back({nums[i],nums[j],nums[k]});\\n                        else\\n                        {\\n                            for( p=0;p<arr.size();p++)\\n                            {\\n                                for( q=0;q<arr[p].size();q++)\\n                                {\\n                                    if(arr[p][q]==nums[i]||arr[p][q]==nums[j]||arr[p][q]==nums[k]) \\n                                    count++;\\n                                }                \\n                                if(count==3)\\n                                {\\n                                    m=1;\\n                                break;\\n                                }\\n                                else\\n                                {\\n                                count=0;\\n                                }\\n                            }\\n                            if(m==0)\\n                            arr.push_back({nums[i],nums[j],nums[k]});  \\n                            \\n\\n                        }\\n                        \\n                    }\\n\\n                }\\n                }\\n            }\\n            return arr;\\n        }\\n    \\n};\\nwhy is this code returning wrong answer for testcase: \\nInput\\n[-1,0,1,2,-1,-4,-2,-3,3,0,4]\\nOutput\\n[[-1,0,1]]\\nExpected\\n[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]\\n"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I literally just blanked out on the hash set solution and could only implement sorting. ded. bye bye job offer."
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve used recursion on my solution, and I felt confident the output was correct as expected.\\nThe problem states that:\\n\\'\\'\\'Notice that the order of the output and the order of the triplets does not matter.\\'\\'\\'\\nAm I missing something here or is it just bad worded?\\n\\n\\n\\nclass Solution(object):\\n    \\n    def threeSum(self, nums,i=0,j=1,k=2,new_list = []):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]\\n        \"\"\"\\n\\n      \\n\\n        if k == len(nums) or j == len(nums):\\n\\n            return new_list\\n\\n       \\n        if len(nums) < 3 or len(nums)>3000:\\n            return []\\n        \\n       \\n        if i!=j!=k and nums[i]+nums[j]+nums[k] == 0:\\n            ls =[]\\n\\n            ls.append(nums[i])\\n            ls.append(nums[j])\\n            ls.append(nums[k])\\n            new_list.append(ls)\\n       \\n        \\n        return self.threeSum(nums,i,j+1,k+1,new_list)\\n    \\n            "
                    },
                    {
                        "username": "Cec_",
                        "content": "Guys, why does my brutal force O(n3) exceeds time limit\n\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> l = new ArrayList<List<Integer>>(0);\n        if (nums.length < 3 || nums.length>3000) return l;\n        \n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k ++) {\n                    if ((nums[i] + nums[j] + nums[k]) == 0) {\n                        List<Integer> li = new ArrayList<>();\n                        li.add(nums[i]);\n                        li.add(nums[j]);\n                        li.add(nums[k]);\n                        if(!l.contains(li))l.add(li);\n                    }\n                }\n            }\n        }\n        return l;\n    }\n}"
                    },
                    {
                        "username": "bartilg",
                        "content": "My code passes 308/311 test cases but exceeds the time limit on the last few. Does anyone have any advice for optimizing my approach so that it means the time requirements? The general approach is as follows:\\n\\n>split into lists of unique positive and negative values\\n>if a value appears more than once in the original list, as well as twice its inverse, that forms a triple.\\n>If the inverse of the sum of 2 negative numbers is in the positive list, that forms a triple\\n>if the inverse of the sum of 2 positive numbers is in the negative list, that forms a triple\\n\\nI\\'m wondering if there are any ways I can optimize my loops to meet the time limit, or if I need to try another solution.\\n\\n`class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        solution = []\\n        nums.sort()\\n\\n        pos = []\\n        neg = []\\n\\n        i = 0\\n        if nums.count(0) >= 3:\\n            solution.append([0,0,0])\\n        \\n        for i in range(0,len(nums)):\\n            if i > 0 and nums[i] != nums[i-1] or i ==0:\\n                if nums[i] >=0:\\n                    pos.append(nums[i])\\n                else: neg.append(nums[i])\\n\\n        for i in range(0,len(neg)):\\n            if(nums.count(neg[i]) > 1 and -2*neg[i] in pos):\\n                solution.append([neg[i],neg[i],-2*neg[i]])\\n            for j in range(i+1,len(neg)):\\n                inverse = -1*(neg[i]+neg[j])\\n                if(inverse in pos):\\n                    solution.append([neg[i],neg[j],inverse])\\n\\n        for i in range(0,len(pos)):\\n            if(nums.count(pos[i]) > 1 and -2*pos[i] in neg):\\n                solution.append([pos[i],pos[i],-2*pos[i]])\\n            for j in range(i+1,len(pos)):\\n                inverse = -1*(pos[i]+pos[j])\\n                if(inverse in neg):\\n                    solution.append([pos[i],pos[j],inverse])\\n        return solution `\\n\\n"
                    },
                    {
                        "username": "_bmn",
                        "content": "how to ensure no duplicate sets are included in the answer? \\nlike for a test case of [0,0,0,0], my code gives me 2 sets of integers -> [[0 (index = 0), 0 (index = 1), 0 (index = 2)] , [0 (index = 1), 0 (index = 2), 0 (index = 3)]]"
                    },
                    {
                        "username": "GeekErra",
                        "content": "Clear Video Explanation:\\n\\nhttps://youtu.be/ofkRc7mNnHY"
                    },
                    {
                        "username": "sanket_makh",
                        "content": "Getting a tle in the below solution.....\\ncan it be improved?\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        long long n(nums.size());\\n        vector<vector<int>> s;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]+nums[j]+nums[k]==0){\\n                        vector<int>v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        sort(v.begin(),v.end());\\n                       if(find(s.begin(),s.end(),v)==s.end()){\\n                             s.push_back(v);\\n               \\n            }\\n                        \\n                    }\\n                }\\n             \\n          }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "sushma2109",
                        "content": "can anyone help me in how to print distinct elements i.e,[-1,-1,2],[-1,0,1]"
                    },
                    {
                        "username": "omkarxpatel",
                        "content": "Testcase number 308 belongs in hell"
                    }
                ]
            },
            {
                "id": 1701966,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1701079,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1700880,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1700708,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1699996,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1694292,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1692636,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1692408,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1689208,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1686609,
                "content": [
                    {
                        "username": "soumyaranjansahoo2031",
                        "content": "Why does it show TLE error?"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "nhi pta bhai\\n"
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Please check my code 310/311 test case pass and one test case create TLE. \\nplease Check.\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        set<vector<int>>s;//storing the unique value\\n        int n=nums.size();\\n       \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n                int j=i+1;\\n                int k=n-1;\\n                while(j<k){\\n                    int sum=nums[i]+nums[j]+nums[k];\\n                    if(sum==0){\\n                        s.insert({nums[i],nums[j],nums[k]});\\n                    }\\n                    if(sum>0){\\n                        k--;\\n                    }\\n                    else{\\n                        j++;\\n                    }\\n                }      \\n        }\\n        for(auto i: s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "digits21",
                        "content": "I\\'m not sure why the expected output of [1,2,-2,-1] is not [[-1,-1,2]] but [] because  (-1-1)+2=0. anybody knows why this is wrong?"
                    },
                    {
                        "username": "himanshubhai30122003",
                        "content": "because you only have one -1 in the input. and you are not allowed to use same index twice; Hope it helped."
                    },
                    {
                        "username": "Bobzero",
                        "content": "so according to the third example  0 is not equal to 0 huh!!!"
                    },
                    {
                        "username": "Toynbee",
                        "content": "Hope this will help you.\\n\\n[https://www.youtube.com/watch?v=TeegtfmEhTY](https://www.youtube.com/watch?v=TeegtfmEhTY)"
                    },
                    {
                        "username": "abcde_code",
                        "content": "in my solution i am facing issue due to duplicate vectors. How to avoid duplicate vector problem\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans;\\n        if(n==0)\\n            return ans;\\n        \\n        vector<int> vec;\\n        \\n        int l,r;\\n        \\n        for(int i = 0;i < n - 2 ; i++)\\n        {\\n            int sum = 0;\\n            l = i + 1;\\n            r = n - 1;\\n            while(l < r)\\n            {\\n                if(nums[i] + nums[l] + nums[r] == 0)\\n                {\\n                    vec.push_back(nums[i]);\\n                    vec.push_back(nums[l]);\\n                    vec.push_back(nums[r]);\\n                    ans.push_back(vec);\\n                    vec.clear();\\n                    while(l < n - 1 && nums[l+1] == nums[l])\\n                    {\\n                        cout<<\"HEre 1\"<<endl;\\n                        l++;\\n                    }\\n                        \\n                    while(r > l && nums[r-1] == nums[r])\\n                    {\\n                        cout<<\"HEre 2\"<<endl;\\n                        r--;\\n\\n                    }\\n                    l++;\\n                    r--;\\n\\n                }\\n                else if(nums[i] + nums[l] + nums[r] < 0)\\n                    l++;\\n                else if(nums[i] + nums[l] + nums[r] > 0)\\n                    r--;\\n            }\\n        }\\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "varunvisible",
                        "content": "My solution works fine in my IDE but i dont know why i get this error\\n#################################################THE CODE#####################################################################\\nclass Solution:\\n    l = []\\n    fd = {}\\n    def twosum(self,a:List[int],target:int):\\n        d = {}\\n        for i in a:\\n            if i!=(-target):\\n                z = target - i \\n                if i not in d:\\n                    d[z] = i \\n            else:\\n                f = [d[i],i,(-target)]\\n                if(sum(f)==0):\\n                    if len(fd) == 0:\\n                        for i in f:\\n                            fd[i] = 1\\n                        l.append(f)\\n                    else:\\n                        count = 0 \\n                        for i in f:\\n                            if i in fd:\\n                                count = count + 1 \\n                        if count!=3:\\n                            l.append(f)\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        if nums ==[0,0,0]:\\n            l.append([0,0,0])\\n        for i in range(len(nums)):\\n            self.twosum(nums,-nums[i])\\n        return l \\n\\n###################################RUNTIME ERROR###################################################################\\nKeyError: -1\\n    f = [d[i],i,(-target)]\\nLine 12 in twosum (Solution.py)\\n    self.twosum(nums,-nums[i])\\nLine 29 in threeSum (Solution.py)\\n    ret = Solution().threeSum(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "HashMap Approach:\\nIn this approach, firstly, we will hash the indices of all elements in a hashMap. In case of repeated elements, the last occurence index would be stored in hashMap.\\n\\nHere also we fix a number (num[i]), by traversing the loop. But the loop traversal here for fixing numbers would leave last two indices. These last two indices would be covered by the nested loop.\\nIf number fixed is +ve, break there because we can\\'t make it zero by searching after it.\\nMake a nested loop to fix a number after the first fixed number. (num[j])\\nTo make sum 0, we would require the -ve sum of both fixed numbers. Let us say this required.\\nNow, we will find the this required number in hashMap. If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet. Push it in answer vector.\\nUpdate j to last occurence of 2nd fixed number to avoid duplicate triplets.\\nUpdate i to last occurence of 1st fixed number to avoid duplicate triplets.\\nReturn answer vector."
                    },
                    {
                        "username": "hcseven_",
                        "content": "Leetcode please give just question. Plese don\\'t give returnsize, returncolumnsize. I hate that. I don\\'t want that, I want write and return my array but you give that and I allocated or define that, why? for nothing."
                    },
                    {
                        "username": "anujsarda",
                        "content": "Input ->\\nnums =\\n[-2,0,1,1,2]\\nOutput -> \\n[[-2,0,2]]\\nMy Output ->\\n[[-2,0,2],[-2,1,1]]\\n\\nI guess the TestCase no. 87 is not correct and leetcode need to check it and correct it.\\n-2 + 1 + 1 = 0 and we can choose index as (0,2,3) for this pair."
                    }
                ]
            },
            {
                "id": 1683861,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1680166,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1679051,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1673233,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1671770,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1671255,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1662452,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1657487,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1657227,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1651670,
                "content": [
                    {
                        "username": "Vijayasekarbk",
                        "content": "How to have a condition for below input. \\nTLE error with two pointer approach\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]"
                    },
                    {
                        "username": "jsaha437",
                        "content": "basically need to generate all possible sub arrays then put the condition \nprobabble size of array on which condition needs to be applied = 3!*3!*3! = 36*6\nfor i\n      for j\n           for k\n                 el1 = nums[i]\n                 el2 = nums[j]\n                 el3 = nums[k]\n                  arr = [el1,el2,el3]\n                  big_arr = big_arr.append(arr)\n                  arr =[] el1,el2,el3 =0\n\nnow iterate bigarr add condi \n\ntime complexity O(N3) ---------------------------------------->generic understanding of soln-------->probabble approch dp,greedy\nreduced complexity(nlogn) -------------------->worst n2\n\ngreedy soln====> pivot one ele linear way then use 2 pointer for remaining array if sum of all 3 points is 0 append in list else move on return appended list\n\nHOPE U CAN GET THE IDEA"
                    },
                    {
                        "username": "amitkumar961215",
                        "content": "python\\n"
                    },
                    {
                        "username": "Ayushprj",
                        "content": "This solution got a TimeOut Error and I can\\'t figure out why given that some of the really fast submissions are also O(n^2). Any help would be appreciated:\\n\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n           for idx in range(len(nums)):\\n            tmp_dict = {}\\n            target = nums[idx] * -1\\n            for idx2 in range(idx + 1, len(nums)):\\n                if (target - nums[idx2]) not in tmp_dict.keys():\\n                    tmp_dict[nums[idx2]] = idx2\\n                else:\\n                    new_addition = [nums[idx], nums[idx2], target - nums[idx2]]\\n                    flag = 1\\n                    for lis in result:\\n                        if(Counter(new_addition) == Counter(lis)):\\n                            flag = 0\\n                    if(flag):\\n                        result.append([nums[idx], nums[idx2], target - nums[idx2]])\\n        return result"
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "Mane what the \\uD83D\\uDE02\\n\\nOutput\\n[[-1,1,0],[-1,-1,2],[0,-1,1]]\\nExpected\\n[[-1,-1,2],[-1,0,1]]"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Can you spot my bug?\\n\\nResult:\\n\\nWrong Answer\\n310 / 311 testcases passed\\n\\nThe last Input and Output are so long, they\\'re elided by LeetCode and don\\'t show my wrong result.\\n\\nHere is my almost-working code:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\n\\n// Adapted from https://www.youtube.com/watch?v=jzZsG8n2R9A\\nconst threeSum = function(nums) {\\n    nums = new Int16Array(nums).sort();\\n    const results = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        if (n === nums[i-1]) continue;\\n        for (let l = i+1, r = nums.length - 1; l < r;) {\\n            let threeSum = n + nums[l] + nums[r];\\n            if (threeSum > 0) {\\n                r--;\\n            } else if (threeSum < 0){\\n                l++;\\n            } else {\\n                results.push([n, nums[l], nums[r]]);\\n                l++;\\n            }\\n            while (l !== i +1 && nums[l] === nums[l-1] && l < r) l++;\\n        }\\n    }\\n    return results;\\n};\\n```\\nThank you."
                    },
                    {
                        "username": "DrWolf",
                        "content": "Tast case 1: [-1,0,1,2,-1,-4]\\n\\nIndices of combinations giving 0:\\n0, 1, 2\\n0, 3, 4\\n1, 2, 4\\n\\nSo the solution would be: [[-1,1,0], [-1,-1,2], [0,-1,1]]\\n\\nWhy is the answer [[-1,-1,2], [-1,0,1]] ?"
                    },
                    {
                        "username": "JOON1234",
                        "content": "The triplets have to be in particular order so that triple[0] is at index pos. i, triplet[1] is at index pos. j, and triple[2] is at index pos. k s.t. i < j < k."
                    },
                    {
                        "username": "wenkang1",
                        "content": "i like 3 sum!"
                    },
                    {
                        "username": "ratneshbharti125",
                        "content": "why this code is not returning output????\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>result;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int j=i+1;\\n            int k=nums.size();\\n            while(j<k){\\n                if(nums[j]+nums[k]<nums[i]){\\n                    j++;\\n                }\\n                else if(nums[i]<nums[j]+nums[k]){\\n                    k--;\\n                }\\n                else{\\n                    vector<int>triplet(3,0);\\n                    triplet[0]=nums[i];\\n                    triplet[1]=nums[j];\\n                    triplet[2]=nums[k];\\n                    result.push_back(triplet);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n"
                    }
                ]
            }
        ]
    }
]