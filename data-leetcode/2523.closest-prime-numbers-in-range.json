[
    {
        "title": "Closest Prime Numbers in Range",
        "question_content": "Given two positive integers left and right, find the two integers num1 and num2 such that:\n\n\tleft <= nums1 < nums2 <= right .\n\tnums1 and nums2 are both prime numbers.\n\tnums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.\n\nReturn the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.\nA number greater than 1 is called prime if it is only divisible by 1 and itself.\n&nbsp;\nExample 1:\n\nInput: left = 10, right = 19\nOutput: [11,13]\nExplanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.\nThe closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].\nSince 11 is smaller than 17, we return the first pair.\n\nExample 2:\n\nInput: left = 4, right = 6\nOutput: [-1,-1]\nExplanation: There exists only one prime number in the given range, so the conditions cannot be satisfied.\n\n&nbsp;\nConstraints:\n\n\t1 <= left <= right <= 106\n\n&nbsp;\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;Â \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "solutions": [
            {
                "id": 2977256,
                "title": "sieve-of-eratosthenes",
                "content": "> Difference between two consecutive primes is called Prime Gap. There is only one gap of `1` (`3 - 2`).\\n> There are many primes with the gap of `2` - they are called twin primes.\\n> So, we exit early if we find a gap < 3, which improves runtime to 0 ms.\\n\\nWe use Sieve of Eratosthenes to find all primes `<= 1000000`.\\n\\nWe store those primes in a global array, so we can reuse it between test cases.\\n\\nThen, we use a binary search to find the smallest prime in the range, and then check all consecutive primes.\\n\\nThe complexity of this approach is \\u03C0(n) - number of primes up to `n` (assuming that the precomputation is amortized).\\n\\n**C++**\\n```cpp\\nvector<int> p{2};\\nbool sieve[1000001] = {};\\nclass Solution {\\npublic:\\nvector<int> closestPrimes(int left, int right) {\\n    if (p.size() == 1)\\n        for (long long i = 3; i < 1000001; i += 2)\\n            if (!sieve[i]) {\\n                p.push_back(i);\\n                for (long long d = i * i; d < 1000001; d += i)\\n                    sieve[d] = true;\\n            }\\n    int n1 = -1, n2 = -1, i = lower_bound(begin(p), end(p), left) - begin(p);\\n    for (; i + 1 < p.size() && p[i + 1] <= right; ++i)\\n        if (n1 == -1 || p[i + 1] - p[i] < n2 - n1) {\\n            n1 = p[i];\\n            n2 = p[i + 1];\\n            if (n2 - n1 < 3)\\n                break;\\n        }\\n    return {n1, n2};\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> p{2};\\nbool sieve[1000001] = {};\\nclass Solution {\\npublic:\\nvector<int> closestPrimes(int left, int right) {\\n    if (p.size() == 1)\\n        for (long long i = 3; i < 1000001; i += 2)\\n            if (!sieve[i]) {\\n                p.push_back(i);\\n                for (long long d = i * i; d < 1000001; d += i)\\n                    sieve[d] = true;\\n            }\\n    int n1 = -1, n2 = -1, i = lower_bound(begin(p), end(p), left) - begin(p);\\n    for (; i + 1 < p.size() && p[i + 1] <= right; ++i)\\n        if (n1 == -1 || p[i + 1] - p[i] < n2 - n1) {\\n            n1 = p[i];\\n            n2 = p[i + 1];\\n            if (n2 - n1 < 3)\\n                break;\\n        }\\n    return {n1, n2};\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979147,
                "title": "python-twin-primes-no-sieve",
                "content": "# Intuition\\n\\n[Twin primes](https://en.wikipedia.org/wiki/Twin_prime) are quite common, so it won\\'t take long to find some.\\n\\n# Approach\\n\\n**Lemma**: every range $$1 \\\\le L \\\\le R \\\\le 10^6$$ of length at least 1\\'452 contains a pair of twin primes. _Proof_: run a sieve of Eratosthenes and see for yourself.\\n\\nIf there are fewer than 1\\'452 numbers in $$[L, R]$$ then finding all primes in $$O((R - L) \\\\sqrt{R})$$ time is fast enough (takes roughly $$10^6$$ operations). Otherwise, you can stop once you encounter a twin pair, since no further gap will be smaller.\\n\\n_Note_: In practice, finding primes in a range $$[L, R]$$ is faster than $$O((R - L) \\\\sqrt{R})$$. For example, all even numbers require only one step to determine that they are composite. All numbers of the form $$6k+3$$ require only two steps, etc. Amortized analysis applies here.\\n\\n**Conjecture**: naively finding primes in a range $$[L, R]$$ takes $$O((R - L) \\\\sqrt R / \\\\log R)$$ time. Experimentally, for $$R \\\\le 10^6$$ the constant factor of this estimate is roughly 2. In other words, checking if a random number close to a million is prime takes on average $$2 \\\\sqrt{10^6} / \\\\log_2(10^6) \\\\approx 100$$ operations, which is much better than $$\\\\sqrt{10^6} = 1000$$.\\n\\n# Complexity\\n\\n- Time complexity: $$O(\\\\min(1\\'452, R - L) \\\\sqrt R / \\\\log R)$$\\n\\n- Space complexity: $$O(\\\\min(1\\'452, R - L) / \\\\log R)$$ due to [prime number theorem](https://en.wikipedia.org/wiki/Prime_number_theorem).\\n\\n# Code\\n\\n[submission link](https://leetcode.com/problems/closest-prime-numbers-in-range/submissions/868988755/).\\n\\n```\\nimport math\\n\\n\\ndef is_prime(num: int) -> bool:\\n    if num == 1:\\n        return False\\n    for divisor in range(2, math.floor(math.sqrt(num)) + 1):\\n        if num % divisor == 0:\\n            return False\\n    return True\\n\\n\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> list[int]:\\n        primes = []\\n        for candidate in range(left, right + 1):\\n            if is_prime(candidate):\\n                if primes and candidate <= primes[-1] + 2:\\n                    return [primes[-1], candidate]  # twin or [2, 3]\\n                primes.append(candidate)\\n        \\n        gaps = ([primes[i - 1], primes[i]]\\n                for i in range(1, len(primes)))\\n\\n        return min(gaps,\\n                   key=lambda gap: (gap[1] - gap[0], gap[0]),\\n                   default=[-1, -1])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nimport math\\n\\n\\ndef is_prime(num: int) -> bool:\\n    if num == 1:\\n        return False\\n    for divisor in range(2, math.floor(math.sqrt(num)) + 1):\\n        if num % divisor == 0:\\n            return False\\n    return True\\n\\n\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> list[int]:\\n        primes = []\\n        for candidate in range(left, right + 1):\\n            if is_prime(candidate):\\n                if primes and candidate <= primes[-1] + 2:\\n                    return [primes[-1], candidate]  # twin or [2, 3]\\n                primes.append(candidate)\\n        \\n        gaps = ([primes[i - 1], primes[i]]\\n                for i in range(1, len(primes)))\\n\\n        return min(gaps,\\n                   key=lambda gap: (gap[1] - gap[0], gap[0]),\\n                   default=[-1, -1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977481,
                "title": "c-sieve-method-for-finding-primes-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        vector<bool>isPrime(right + 1, true); //Sieve of Eratosthenes\\n        isPrime[1] = false;\\n        vector<int>primes;\\n        for (int num = 2; num * num <= right; num++)\\n        {\\n            if (isPrime[num])\\n            {\\n                for (int j = num * num; j <= right; j = j + num) isPrime[j] = false;\\n            }\\n        }\\n        //==============================================================================================\\n        for (int i = left; i <= right; i++)  //push all the prime numbers in \"primes\" array\\n        {\\n            if (isPrime[i]) primes.push_back(i);  \\n        }\\n        //==================================================================================================\\n        int mnDiff = INT_MAX;\\n        int leftAns = -1, rightAns = -1;\\n        for (int i = 0; primes.size() != 0 && i < primes.size() - 1; i++) //check for minimum difference between consecutive primes\\n        {\\n            int diff = primes[i + 1] - primes[i];\\n            if (diff < mnDiff)\\n            {\\n                mnDiff = diff;\\n                leftAns = curr;\\n                rightAns = next;\\n            }\\n            else if (diff == mnDiff) leftAns = min(leftAns, curr); \\n        }\\n        //===================================================================================================\\n        if (leftAns != -1 && rightAns != -1) return {leftAns, rightAns};\\n        else return {-1, -1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        vector<bool>isPrime(right + 1, true); //Sieve of Eratosthenes\\n        isPrime[1] = false;\\n        vector<int>primes;\\n        for (int num = 2; num * num <= right; num++)\\n        {\\n            if (isPrime[num])\\n            {\\n                for (int j = num * num; j <= right; j = j + num) isPrime[j] = false;\\n            }\\n        }\\n        //==============================================================================================\\n        for (int i = left; i <= right; i++)  //push all the prime numbers in \"primes\" array\\n        {\\n            if (isPrime[i]) primes.push_back(i);  \\n        }\\n        //==================================================================================================\\n        int mnDiff = INT_MAX;\\n        int leftAns = -1, rightAns = -1;\\n        for (int i = 0; primes.size() != 0 && i < primes.size() - 1; i++) //check for minimum difference between consecutive primes\\n        {\\n            int diff = primes[i + 1] - primes[i];\\n            if (diff < mnDiff)\\n            {\\n                mnDiff = diff;\\n                leftAns = curr;\\n                rightAns = next;\\n            }\\n            else if (diff == mnDiff) leftAns = min(leftAns, curr); \\n        }\\n        //===================================================================================================\\n        if (leftAns != -1 && rightAns != -1) return {leftAns, rightAns};\\n        else return {-1, -1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977367,
                "title": "100-faster-easy-to-understand-optimized-prime",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1)\\n            return false;\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n    int primes(int low, int high, vector<int> &ans)\\n    {\\n        for (int i = low; i <= high; i++)\\n            if (isPrime(i))\\n                ans.push_back(i);\\n        return 0;\\n    }\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        vector<int> ans;\\n        primes(left, right, ans);\\n        if (ans.size() <= 1)\\n            return {-1, -1};\\n        int nums1 = -1, nums2 = -1;\\n        int mn = INT_MAX;\\n        for (int i = 0; i < ans.size() - 1; i++)\\n        {\\n            if (ans[i + 1] - ans[i] == mn)\\n            {\\n                if (nums1 > ans[i])\\n                {\\n                    nums1 = ans[i];\\n                    nums2 = ans[i + 1];\\n                }\\n            }\\n            if (ans[i + 1] - ans[i] < mn)\\n            {\\n                nums1 = ans[i];\\n                nums2 = ans[i + 1];\\n                mn = ans[i + 1] - ans[i];\\n            }\\n        }\\n        return {nums1, nums2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1)\\n            return false;\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n    int primes(int low, int high, vector<int> &ans)\\n    {\\n        for (int i = low; i <= high; i++)\\n            if (isPrime(i))\\n                ans.push_back(i);\\n        return 0;\\n    }\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        vector<int> ans;\\n        primes(left, right, ans);\\n        if (ans.size() <= 1)\\n            return {-1, -1};\\n        int nums1 = -1, nums2 = -1;\\n        int mn = INT_MAX;\\n        for (int i = 0; i < ans.size() - 1; i++)\\n        {\\n            if (ans[i + 1] - ans[i] == mn)\\n            {\\n                if (nums1 > ans[i])\\n                {\\n                    nums1 = ans[i];\\n                    nums2 = ans[i + 1];\\n                }\\n            }\\n            if (ans[i + 1] - ans[i] < mn)\\n            {\\n                nums1 = ans[i];\\n                nums2 = ans[i + 1];\\n                mn = ans[i + 1] - ans[i];\\n            }\\n        }\\n        return {nums1, nums2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028359,
                "title": "very-simple-and-easy-to-understand-solution",
                "content": "\\n```\\nvector<int> nums(1000001, 1);\\nclass Solution {\\npublic:\\n    void findPrimes(){\\n        nums[1] = 0;\\n        for(int i = 3; i < 1000; i+=2){\\n            for(int j = i*i; j < 1000000; j = j + i){\\n                nums[j] = 0;\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        if(nums[2] == 1) findPrimes();\\n        int ans = -1, diff = INT_MAX, n1 = -1, n2 = -1;\\n        if(left <= 2) { n2 = 2; left = 3; }\\n        if(left%2 == 0) left++;\\n        for(int i = left; i <= right; i+=2){\\n            if(nums[i]){\\n                if(n2 == -1) n2 = i;\\n                else{\\n                    n1 = n2;\\n                    n2 = i;\\n                    if(diff > n2 - n1){\\n                        diff = n2 - n1;\\n                        ans = n1; \\n                    }\\n                }\\n            }\\n        }\\n        if( n1 == -1) return {-1, -1};\\n        return {ans, ans + diff};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> nums(1000001, 1);\\nclass Solution {\\npublic:\\n    void findPrimes(){\\n        nums[1] = 0;\\n        for(int i = 3; i < 1000; i+=2){\\n            for(int j = i*i; j < 1000000; j = j + i){\\n                nums[j] = 0;\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        if(nums[2] == 1) findPrimes();\\n        int ans = -1, diff = INT_MAX, n1 = -1, n2 = -1;\\n        if(left <= 2) { n2 = 2; left = 3; }\\n        if(left%2 == 0) left++;\\n        for(int i = left; i <= right; i+=2){\\n            if(nums[i]){\\n                if(n2 == -1) n2 = i;\\n                else{\\n                    n1 = n2;\\n                    n2 = i;\\n                    if(diff > n2 - n1){\\n                        diff = n2 - n1;\\n                        ans = n1; \\n                    }\\n                }\\n            }\\n        }\\n        if( n1 == -1) return {-1, -1};\\n        return {ans, ans + diff};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979376,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    vector<bool> is_prime;\\n    void prime_sieve(int n) {\\n        is_prime.assign(n + 1, 1);\\n        is_prime[0] = is_prime[1] = 0;\\n        for (int i = 4; i <= n; i += 2) is_prime[i] = 0;\\n        for (int i = 3; i * i <= n; i += 2) {\\n          if (is_prime[i]) {\\n            for (int j = i * i; j <= n; j += i * 2) {\\n              is_prime[j] = 0;\\n            }\\n          }   \\n        } \\n        primes.push_back(2);\\n        for (int i = 3; i <= n; i += 2) {\\n            if (is_prime[i]) {\\n              primes.push_back(i);\\n            }\\n        }\\n    }\\n    \\n    vector<int> closestPrimes(int left, int right) {\\n        // generate prime numbers\\n        prime_sieve(right);\\n        int l = -1, r = -1, mi = INT_MAX;\\n        // for each prime number\\n        for (int i = 1; i < primes.size(); i++) {\\n            // if it is within the target range\\n            if (left <= primes[i - 1] && primes[i] <= right) {\\n                // we calculate the difference\\n                int d = primes[i] - primes[i - 1];\\n                // if it is less than the min one\\n                if (d < mi) {\\n                    // update min\\n                    mi = d;\\n                    // set l and r\\n                    l = primes[i - 1];\\n                    r = primes[i];\\n                }   \\n            }\\n        }\\n        // if both l and r are set, then return {l, r}\\n        // else return {-1, -1}\\n        return l != -1 && r != 1 ? vector<int>{l, r} : vector<int>{-1, -1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    vector<bool> is_prime;\\n    void prime_sieve(int n) {\\n        is_prime.assign(n + 1, 1);\\n        is_prime[0] = is_prime[1] = 0;\\n        for (int i = 4; i <= n; i += 2) is_prime[i] = 0;\\n        for (int i = 3; i * i <= n; i += 2) {\\n          if (is_prime[i]) {\\n            for (int j = i * i; j <= n; j += i * 2) {\\n              is_prime[j] = 0;\\n            }\\n          }   \\n        } \\n        primes.push_back(2);\\n        for (int i = 3; i <= n; i += 2) {\\n            if (is_prime[i]) {\\n              primes.push_back(i);\\n            }\\n        }\\n    }\\n    \\n    vector<int> closestPrimes(int left, int right) {\\n        // generate prime numbers\\n        prime_sieve(right);\\n        int l = -1, r = -1, mi = INT_MAX;\\n        // for each prime number\\n        for (int i = 1; i < primes.size(); i++) {\\n            // if it is within the target range\\n            if (left <= primes[i - 1] && primes[i] <= right) {\\n                // we calculate the difference\\n                int d = primes[i] - primes[i - 1];\\n                // if it is less than the min one\\n                if (d < mi) {\\n                    // update min\\n                    mi = d;\\n                    // set l and r\\n                    l = primes[i - 1];\\n                    r = primes[i];\\n                }   \\n            }\\n        }\\n        // if both l and r are set, then return {l, r}\\n        // else return {-1, -1}\\n        return l != -1 && r != 1 ? vector<int>{l, r} : vector<int>{-1, -1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977714,
                "title": "c-explanation-with-comments-clean-easy-code",
                "content": "![image](https://assets.leetcode.com/users/images/ec8be3c2-e4f5-477b-be8f-b036d2743fd5_1672548033.971329.png)\\n\\n**n == right-left\\nN == 1e6\\nT->O(N Log(LogN) + n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> closestPrimes(int left, int right) {\\n\\n\\t\\t\\t\\t// sieve of eratosthenes (Algo to find prime numbers less than n, here n=1e6+1)\\n\\t\\t\\t\\tvector<bool> p(1e6+1,true);\\n\\t\\t\\t\\tp[0]=p[1]=false;\\n\\t\\t\\t\\tfor(int i=2;i*i<=1e6;i++){\\n\\t\\t\\t\\t\\tfor(int j=2;i*j<=1e6;j++) p[i*j]=false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Comparing Adjancent primes pair forn finding the minimum pair\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tvector<int> temp;\\n\\t\\t\\t\\tint diff=1e9;\\n\\t\\t\\t\\tfor(int i=left;i<=right;i++){\\n\\t\\t\\t\\t\\tif(p[i]){\\n\\t\\t\\t\\t\\t\\ttemp.push_back(i);\\n\\t\\t\\t\\t\\t\\tif(temp.size()==2){\\n\\t\\t\\t\\t\\t\\t\\tif(temp[1]-temp[0]<diff){\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff=temp[1]-temp[0];\\n\\t\\t\\t\\t\\t\\t\\t\\tans=temp;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\ttemp.clear();\\n\\t\\t\\t\\t\\t\\t\\ttemp.push_back(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ans.size()==0) return {-1,-1};\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> closestPrimes(int left, int right) {\\n\\n\\t\\t\\t\\t// sieve of eratosthenes (Algo to find prime numbers less than n, here n=1e6+1)\\n\\t\\t\\t\\tvector<bool> p(1e6+1,true);\\n\\t\\t\\t\\tp[0]=p[1]=false;\\n\\t\\t\\t\\tfor(int i=2;i*i<=1e6;i++){\\n\\t\\t\\t\\t\\tfor(int j=2;i*j<=1e6;j++) p[i*j]=false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3210017,
                "title": "c-using-sieve-algorithm-for-finding-primes",
                "content": "Please learn Sieve of Eratosthenes so that you can understand this solution!\\n\\nhttps://www.youtube.com/watch?v=T8PaMnb0GPo&list=PLauivoElc3ggagradg8MfOZreCMmXMmJ-&index=72\\n(Hindi Tutorial)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int a = -1, b=-1; \\n        bool seen[1000001]={};\\n        vector<int> res(2, -1); \\n        seen[1] = seen[0]= true; \\n        \\n        for(int i=2; i<=right; i++)\\n            if(!seen[i])\\n                for(int j=2*i; j<=right; j+=i)\\n                    seen[j] = true;\\n            \\n        for(int i=left; i<=right; i++){\\n            if(!seen[i]){\\n                b = a;\\n                a = i;\\n                if(res[1]==-1 || (a-b)<(res[1]-res[0])){\\n                    res[0] = b;\\n                    res[1] = a;\\n                    if(res[1]-res[0]<3)\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        if(res[0]==-1){\\n            res[1]=-1;\\n\\n            return res;\\n        }        \\n        return res;\\n    }\\n};\\n```\\n\\nIf you are having any doubts please comment below, I will try to explain within a day!\\nIf you like my solution please upvote\\nThank you",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int a = -1, b=-1; \\n        bool seen[1000001]={};\\n        vector<int> res(2, -1); \\n        seen[1] = seen[0]= true; \\n        \\n        for(int i=2; i<=right; i++)\\n            if(!seen[i])\\n                for(int j=2*i; j<=right; j+=i)\\n                    seen[j] = true;\\n            \\n        for(int i=left; i<=right; i++){\\n            if(!seen[i]){\\n                b = a;\\n                a = i;\\n                if(res[1]==-1 || (a-b)<(res[1]-res[0])){\\n                    res[0] = b;\\n                    res[1] = a;\\n                    if(res[1]-res[0]<3)\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        if(res[0]==-1){\\n            res[1]=-1;\\n\\n            return res;\\n        }        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994027,
                "title": "c-use-sieve-algorithm-simple-approach",
                "content": "# Intuition\\nWe need to find all prime numbers between range(left, right) using minimum time complexity. \\n\\n# Approach\\nFor finding prime number between left and right range we use sieve algorithm. It takes O(nlog(logn)) time. Then, we find prime number pairs having minimum difference and return them.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(logn))\\n\\n- Space complexity:\\nO(n)\\n\\nwhere n=right value\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        //marks all prime number from 2 to right using sieve algorithm\\n        vector<int> nums(right+1, 1);\\n        for(int i=2; i*i<=right; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                for(int j=i*i; j<=right; j+=i)\\n                    nums[j]=0;\\n            }\\n        }\\n\\n        //storing all prime number between left and right\\n        vector<int> prime;\\n        for(int i=max(2,left); i<=right; i++)\\n        {\\n            if(nums[i]==1) prime.push_back(i);\\n        }\\n\\n        //finding pair of prime numbers having minimum difference\\n        int n1=-1, n2=-1, mini=1e8, diff;\\n        for(int i=1; i<prime.size(); i++)\\n        {\\n            diff = prime[i]-prime[i-1];\\n            if(diff < mini)\\n            {\\n                mini = diff;\\n                n1 = prime[i-1];\\n                n2 = prime[i];\\n            }\\n        }\\n        return {n1, n2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        //marks all prime number from 2 to right using sieve algorithm\\n        vector<int> nums(right+1, 1);\\n        for(int i=2; i*i<=right; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                for(int j=i*i; j<=right; j+=i)\\n                    nums[j]=0;\\n            }\\n        }\\n\\n        //storing all prime number between left and right\\n        vector<int> prime;\\n        for(int i=max(2,left); i<=right; i++)\\n        {\\n            if(nums[i]==1) prime.push_back(i);\\n        }\\n\\n        //finding pair of prime numbers having minimum difference\\n        int n1=-1, n2=-1, mini=1e8, diff;\\n        for(int i=1; i<prime.size(); i++)\\n        {\\n            diff = prime[i]-prime[i-1];\\n            if(diff < mini)\\n            {\\n                mini = diff;\\n                n1 = prime[i-1];\\n                n2 = prime[i];\\n            }\\n        }\\n        return {n1, n2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977845,
                "title": "java-solution-with-comments-sieve-of-eratosthenes-hashtable",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        boolean[] IsPrime = new boolean[right+1];\\n        Arrays.fill(IsPrime, true);\\n        IsPrime[0]=IsPrime[1]=false;\\n\\n        int min = Integer.MAX_VALUE;\\n        //finding prime numbers in range [2,right];\\n        findPrimes(right,IsPrime);\\n        \\n        //storing prime numbers in range[left,right] in list\\n        ArrayList<Integer> primes = new ArrayList<>();\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(IsPrime[i])\\n                primes.add(i);\\n        }\\n      \\n        int[] res=null;\\n        //finding two prime numbers with smallest absolute difference\\n        for(int i=0;i<primes.size()-1;i++)\\n        {\\n            if(primes.get(i+1)-primes.get(i)<min)\\n            {\\n                min=primes.get(i+1)-primes.get(i);\\n                res=new int[]{primes.get(i),primes.get(i+1)};\\n            }\\n        }\\n        //if no result found return [-1,-1]\\n        return res==null? new int[]{-1,-1}:res;\\n    }\\n    \\n    private void findPrimes(int n,boolean[] IsPrime)\\n    {\\n       for(int i = 2; i*i<=n; i++){\\n           if(IsPrime[i]){\\n               for(int j=i*i; j<=n; j+=i)\\n                   IsPrime[j] = false;\\n           }\\n       }  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        boolean[] IsPrime = new boolean[right+1];\\n        Arrays.fill(IsPrime, true);\\n        IsPrime[0]=IsPrime[1]=false;\\n\\n        int min = Integer.MAX_VALUE;\\n        //finding prime numbers in range [2,right];\\n        findPrimes(right,IsPrime);\\n        \\n        //storing prime numbers in range[left,right] in list\\n        ArrayList<Integer> primes = new ArrayList<>();\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(IsPrime[i])\\n                primes.add(i);\\n        }\\n      \\n        int[] res=null;\\n        //finding two prime numbers with smallest absolute difference\\n        for(int i=0;i<primes.size()-1;i++)\\n        {\\n            if(primes.get(i+1)-primes.get(i)<min)\\n            {\\n                min=primes.get(i+1)-primes.get(i);\\n                res=new int[]{primes.get(i),primes.get(i+1)};\\n            }\\n        }\\n        //if no result found return [-1,-1]\\n        return res==null? new int[]{-1,-1}:res;\\n    }\\n    \\n    private void findPrimes(int n,boolean[] IsPrime)\\n    {\\n       for(int i = 2; i*i<=n; i++){\\n           if(IsPrime[i]){\\n               for(int j=i*i; j<=n; j+=i)\\n                   IsPrime[j] = false;\\n           }\\n       }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982421,
                "title": "python-3-8-lines-w-example-t-m-7937-ms-35-8-mb",
                "content": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        right+= 1                                   #  Example: right = 6   left  = 15\\n\\n                                                    # Before sieve:  \\n        prime = [False,False]+[True]*(right-2)      #  prime = [F,F,T,T,T,T,T,T,T,T,T,T,T,T,T,T]\\n                                                    #           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\\n        for i in range(2,isqrt(right)+1):           # After sieve: \\n                for j in range(i * i, right, i):    #  prime = [F,F,T,T,F,T,F,T,F,F,F,T,F,T,F,F]\\n                    prime[j] = False                #           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\\n        print(prime)                                # \\n        prime = [i for i,p in enumerate(prime)      #  prime = [              7,     11, 13,      ]\\n                 if p and left<=i<=right] \\n\\n        if len(prime) < 2: return [-1,-1]           # <-- if not two primes, no solution\\n\\n        return list(min(list(zip(prime,prime[1:])), #  min(11-7, 13-11) = 13-11 --> [11, 13]\\n                    key = lambda x: x[1]-x[0]))\\n```\\n[https://leetcode.com/problems/closest-prime-numbers-in-range/submissions/869311374/](http://)\\n\\nNot sure about time complexity. I think space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        right+= 1                                   #  Example: right = 6   left  = 15\\n\\n                                                    # Before sieve:  \\n        prime = [False,False]+[True]*(right-2)      #  prime = [F,F,T,T,T,T,T,T,T,T,T,T,T,T,T,T]\\n                                                    #           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\\n        for i in range(2,isqrt(right)+1):           # After sieve: \\n                for j in range(i * i, right, i):    #  prime = [F,F,T,T,F,T,F,T,F,F,F,T,F,T,F,F]\\n                    prime[j] = False                #           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\\n        print(prime)                                # \\n        prime = [i for i,p in enumerate(prime)      #  prime = [              7,     11, 13,      ]\\n                 if p and left<=i<=right] \\n\\n        if len(prime) < 2: return [-1,-1]           # <-- if not two primes, no solution\\n\\n        return list(min(list(zip(prime,prime[1:])), #  min(11-7, 13-11) = 13-11 --> [11, 13]\\n                    key = lambda x: x[1]-x[0]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978328,
                "title": "c-o-n-solution-fast-90",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void fillPrimes(vector<int>& prime, int high)\\n    {\\n        bool ck[high + 1];\\n        memset(ck, true, sizeof(ck));\\n        ck[1] = false;\\n        ck[0] = false;\\n        for (int i = 2; (i * i) <= high; i++) {\\n            if (ck[i] == true) {\\n                for (int j = i * i; j <= sqrt(high); j = j + i) {\\n                    ck[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i * i <= high; i++) {\\n            if (ck[i] == true) {\\n                prime.push_back(i);\\n            }\\n        }\\n    }\\n    void segmentedSieve(int low, int high)\\n    {\\n        if (low<2 and high>=2){\\n            low = 2;\\n        }\\n        bool prime[high - low + 1];\\n\\n        memset(prime, true, sizeof(prime));\\n\\n        vector<int> chprime;\\n        fillPrimes(chprime, high);\\n\\n        for (int i : chprime) {\\n            int lower = (low / i);\\n\\n            if (lower <= 1) {\\n                lower = i + i;\\n            }\\n            else if (low % i) {\\n                lower = (lower * i) + i;\\n            }\\n            else {\\n                lower = (lower * i);\\n            }\\n            for (int j = lower; j <= high; j = j + i) {\\n                prime[j - low] = false;\\n            }\\n        }\\n\\n        for (int i = low; i <= high; i++) {\\n            if (prime[i - low] == true) {\\n                ans.push_back(i);\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        segmentedSieve(left,right);\\n        sort(ans.begin(),ans.end());\\n        int mini=INT_MAX;\\n        vector<int>arr(2);\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            if(ans[i]-ans[i-1]<mini)\\n            {\\n                mini=ans[i]-ans[i-1];\\n                arr={ans[i-1],ans[i]};\\n            }\\n        }\\n        if(ans.size()<2) return {-1,-1};\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void fillPrimes(vector<int>& prime, int high)\\n    {\\n        bool ck[high + 1];\\n        memset(ck, true, sizeof(ck));\\n        ck[1] = false;\\n        ck[0] = false;\\n        for (int i = 2; (i * i) <= high; i++) {\\n            if (ck[i] == true) {\\n                for (int j = i * i; j <= sqrt(high); j = j + i) {\\n                    ck[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i * i <= high; i++) {\\n            if (ck[i] == true) {\\n                prime.push_back(i);\\n            }\\n        }\\n    }\\n    void segmentedSieve(int low, int high)\\n    {\\n        if (low<2 and high>=2){\\n            low = 2;\\n        }\\n        bool prime[high - low + 1];\\n\\n        memset(prime, true, sizeof(prime));\\n\\n        vector<int> chprime;\\n        fillPrimes(chprime, high);\\n\\n        for (int i : chprime) {\\n            int lower = (low / i);\\n\\n            if (lower <= 1) {\\n                lower = i + i;\\n            }\\n            else if (low % i) {\\n                lower = (lower * i) + i;\\n            }\\n            else {\\n                lower = (lower * i);\\n            }\\n            for (int j = lower; j <= high; j = j + i) {\\n                prime[j - low] = false;\\n            }\\n        }\\n\\n        for (int i = low; i <= high; i++) {\\n            if (prime[i - low] == true) {\\n                ans.push_back(i);\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        segmentedSieve(left,right);\\n        sort(ans.begin(),ans.end());\\n        int mini=INT_MAX;\\n        vector<int>arr(2);\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            if(ans[i]-ans[i-1]<mini)\\n            {\\n                mini=ans[i]-ans[i-1];\\n                arr={ans[i-1],ans[i]};\\n            }\\n        }\\n        if(ans.size()<2) return {-1,-1};\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977410,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vi(bool)primes;\\n    void setPrimes(ll n) {\\n        primes.assign(n+1, 1);\\n        primes[0] = primes[1] = 0;\\n        for (ll i = 2;i * i <= n;i++) {\\n            if (primes[i]) {\\n                for (ll j = i;j * i <= n;++j){\\n                    primes[j * i] = 0;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int l, int r) {\\n        setPrimes(r);\\n        ll pre=-1; // prev encountered prime number\\n        vi(int)ans={-1, -1};\\n        for(ll i=l;i<=r;++i){\\n            if(!primes[i]){\\n                continue;\\n            }\\n            if(pre>-1 && (ans[0]==-1 || i-pre<ans[1]-ans[0])){\\n                ans={int(pre), int(i)};\\n            }\\n            pre=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vi(bool)primes;\\n    void setPrimes(ll n) {\\n        primes.assign(n+1, 1);\\n        primes[0] = primes[1] = 0;\\n        for (ll i = 2;i * i <= n;i++) {\\n            if (primes[i]) {\\n                for (ll j = i;j * i <= n;++j){\\n                    primes[j * i] = 0;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int l, int r) {\\n        setPrimes(r);\\n        ll pre=-1; // prev encountered prime number\\n        vi(int)ans={-1, -1};\\n        for(ll i=l;i<=r;++i){\\n            if(!primes[i]){\\n                continue;\\n            }\\n            if(pre>-1 && (ans[0]==-1 || i-pre<ans[1]-ans[0])){\\n                ans={int(pre), int(i)};\\n            }\\n            pre=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977400,
                "title": "python-39ms-beat-100-queue",
                "content": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isPrime(n):\\n            if n < 2: return False\\n            for x in range(2, int(n**0.5) + 1):\\n                if n % x == 0:\\n                    return False\\n            return True\\n        q = []\\n        diff = float(\\'inf\\')\\n        pair = [-1,-1]\\n        for i in range(left,right+1):\\n            if isPrime(i): \\n                q.append(i)\\n            while len(q)>=2:\\n                if abs(q[0]-q[1])<diff:\\n                    pair=[q[0],q[1]]\\n                    diff=abs(q[0]-q[1])  \\n                    if diff<=2: return pair\\n                q.pop(0)\\n        return pair\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isPrime(n):\\n            if n < 2: return False\\n            for x in range(2, int(n**0.5) + 1):\\n                if n % x == 0:\\n                    return False\\n            return True\\n        q = []\\n        diff = float(\\'inf\\')\\n        pair = [-1,-1]\\n        for i in range(left,right+1):\\n            if isPrime(i): \\n                q.append(i)\\n            while len(q)>=2:\\n                if abs(q[0]-q[1])<diff:\\n                    pair=[q[0],q[1]]\\n                    diff=abs(q[0]-q[1])  \\n                    if diff<=2: return pair\\n                q.pop(0)\\n        return pair\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832643,
                "title": "95-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if(left==1)left++;\\n        vector<bool> v(right+1,true);\\n        for(int i = 2; i <= sqrt(right); i++){\\n            if(v[i]){\\n                for(int j = i*i; j <= right; j += i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n        int i = left;\\n        int j;\\n        int a = -1, b = -1, k = INT_MAX;\\n        while(i<= right){\\n            if(v[i])break;\\n            i++;\\n        }\\n        j = i+1;\\n        while(j<=right){\\n            if(v[j]){\\n                if(j-i<k){\\n                    k = j-i;\\n                    a = i,b = j;\\n                }\\n                    i = j;\\n            }\\n            j++;\\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if(left==1)left++;\\n        vector<bool> v(right+1,true);\\n        for(int i = 2; i <= sqrt(right); i++){\\n            if(v[i]){\\n                for(int j = i*i; j <= right; j += i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n        int i = left;\\n        int j;\\n        int a = -1, b = -1, k = INT_MAX;\\n        while(i<= right){\\n            if(v[i])break;\\n            i++;\\n        }\\n        j = i+1;\\n        while(j<=right){\\n            if(v[j]){\\n                if(j-i<k){\\n                    k = j-i;\\n                    a = i,b = j;\\n                }\\n                    i = j;\\n            }\\n            j++;\\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408466,
                "title": "brute-force-c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    bool check(int x){//function for number x is prime or not\\n        for(int i = 2; i <= sqrt(x); i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int l, int r) {\\n        int ans = INT_MAX,a=-1,b=-1;\\n        vector<int> v;\\n        if(l==1)l++;//1 is not prime or non-prime\\n        while(l<=r){\\n            if(check(l)){//find 1st prime no\\n                a = l;\\n            }\\n            l++;\\n            if(a!=-1)break;\\n        }\\n        while(l<=r){\\n            if(check(l)){\\n                b = l;//2nd prime number\\n                if(b-a<ans){//if b - a < any previous answers update ans by {a,b}\\n                    v = {a,b};\\n                    ans= b-a;\\n                }\\n                a = b;\\n            }\\n            l++;\\n        }\\n        if(a==-1||b==-1){//if second prime no not find return {-1,-1}\\n            return {-1,-1};\\n        }\\n        return v;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    bool check(int x){//function for number x is prime or not\\n        for(int i = 2; i <= sqrt(x); i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int l, int r) {\\n        int ans = INT_MAX,a=-1,b=-1;\\n        vector<int> v;\\n        if(l==1)l++;//1 is not prime or non-prime\\n        while(l<=r){\\n            if(check(l)){//find 1st prime no\\n                a = l;\\n            }\\n            l++;\\n            if(a!=-1)break;\\n        }\\n        while(l<=r){\\n            if(check(l)){\\n                b = l;//2nd prime number\\n                if(b-a<ans){//if b - a < any previous answers update ans by {a,b}\\n                    v = {a,b};\\n                    ans= b-a;\\n                }\\n                a = b;\\n            }\\n            l++;\\n        }\\n        if(a==-1||b==-1){//if second prime no not find return {-1,-1}\\n            return {-1,-1};\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981354,
                "title": "c-prime-gap-pre-built-o-n-logn-100-faster-less-than-10ms",
                "content": "\\n![image](https://assets.leetcode.com/users/images/603eb97e-e4d7-438f-8b7b-b95281547952_1672598226.7452145.png)\\n\\n\\nWe can study prime gap first. \\nRefer \\n(1) https://primes.utm.edu/howmany.html\\n(2) https://en.wikipedia.org/wiki/Prime_gap\\nAnd we got this useful information. \\n\\u03C0(x) ~ x/ln x. (number of primes from 1 to x)\\np(n) ~ n ln n (nth prime is about n ln n)\\ng(n) = O( log(p(n))^2 ). so 10^6 can let us to encrpyt prime gap into string\\'s character.\\n\\n\\nWe can make a special pre-built table of prime gap to solve this problem less than 10ms\\nBecause prime gap is not too large, so that each record of this table can be represented in one character. \\nThe number of record in this table is about O(N/logN) if you know the math of prime gap.\\nIn the constraint of 10^6, the size of pre-built table will be 78497 number of characters. \\n\\nI put some effort to generate the pre-built table by coding. \\nAnd I put the detail here. \\nhttps://github.com/milochen0418/leetcode/tree/master/topics/primegap\\n\\nTo ignore how to generate the pre-built table, I put my solution here.\\nIn the following code, the primegaps_str is the pre-built table. \\n\\nBecause the constraint of the size of the article cannot let me put all pre-built table, \\nSo you can copy this source code to submit. \\nhttps://leetcode.com/problems/closest-prime-numbers-in-range/submissions/869228418/\\n\\nIn the following source code,  The pre-built table is not enough, it\\'s for you to understand. \\nIf you want to run the code, you can refer above link. \\n# Source Code \\n```C++\\nclass Solution {\\npublic:\\n    const string primegaps_str = \"#$$%$%$%&$&%$%&&$&%$&%&\\'%$%$%*%&$($&&%&&$($%$))%$%&$(&&&$&%$(*%$%*&($%&\\'&&%&\\'%\\'($($&%&\\'%$%)\\'%\\'%&)$,&(&&$&(&&$&&%$)($%&&$)%&\\'(\\'(\\'&&%\\'&%\\'%*()$($%$(*%$%*%$%-%\\'(\\'%&&*%&&\\'&)%&$($&($($&,%$%&&\\'&&.$(\\'(&&\\')%&&$&)(,$%&$&%$%)$&4&&\\',(*%$%&\\'%$&)($%$%&))\\')&%&\\'%\\'%*%&$%&$&(-&%$/%$()$(\\'&&&,&%$)()\\'+*&%$%$()&&,$+$.&\\'&%$%\\'&($(*(&)$%$()$+$&%$(\\',/%&\\'+$%\\'+$%\\'&&%)$.&$&%&*&%$&%&)&&*%&)\\'&%0,(\\'%&$&.)$+\\'%)*($%\\'&&%$%&\\'%$&($(\\'%*()$&%$+*%&\\'&%,\\'(&&\\'()*%&&$1$(\\'%*%\\')&)%&-($+0%$)&%)&\\'%\\'.$%$)1$&&&%&$)%)$($+$+&-+\\'%$%$.\\')&($%&$&($)($(*&%&\\'&&+)$%*&%\\'(\\'&&.&$(*%&,$(*%$(*%\\',%&$%&$)%-.)$%&&$&.$&+&)$&)+$%&*%$,/(&$($($(&$($(&\\'2($(\\'&(,&))$,&%&&,$(*&%$%/$)&+\\'&&,+$%&$&&(&)),$&%,\\'/%$%&$)%*2(&)*&()$%&\\'&($%*&&%&$($+)\\',%&)$&&&1&*%\\'(\\'),%$%/)&$+&&*(*%2&&&\\'&%$)&%$&.&$%,$%)$&%0&&%\\'(3+$&%$%$(*&%\\'(&-%$&2%\\'(&&\\'&)%&$&%&$($+&-%)*1&-%,\\'&%&*&&($()\\'($(\\')(/$%\\'&%\\',(&&$&()$(&&&\\'&(&$&&&(\\'/&.$,%\\'(2\\',%$(&$&%,\\'),+&$)&($($&(*%/$+$($(-%$%\\'+&&$)+\\'%&2$($&%&&\\'&%)&\\')%*)(/&)&$.\\',(&*%$&(\\'&%&2*($)($+$,/,&+,&$,%&$(\\'(&&\\'%&$($)%&&$)%*,%&-%\\'&%\\'%*&%*)%$2%/&&))*&%$%,&)\\'&%)$)2+$&.*&()&$%\\'(&&/*&%\\'),($($%&-&%*%$%*&)/(&\\'($2%&$)%*&4)\\'&($%-(\\'+$(*%$)&+&\\'%\\'%&\\'&&)&%&&\\',%-%)$(&$()$%-&2&%\\'()&$1$&%$+)$&(\\'/)&,&%*&%)\\'&)%&)&)$+-%$(,\\'%*%$&.&*&&(&$($%$.$%&&)&*()&\\'%5*)&%&$)&)+$(\\'.$)&%&,$)&%)\\'&)%&)&$))%*&+&$(\\',&4$1$.&$()$&%\\'.&$(\\'%&\\'%),)-%&&\\'%$+)$(\\'($%&*).\\'1$%-%$%*()$)+$1\\'.\\'%&&*%\\')&&%-%,$)&%&*,(\\'(3&(&&$&+&$)&1$(\\'+&\\'&(/-($($)%&-%$),($($%-+0%\\'&%)&\\'))&%\\'.$+*(&))*&%-%)&$&&+\\'.$1\\'&%-%)/-%\\'($+$))4$%&)&&\\'&%$&/%-(&&*%&&$)&($(&-%0%$&.$/%&$%&/&\\'%$4&\\'+)$($(&\\'%\\').&*%0%$)(\\'%\\')%*&+&\\'%&&\\'&()$&&+\\'&&)($&,%&&&),\\'&(\\',%*&,(\\'()$&))5%&\\'%&$%,)&\\'&&%,$%$/%&&*2&%&)&-%\\'%\\'&&%2$()\\'(\\'/&)%*%&$1*+$)&%-(&&&\\'()*(*+*(*&+&\\'&+-($&%$%)$($&.&$%,\\'(\\'.$(,*%$%,$%&\\'($2%2$($,%,&*($%-5&%&*%-(*.&$2)(,$%*&.,$)&%\\'%\\'&($),(*+*%&&$&%$1$1&$%&*%)*+*%&\\'&%&&&\\'%\\'%*+\\'&%)\\'+$(\\'%&0&(\\'%&)*2%*.\\')%&\\'(&*(&$())*&&,(&\\',%&$&($(\\'&&($,($)%&\\'()*)%\\'(&&-%*+*(\\'()$,&)()$%$)&%\\'%9%$%$()&&*%&&&\\'&5,%&$)&&&%*.)$,(&0/%$%$%*%&&\\'+)$8%$%/&&$,%*&1,*&()$&)2&%&&*%$/%&&0(,&\\'&&2%))$+$&%),$&%0)&)%//)&$)1\\'%&)$,&%&&-+$&&,(&$%\\'&&/+&\\'(&*.\\'+&$)%$.\\',4$&,%&&\\'(\\',&%$%\\'+$))&,%&&&$&)(-),%&$+$(*%2$()$/&+\\'($).&$+-($)),()&$($&(,$)&%&$/1$%$($+)\\'.$&%$(&-)(\\')&&&%,$%),$)&%$+))*%\\',%)*&&%\\'&%-)(*%$+$)2%&/-/(\\')()&))&\\'+*&%&5-(2)$%$1)*&.\\'%,&*,%&$&4,$+&,$/%$&)&)(\\'&+)\\'(*7&$&%)*%$%$%\\'&(&&$&&&)&/($(&)&&*&&=-&($(\\'())$&%*+\\')&.$(\\'&.$.&\\'())$(&)$%*($&,%)\\',)&&%&&*%$))%&,,)$+)\\',(0%&\\'&&%$(-%&\\'%-($4$%/$))(&$)2&)+)$.,)*($))%$%&)$+,$7\\'+&\\'($%,\\'(\\')%,$,($%$%\\'1$&.)&*,%&\\'&&(\\'%$,(&-.\\'&2%$%,&2$%\\'&%&)*4*&%$&%*%$&1$%&\\'($($($%2$))(,)*($)&(&*)%*%,$(\\'%\\'(),,\\'&,+*&&(*%&$))%&&)$+$)&%*&%$),%5,))$%$%\\')%5&,$)(&)/\\'&&+)$,(-($&,%$7&$+$%\\',()&$(\\'%&)$(,\\'&%-%&5&$(&/&*+&,$(-(\\'&%&$($)%$%\\'(&),*)+\\'&+\\'%$&,/,()$%*(&&&,)$1,*+)*/).&$(\\'%$%*)&%&*%$%2&$&($2.$%&\\'&&+))&\\'%$/)%&\\'&&($&)1*&%)\\'&)%&*&)(&&\\'&&%$%\\')%*,($+&-&(\\'%25)\\'.)$&)+&&$,%0%\\',(\\'(&*%-.,)\\'1)&&\\'&)/+*%*)&()-&%\\',),($%-(*%&$(/,$%-+*(*&%&-&(&$)&2(\\'&%&\\'7$%$),%&\\'(&,,$)+\\'&%&&$=*%-+$%&)$&))&%*(&&*(*+\\'&)%\\'.&$,.&$,&+*(&)$&%\\',)+$%*%\\'))2+\\'%$&.)\\'(&&&*&,()$($%0%)\\'%,\\'(*+&&\\'(&\\'&)(-(\\'%)0,%),&2&\\'&.)$%&&$($%&&$&.,&,)\\')&()$+$($(,&-%$&.&&,&*)+$&&%*)%$,+5)&*1$)&)&%$+2\\'/&2($,%&)\\'.$&.,$($(2$1&*+&-+$&%3%$%&$)%&&)$&%&\\'&%-%3(\\'+$.$%&\\'&+*%,\\'%-&))&($($)1),$,(\\'(;$%&\\'($(2$5&(&$,%&\\'+*+&*%-%&$()$&)&&%)$&%)&\\'%$&,(&\\')&.$&),%*&%-&+\\'%\\'.\\')&&+),2\\'%$%&0%*/.&$&(&*&&)(&$)()\\',,(&\\'+&&\\'+-%$($()&\\'&(-(,0%&2$%\\'&)),%\\'.&$)4&,)&$1*+*%*)%&&$5%&-)/&.$+,)),$&&&%&*%$.\\')&(&\\'),)&($.*&&%,&-.$)/%,,$.$%)\\')(*%$,+6&&&)(&)\\'&%&*2&(\\'.&\\')($($&($(),-&%\\'.&&2&*&))&($(2$+\\'%$&,%$&%0%\\'&($%&\\'%&2)$&&%-.\\'%$%G\\'%\\'.$%*($%-&(,&-+&\\'&%-).$%$)(,$\";\\n\\n    vector<int> closestPrimes(int left, int right) { //Time & Space complexity O( N / Log(N) )\\n        int n = primegaps_str.length();\\n        if(left==right) return {-1,-1};\\n        if(left<=2&&right>=3) return {2,3};\\n        int prime_idx=0;\\n        int prime = 2;\\n        int min_gap=INT_MAX;\\n        vector<int> ans = {-1,-1};\\n        \\n        for(int i = 0;i<n; i++) {\\n            int gap = decode(primegaps_str[i]);\\n            int next_prime = prime+gap;\\n            if(next_prime>right) break;\\n            if(prime>=left) {\\n                if(gap==2) return {prime,next_prime};\\n                if(gap<min_gap) {\\n                    min_gap=gap;\\n                    ans[0]=prime;\\n                    ans[1]=next_prime;\\n                }\\n            }\\n            prime=next_prime;\\n        }\\n        return ans;\\n    }\\n\\n    int decode(const char &c) {\\n        int b = (int)((c-35)*2);\\n        b = b==0?1:b;\\n        return b;\\n    }\\n};\\n```\\n\\n# Complexity\\nBecause the number of prime from 1 to x is O(x / lnx -1), \\nOur algorithm just run one loop for all primes from 1 to x. \\nThus, \\nTime complexity O(N / logN) -- one loop runng for pre-built table\\nSpace complexity O(N / logN)  -- pre-built table\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    const string primegaps_str = \"#$$%$%$%&$&%$%&&$&%$&%&\\'%$%$%*%&$($&&%&&$($%$))%$%&$(&&&$&%$(*%$%*&($%&\\'&&%&\\'%\\'($($&%&\\'%$%)\\'%\\'%&)$,&(&&$&(&&$&&%$)($%&&$)%&\\'(\\'(\\'&&%\\'&%\\'%*()$($%$(*%$%*%$%-%\\'(\\'%&&*%&&\\'&)%&$($&($($&,%$%&&\\'&&.$(\\'(&&\\')%&&$&)(,$%&$&%$%)$&4&&\\',(*%$%&\\'%$&)($%$%&))\\')&%&\\'%\\'%*%&$%&$&(-&%$/%$()$(\\'&&&,&%$)()\\'+*&%$%$()&&,$+$.&\\'&%$%\\'&($(*(&)$%$()$+$&%$(\\',/%&\\'+$%\\'+$%\\'&&%)$.&$&%&*&%$&%&)&&*%&)\\'&%0,(\\'%&$&.)$+\\'%)*($%\\'&&%$%&\\'%$&($(\\'%*()$&%$+*%&\\'&%,\\'(&&\\'()*%&&$1$(\\'%*%\\')&)%&-($+0%$)&%)&\\'%\\'.$%$)1$&&&%&$)%)$($+$+&-+\\'%$%$.\\')&($%&$&($)($(*&%&\\'&&+)$%*&%\\'(\\'&&.&$(*%&,$(*%$(*%\\',%&$%&$)%-.)$%&&$&.$&+&)$&)+$%&*%$,/(&$($($(&$($(&\\'2($(\\'&(,&))$,&%&&,$(*&%$%/$)&+\\'&&,+$%&$&&(&)),$&%,\\'/%$%&$)%*2(&)*&()$%&\\'&($%*&&%&$($+)\\',%&)$&&&1&*%\\'(\\'),%$%/)&$+&&*(*%2&&&\\'&%$)&%$&.&$%,$%)$&%0&&%\\'(3+$&%$%$(*&%\\'(&-%$&2%\\'(&&\\'&)%&$&%&$($+&-%)*1&-%,\\'&%&*&&($()\\'($(\\')(/$%\\'&%\\',(&&$&()$(&&&\\'&(&$&&&(\\'/&.$,%\\'(2\\',%$(&$&%,\\'),+&$)&($($&(*%/$+$($(-%$%\\'+&&$)+\\'%&2$($&%&&\\'&%)&\\')%*)(/&)&$.\\',(&*%$&(\\'&%&2*($)($+$,/,&+,&$,%&$(\\'(&&\\'%&$($)%&&$)%*,%&-%\\'&%\\'%*&%*)%$2%/&&))*&%$%,&)\\'&%)$)2+$&.*&()&$%\\'(&&/*&%\\'),($($%&-&%*%$%*&)/(&\\'($2%&$)%*&4)\\'&($%-(\\'+$(*%$)&+&\\'%\\'%&\\'&&)&%&&\\',%-%)$(&$()$%-&2&%\\'()&$1$&%$+)$&(\\'/)&,&%*&%)\\'&)%&)&)$+-%$(,\\'%*%$&.&*&&(&$($%$.$%&&)&*()&\\'%5*)&%&$)&)+$(\\'.$)&%&,$)&%)\\'&)%&)&$))%*&+&$(\\',&4$1$.&$()$&%\\'.&$(\\'%&\\'%),)-%&&\\'%$+)$(\\'($%&*).\\'1$%-%$%*()$)+$1\\'.\\'%&&*%\\')&&%-%,$)&%&*,(\\'(3&(&&$&+&$)&1$(\\'+&\\'&(/-($($)%&-%$),($($%-+0%\\'&%)&\\'))&%\\'.$+*(&))*&%-%)&$&&+\\'.$1\\'&%-%)/-%\\'($+$))4$%&)&&\\'&%$&/%-(&&*%&&$)&($(&-%0%$&.$/%&$%&/&\\'%$4&\\'+)$($(&\\'%\\').&*%0%$)(\\'%\\')%*&+&\\'%&&\\'&()$&&+\\'&&)($&,%&&&),\\'&(\\',%*&,(\\'()$&))5%&\\'%&$%,)&\\'&&%,$%$/%&&*2&%&)&-%\\'%\\'&&%2$()\\'(\\'/&)%*%&$1*+$)&%-(&&&\\'()*(*+*(*&+&\\'&+-($&%$%)$($&.&$%,\\'(\\'.$(,*%$%,$%&\\'($2%2$($,%,&*($%-5&%&*%-(*.&$2)(,$%*&.,$)&%\\'%\\'&($),(*+*%&&$&%$1$1&$%&*%)*+*%&\\'&%&&&\\'%\\'%*+\\'&%)\\'+$(\\'%&0&(\\'%&)*2%*.\\')%&\\'(&*(&$())*&&,(&\\',%&$&($(\\'&&($,($)%&\\'()*)%\\'(&&-%*+*(\\'()$,&)()$%$)&%\\'%9%$%$()&&*%&&&\\'&5,%&$)&&&%*.)$,(&0/%$%$%*%&&\\'+)$8%$%/&&$,%*&1,*&()$&)2&%&&*%$/%&&0(,&\\'&&2%))$+$&%),$&%0)&)%//)&$)1\\'%&)$,&%&&-+$&&,(&$%\\'&&/+&\\'(&*.\\'+&$)%$.\\',4$&,%&&\\'(\\',&%$%\\'+$))&,%&&&$&)(-),%&$+$(*%2$()$/&+\\'($).&$+-($)),()&$($&(,$)&%&$/1$%$($+)\\'.$&%$(&-)(\\')&&&%,$%),$)&%$+))*%\\',%)*&&%\\'&%-)(*%$+$)2%&/-/(\\')()&))&\\'+*&%&5-(2)$%$1)*&.\\'%,&*,%&$&4,$+&,$/%$&)&)(\\'&+)\\'(*7&$&%)*%$%$%\\'&(&&$&&&)&/($(&)&&*&&=-&($(\\'())$&%*+\\')&.$(\\'&.$.&\\'())$(&)$%*($&,%)\\',)&&%&&*%$))%&,,)$+)\\',(0%&\\'&&%$(-%&\\'%-($4$%/$))(&$)2&)+)$.,)*($))%$%&)$+,$7\\'+&\\'($%,\\'(\\')%,$,($%$%\\'1$&.)&*,%&\\'&&(\\'%$,(&-.\\'&2%$%,&2$%\\'&%&)*4*&%$&%*%$&1$%&\\'($($($%2$))(,)*($)&(&*)%*%,$(\\'%\\'(),,\\'&,+*&&(*%&$))%&&)$+$)&%*&%$),%5,))$%$%\\')%5&,$)(&)/\\'&&+)$,(-($&,%$7&$+$%\\',()&$(\\'%&)$(,\\'&%-%&5&$(&/&*+&,$(-(\\'&%&$($)%$%\\'(&),*)+\\'&+\\'%$&,/,()$%*(&&&,)$1,*+)*/).&$(\\'%$%*)&%&*%$%2&$&($2.$%&\\'&&+))&\\'%$/)%&\\'&&($&)1*&%)\\'&)%&*&)(&&\\'&&%$%\\')%*,($+&-&(\\'%25)\\'.)$&)+&&$,%0%\\',(\\'(&*%-.,)\\'1)&&\\'&)/+*%*)&()-&%\\',),($%-(*%&$(/,$%-+*(*&%&-&(&$)&2(\\'&%&\\'7$%$),%&\\'(&,,$)+\\'&%&&$=*%-+$%&)$&))&%*(&&*(*+\\'&)%\\'.&$,.&$,&+*(&)$&%\\',)+$%*%\\'))2+\\'%$&.)\\'(&&&*&,()$($%0%)\\'%,\\'(*+&&\\'(&\\'&)(-(\\'%)0,%),&2&\\'&.)$%&&$($%&&$&.,&,)\\')&()$+$($(,&-%$&.&&,&*)+$&&%*)%$,+5)&*1$)&)&%$+2\\'/&2($,%&)\\'.$&.,$($(2$1&*+&-+$&%3%$%&$)%&&)$&%&\\'&%-%3(\\'+$.$%&\\'&+*%,\\'%-&))&($($)1),$,(\\'(;$%&\\'($(2$5&(&$,%&\\'+*+&*%-%&$()$&)&&%)$&%)&\\'%$&,(&\\')&.$&),%*&%-&+\\'%\\'.\\')&&+),2\\'%$%&0%*/.&$&(&*&&)(&$)()\\',,(&\\'+&&\\'+-%$($()&\\'&(-(,0%&2$%\\'&)),%\\'.&$)4&,)&$1*+*%*)%&&$5%&-)/&.$+,)),$&&&%&*%$.\\')&(&\\'),)&($.*&&%,&-.$)/%,,$.$%)\\')(*%$,+6&&&)(&)\\'&%&*2&(\\'.&\\')($($&($(),-&%\\'.&&2&*&))&($(2$+\\'%$&,%$&%0%\\'&($%&\\'%&2)$&&%-.\\'%$%G\\'%\\'.$%*($%-&(,&-+&\\'&%-).$%$)(,$\";\\n\\n    vector<int> closestPrimes(int left, int right) { //Time & Space complexity O( N / Log(N) )\\n        int n = primegaps_str.length();\\n        if(left==right) return {-1,-1};\\n        if(left<=2&&right>=3) return {2,3};\\n        int prime_idx=0;\\n        int prime = 2;\\n        int min_gap=INT_MAX;\\n        vector<int> ans = {-1,-1};\\n        \\n        for(int i = 0;i<n; i++) {\\n            int gap = decode(primegaps_str[i]);\\n            int next_prime = prime+gap;\\n            if(next_prime>right) break;\\n            if(prime>=left) {\\n                if(gap==2) return {prime,next_prime};\\n                if(gap<min_gap) {\\n                    min_gap=gap;\\n                    ans[0]=prime;\\n                    ans[1]=next_prime;\\n                }\\n            }\\n            prime=next_prime;\\n        }\\n        return ans;\\n    }\\n\\n    int decode(const char &c) {\\n        int b = (int)((c-35)*2);\\n        b = b==0?1:b;\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981326,
                "title": "simple-java-solution-using-sieve-of-eratosthenes",
                "content": "# Complexity\\n- Time complexity: 0(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        boolean k[]=new boolean[right+1];\\n        Arrays.fill(k,true);\\n        k[0]=k[1]=false;\\n        for(int i=2;i<=Math.sqrt(right);i++)\\n        {\\n            if(k[i])\\n            {\\n                for(int j=i*i;j<=right;j+=i)\\n                {\\n                    k[j]=false;\\n                }\\n            }\\n        }\\n        int a[]=new int[2];\\n        a[0]=a[1]=-1;\\n        int p=Integer.MAX_VALUE,m=1,f=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(k[i] && m==0)\\n            {\\n                p=Math.min(p,i-f);\\n                f=i;\\n            }\\n            else if(k[i] && m==1)\\n            {\\n                f=i;\\n                m=0;\\n            }\\n        }\\n        //System.out.println(p);\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(k[i] == true && a[0] != -1)\\n            {\\n                if(p == i-a[0])\\n                {\\n                    a[1]=i;\\n                    break;\\n                }\\n                else\\n                {\\n                    a[0]=i;\\n                }\\n            }\\n            else if(k[i] == true && a[0]==-1)\\n            {\\n                a[0]=i;\\n            }\\n        }\\n        //System.out.println(a[0]+\" \"+a[1]);\\n        if(a[0] == -1 || a[1] == -1)\\n        {\\n            a[0]=a[1]=-1;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        boolean k[]=new boolean[right+1];\\n        Arrays.fill(k,true);\\n        k[0]=k[1]=false;\\n        for(int i=2;i<=Math.sqrt(right);i++)\\n        {\\n            if(k[i])\\n            {\\n                for(int j=i*i;j<=right;j+=i)\\n                {\\n                    k[j]=false;\\n                }\\n            }\\n        }\\n        int a[]=new int[2];\\n        a[0]=a[1]=-1;\\n        int p=Integer.MAX_VALUE,m=1,f=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(k[i] && m==0)\\n            {\\n                p=Math.min(p,i-f);\\n                f=i;\\n            }\\n            else if(k[i] && m==1)\\n            {\\n                f=i;\\n                m=0;\\n            }\\n        }\\n        //System.out.println(p);\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(k[i] == true && a[0] != -1)\\n            {\\n                if(p == i-a[0])\\n                {\\n                    a[1]=i;\\n                    break;\\n                }\\n                else\\n                {\\n                    a[0]=i;\\n                }\\n            }\\n            else if(k[i] == true && a[0]==-1)\\n            {\\n                a[0]=i;\\n            }\\n        }\\n        //System.out.println(a[0]+\" \"+a[1]);\\n        if(a[0] == -1 || a[1] == -1)\\n        {\\n            a[0]=a[1]=-1;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977581,
                "title": "optimized-sieve-explained-time-complexity",
                "content": "##### How Sieve of eratosthenes work?\\n- For every number you mark all it\\'s multiples larger than itself (i.e for 7 say 7x2, 7x3, 7x4 ...) as not prime since as they have non trivial divisor (1 & itself) i.e 7 in this case for 14, 21, 28.... Start with considering all numbers as prime. You\\'ll end up with only primes at the end.\\n- Small optimization here is starting the second loop of sieve from j=ixi and not j=2i. why? and why not iterate multiples like j=ix2, ix3, ix4, ix5, ix6 ..... i*(i-1)? \\n- Because they would\\'ve already been marked not prime as they are some multiple of numbers smaller than i like 2xi, 3xi, 4xi, 5xi ....  (i-1)xi.\\n\\n##### Complexity\\n- Sieve of Eratosthenes is O(nloglogn) (complicated mathematical derivation). Here n = right since all the primes <=right are computed & since we are storing them using bool array space complexity is O(n)\\n\\n##### Code\\n```\\n`    vector<int> closestPrimes(int left, int right) {\\n    \\n    // Sieve of eratosthenes\\n    bool isprime[right+1];\\n    fill(isprime, isprime+right+1, true);\\n    isprime[0]=isprime[1]=false;\\n    \\n    for(int i=2;i<=right;i++){\\n        if(!isprime[i]) continue;\\n        for(long long j=1LL*i*i;j<=right;j+=i){\\n            isprime[j] = false;\\n        }\\n    }\\n\\n    int l=-1, r=-1, prev=-1;\\n    for(int i=left; i<=right; i++){\\n        if(!isprime[i]) continue;\\n        if(l==-1) l = i;\\n        else if(r==-1){\\n            r = i;\\n        }\\n        else if(i-prev < r-l){\\n            l=prev;\\n            r=i;\\n        }\\n        prev = i;\\n    }\\n\\n    if(r==-1) return {-1, -1};\\n    else return {l, r};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n`    vector<int> closestPrimes(int left, int right) {\\n    \\n    // Sieve of eratosthenes\\n    bool isprime[right+1];\\n    fill(isprime, isprime+right+1, true);\\n    isprime[0]=isprime[1]=false;\\n    \\n    for(int i=2;i<=right;i++){\\n        if(!isprime[i]) continue;\\n        for(long long j=1LL*i*i;j<=right;j+=i){\\n            isprime[j] = false;\\n        }\\n    }\\n\\n    int l=-1, r=-1, prev=-1;\\n    for(int i=left; i<=right; i++){\\n        if(!isprime[i]) continue;\\n        if(l==-1) l = i;\\n        else if(r==-1){\\n            r = i;\\n        }\\n        else if(i-prev < r-l){\\n            l=prev;\\n            r=i;\\n        }\\n        prev = i;\\n    }\\n\\n    if(r==-1) return {-1, -1};\\n    else return {l, r};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977469,
                "title": "python-sieve-of-eratosthenes",
                "content": "This solution uses the Sieve of Eratosthenes to iterate through all of the prime numbers up to `right`.\\n\\nOnce you can do that, simply find the pair with the smallest range.\\n\\nThis could be made faster by stopping as soon as $$right - left == 2$$, but this is so fast it isn\\'t really necessary.\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> list[int]:\\n        sieve = [False] * (right+1)\\n        \\n        last_prime = -1\\n        result = [-1, -1]\\n        for p in range(2, right+1):\\n            if not sieve[p]:\\n                for p2 in range(p*2, right+1, p):\\n                    sieve[p2] = True\\n                if left <= p <= right:\\n                    if last_prime == -1:\\n                        last_prime = p\\n                    elif result == [-1, -1]:\\n                        result = [last_prime, p]\\n                    elif p - last_prime < result[1] - result[0]:\\n                        result = [last_prime, p]\\n                    last_prime = p\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> list[int]:\\n        sieve = [False] * (right+1)\\n        \\n        last_prime = -1\\n        result = [-1, -1]\\n        for p in range(2, right+1):\\n            if not sieve[p]:\\n                for p2 in range(p*2, right+1, p):\\n                    sieve[p2] = True\\n                if left <= p <= right:\\n                    if last_prime == -1:\\n                        last_prime = p\\n                    elif result == [-1, -1]:\\n                        result = [last_prime, p]\\n                    elif p - last_prime < result[1] - result[0]:\\n                        result = [last_prime, p]\\n                    last_prime = p\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004733,
                "title": "sieve-eratosthenes-java-sol-easy-sol",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int[] isPrime(int l, int n) {\\n        ArrayList<Integer> v = new ArrayList<>();\\n        boolean[] prime = new boolean[n + 1];\\n        int[] arr = new int[2];\\n        for (int i = 2; i * i <= n; i++) {\\n            if (prime[i] == false) {\\n                for (int j = i * i; j <= n; j = j + i) {\\n                    prime[j] = true;\\n                }\\n            }\\n        }\\n        \\n        for (int i = l; i <= n; i++) {\\n            if (prime[i] == false) {\\n                v.add(i);\\n            }\\n        }\\n        if (l<=1) {\\n            v.remove(0);\\n        }\\n        arr[0]=-1;\\n        arr[1]=-1;\\n        int min = Integer.MAX_VALUE;\\n        int j=-1;\\n        for (int i=0;i<=v.size()-1;i++) {\\n            if (j==-1) {\\n                j=i;\\n            } else if (v.get(i)-v.get(j)<min) {\\n                arr[0]=v.get(j);\\n                arr[1]=v.get(i);\\n                min=v.get(i)-v.get(j);\\n            }\\n            j=i;\\n        }\\n        return arr;\\n    }\\n    public int[] closestPrimes(int left, int right) {\\n        int[] ans=isPrime(left,right);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] isPrime(int l, int n) {\\n        ArrayList<Integer> v = new ArrayList<>();\\n        boolean[] prime = new boolean[n + 1];\\n        int[] arr = new int[2];\\n        for (int i = 2; i * i <= n; i++) {\\n            if (prime[i] == false) {\\n                for (int j = i * i; j <= n; j = j + i) {\\n                    prime[j] = true;\\n                }\\n            }\\n        }\\n        \\n        for (int i = l; i <= n; i++) {\\n            if (prime[i] == false) {\\n                v.add(i);\\n            }\\n        }\\n        if (l<=1) {\\n            v.remove(0);\\n        }\\n        arr[0]=-1;\\n        arr[1]=-1;\\n        int min = Integer.MAX_VALUE;\\n        int j=-1;\\n        for (int i=0;i<=v.size()-1;i++) {\\n            if (j==-1) {\\n                j=i;\\n            } else if (v.get(i)-v.get(j)<min) {\\n                arr[0]=v.get(j);\\n                arr[1]=v.get(i);\\n                min=v.get(i)-v.get(j);\\n            }\\n            j=i;\\n        }\\n        return arr;\\n    }\\n    public int[] closestPrimes(int left, int right) {\\n        int[] ans=isPrime(left,right);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988513,
                "title": "c-easy-solution-using-sieve-of-eratosthenes",
                "content": "# **Upvote if you found it useful**\\n\\nFor more solution go through this repo\\nhttps://github.com/Funik69/Leetcode_Solution\\nhttps://github.com/Funik69/Leetcode-Algorithm-StudyPlan-\\nhttps://github.com/Funik69/LeetCode-75---Study-Plan\\nhttps://github.com/Funik69/Programming-Skills-1\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n         vector<int> ans(2,-1);\\n        if(left==right)return ans;\\n        vector<int> prime(right+1,1);\\n        prime[0]=0;\\n        prime[1]=0;\\n        for(long i=2;i<=right;i++){\\n            if(prime[i]==1){\\n               for(long j=i*i;j<=right;j+=i)\\n                prime[j]=0;}\\n        }\\n        vector<int> v;\\n        for(int i=left;i<=right;i++){\\n            if(prime[i]==1){\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()<2)return ans;\\n        int d=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++){\\n            if(d>v[i+1]-v[i]){\\n                d=v[i+1]-v[i];\\n                ans[0]=v[i];\\n                ans[1]=v[i+1];\\n            }\\n            else continue;\\n        }\\n    return ans;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n         vector<int> ans(2,-1);\\n        if(left==right)return ans;\\n        vector<int> prime(right+1,1);\\n        prime[0]=0;\\n        prime[1]=0;\\n        for(long i=2;i<=right;i++){\\n            if(prime[i]==1){\\n               for(long j=i*i;j<=right;j+=i)\\n                prime[j]=0;}\\n        }\\n        vector<int> v;\\n        for(int i=left;i<=right;i++){\\n            if(prime[i]==1){\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()<2)return ans;\\n        int d=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++){\\n            if(d>v[i+1]-v[i]){\\n                d=v[i+1]-v[i];\\n                ans[0]=v[i];\\n                ans[1]=v[i+1];\\n            }\\n            else continue;\\n        }\\n    return ans;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987771,
                "title": "brute-force-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool is_prime(int n)\\n    {\\n        if (n == 1)\\n        {\\n            return false;\\n        }\\n        int i = 2;\\n        while (i * i <= n)\\n        {\\n            if (n % i == 0)\\n            {\\n                return false;\\n            }\\n            i += 1;\\n        }\\n        return true;\\n    }\\n\\n    vector<int> closestPrimes(int left, int right)\\n    {\\n        if (left == right)\\n            return {-1, -1};\\n        vector<int> primes;\\n        for (int i = left; i <= right; i++)\\n        {\\n            if (is_prime(i))\\n                primes.push_back(i);\\n        }\\n\\n        int diff = INT_MAX;\\n        vector<int> arr(2, -1);\\n\\n        for (int i = 0; i < primes.size() - 1; i++)\\n        {\\n            if (primes[i + 1] - primes[i] < diff)\\n            {\\n                diff = primes[i + 1] - primes[i];\\n                arr[0] = primes[i];\\n                arr[1] = primes[i + 1];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool is_prime(int n)\\n    {\\n        if (n == 1)\\n        {\\n            return false;\\n        }\\n        int i = 2;\\n        while (i * i <= n)\\n        {\\n            if (n % i == 0)\\n            {\\n                return false;\\n            }\\n            i += 1;\\n        }\\n        return true;\\n    }\\n\\n    vector<int> closestPrimes(int left, int right)\\n    {\\n        if (left == right)\\n            return {-1, -1};\\n        vector<int> primes;\\n        for (int i = left; i <= right; i++)\\n        {\\n            if (is_prime(i))\\n                primes.push_back(i);\\n        }\\n\\n        int diff = INT_MAX;\\n        vector<int> arr(2, -1);\\n\\n        for (int i = 0; i < primes.size() - 1; i++)\\n        {\\n            if (primes[i + 1] - primes[i] < diff)\\n            {\\n                diff = primes[i + 1] - primes[i];\\n                arr[0] = primes[i];\\n                arr[1] = primes[i + 1];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985286,
                "title": "c-brute-force-approach-16-time-55-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(int n){      // Checks if a number is prime or not\\n      if (n <= 1)\\n        return false;\\n      for (int i = 2; i * i <= n; i++)\\n        if (n % i == 0){\\n          return false;\\n        }\\n      return true;\\n    }\\n    vector<int> closestPrimes(int l, int r) {\\n      if(r - l < 1) return {-1, -1};\\n      vector<int> v;\\n      int p = -1, q = -1;\\n      for(int i = l; i <= r; i++){\\n        if(helper(i)) v.emplace_back(i);\\n      }\\n      int dif = 0;\\n      if(v.size() > 1){\\n        p = v[0]; q = v[1];\\n        dif = v[1] - v[0];\\n        for(int i = 0; i < v.size() - 1; i++){\\n          if(dif > v[i + 1] - v[i]){\\n            dif = v[i + 1] - v[i];\\n            p = v[i]; q = v[i + 1];\\n          }\\n        }\\n      }\\n      return {p, q};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int n){      // Checks if a number is prime or not\\n      if (n <= 1)\\n        return false;\\n      for (int i = 2; i * i <= n; i++)\\n        if (n % i == 0){\\n          return false;\\n        }\\n      return true;\\n    }\\n    vector<int> closestPrimes(int l, int r) {\\n      if(r - l < 1) return {-1, -1};\\n      vector<int> v;\\n      int p = -1, q = -1;\\n      for(int i = l; i <= r; i++){\\n        if(helper(i)) v.emplace_back(i);\\n      }\\n      int dif = 0;\\n      if(v.size() > 1){\\n        p = v[0]; q = v[1];\\n        dif = v[1] - v[0];\\n        for(int i = 0; i < v.size() - 1; i++){\\n          if(dif > v[i + 1] - v[i]){\\n            dif = v[i + 1] - v[i];\\n            p = v[i]; q = v[i + 1];\\n          }\\n        }\\n      }\\n      return {p, q};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983923,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> res={-1,-1};\\n        int maxd=INT_MAX;\\n        vector<int> prime;\\n        for(int i=left;i<=right;i++){\\n            if(isprime(i)){\\n                prime.push_back(i);\\n                if(prime.size()>1){ // check is their any prime number preveously exist or not\\n                    int cur_d=i-prime[prime.size()-2];\\n                    if(maxd > cur_d){\\n                        res={prime[prime.size()-2], i};\\n                        maxd=cur_d;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    bool isprime(int n){\\n        int cnt=0;\\n        if(n==1)return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> res={-1,-1};\\n        int maxd=INT_MAX;\\n        vector<int> prime;\\n        for(int i=left;i<=right;i++){\\n            if(isprime(i)){\\n                prime.push_back(i);\\n                if(prime.size()>1){ // check is their any prime number preveously exist or not\\n                    int cur_d=i-prime[prime.size()-2];\\n                    if(maxd > cur_d){\\n                        res={prime[prime.size()-2], i};\\n                        maxd=cur_d;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    bool isprime(int n){\\n        int cnt=0;\\n        if(n==1)return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980524,
                "title": "accepted-sieve-of-eratosthenes-c",
                "content": "# Intuition\\nwe just have to generate prime number\\'s optimally and for that i used SieveOfEratosthenes.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void SieveOfEratosthenes(int left , int n, vector<int>&s)\\n    {\\n        // Create a boolean array \"prime[0..n]\" and initialize\\n        // all entries it as true. A value in prime[i] will\\n        // finally be false if i is Not a prime, else true.\\n        bool prime[n+1];\\n        memset(prime, true, sizeof(prime));\\n\\n        for (int p=2; p*p<=n; p++)\\n        {\\n            // If prime[p] is not changed, then it is a prime\\n            if (prime[p] == true)\\n            {\\n                // Update all multiples of p\\n                for (int i=p*2; i<=n; i += p)\\n                    prime[i] = false;\\n            }\\n        } \\n        // get all prime numbers\\n        for (int p=left; p<=n; p++)\\n           if (prime[p])\\n              s.push_back(p);\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int>s;\\n        SieveOfEratosthenes(left,right,s);\\n        int mini = INT_MAX;\\n        vector<int>ans;\\n        if(s.size() == 1) return {-1,-1}; \\n        for(int i = 1 ; i  < s.size();i++){\\n            if(s[i-1] == 1) continue; \\n            if(abs(s[i] - s[i-1]) < mini){\\n                mini = abs(s[i] - s[i-1]);\\n                ans = {s[i-1],s[i]};\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void SieveOfEratosthenes(int left , int n, vector<int>&s)\\n    {\\n        // Create a boolean array \"prime[0..n]\" and initialize\\n        // all entries it as true. A value in prime[i] will\\n        // finally be false if i is Not a prime, else true.\\n        bool prime[n+1];\\n        memset(prime, true, sizeof(prime));\\n\\n        for (int p=2; p*p<=n; p++)\\n        {\\n            // If prime[p] is not changed, then it is a prime\\n            if (prime[p] == true)\\n            {\\n                // Update all multiples of p\\n                for (int i=p*2; i<=n; i += p)\\n                    prime[i] = false;\\n            }\\n        } \\n        // get all prime numbers\\n        for (int p=left; p<=n; p++)\\n           if (prime[p])\\n              s.push_back(p);\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int>s;\\n        SieveOfEratosthenes(left,right,s);\\n        int mini = INT_MAX;\\n        vector<int>ans;\\n        if(s.size() == 1) return {-1,-1}; \\n        for(int i = 1 ; i  < s.size();i++){\\n            if(s[i-1] == 1) continue; \\n            if(abs(s[i] - s[i-1]) < mini){\\n                mini = abs(s[i] - s[i-1]);\\n                ans = {s[i-1],s[i]};\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978062,
                "title": "python-3-sieve-of-eratosthenes",
                "content": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        prime = [True for i in range(right + 1)]\\n        \\n        p = 2\\n        while p ** 2 <= right:\\n            if prime[p]:\\n                for i in range(p ** 2, right + 1, p):\\n                    prime[i] = False\\n            p += 1\\n        \\n        prime = [i for i in range(len(prime)) if prime[i] and max(2, left) <= i <= right]\\n        \\n        res = [-1, -1]\\n        diff = inf\\n        \\n        for i in range(len(prime) - 1):\\n            if prime[i + 1] - prime[i] < diff:\\n                diff = prime[i + 1] - prime[i]\\n                res = [prime[i], prime[i + 1]]\\n            \\n            if diff <= 2:\\n                return res\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        prime = [True for i in range(right + 1)]\\n        \\n        p = 2\\n        while p ** 2 <= right:\\n            if prime[p]:\\n                for i in range(p ** 2, right + 1, p):\\n                    prime[i] = False\\n            p += 1\\n        \\n        prime = [i for i in range(len(prime)) if prime[i] and max(2, left) <= i <= right]\\n        \\n        res = [-1, -1]\\n        diff = inf\\n        \\n        for i in range(len(prime) - 1):\\n            if prime[i + 1] - prime[i] < diff:\\n                diff = prime[i + 1] - prime[i]\\n                res = [prime[i], prime[i + 1]]\\n            \\n            if diff <= 2:\\n                return res\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977867,
                "title": "explained-java-solution",
                "content": "# Intuition\\nthe brute force solution to get prime number is not enough so we need to apply **Sieve of eratosthenes** Algorithm.  \\n# Ressources\\nif you are not familiar with this algorithm check this video : [link](https://www.youtube.com/watch?v=pKvGYOnO9Ao).\\nPS: in the video, the algorithm loop until right/2 but it\\'s not working in our case ( I don\\'t know why), this is why am looping until right.\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        // Use sieve of eratosthenes or you will get a time limit exceeded\\n        List<Integer> primes = getPrimes(left,right);\\n\\n        int[] ans = new int[]{0,Integer.MAX_VALUE}; \\n        // set the minimal_distance to a large number\\n        int m_d = ans[1]-ans[0];\\n        // find the minimal distance between two consecutive primes\\n        for( int i =0;i< primes.size()-1;i++){  \\n                int c_d = primes.get(i+1)-primes.get(i);\\n                if(c_d < m_d){\\n                    ans[0] = primes.get(i);\\n                    ans[1] = primes.get(i+1);\\n                    m_d = ans[1]-ans[0];\\n                }\\n        }\\n        // if the minimal distance did not change then the solution does not exist.\\n        if(m_d == Integer.MAX_VALUE) return new int[]{-1,-1};\\n        return ans;\\n    }\\n    /**\\n     * Sieve of eratosthenes Algorithm to get all prime numbers\\n     */\\n    public List<Integer> getPrimes(int left,int right ){\\n        List<Integer> primes = new ArrayList<>();\\n        int[] sieve = new int[1_000_001];\\n        Arrays.fill(sieve,1);\\n        for(int i = 2;i<=right;i++){\\n            if(sieve[i] == 1){\\n                if(i>=left) primes.add(i);\\n                for(int j=2*i ; j<=right;j+=i){\\n                    sieve[j]=0;\\n                }\\n            }\\n        }\\n        return primes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        // Use sieve of eratosthenes or you will get a time limit exceeded\\n        List<Integer> primes = getPrimes(left,right);\\n\\n        int[] ans = new int[]{0,Integer.MAX_VALUE}; \\n        // set the minimal_distance to a large number\\n        int m_d = ans[1]-ans[0];\\n        // find the minimal distance between two consecutive primes\\n        for( int i =0;i< primes.size()-1;i++){  \\n                int c_d = primes.get(i+1)-primes.get(i);\\n                if(c_d < m_d){\\n                    ans[0] = primes.get(i);\\n                    ans[1] = primes.get(i+1);\\n                    m_d = ans[1]-ans[0];\\n                }\\n        }\\n        // if the minimal distance did not change then the solution does not exist.\\n        if(m_d == Integer.MAX_VALUE) return new int[]{-1,-1};\\n        return ans;\\n    }\\n    /**\\n     * Sieve of eratosthenes Algorithm to get all prime numbers\\n     */\\n    public List<Integer> getPrimes(int left,int right ){\\n        List<Integer> primes = new ArrayList<>();\\n        int[] sieve = new int[1_000_001];\\n        Arrays.fill(sieve,1);\\n        for(int i = 2;i<=right;i++){\\n            if(sieve[i] == 1){\\n                if(i>=left) primes.add(i);\\n                for(int j=2*i ; j<=right;j+=i){\\n                    sieve[j]=0;\\n                }\\n            }\\n        }\\n        return primes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977422,
                "title": "python-easy-logic-explained-seive-s-algo-for-prime-numbers-codeplug",
                "content": "# Intuition\\n\\nSieve\\'s algo is one of the most efficient algos to find prime numbers from 2 to n. We find all these primes and store the results in a prime array. Initially all numbers are considered as primes. Then we start marking multiples of any prime marked number as non-prime.\\n\\nWe repeat this process starting from 2 till we reach n. In the end the prime array indicates the prime numbers.\\n\\nOnce we have the primes, we sort the result according to the difference between consecutive prime pairs followed by the first number in the pair. And return the first pair.\\n\\n**Upvote if you like the solution :)**\\n# Code\\n```python []\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def solve(start, end):\\n            prime = [True for i in range(end + 1)] # initially mark all numbers as prime\\n            p = 2\\n            \\n            while(p * p <= end):\\n                if prime[p]:\\n                    for i in range(p * p, end + 1, p):\\n                        prime[i] = False # mark all multiples except for the first number as non-prime\\n                p += 1\\n            \\n            res = deque()\\n            ans = []\\n            \\n            for p in range(max(2, start), end + 1):\\n                if prime[p]:\\n                    res.append(p)\\n                    if len(res) == 2:\\n                        ans.append((res[1] - res[0],  res[0], res[1]))\\n                        res.popleft()\\n            ans.sort()\\n            return (ans[0][1],ans[0][2]) if ans else [-1, -1]\\n        \\n        return solve(left, right)\\n    \\n# class Solution: # TLE\\n#     def closestPrimes(self, left: int, right: int) -> List[int]:\\n#         def isPrime(n):\\n#             x = ceil(sqrt(n))\\n            \\n#             for i in range(2, x + 1):\\n#                 if n % i == 0: return False\\n            \\n#             return True\\n        \\n#         ans = []\\n#         res = deque()\\n        \\n#         for n in range(left, right + 1):\\n#             if isPrime(n):\\n#                 res.append(n)\\n#                 if len(res) == 2:\\n#                     ans.append((res[1] - res[0],  res[0], res[1]))\\n#                     res.popleft()\\n        \\n#         ans.sort()\\n#         return (ans[0][1],ans[0][2]) if ans else [-1, -1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python []\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def solve(start, end):\\n            prime = [True for i in range(end + 1)] # initially mark all numbers as prime\\n            p = 2\\n            \\n            while(p * p <= end):\\n                if prime[p]:\\n                    for i in range(p * p, end + 1, p):\\n                        prime[i] = False # mark all multiples except for the first number as non-prime\\n                p += 1\\n            \\n            res = deque()\\n            ans = []\\n            \\n            for p in range(max(2, start), end + 1):\\n                if prime[p]:\\n                    res.append(p)\\n                    if len(res) == 2:\\n                        ans.append((res[1] - res[0],  res[0], res[1]))\\n                        res.popleft()\\n            ans.sort()\\n            return (ans[0][1],ans[0][2]) if ans else [-1, -1]\\n        \\n        return solve(left, right)\\n    \\n# class Solution: # TLE\\n#     def closestPrimes(self, left: int, right: int) -> List[int]:\\n#         def isPrime(n):\\n#             x = ceil(sqrt(n))\\n            \\n#             for i in range(2, x + 1):\\n#                 if n % i == 0: return False\\n            \\n#             return True\\n        \\n#         ans = []\\n#         res = deque()\\n        \\n#         for n in range(left, right + 1):\\n#             if isPrime(n):\\n#                 res.append(n)\\n#                 if len(res) == 2:\\n#                     ans.append((res[1] - res[0],  res[0], res[1]))\\n#                     res.popleft()\\n        \\n#         ans.sort()\\n#         return (ans[0][1],ans[0][2]) if ans else [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878818,
                "title": "simple-use-of-sieve-of-eratosthenes",
                "content": "# Intuition\\nAs we have to work with primes we will use the popular method for storing primes i.e SieveOfEratosthenes.\\n\\n# Approach\\nFirst calculate all the prime numbers between left and right with the SieveOfEratosthenes function. \\n\\nThen check whether there are at least 2 primes between left and right. If not then return {-1,-1}.\\n\\nIf yes then travel from right to left in the prime array and keep storing the minimum difference and the prime numbers corresponding to the difference.\\n\\nTraversing backwards in array will ensure that the numbers are minimum with the minimum difference.\\n\\n# Complexity\\n- Time complexity:\\nO(right * log(right) * log(right) )\\n\\n- Space complexity:\\nO(right-left)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void SieveOfEratosthenes(int n, vector<int> &p, int left){\\n        bool prime[n+1];\\n        memset(prime, true, sizeof(prime));\\n        for(int i=2; i*i<=n; i++){\\n            if(prime[i]){\\n                for(int j=i*i; j<=n; j+=i)\\n                    prime[j]=false;\\n            }\\n        }\\n\\n        for(int i=2; i<=n; i++){\\n            if(prime[i]){\\n                if(i>=left) p.push_back(i);\\n            }\\n        }\\n    }\\n\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> prime;\\n        SieveOfEratosthenes(right, prime, left);\\n        if(prime.size()<2) return {-1,-1};\\n        int n=prime.size();\\n        vector<int> res(3);\\n        res[0]=INT_MAX;\\n        res[1]=0;\\n        res[2]=0;\\n        for(int i=n-2; i>=0; i--){\\n            if(prime[i+1]-prime[i]<=res[0]){\\n                res[0]=prime[i+1]-prime[i];\\n                res[1]=prime[i];\\n                res[2]=prime[i+1];\\n            }\\n        }\\n        return {res[1], res[2]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void SieveOfEratosthenes(int n, vector<int> &p, int left){\\n        bool prime[n+1];\\n        memset(prime, true, sizeof(prime));\\n        for(int i=2; i*i<=n; i++){\\n            if(prime[i]){\\n                for(int j=i*i; j<=n; j+=i)\\n                    prime[j]=false;\\n            }\\n        }\\n\\n        for(int i=2; i<=n; i++){\\n            if(prime[i]){\\n                if(i>=left) p.push_back(i);\\n            }\\n        }\\n    }\\n\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> prime;\\n        SieveOfEratosthenes(right, prime, left);\\n        if(prime.size()<2) return {-1,-1};\\n        int n=prime.size();\\n        vector<int> res(3);\\n        res[0]=INT_MAX;\\n        res[1]=0;\\n        res[2]=0;\\n        for(int i=n-2; i>=0; i--){\\n            if(prime[i+1]-prime[i]<=res[0]){\\n                res[0]=prime[i+1]-prime[i];\\n                res[1]=prime[i];\\n                res[2]=prime[i+1];\\n            }\\n        }\\n        return {res[1], res[2]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376268,
                "title": "python-optimized-sieve",
                "content": "```\\n# Time: O(N*(log(N)) ^ 2)\\n# Space: O(N ^ 0.5)\\n\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        def find_all_primes(end):\\n            for index in range(2, end + 1):\\n                cur = index\\n                \\n                if is_prime[cur]:\\n                    while cur <= right:\\n                        is_prime[cur] = False\\n                        cur += index\\n                    is_prime[index] = True\\n                \\n        mx = right\\n        is_prime = [True for _ in range(mx + 1)]\\n        is_prime[0] = False\\n        is_prime[1] = False\\n        \\n        end = ceil(sqrt(mx)) # optimized sieve\\n        find_all_primes(end)\\n        \\n        res = []\\n        for val in range(left, right + 1):\\n            if is_prime[val]:\\n                res.append(val)\\n\\n        # record prime pairs and thier gaps\\n        distance = [float(\"inf\"), [0, 0]]\\n        if len(res) > 1:\\n            for index in range(1, len(res)):\\n                distance = min(distance, [(res[index] - res[index - 1]), [res[index - 1], res[index]]]) \\n        else:\\n            return [-1, -1]\\n        \\n        return [distance[1][0], distance[1][1]]                       \\n        \\n                               \\n                               \\n        \\n        \\n        \\n",
                "solutionTags": [],
                "code": "```\\n# Time: O(N*(log(N)) ^ 2)\\n# Space: O(N ^ 0.5)\\n\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        def find_all_primes(end):\\n            for index in range(2, end + 1):\\n                cur = index\\n                \\n                if is_prime[cur]:\\n                    while cur <= right:\\n                        is_prime[cur] = False\\n                        cur += index\\n                    is_prime[index] = True\\n                \\n        mx = right\\n        is_prime = [True for _ in range(mx + 1)]\\n        is_prime[0] = False\\n        is_prime[1] = False\\n        \\n        end = ceil(sqrt(mx)) # optimized sieve\\n        find_all_primes(end)\\n        \\n        res = []\\n        for val in range(left, right + 1):\\n            if is_prime[val]:\\n                res.append(val)\\n\\n        # record prime pairs and thier gaps\\n        distance = [float(\"inf\"), [0, 0]]\\n        if len(res) > 1:\\n            for index in range(1, len(res)):\\n                distance = min(distance, [(res[index] - res[index - 1]), [res[index - 1], res[index]]]) \\n        else:\\n            return [-1, -1]\\n        \\n        return [distance[1][0], distance[1][1]]                       \\n        \\n                               \\n                               \\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3150742,
                "title": "detailed-explanation-clean-code-easy-to-understand",
                "content": "# **Intuition:**\\nFirst off, lets understand why we need to check why we need to find all primes between left and right. The reason is that our answer may lie anywhere in that range. But we can be certain that the answer will be some pair of adjacent primes. This is because the difference has to be minimum and this will be true for adjacent primes.\\n# **Code Explaination:**\\nThe most optimum way of finding all primes between a given range is the seive of erasthones method. Others have done a good job explaining that so I won\\'t waste my time on that. So, our answer will be the pair of adjacent primes such that their difference is minimum.\\n# **Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool>prime(right+1,1);\\n        prime[1]=0;\\n        for(int i=2;i<=right;i++){\\n            if(prime[i]==1)\\n            {for(int j=i*2;j<=right;j+=i)prime[j]=0;}\\n        }\\n        int prev=-1;\\n        int val=INT_MAX;\\n        vector<int>ans{-1,-1};\\n        for(int i=left;i<=right;i++){\\n           if( prime[i]==1){\\n               if(prev==-1){\\n                  \\n               }else{\\n                   if(i-prev<val)\\n                  { val=i-prev;ans[0]=prev;ans[1]=i;}\\n               }\\n               prev=i;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool>prime(right+1,1);\\n        prime[1]=0;\\n        for(int i=2;i<=right;i++){\\n            if(prime[i]==1)\\n            {for(int j=i*2;j<=right;j+=i)prime[j]=0;}\\n        }\\n        int prev=-1;\\n        int val=INT_MAX;\\n        vector<int>ans{-1,-1};\\n        for(int i=left;i<=right;i++){\\n           if( prime[i]==1){\\n               if(prev==-1){\\n                  \\n               }else{\\n                   if(i-prev<val)\\n                  { val=i-prev;ans[0]=prev;ans[1]=i;}\\n               }\\n               prev=i;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089490,
                "title": "very-easy-java-easily-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n- O(N+1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean[]sieve(int n){\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++) prime[i] = true;\\n        for (int p=2;p*p<= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        return prime;\\n    }\\n    public int diff(int a,int b) {\\n        return b-a;\\n        }\\n    public int[] closestPrimes(int left, int right) {\\n        boolean []ans =sieve(right);\\n        ans[0]=false;\\n        ans[1]=false;\\n        int arr[] ={0,0};\\n        ArrayList<Integer> prime1=new ArrayList();\\n        for(int i=left;i<=right;i++){\\n            if(ans[i]) prime1.add(i);\\n        }\\n        if(prime1.size()<=1){\\n            int arrr[]={-1,-1};\\n            return arrr;\\n        }\\n        if(prime1.size()==2){\\n             int abc[]={prime1.get(0),prime1.get(1)};\\n             return abc;\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<prime1.size()-1;i++){\\n                if(diff(prime1.get(i),prime1.get(i+1))<min){\\n                    min=diff(prime1.get(i),prime1.get(i+1));\\n                    arr[0]=prime1.get(i);\\n                    arr[1]=prime1.get(i+1);\\n                }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean[]sieve(int n){\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++) prime[i] = true;\\n        for (int p=2;p*p<= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        return prime;\\n    }\\n    public int diff(int a,int b) {\\n        return b-a;\\n        }\\n    public int[] closestPrimes(int left, int right) {\\n        boolean []ans =sieve(right);\\n        ans[0]=false;\\n        ans[1]=false;\\n        int arr[] ={0,0};\\n        ArrayList<Integer> prime1=new ArrayList();\\n        for(int i=left;i<=right;i++){\\n            if(ans[i]) prime1.add(i);\\n        }\\n        if(prime1.size()<=1){\\n            int arrr[]={-1,-1};\\n            return arrr;\\n        }\\n        if(prime1.size()==2){\\n             int abc[]={prime1.get(0),prime1.get(1)};\\n             return abc;\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<prime1.size()-1;i++){\\n                if(diff(prime1.get(i),prime1.get(i+1))<min){\\n                    min=diff(prime1.get(i),prime1.get(i+1));\\n                    arr[0]=prime1.get(i);\\n                    arr[1]=prime1.get(i+1);\\n                }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068929,
                "title": "java-without-sieve",
                "content": "### [Twin prime](https://en.wikipedia.org/wiki/Twin_prime)\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        PrimePair primePair = new PrimePair(0, 0);\\n        for (int number = Math.max(2, left), lastPrime = 0; number <= right; ++number) {\\n            if (isPrime(number)) {\\n                if (lastPrime > 0 && number - lastPrime < primePair.difference()) {\\n                    primePair = new PrimePair(lastPrime, number);\\n\\n                    if (number - lastPrime <= 2)\\n                        return primePair.arrayRepresentation();\\n                }\\n\\n                lastPrime = number;\\n            }\\n        }\\n        return primePair.arrayRepresentation();\\n    }\\n\\n\\n    private boolean isPrime(int number) {\\n        for (int i = 2; i <= number / 2; ++i) {\\n            if (number % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n\\n    public record PrimePair(int first, int second) {\\n        private int difference() {\\n            return first == 0 ? Integer.MAX_VALUE : second - first;\\n        }\\n\\n        private int[] arrayRepresentation() {\\n            return first == 0 ? new int[]{-1, -1} : new int[]{first, second};\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        PrimePair primePair = new PrimePair(0, 0);\\n        for (int number = Math.max(2, left), lastPrime = 0; number <= right; ++number) {\\n            if (isPrime(number)) {\\n                if (lastPrime > 0 && number - lastPrime < primePair.difference()) {\\n                    primePair = new PrimePair(lastPrime, number);\\n\\n                    if (number - lastPrime <= 2)\\n                        return primePair.arrayRepresentation();\\n                }\\n\\n                lastPrime = number;\\n            }\\n        }\\n        return primePair.arrayRepresentation();\\n    }\\n\\n\\n    private boolean isPrime(int number) {\\n        for (int i = 2; i <= number / 2; ++i) {\\n            if (number % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n\\n    public record PrimePair(int first, int second) {\\n        private int difference() {\\n            return first == 0 ? Integer.MAX_VALUE : second - first;\\n        }\\n\\n        private int[] arrayRepresentation() {\\n            return first == 0 ? new int[]{-1, -1} : new int[]{first, second};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042173,
                "title": "python-badly-looking-but-working-fast",
                "content": "# Approach\\n0) To check if number is prime we just iterate over numbers up to $$sqrt(N)$$ and check if it divides target\\n1) We start with $$left$$ bound, check if it is $$prime$$. If yes - get next $$prime$$ number\\n2) Recalc answer on minimum $$diff$$\\n3) If we get $$diff$$ less than or equal $$2$$ - than stop iteration  \\n\\n# Complexity\\n- Time complexity: Much faster than $$O(Nlog(N))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfrom math import sqrt \\n\\n\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n\\n        def check_prime(num):\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n        \\n        ans, found = [-1, -1], False\\n        start, diff = left, 1e18\\n        while start < right + 1:\\n            if check_prime(start):\\n                for num2 in range(start + 1, right + 1):\\n                    if check_prime(num2):\\n                        found = True\\n                        break\\n                if found and 0 < num2 - start < diff and start > 1:\\n                    ans = [start, num2]\\n                    diff = num2 - start\\n                    start = num2\\n                else:\\n                    start += 1\\n            else:\\n                start += 1\\n            if 1 <= diff <= 2:\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nfrom math import sqrt \\n\\n\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n\\n        def check_prime(num):\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n        \\n        ans, found = [-1, -1], False\\n        start, diff = left, 1e18\\n        while start < right + 1:\\n            if check_prime(start):\\n                for num2 in range(start + 1, right + 1):\\n                    if check_prime(num2):\\n                        found = True\\n                        break\\n                if found and 0 < num2 - start < diff and start > 1:\\n                    ans = [start, num2]\\n                    diff = num2 - start\\n                    start = num2\\n                else:\\n                    start += 1\\n            else:\\n                start += 1\\n            if 1 <= diff <= 2:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036660,
                "title": "c-solution-sieve-of-eratosthenes-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        \\n        vector<bool> primes(right+1,1);\\n        primes[0]=0;\\n        primes[1]=0;\\n        for(int i=2;i*i<right+1;i++){\\n            if(primes[i]==true){  \\n                for(int j=i*i;j<right+1;j=j+i){\\n                    primes[j]=false;\\n                }\\n            }\\n        }\\n\\n        vector<int> ans,m;\\n        \\n        for(int i = left; i <= right; i++){\\n            if(primes[i]==true){\\n                ans.push_back(i);\\n            }\\n        }\\n \\n        if(ans.size()<=1)\\n            return{-1,-1};\\n\\n        int diff=INT_MAX;\\n        for(int i=1; i<ans.size(); i++){\\n            if(ans[i]-ans[i-1] < diff){\\n                diff = ans[i]-ans[i-1];\\n                m={ans[i-1],ans[i]};\\n            }\\n        } \\n        return m;   \\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        \\n        vector<bool> primes(right+1,1);\\n        primes[0]=0;\\n        primes[1]=0;\\n        for(int i=2;i*i<right+1;i++){\\n            if(primes[i]==true){  \\n                for(int j=i*i;j<right+1;j=j+i){\\n                    primes[j]=false;\\n                }\\n            }\\n        }\\n\\n        vector<int> ans,m;\\n        \\n        for(int i = left; i <= right; i++){\\n            if(primes[i]==true){\\n                ans.push_back(i);\\n            }\\n        }\\n \\n        if(ans.size()<=1)\\n            return{-1,-1};\\n\\n        int diff=INT_MAX;\\n        for(int i=1; i<ans.size(); i++){\\n            if(ans[i]-ans[i-1] < diff){\\n                diff = ans[i]-ans[i-1];\\n                m={ans[i-1],ans[i]};\\n            }\\n        } \\n        return m;   \\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990979,
                "title": "simple-c-solution-using-segmented-sieve",
                "content": "# Intuition\\nCalculate all the prime numbers in the given range and then found the pair having smallest difference.\\n\\nTo find the pair having smallest difference, sort the array(in this case array I calculated was already sorted) and then the smallest difference will be one of the differences among difference between adjacent elements.\\n\\nAlternate approach-Calculate all the prime numbers [1,1000000]  and then find the smallest difference between any pair in the given range.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed segmented sieve to calculate the prime numbers in the range [left, right]. And, then traverse the array of prime numbers to calculate the pair having minimum difference.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> closestPrimes(int left, int right)\\n\\t{\\n\\t\\tvector<bool> isPrime(right - left + 1, 1);\\n\\t\\tif (left == 1)\\n\\t\\t\\tisPrime[0] = 0;\\n\\t\\tfor (int j = 2; j * j <= right; j++)\\n\\t\\t{\\n\\t\\t\\tfor (int i = max(j * j, ((left + j - 1) / j) * j); i <= right; i += j)\\n\\t\\t\\t\\tisPrime[i - left] = 0;\\n\\t\\t}\\n\\t\\tvector<int> temp;\\n\\t\\tfor (int i = left; i <= right; i++)\\n\\t\\t{\\n\\t\\t\\tif (isPrime[i - left])\\n\\t\\t\\t\\ttemp.push_back(i);\\n\\t\\t}\\n\\t\\tint n = temp.size();\\n\\t\\tif (n <= 1)\\n\\t\\t\\treturn {-1, -1};\\n\\t\\tint dis = temp[1] - temp[0];\\n\\t\\tint x = temp[0], y = temp[1];\\n\\t\\tfor (int i = 2; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tint diff = temp[i] - temp[i - 1];\\n\\t\\t\\tif (dis > diff)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdis = diff;\\n\\t\\t\\t\\tx = temp[i - 1];\\n\\t\\t\\t\\ty = temp[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn {x, y};\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> closestPrimes(int left, int right)\\n\\t{\\n\\t\\tvector<bool> isPrime(right - left + 1, 1);\\n\\t\\tif (left == 1)\\n\\t\\t\\tisPrime[0] = 0;\\n\\t\\tfor (int j = 2; j * j <= right; j++)\\n\\t\\t{\\n\\t\\t\\tfor (int i = max(j * j, ((left + j - 1) / j) * j); i <= right; i += j)\\n\\t\\t\\t\\tisPrime[i - left] = 0;\\n\\t\\t}\\n\\t\\tvector<int> temp;\\n\\t\\tfor (int i = left; i <= right; i++)\\n\\t\\t{\\n\\t\\t\\tif (isPrime[i - left])\\n\\t\\t\\t\\ttemp.push_back(i);\\n\\t\\t}\\n\\t\\tint n = temp.size();\\n\\t\\tif (n <= 1)\\n\\t\\t\\treturn {-1, -1};\\n\\t\\tint dis = temp[1] - temp[0];\\n\\t\\tint x = temp[0], y = temp[1];\\n\\t\\tfor (int i = 2; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tint diff = temp[i] - temp[i - 1];\\n\\t\\t\\tif (dis > diff)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdis = diff;\\n\\t\\t\\t\\tx = temp[i - 1];\\n\\t\\t\\t\\ty = temp[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn {x, y};\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987307,
                "title": "c-using-sieve-of-eratosthenes-t-c-o-nlognlogn-s-c-o-n",
                "content": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\t T.C : O(NlogNlogN)\\n\\t\\t S.C. : O(N)\\n\\t*/\\n\\nprivate:\\n    vector<bool> prime;\\n    \\n    void sieveOfEratothenes(int n){\\n        for(int p=2; p*p<=n; p++){\\n            if(prime[p]){\\n                for(int i=p*p; i<=n; i+=p){\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        prime.resize(right+1, true);\\n        sieveOfEratothenes(right+1);\\n        \\n        prime[0] = 0;\\n        prime[1] = 0;\\n        \\n        vector<int> ans(2, -1);\\n        int prev = -1, res = INT_MAX;\\n        \\n        for(int i=left; i<=right; i++){\\n            if(prime[i]){\\n                if(prev == -1){\\n                    prev = i;\\n                }else if(i-prev < res){\\n                    ans[0] = prev;\\n                    ans[1] = i;\\n                    res = i-prev;\\n                }\\n                \\n                prev = i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\t T.C : O(NlogNlogN)\\n\\t\\t S.C. : O(N)\\n\\t*/\\n\\nprivate:\\n    vector<bool> prime;\\n    \\n    void sieveOfEratothenes(int n){\\n        for(int p=2; p*p<=n; p++){\\n            if(prime[p]){\\n                for(int i=p*p; i<=n; i+=p){\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        prime.resize(right+1, true);\\n        sieveOfEratothenes(right+1);\\n        \\n        prime[0] = 0;\\n        prime[1] = 0;\\n        \\n        vector<int> ans(2, -1);\\n        int prev = -1, res = INT_MAX;\\n        \\n        for(int i=left; i<=right; i++){\\n            if(prime[i]){\\n                if(prev == -1){\\n                    prev = i;\\n                }else if(i-prev < res){\\n                    ans[0] = prev;\\n                    ans[1] = i;\\n                    res = i-prev;\\n                }\\n                \\n                prev = i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987125,
                "title": "using-sieve-of-eratosthenes-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> ans(2,-1);\\n        if(left==right) return ans;\\n        vector<int> allPrimes;\\n        vector<bool> primes(right+1,true);\\n        primes[0]=false;\\n        primes[1]=false;\\n        for(int i=2;i<=right;i++)\\n        {\\n            if(primes[i])\\n            {\\n                if(i>=left) allPrimes.push_back(i);\\n                for (int j = 2 * i; j <=right; j = j + i)\\n                {\\n                    primes[j]=false;\\n                }\\n            }\\n        }\\n        \\n        int miniDiff=INT_MAX;\\n        for(int i=0;i<allPrimes.size()-1;i++)\\n        {\\n            int diff=allPrimes[i+1]-allPrimes[i];\\n            if(diff<miniDiff)\\n            {\\n                miniDiff=diff;\\n                ans[0]=allPrimes[i];\\n                ans[1]=allPrimes[i+1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> ans(2,-1);\\n        if(left==right) return ans;\\n        vector<int> allPrimes;\\n        vector<bool> primes(right+1,true);\\n        primes[0]=false;\\n        primes[1]=false;\\n        for(int i=2;i<=right;i++)\\n        {\\n            if(primes[i])\\n            {\\n                if(i>=left) allPrimes.push_back(i);\\n                for (int j = 2 * i; j <=right; j = j + i)\\n                {\\n                    primes[j]=false;\\n                }\\n            }\\n        }\\n        \\n        int miniDiff=INT_MAX;\\n        for(int i=0;i<allPrimes.size()-1;i++)\\n        {\\n            int diff=allPrimes[i+1]-allPrimes[i];\\n            if(diff<miniDiff)\\n            {\\n                miniDiff=diff;\\n                ans[0]=allPrimes[i];\\n                ans[1]=allPrimes[i+1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986523,
                "title": "c-easy-approach-sieve-of-eratosthenes",
                "content": "# Intuition\\nusing Sieve of Eratosthenes Approach\\n\\n# Approach\\n\\n1-> mark all prime numbers using Sieve of Eratosthenes approach\\n2-> Iterate through numbers and find the prime numbers such that difference is minimum\\n\\n# Complexity\\n- Time complexity:\\nTime to create Sieve of Eratosthenes (only once) + \\u03C0(n) for each operation\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvector<bool>v(1000002,1);\\nclass Solution {\\npublic:\\n    void solve(){\\n        v[1]=false;\\n        for(int i=2;i<=sqrt(1000001);i++){\\n            if(v[i]){\\n                for(int j=i*2;j<=1000001;j+=i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> closestPrimes(int left, int right) {\\n        static int i=0;\\n        \\n        if(i==0){\\n            solve();\\n            i++;\\n        }\\n        int cnt=0,a=-1,b,diff=INT_MAX,p=-1,q=-1;\\n        for(int i=left;i<=right;i++){\\n            if(v[i]==1 && a==-1){\\n                a=i;\\n            }\\n            else if(v[i]==1){\\n                b = i;\\n                if((b-a) < diff){\\n                    p=a,q=b;\\n                    diff = q-p;\\n                }\\n                a=b;\\n            }\\n        }\\n        vector<int> ans;\\n        ans.push_back(p);\\n        ans.push_back(q);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<bool>v(1000002,1);\\nclass Solution {\\npublic:\\n    void solve(){\\n        v[1]=false;\\n        for(int i=2;i<=sqrt(1000001);i++){\\n            if(v[i]){\\n                for(int j=i*2;j<=1000001;j+=i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> closestPrimes(int left, int right) {\\n        static int i=0;\\n        \\n        if(i==0){\\n            solve();\\n            i++;\\n        }\\n        int cnt=0,a=-1,b,diff=INT_MAX,p=-1,q=-1;\\n        for(int i=left;i<=right;i++){\\n            if(v[i]==1 && a==-1){\\n                a=i;\\n            }\\n            else if(v[i]==1){\\n                b = i;\\n                if((b-a) < diff){\\n                    p=a,q=b;\\n                    diff = q-p;\\n                }\\n                a=b;\\n            }\\n        }\\n        vector<int> ans;\\n        ans.push_back(p);\\n        ans.push_back(q);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982147,
                "title": "sieveoferatosthenes-sliding-window-python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        def sieve(n):\\n            prime = [True] * (n+1)\\n            for i in range(2, n//2):\\n                if prime[i]:\\n                    for jj in range(2*i, n+1, i):\\n                        prime[jj] = False\\n            return [i for i in range(2, n+1) if prime[i]]\\n        \\n        primes = sieve(right)\\n        inRange = False\\n        minDiff = float(\"inf\")\\n        ans = [-1, -1]\\n        \\n        for ind in range(0, len(primes)-1):\\n            if not inRange:\\n                if primes[ind] >= left:\\n                    inRange = True\\n                    \\n            if inRange:\\n                l = primes[ind]\\n                r = primes[ind+1]\\n                if (r-l) < minDiff:\\n                    minDiff = r-l\\n                    ans = [l, r]\\n        return ans\\n                \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        def sieve(n):\\n            prime = [True] * (n+1)\\n            for i in range(2, n//2):\\n                if prime[i]:\\n                    for jj in range(2*i, n+1, i):\\n                        prime[jj] = False\\n            return [i for i in range(2, n+1) if prime[i]]\\n        \\n        primes = sieve(right)\\n        inRange = False\\n        minDiff = float(\"inf\")\\n        ans = [-1, -1]\\n        \\n        for ind in range(0, len(primes)-1):\\n            if not inRange:\\n                if primes[ind] >= left:\\n                    inRange = True\\n                    \\n            if inRange:\\n                l = primes[ind]\\n                r = primes[ind+1]\\n                if (r-l) < minDiff:\\n                    minDiff = r-l\\n                    ans = [l, r]\\n        return ans\\n                \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981809,
                "title": "clean-simple-javascript-solution",
                "content": "# Code\\n```\\nvar closestPrimes = function(left, right) {\\n    let primeArr = [];\\n    let res = [-1, -1];\\n    let minDiff = Infinity;\\n\\n    for(let i=left; i<=right; i++){\\n        if(isPrime(i)) primeArr.push(i)\\n    }\\n\\n    for(let i=1; i<primeArr.length; i++){\\n        let diff = primeArr[i]-primeArr[i-1];\\n        if(diff<minDiff){\\n            res = [primeArr[i-1], primeArr[i]]\\n            minDiff = diff;\\n        }\\n    }\\n    return res\\n\\n};\\n\\nfunction isPrime(n) {\\n    if (n === 1) return false;\\n    if (n % 2 === 0) return n === 2;\\n    let max = Math.floor(Math.sqrt(n)) ;\\n    for(let i = 3; i <= max; i += 2) {\\n        if (n % i === 0) return false;\\n    }\\n    return true;\\n}\\n```\\n## Please upvote.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar closestPrimes = function(left, right) {\\n    let primeArr = [];\\n    let res = [-1, -1];\\n    let minDiff = Infinity;\\n\\n    for(let i=left; i<=right; i++){\\n        if(isPrime(i)) primeArr.push(i)\\n    }\\n\\n    for(let i=1; i<primeArr.length; i++){\\n        let diff = primeArr[i]-primeArr[i-1];\\n        if(diff<minDiff){\\n            res = [primeArr[i-1], primeArr[i]]\\n            minDiff = diff;\\n        }\\n    }\\n    return res\\n\\n};\\n\\nfunction isPrime(n) {\\n    if (n === 1) return false;\\n    if (n % 2 === 0) return n === 2;\\n    let max = Math.floor(Math.sqrt(n)) ;\\n    for(let i = 3; i <= max; i += 2) {\\n        if (n % i === 0) return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2980163,
                "title": "javascript-neat-eratosthenes-fast-generator",
                "content": "\\n```js\\nconst closestPrimes = function(left, right) {\\n    const primes = eratosthenes(right + 1)\\n    let minDiff = Infinity, min = [-1, -1], prev\\n    for (const p of primes) {\\n        if (left <= prev && p - prev < minDiff)\\n            minDiff = p - prev,\\n            min = [prev, p]\\n        prev = p\\n    }\\n    return min \\n}\\n\\nfunction* eratosthenes(n) {\\n    if (2 < n) yield 2\\n    const sieve = Array(n).fill(true)\\n    for (let x = 3; x < n; x += 2)\\n        if (sieve[x]) {\\n            yield x\\n            for (let p = x**2, x2 = 2 * x; p < n; p += x2)\\n                sieve[p] = false\\n        }\\n}\\n```\\nRuntime 388 ms",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst closestPrimes = function(left, right) {\\n    const primes = eratosthenes(right + 1)\\n    let minDiff = Infinity, min = [-1, -1], prev\\n    for (const p of primes) {\\n        if (left <= prev && p - prev < minDiff)\\n            minDiff = p - prev,\\n            min = [prev, p]\\n        prev = p\\n    }\\n    return min \\n}\\n\\nfunction* eratosthenes(n) {\\n    if (2 < n) yield 2\\n    const sieve = Array(n).fill(true)\\n    for (let x = 3; x < n; x += 2)\\n        if (sieve[x]) {\\n            yield x\\n            for (let p = x**2, x2 = 2 * x; p < n; p += x2)\\n                sieve[p] = false\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2979394,
                "title": "c-solution-using-seive-of-eratosthenes",
                "content": "# Intuition\\nSieve of eratosthenes is used to store primes range of left and right is between 1 to 10^6  so we can just store the primes in the vector and check for the element between the left and right .. if there is 1 or less element between left and right return -1,-1 else check for the distance of each pair for least difference\\n\\n# Approach\\nApproch of Sieve is make  array of range 10^6 a boolean array make all true\\nnow   for element i= 2 to  root(10^6) iterate  for 2nd loop if(arr[i]==false;)  starting j= i*i to 10^6 upadate j+=i make all them arr[j] to false coz they have a divisor that is i \\nwe can store all there primes which remain true\\n\\nand then extract the ones which are left and right\\n\\nand check for the minimum difference\\n\\n# Complexity\\n- Time complexity:O(n*log(log(n))+n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n\\nbool ar[1000001];\\nvoid sieve()\\n{\\n\\n  int maxn = 1000000;\\n  ar[0] = ar[1] = true;\\n\\n  for (int i = 2; i * i <= maxn; i++)\\n  {\\n    if (ar[i] == false)\\n    {\\n      for (int j = i * i; j <= maxn; j += i)\\n      {\\n        ar[j] = true;\\n      }\\n    }\\n  }\\n  for (int i = 2; i <= maxn; i++)\\n  {\\n    if (ar[i] == false)\\n      primes.push_back(i);\\n  }\\n}\\n    vector<int> closestPrimes(int left, int right) {\\n        \\n        sieve();\\n        vector<int>v;\\n        for(auto x:primes){\\n            if(x>=left&&x<=right){v.push_back(x);}\\n        }\\n        vector<int>ans;\\n        if(v.size()<=1){\\n              ans.push_back(-1);ans.push_back(-1);\\n        }\\n        else{\\n            int m=1000000;\\n            int a,b;\\n            for(int i=1;i<v.size();i++){\\n                  if(v[i]-v[i-1]<m){\\n                      m=v[i]-v[i-1];\\n                      a=v[i-1]; b=v[i];\\n                  }\\n            }\\n              ans.push_back(a);ans.push_back(b);\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n\\nbool ar[1000001];\\nvoid sieve()\\n{\\n\\n  int maxn = 1000000;\\n  ar[0] = ar[1] = true;\\n\\n  for (int i = 2; i * i <= maxn; i++)\\n  {\\n    if (ar[i] == false)\\n    {\\n      for (int j = i * i; j <= maxn; j += i)\\n      {\\n        ar[j] = true;\\n      }\\n    }\\n  }\\n  for (int i = 2; i <= maxn; i++)\\n  {\\n    if (ar[i] == false)\\n      primes.push_back(i);\\n  }\\n}\\n    vector<int> closestPrimes(int left, int right) {\\n        \\n        sieve();\\n        vector<int>v;\\n        for(auto x:primes){\\n            if(x>=left&&x<=right){v.push_back(x);}\\n        }\\n        vector<int>ans;\\n        if(v.size()<=1){\\n              ans.push_back(-1);ans.push_back(-1);\\n        }\\n        else{\\n            int m=1000000;\\n            int a,b;\\n            for(int i=1;i<v.size();i++){\\n                  if(v[i]-v[i-1]<m){\\n                      m=v[i]-v[i-1];\\n                      a=v[i-1]; b=v[i];\\n                  }\\n            }\\n              ans.push_back(a);ans.push_back(b);\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979380,
                "title": "c-in-o-n-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst we make vector to identify prime and non prime numbers....then the ones which are prime are worked upon.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>closestPrimes(int left, int right) \\n    {\\n        if(left==right)\\n        {\\n            return {-1,-1};\\n        }\\n        vector<int>isprime(right+1,1);\\n        int i,j,recent,count=0,Mindiff=right-left;\\n        for(i=2;i<isprime.size();i++)\\n        {\\n            if(isprime[i]==0)\\n            {\\n                continue;\\n            }\\n            j=2*i;           \\n            while(j<=right)\\n            {\\n                isprime[j]=0;\\n                j+=i;\\n            }\\n        }\\n        unordered_map<int,vector<vector<int>>>vectorwithdiff;\\n        bool assigned=false;\\n        if(left==1)\\n        {\\n            left++;\\n        }\\n        for(i=left;i<=right;i++)\\n        {\\n            if(isprime[i])\\n            {\\n                if(!assigned)\\n                {\\n                    recent=i;\\n                    assigned=true;\\n                }\\n                count++;\\n            }\\n        }\\n        if(count<2)\\n        {\\n            return {-1,-1};\\n        }\\n        for(i=recent+1;i<=right;i++)\\n        {\\n            if(isprime[i])\\n            {\\n                vectorwithdiff[i-recent].push_back({recent,i});\\n                recent=i;\\n            }\\n        }\\n        for(auto j:vectorwithdiff)\\n        {\\n            Mindiff=min(Mindiff,j.first);\\n        }\\n        return vectorwithdiff[Mindiff][0];\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>closestPrimes(int left, int right) \\n    {\\n        if(left==right)\\n        {\\n            return {-1,-1};\\n        }\\n        vector<int>isprime(right+1,1);\\n        int i,j,recent,count=0,Mindiff=right-left;\\n        for(i=2;i<isprime.size();i++)\\n        {\\n            if(isprime[i]==0)\\n            {\\n                continue;\\n            }\\n            j=2*i;           \\n            while(j<=right)\\n            {\\n                isprime[j]=0;\\n                j+=i;\\n            }\\n        }\\n        unordered_map<int,vector<vector<int>>>vectorwithdiff;\\n        bool assigned=false;\\n        if(left==1)\\n        {\\n            left++;\\n        }\\n        for(i=left;i<=right;i++)\\n        {\\n            if(isprime[i])\\n            {\\n                if(!assigned)\\n                {\\n                    recent=i;\\n                    assigned=true;\\n                }\\n                count++;\\n            }\\n        }\\n        if(count<2)\\n        {\\n            return {-1,-1};\\n        }\\n        for(i=recent+1;i<=right;i++)\\n        {\\n            if(isprime[i])\\n            {\\n                vectorwithdiff[i-recent].push_back({recent,i});\\n                recent=i;\\n            }\\n        }\\n        for(auto j:vectorwithdiff)\\n        {\\n            Mindiff=min(Mindiff,j.first);\\n        }\\n        return vectorwithdiff[Mindiff][0];\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979196,
                "title": "c-begineers-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n     bool isprime(int n)\\n    {\\n        if (n <= 1)\\n            return false;\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n       return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n       vector<int>primes,ans={-1,-1};\\n        for(int i=left;i<=right;i++){\\n            if(isprime(i))primes.push_back(i);\\n        }\\n     if(primes.size()==1||primes.empty())return ans;\\n      int min=INT_MAX,minIndex=1;\\n      for(int i=1;i<primes.size();i++){\\n          if(primes[i]-primes[i-1]<min){\\n             min=primes[i]-primes[i-1];\\n             minIndex=i;\\n          }\\n      }\\n     ans[0]=primes[minIndex-1];\\n     ans[1]=primes[minIndex];   \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isprime(int n)\\n    {\\n        if (n <= 1)\\n            return false;\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n       return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n       vector<int>primes,ans={-1,-1};\\n        for(int i=left;i<=right;i++){\\n            if(isprime(i))primes.push_back(i);\\n        }\\n     if(primes.size()==1||primes.empty())return ans;\\n      int min=INT_MAX,minIndex=1;\\n      for(int i=1;i<primes.size();i++){\\n          if(primes[i]-primes[i-1]<min){\\n             min=primes[i]-primes[i-1];\\n             minIndex=i;\\n          }\\n      }\\n     ans[0]=primes[minIndex-1];\\n     ans[1]=primes[minIndex];   \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979099,
                "title": "brute-force-approach-but-terminate-if-you-find-a-pair-of-primes-whose-difference-is-two",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you look at the list of primes, you will notice that there\\nare many pairs of primes whose difference is two. \\n\\nFor example (3,5),(11,13),(101,103),....\\n\\nA pair of primes whose difference is two is called a twin prime.\\nIf you are given a table of primes, you\\'ll probably find a twin prime, even if the primes get big.\\n\\nI also knew that whether there are infinitely many twin primes is still unsolved. Thus, I thought there may be a lot of twin primes. The larger the difference between right and left, the more likely we will find a twin pair.\\n\\nThus, I simply searched all primes from left to right, keep track of the diff, and check if it is minimal; a brute force approach. However, if I find a twin prime, terminate. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe only time the difference between two primes equals one is (2,3). Handle this edge case first. Then brute force as written above.\\n\\n# Notes\\n\\nI realize this approach just worked luckily; If n=right-left, the time complexity is O(n sqrt(n)) which generally causes TLE. Moreover, I don\\'t know if there is a mathematical theorem that gives info about how frequently twin primes appear. It just so worked.\\n\\nHowever, I wanted to share it because I haven\\'t used complex algorithms.\\n\\nHave a nice day!\\n\\n# Complexity\\nIf n = right - left,\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case: O(n * sqrt(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        if (left == 1 and right >=3): return [2,3]\\n        if (left ==2 and right >=3): return[2,3]\\n        if (left == 1 and right <=2):return [-1,-1]\\n        if (left == right): return [-1,-1]\\n        def isPrime(n):\\n            if (n==2): return True\\n            sq = int(math.sqrt(n))+1\\n            for i in range(2,sq):\\n                if (n %i == 0): return False\\n            return True\\n\\n        primes = []\\n        minDiff = 99999999999999999999\\n        output = [-1,-1]\\n        \\n        for i in range(left,right+1):\\n            if (isPrime(i) == True):\\n                primes.append(i)\\n                if (len(primes)>1):\\n                    d = i - primes[-2]\\n                    if (d==2):\\n                        return [primes[-2],i]\\n                    else:\\n                        if (d < minDiff):\\n                            minDiff = d\\n                            output[0] = primes[-2]\\n                            output[1] = primes[-1]\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        if (left == 1 and right >=3): return [2,3]\\n        if (left ==2 and right >=3): return[2,3]\\n        if (left == 1 and right <=2):return [-1,-1]\\n        if (left == right): return [-1,-1]\\n        def isPrime(n):\\n            if (n==2): return True\\n            sq = int(math.sqrt(n))+1\\n            for i in range(2,sq):\\n                if (n %i == 0): return False\\n            return True\\n\\n        primes = []\\n        minDiff = 99999999999999999999\\n        output = [-1,-1]\\n        \\n        for i in range(left,right+1):\\n            if (isPrime(i) == True):\\n                primes.append(i)\\n                if (len(primes)>1):\\n                    d = i - primes[-2]\\n                    if (d==2):\\n                        return [primes[-2],i]\\n                    else:\\n                        if (d < minDiff):\\n                            minDiff = d\\n                            output[0] = primes[-2]\\n                            output[1] = primes[-1]\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979048,
                "title": "faster-c-sieve-of-eratosthenes-approach-simple-clean-code",
                "content": "```\\nclass Solution {\\n    \\n//template for Sieve of Eratosthenes\\nint n;\\nvector<bool> prime;\\n  void sieve(int n)\\n  {\\n      prime[0] = prime[1] = false;  \\n      for(int i = 2; i <= n; i++) \\n      {   \\n          if (prime[i] && (long long)i * i <= n)\\n          {\\n              for(int j = i * i; j <= n; j += i) prime[j] = false;\\n          }\\n      }\\n  }\\n    \\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        prime.resize(right+1, true);\\n        sieve(right+1);\\n        int prev = -1, curr = -1;\\n        vector<int> ans = {-1,-1};\\n        int mini = INT_MAX;\\n        for(int i=left; i<=right; i++)\\n        {\\n            if(prime[i] == 1)\\n            {\\n                if(curr == -1) curr = i;\\n                else{\\n                    prev = curr;\\n                    curr = i;\\n                    if(curr-prev < mini)\\n                    {\\n                        ans = {prev, curr};\\n                        mini = curr-prev;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n//template for Sieve of Eratosthenes\\nint n;\\nvector<bool> prime;\\n  void sieve(int n)\\n  {\\n      prime[0] = prime[1] = false;  \\n      for(int i = 2; i <= n; i++) \\n      {   \\n          if (prime[i] && (long long)i * i <= n)\\n          {\\n              for(int j = i * i; j <= n; j += i) prime[j] = false;\\n          }\\n      }\\n  }\\n    \\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        prime.resize(right+1, true);\\n        sieve(right+1);\\n        int prev = -1, curr = -1;\\n        vector<int> ans = {-1,-1};\\n        int mini = INT_MAX;\\n        for(int i=left; i<=right; i++)\\n        {\\n            if(prime[i] == 1)\\n            {\\n                if(curr == -1) curr = i;\\n                else{\\n                    prev = curr;\\n                    curr = i;\\n                    if(curr-prev < mini)\\n                    {\\n                        ans = {prev, curr};\\n                        mini = curr-prev;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978336,
                "title": "easy-and-simple-c-solution",
                "content": "```\\nclass Solution {\\n\\tconst static int n = 1e6;\\n    bool prime[1000001];\\n\\tvoid SieveOfEratosthenes()\\n\\t{\\n\\t\\tmemset(prime, true, sizeof(prime));\\n        prime[1] = prime[0] = false;\\n\\t\\tfor (int p = 2; p * p <= n; p++) {\\n\\t\\t\\tif (prime[p] == true) {\\n\\t\\t\\t\\tfor (int i = p * p; i <= n; i += p)\\n\\t\\t\\t\\t\\tprime[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<int> closestPrimes(int left, int right) {\\n        vector<int> res(2, -1), ans;\\n        SieveOfEratosthenes();\\n        int k = 0;\\n        \\n        for (int i = left; i <= right; ++i) {\\n            if (prime[i]) ans.push_back(i);\\n        }\\n        \\n        if (ans.size() == 1) return {-1, -1};\\n        int n = ans.size(), mn = INT_MAX;\\n        for (int i = 1; i < n; ++i) {\\n            int mm = ans[i] - ans[i - 1];\\n            if (mn > mm) {\\n                res[0] = ans[i - 1];\\n                res[1] = ans[i];\\n                mn = mm;\\n            }\\n        }\\n        return res;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n\\tconst static int n = 1e6;\\n    bool prime[1000001];\\n\\tvoid SieveOfEratosthenes()\\n\\t{\\n\\t\\tmemset(prime, true, sizeof(prime));\\n        prime[1] = prime[0] = false;\\n\\t\\tfor (int p = 2; p * p <= n; p++) {\\n\\t\\t\\tif (prime[p] == true) {\\n\\t\\t\\t\\tfor (int i = p * p; i <= n; i += p)\\n\\t\\t\\t\\t\\tprime[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n\\tvector<int> closestPrimes(int left, int right) {\\n        vector<int> res(2, -1), ans;\\n        SieveOfEratosthenes();\\n        int k = 0;\\n        \\n        for (int i = left; i <= right; ++i) {\\n            if (prime[i]) ans.push_back(i);\\n        }\\n        \\n        if (ans.size() == 1) return {-1, -1};\\n        int n = ans.size(), mn = INT_MAX;\\n        for (int i = 1; i < n; ++i) {\\n            int mm = ans[i] - ans[i - 1];\\n            if (mn > mm) {\\n                res[0] = ans[i - 1];\\n                res[1] = ans[i];\\n                mn = mm;\\n            }\\n        }\\n        return res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978016,
                "title": "optimized-solution",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> closestPrimes(int left, int right)\\n    {\\n        int i, j;\\n        vector<int> v;\\n        if (left <= 2)\\n        {\\n            left = 2;\\n            if (right >= 2)\\n            {\\n                v.push_back(left);\\n                left++;\\n            }\\n        }\\n        if (left % 2 == 0)\\n            left++;\\n        for (i = left; i <= right; i = i + 2)\\n        {\\n            bool flag = 1;\\n            for (j = 2; j * j <= i; ++j)\\n            {\\n                if (i % j == 0)\\n                {\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n            if (flag == 1)\\n            {\\n                if (i == 1)\\n                    continue;\\n                else\\n                    v.push_back(i);\\n            }\\n        }\\n        if (v.size() <= 1)\\n        {\\n            return {-1, -1};\\n        }\\n        int mini=INT_MAX;\\n        int num1,num2;\\n        for (int i = 1; i < v.size(); i++)\\n        {\\n            int sub = v[i] - v[i - 1];\\n            if(sub<mini){\\n                mini=sub;\\n                num1=v[i-1];\\n                num2=v[i];\\n            }\\n        }\\n        return {num1,num2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> closestPrimes(int left, int right)\\n    {\\n        int i, j;\\n        vector<int> v;\\n        if (left <= 2)\\n        {\\n            left = 2;\\n            if (right >= 2)\\n            {\\n                v.push_back(left);\\n                left++;\\n            }\\n        }\\n        if (left % 2 == 0)\\n            left++;\\n        for (i = left; i <= right; i = i + 2)\\n        {\\n            bool flag = 1;\\n            for (j = 2; j * j <= i; ++j)\\n            {\\n                if (i % j == 0)\\n                {\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n            if (flag == 1)\\n            {\\n                if (i == 1)\\n                    continue;\\n                else\\n                    v.push_back(i);\\n            }\\n        }\\n        if (v.size() <= 1)\\n        {\\n            return {-1, -1};\\n        }\\n        int mini=INT_MAX;\\n        int num1,num2;\\n        for (int i = 1; i < v.size(); i++)\\n        {\\n            int sub = v[i] - v[i - 1];\\n            if(sub<mini){\\n                mini=sub;\\n                num1=v[i-1];\\n                num2=v[i];\\n            }\\n        }\\n        return {num1,num2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977801,
                "title": "java-sieve-of-eratosthenes",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    private List<Integer> primes = new ArrayList<>();\\n    public int[] closestPrimes(int left, int right) {\\n        sieve(left, right);\\n        int a = -1, b = -1;\\n        int minDiff = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i < primes.size(); i++) {\\n            int currDiff = primes.get(i) - primes.get(i-1);\\n            if (minDiff > currDiff) {\\n                minDiff = currDiff;\\n                a = primes.get(i-1);\\n                b = primes.get(i);\\n            }\\n        }\\n        \\n        return new int[] {a, b};\\n    }\\n    \\n    private void sieve(int l, int r) {\\n        boolean[] p = new boolean[r+1];\\n        Arrays.fill(p, true);\\n        \\n        for (int i = 2; i * i <= r; i++) {\\n            if (!p[i]) continue;\\n            for (int j = 2 * i; j <= r; j += i) {\\n                p[j] = false;\\n            }\\n        }\\n        p[0] = p[1] = false;\\n        \\n        // adding the primes only within the given range\\n        for (int i = l; i <= r; i++) {\\n            if (p[i]) primes.add(i);\\n        }\\n    }\\n}\\n\\n\\n// TC: O(right * log(log(right)) + O(right - left)\\n// SC: O(right) + O(right - left)\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Number Theory"
                ],
                "code": "``` java []\\nclass Solution {\\n    private List<Integer> primes = new ArrayList<>();\\n    public int[] closestPrimes(int left, int right) {\\n        sieve(left, right);\\n        int a = -1, b = -1;\\n        int minDiff = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i < primes.size(); i++) {\\n            int currDiff = primes.get(i) - primes.get(i-1);\\n            if (minDiff > currDiff) {\\n                minDiff = currDiff;\\n                a = primes.get(i-1);\\n                b = primes.get(i);\\n            }\\n        }\\n        \\n        return new int[] {a, b};\\n    }\\n    \\n    private void sieve(int l, int r) {\\n        boolean[] p = new boolean[r+1];\\n        Arrays.fill(p, true);\\n        \\n        for (int i = 2; i * i <= r; i++) {\\n            if (!p[i]) continue;\\n            for (int j = 2 * i; j <= r; j += i) {\\n                p[j] = false;\\n            }\\n        }\\n        p[0] = p[1] = false;\\n        \\n        // adding the primes only within the given range\\n        for (int i = l; i <= r; i++) {\\n            if (p[i]) primes.add(i);\\n        }\\n    }\\n}\\n\\n\\n// TC: O(right * log(log(right)) + O(right - left)\\n// SC: O(right) + O(right - left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977479,
                "title": "o-n-log-log-n-tc-using-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSieve of Eratosthenes to get primes between left and right\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind all primes between left and right, all inclusive. If lenght is less than 2, it is not possible. Else find two adjacent primes that have the smallest difference.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(log(n))) to get the sieve + O(n) -> O(nlog(log(n)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) with n being right. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> prime(right+1,1);\\n        prime[1]=0;\\n        vector<int> pos;\\n        for (long i=2; i<=right; i++){\\n            if (prime[i]){\\n                if (i>=left) pos.push_back(i);\\n                for (long long j=i*i; j<=right; j+=i){\\n                    prime[j]=0;\\n                }\\n            }\\n        }\\n        if (pos.size() < 2) return {-1,-1};\\n        int l=pos[0], r=pos[1];\\n        for (int i=2; i<pos.size(); i++){\\n            if (pos[i]-pos[i-1] < r-l){\\n                r=pos[i];\\n                l=pos[i-1];\\n            }\\n        }\\n        return {l,r};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> prime(right+1,1);\\n        prime[1]=0;\\n        vector<int> pos;\\n        for (long i=2; i<=right; i++){\\n            if (prime[i]){\\n                if (i>=left) pos.push_back(i);\\n                for (long long j=i*i; j<=right; j+=i){\\n                    prime[j]=0;\\n                }\\n            }\\n        }\\n        if (pos.size() < 2) return {-1,-1};\\n        int l=pos[0], r=pos[1];\\n        for (int i=2; i<pos.size(); i++){\\n            if (pos[i]-pos[i-1] < r-l){\\n                r=pos[i];\\n                l=pos[i-1];\\n            }\\n        }\\n        return {l,r};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977448,
                "title": "prime-number-in-range-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool is_primeNum(int a)\\n    {\\n        if(a == 1)\\n            return false;\\n        if(a == 2 || a == 3)\\n            return true;\\n        for(int i=2; i*i<=a; i++)\\n        {\\n            if(a % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> closestPrimes(int left, int right) {\\n         int ans = right - left+1;\\n        vector<int> v(2, 0);\\n        for(int i=left; i<=right-1; i++)\\n        {\\n            if(is_primeNum(i))\\n            {\\n                for(int j=i+1; j<=right; j++)\\n                {\\n                    if(is_primeNum(j))\\n                    {\\n                        if((j - i) < ans)\\n                        {\\n                            ans = j-i;\\n                            v[0] = i;\\n                            v[1] = j;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n            if(ans == 2 && v[0] != 0 && v[1] != 0)\\n                return v;\\n        }\\n        if(ans == (right - left + 1) && (!is_primeNum(left) || !is_primeNum(right)))\\n            return vector<int>{-1, -1};\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool is_primeNum(int a)\\n    {\\n        if(a == 1)\\n            return false;\\n        if(a == 2 || a == 3)\\n            return true;\\n        for(int i=2; i*i<=a; i++)\\n        {\\n            if(a % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> closestPrimes(int left, int right) {\\n         int ans = right - left+1;\\n        vector<int> v(2, 0);\\n        for(int i=left; i<=right-1; i++)\\n        {\\n            if(is_primeNum(i))\\n            {\\n                for(int j=i+1; j<=right; j++)\\n                {\\n                    if(is_primeNum(j))\\n                    {\\n                        if((j - i) < ans)\\n                        {\\n                            ans = j-i;\\n                            v[0] = i;\\n                            v[1] = j;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n            if(ans == 2 && v[0] != 0 && v[1] != 0)\\n                return v;\\n        }\\n        if(ans == (right - left + 1) && (!is_primeNum(left) || !is_primeNum(right)))\\n            return vector<int>{-1, -1};\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977432,
                "title": "how-to-optimize-more-than-this",
                "content": "Fortunately, with 3 check, we could take care of the edge cases so that firstly, we could return the answer immidiately if any of them is true and secondly, reach the final answer more efficiently if they are not true.\\n\\n# Complexity\\n- Time complexity:\\nGuess!\\n\\n- Space complexity:\\nO(right)\\n\\n# Code\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977412,
                "title": "c-prime-number-in-the-range-left-to-right",
                "content": "```\\n#define LIMIT 1000001\\nlong long prime_flag[LIMIT];\\n\\nvoid calculatePrime()\\n{\\n    prime_flag[0] = prime_flag[1] = 1;\\n    for (long long i = 2; i < LIMIT; i++)\\n    {\\n        if (prime_flag[i] == 0)\\n        {\\n            for (long long j = i * i; j < LIMIT; j += i)\\n            {\\n                prime_flag[j] = 1;\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        calculatePrime();\\n        \\n        int ans1=-1, ans2=-1;\\n        \\n        int res1=-1,res2=-1;\\n        \\n        int minNum=INT_MAX;\\n        \\n        for(int i=left; i<=right; i++)\\n        {\\n            if(prime_flag[i] == 0)\\n            {\\n                if(ans1 == -1)\\n                    ans1=i;\\n                else if(ans2 == -1) \\n                {\\n                    ans2=i;\\n                    minNum=ans2-ans1;\\n                    res1=ans1;\\n                    res2=ans2;\\n                }\\n                \\n                if(ans1!=-1 && ans2!=-1)\\n                {\\n                    if(ans2 < i)\\n                    {\\n                        ans1=ans2;\\n                        ans2=i;\\n                    }\\n                    if(minNum > (ans2-ans1))\\n                    {\\n                        res1=ans1;\\n                        res2=ans2;\\n                        minNum=(ans2-ans1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(minNum == INT_MAX)\\n            return {-1,-1};\\n        \\n        return {res1,res2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define LIMIT 1000001\\nlong long prime_flag[LIMIT];\\n\\nvoid calculatePrime()\\n{\\n    prime_flag[0] = prime_flag[1] = 1;\\n    for (long long i = 2; i < LIMIT; i++)\\n    {\\n        if (prime_flag[i] == 0)\\n        {\\n            for (long long j = i * i; j < LIMIT; j += i)\\n            {\\n                prime_flag[j] = 1;\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        calculatePrime();\\n        \\n        int ans1=-1, ans2=-1;\\n        \\n        int res1=-1,res2=-1;\\n        \\n        int minNum=INT_MAX;\\n        \\n        for(int i=left; i<=right; i++)\\n        {\\n            if(prime_flag[i] == 0)\\n            {\\n                if(ans1 == -1)\\n                    ans1=i;\\n                else if(ans2 == -1) \\n                {\\n                    ans2=i;\\n                    minNum=ans2-ans1;\\n                    res1=ans1;\\n                    res2=ans2;\\n                }\\n                \\n                if(ans1!=-1 && ans2!=-1)\\n                {\\n                    if(ans2 < i)\\n                    {\\n                        ans1=ans2;\\n                        ans2=i;\\n                    }\\n                    if(minNum > (ans2-ans1))\\n                    {\\n                        res1=ans1;\\n                        res2=ans2;\\n                        minNum=(ans2-ans1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(minNum == INT_MAX)\\n            return {-1,-1};\\n        \\n        return {res1,res2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977359,
                "title": "sieve-of-eratosthenes-c",
                "content": "```\\nclass Solution {\\n    vector<int> solve(int b) {\\n        if(b <= 2) return {};\\n        vector<int> v(b, 0);\\n        for(int i=2; i<=sqrt(b); i++) {\\n            if(!v[i]) {\\n                for(int j=i*i; j<b; j += i) v[j] = 1;\\n            }\\n        }\\n        return v;\\n    }\\n    \\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if(left == 1) left++;\\n        vector<int> v, a, primes;\\n        v = solve(right + 1);\\n        for(int i=left; i<=right; i++) {\\n            if(!v[i]) primes.push_back(i);\\n        }\\n        \\n        if(primes.size() <= 1) return {-1, -1};\\n        \\n        int ans = 1e9;\\n        for(int i=1; i<primes.size(); i++) {\\n            if(primes[i] - primes[i - 1] < ans) ans = primes[i] - primes[i - 1], a = {primes[i - 1], primes[i]}; \\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> solve(int b) {\\n        if(b <= 2) return {};\\n        vector<int> v(b, 0);\\n        for(int i=2; i<=sqrt(b); i++) {\\n            if(!v[i]) {\\n                for(int j=i*i; j<b; j += i) v[j] = 1;\\n            }\\n        }\\n        return v;\\n    }\\n    \\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if(left == 1) left++;\\n        vector<int> v, a, primes;\\n        v = solve(right + 1);\\n        for(int i=left; i<=right; i++) {\\n            if(!v[i]) primes.push_back(i);\\n        }\\n        \\n        if(primes.size() <= 1) return {-1, -1};\\n        \\n        int ans = 1e9;\\n        for(int i=1; i<primes.size(); i++) {\\n            if(primes[i] - primes[i - 1] < ans) ans = primes[i] - primes[i - 1], a = {primes[i - 1], primes[i]}; \\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977292,
                "title": "c-explanation-sieve-of-eratosthenes",
                "content": "\\n**Happy New Year!!!**\\n\\n* **Approach** - \\n    1. Find out all prime number in between `left` and `right`\\n    2. Then find two prime number which is difference minimum\\n    \\n* Time Complexity - O(N*Log(N)), where N = right;\\n* space Complexity - O(N)\\n    \\n**REQUEST** :\\xA0If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.\\n    \\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> prime(right+1, true);\\n        \\n        // sieve of eratosthenes algorithm\\n        for (int p = 2; p * p <= right; p++) \\n            if (prime[p] == true) \\n                for (int i = p * p; i <= right; i += p)\\n                    prime[i] = false;\\n        \\n        vector<int> a;\\n        if(left == 1) left++;   // if left = 1,we start left = 2\\n        for(int i = left; i <= right; i++) \\n            if(prime[i]) a.push_back(i);\\n    \\n        \\n        if(a.size() <= 1) return {-1, -1};  // no prime numbers in b/w left and right then return -1;\\n        \\n        int mn = INT_MAX;\\n        \\n        int f, s;\\n        for(int i = 1; i < a.size(); i++) \\n            if(a[i] - a[i-1] < mn) {\\n                f = a[i-1], s = a[i];\\n                mn = a[i] - a[i-1];\\n            }\\n       \\n        return {f, s};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> prime(right+1, true);\\n        \\n        // sieve of eratosthenes algorithm\\n        for (int p = 2; p * p <= right; p++) \\n            if (prime[p] == true) \\n                for (int i = p * p; i <= right; i += p)\\n                    prime[i] = false;\\n        \\n        vector<int> a;\\n        if(left == 1) left++;   // if left = 1,we start left = 2\\n        for(int i = left; i <= right; i++) \\n            if(prime[i]) a.push_back(i);\\n    \\n        \\n        if(a.size() <= 1) return {-1, -1};  // no prime numbers in b/w left and right then return -1;\\n        \\n        int mn = INT_MAX;\\n        \\n        int f, s;\\n        for(int i = 1; i < a.size(); i++) \\n            if(a[i] - a[i-1] < mn) {\\n                f = a[i-1], s = a[i];\\n                mn = a[i] - a[i-1];\\n            }\\n       \\n        return {f, s};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977271,
                "title": "c-sieve-commented-straight-forward",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    bool isPrime[1000001];\\n    vector<int> closestPrimes(int left, int right) {\\n        memset(isPrime, true, sizeof isPrime);\\n        isPrime[0] = isPrime[1] = 0;\\n        //Computing all the primes between 1 to 1e6\\n        for(int i = 2;i * i <= 1e6;i++){\\n            if(isPrime[i] == 1){\\n                for(int j = i * i;j <= 1e6;j += i){\\n                    isPrime[j] = false;\\n                }\\n            }\\n            \\n        }\\n        //Storing those prime number which does exist only between left and right\\n        for(int i = 2;i <= 1e6;i++){\\n            if(isPrime[i] && (i >= left && i <= right)){\\n                primes.push_back(i);\\n            }\\n        }\\n        \\n        long nums1 = -1e6, nums2 = 1e6;\\n        //Finding two closest numbers in sorted vector primes\\n        for(int i = primes.size() - 2;i >= 0;i--){\\n            if(primes[i + 1] - primes[i] <= nums2 - nums1){\\n                nums1 = primes[i];\\n                nums2 = primes[i + 1];\\n            }\\n        }\\n        \\n        if(primes.size() < 2) return {-1, -1};\\n        return {(int)nums1, (int)nums2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    bool isPrime[1000001];\\n    vector<int> closestPrimes(int left, int right) {\\n        memset(isPrime, true, sizeof isPrime);\\n        isPrime[0] = isPrime[1] = 0;\\n        //Computing all the primes between 1 to 1e6\\n        for(int i = 2;i * i <= 1e6;i++){\\n            if(isPrime[i] == 1){\\n                for(int j = i * i;j <= 1e6;j += i){\\n                    isPrime[j] = false;\\n                }\\n            }\\n            \\n        }\\n        //Storing those prime number which does exist only between left and right\\n        for(int i = 2;i <= 1e6;i++){\\n            if(isPrime[i] && (i >= left && i <= right)){\\n                primes.push_back(i);\\n            }\\n        }\\n        \\n        long nums1 = -1e6, nums2 = 1e6;\\n        //Finding two closest numbers in sorted vector primes\\n        for(int i = primes.size() - 2;i >= 0;i--){\\n            if(primes[i + 1] - primes[i] <= nums2 - nums1){\\n                nums1 = primes[i];\\n                nums2 = primes[i + 1];\\n            }\\n        }\\n        \\n        if(primes.size() < 2) return {-1, -1};\\n        return {(int)nums1, (int)nums2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977255,
                "title": "c-find-prime-from-left-to-right",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> arr;\\n        for(int i=left;i<=right;i++){\\n            bool flg = true;\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg && i!=1) arr.push_back(i);\\n        }\\n        int ind=0,mn=INT_MAX;\\n        if(arr.size()<2) return {-1,-1};\\n        for(int i=0;i<arr.size()-1;i++){\\n            if((arr[i+1]-arr[i])<mn){\\n                mn = (arr[i+1]-arr[i]);\\n                ind = i;\\n            }\\n        }\\n        return {arr[ind],arr[ind+1]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> arr;\\n        for(int i=left;i<=right;i++){\\n            bool flg = true;\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg && i!=1) arr.push_back(i);\\n        }\\n        int ind=0,mn=INT_MAX;\\n        if(arr.size()<2) return {-1,-1};\\n        for(int i=0;i<arr.size()-1;i++){\\n            if((arr[i+1]-arr[i])<mn){\\n                mn = (arr[i+1]-arr[i]);\\n                ind = i;\\n            }\\n        }\\n        return {arr[ind],arr[ind+1]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016129,
                "title": "rust-sieve-of-eratosthenes",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn closest_primes(left: i32, right: i32) -> Vec<i32> {\\n        let max = 1000001.min(right as usize + 1);\\n        let mut primes = vec![true; max];\\n        primes[0] = false;\\n        primes[1] = false;\\n\\n        let mut i = 2;\\n        while i < max {\\n            if primes[i] {\\n                let mut j = i * i;\\n                while j < max {\\n                    primes[j] = false;\\n                    j += i;\\n                }\\n            }\\n            i += 1;\\n        }\\n\\n        let left = left as usize;\\n        let right = right as usize;\\n\\n        let mut ans = vec![-1; 2];\\n        let mut min = usize::MAX;\\n\\n        let mut i = right;\\n        while i >= left {\\n            if primes[i] {\\n                let mut j = i - 1;\\n                while j >= left {\\n                    if primes[j] {\\n                        if i - j <= min {\\n                            min = i - j;\\n                            ans[0] = j as i32;\\n                            ans[1] = i as i32;\\n                        }\\n                        i = j + 1;\\n                        break;\\n                    }\\n                    j -= 1;\\n                }\\n            }\\n            i -= 1;\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn closest_primes(left: i32, right: i32) -> Vec<i32> {\\n        let max = 1000001.min(right as usize + 1);\\n        let mut primes = vec![true; max];\\n        primes[0] = false;\\n        primes[1] = false;\\n\\n        let mut i = 2;\\n        while i < max {\\n            if primes[i] {\\n                let mut j = i * i;\\n                while j < max {\\n                    primes[j] = false;\\n                    j += i;\\n                }\\n            }\\n            i += 1;\\n        }\\n\\n        let left = left as usize;\\n        let right = right as usize;\\n\\n        let mut ans = vec![-1; 2];\\n        let mut min = usize::MAX;\\n\\n        let mut i = right;\\n        while i >= left {\\n            if primes[i] {\\n                let mut j = i - 1;\\n                while j >= left {\\n                    if primes[j] {\\n                        if i - j <= min {\\n                            min = i - j;\\n                            ans[0] = j as i32;\\n                            ans[1] = i as i32;\\n                        }\\n                        i = j + 1;\\n                        break;\\n                    }\\n                    j -= 1;\\n                }\\n            }\\n            i -= 1;\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010215,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        //marks all prime number from 2 to right using sieve algorithm\\n        vector<int> nums(right+1, 1);\\n        for(int i=2; i*i<=right; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                for(int j=i*i; j<=right; j+=i)\\n                    nums[j]=0;\\n            }\\n        }\\n\\n        //storing all prime number between left and right\\n        vector<int> prime;\\n        for(int i=max(2,left); i<=right; i++)\\n        {\\n            if(nums[i]==1) prime.push_back(i);\\n        }\\n\\n        //finding pair of prime numbers having minimum difference\\n        int n1=-1, n2=-1, mini=1e8, diff;\\n        for(int i=1; i<prime.size(); i++)\\n        {\\n            diff = prime[i]-prime[i-1];\\n            if(diff < mini)\\n            {\\n                mini = diff;\\n                n1 = prime[i-1];\\n                n2 = prime[i];\\n            }\\n        }\\n        return {n1, n2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        //marks all prime number from 2 to right using sieve algorithm\\n        vector<int> nums(right+1, 1);\\n        for(int i=2; i*i<=right; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                for(int j=i*i; j<=right; j+=i)\\n                    nums[j]=0;\\n            }\\n        }\\n\\n        //storing all prime number between left and right\\n        vector<int> prime;\\n        for(int i=max(2,left); i<=right; i++)\\n        {\\n            if(nums[i]==1) prime.push_back(i);\\n        }\\n\\n        //finding pair of prime numbers having minimum difference\\n        int n1=-1, n2=-1, mini=1e8, diff;\\n        for(int i=1; i<prime.size(); i++)\\n        {\\n            diff = prime[i]-prime[i-1];\\n            if(diff < mini)\\n            {\\n                mini = diff;\\n                n1 = prime[i-1];\\n                n2 = prime[i];\\n            }\\n        }\\n        return {n1, n2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003893,
                "title": "sieve-of-eratosthenes-java-approach",
                "content": "# Approach\\nUsed Sieve of Eratosthenes to generate primes from left to right. Then travered to get the result according to minimum gap.\\n\\n# Complexity\\n- Time complexity:\\no(n) where n=right-left+1\\n\\n- Space complexity:\\no(n) where n=right-left+1\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n       ArrayList<Integer> primes=new ArrayList<>();\\n       int n=right-left+1;\\n       boolean sieveNonPrime[]=new boolean[n];\\n       for(int i=2;i*i<=right;i++){\\n           int j;\\n           if(i*i>left)j=i*i;\\n           else j=left;\\n           while(j<=right){\\n\\n               if(j%i==0 && j>3 && j!=i){\\n                   sieveNonPrime[j-left]=true;\\n                   j+=i;\\n               }\\n               else j++;\\n           }\\n       } \\n       for(int j=left;j<=right;j++){\\n           if(!sieveNonPrime[j-left] && j>1) primes.add(j);\\n       }\\n       int gap=(int)1e9;\\n       int[] res=new int[]{-1,-1};\\n       for(int i=0;i<primes.size()-1;i++){\\n           int sub=primes.get(i+1)-primes.get(i);\\n           if(sub<gap){\\n               res[0]=primes.get(i);\\n               res[1]=primes.get(i+1);\\n               gap=sub;\\n           }\\n       }\\n       return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n       ArrayList<Integer> primes=new ArrayList<>();\\n       int n=right-left+1;\\n       boolean sieveNonPrime[]=new boolean[n];\\n       for(int i=2;i*i<=right;i++){\\n           int j;\\n           if(i*i>left)j=i*i;\\n           else j=left;\\n           while(j<=right){\\n\\n               if(j%i==0 && j>3 && j!=i){\\n                   sieveNonPrime[j-left]=true;\\n                   j+=i;\\n               }\\n               else j++;\\n           }\\n       } \\n       for(int j=left;j<=right;j++){\\n           if(!sieveNonPrime[j-left] && j>1) primes.add(j);\\n       }\\n       int gap=(int)1e9;\\n       int[] res=new int[]{-1,-1};\\n       for(int i=0;i<primes.size()-1;i++){\\n           int sub=primes.get(i+1)-primes.get(i);\\n           if(sub<gap){\\n               res[0]=primes.get(i);\\n               res[1]=primes.get(i+1);\\n               gap=sub;\\n           }\\n       }\\n       return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999395,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void prime(vector<bool>&arr,int n){\\n        arr[0] = false;\\n        arr[1] = false;\\n        for(int i = 2;i*i <= n;i++){\\n            for(int j = 2*i;j <= n;j = j + i)\\n                arr[j] = false;\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        int i = left;\\n        int n = right+1;\\n        vector<bool>arr(n,true);\\n        vector<int>ans;\\n        prime(arr,n);\\n        int a = -1;\\n        int b = -1;\\n        int diff = INT_MAX;\\n        while(i < n){\\n            if(arr[i])\\n                break;\\n            i++;\\n        }\\n        int j = i+1;\\n        while(j < n){\\n            if(arr[j]){\\n                if(j - i < diff){\\n                    diff = j-i;\\n                    a = i;\\n                    b = j;\\n                }\\n                i=j;\\n            }\\n            j++;\\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void prime(vector<bool>&arr,int n){\\n        arr[0] = false;\\n        arr[1] = false;\\n        for(int i = 2;i*i <= n;i++){\\n            for(int j = 2*i;j <= n;j = j + i)\\n                arr[j] = false;\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        int i = left;\\n        int n = right+1;\\n        vector<bool>arr(n,true);\\n        vector<int>ans;\\n        prime(arr,n);\\n        int a = -1;\\n        int b = -1;\\n        int diff = INT_MAX;\\n        while(i < n){\\n            if(arr[i])\\n                break;\\n            i++;\\n        }\\n        int j = i+1;\\n        while(j < n){\\n            if(arr[j]){\\n                if(j - i < diff){\\n                    diff = j-i;\\n                    a = i;\\n                    b = j;\\n                }\\n                i=j;\\n            }\\n            j++;\\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990354,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number[]}\\n */\\nvar closestPrimes = function(left, right) {\\n    let primes = []\\n\\n    const isPrime = (num) => {\\n        if (num < 2) return false\\n        \\n        if (num % 2 == 0) return num == 2\\n\\n        let max = Math.floor(Math.sqrt(num))\\n\\n        for (let i = 3; i <= max; i += 2) {\\n            if(num % i == 0) return false\\n        }\\n\\n        return true\\n    }\\n\\n\\n    for(let start = left; start <= right; ++start) {\\n        if (isPrime(start)) {\\n            primes.push(start)\\n        }\\n    }\\n\\n\\n    let minGap = Infinity\\n    let l = 0\\n    let r = 1\\n    let minGapIndices = [-1, -1]\\n\\n    if(primes.length == 1) return minGapIndices\\n\\n    while(l < primes.length - 1) {\\n       let diff = primes[r] - primes[l]\\n       if(diff < minGap) {\\n           minGap = diff\\n           minGapIndices = [primes[l], primes[r]]\\n       }\\n       l++\\n       r++\\n    }\\n\\n    return minGapIndices\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number[]}\\n */\\nvar closestPrimes = function(left, right) {\\n    let primes = []\\n\\n    const isPrime = (num) => {\\n        if (num < 2) return false\\n        \\n        if (num % 2 == 0) return num == 2\\n\\n        let max = Math.floor(Math.sqrt(num))\\n\\n        for (let i = 3; i <= max; i += 2) {\\n            if(num % i == 0) return false\\n        }\\n\\n        return true\\n    }\\n\\n\\n    for(let start = left; start <= right; ++start) {\\n        if (isPrime(start)) {\\n            primes.push(start)\\n        }\\n    }\\n\\n\\n    let minGap = Infinity\\n    let l = 0\\n    let r = 1\\n    let minGapIndices = [-1, -1]\\n\\n    if(primes.length == 1) return minGapIndices\\n\\n    while(l < primes.length - 1) {\\n       let diff = primes[r] - primes[l]\\n       if(diff < minGap) {\\n           minGap = diff\\n           minGapIndices = [primes[l], primes[r]]\\n       }\\n       l++\\n       r++\\n    }\\n\\n    return minGapIndices\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984100,
                "title": "c-segmented-sieve-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n#define VI vector<int> \\n#define VB vector<bool>\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if(left==right)return {-1,-1};\\n        VI primes;\\n        if(left==1)primes=getPrimes(right+1);\\n        else primes=generatePrimes(left,right);\\n        int n=primes.size();\\n        if(n<=1)return {-1,-1};\\n        int mini=primes[0],maxi=primes[1],diff=maxi-mini;\\n        for(int i=1,j=2;j<n;j++,i++){\\n            if(diff>primes[j]-primes[i]){\\n                diff=primes[j]-primes[i];\\n                maxi=primes[j];\\n                mini=primes[i];\\n            }\\n        }\\n        return {mini,maxi};\\n    }\\n    VI generatePrimes(int l,int r){\\n        int n=sqrt(r);\\n        VI primes=getPrimes(n);\\n        if(primes.size()==0)return {};\\n        VI res;\\n        VB seg_sieve(r-l+1,true);\\n        for(int pr:primes){\\n            int fm=(l/pr) * pr;\\n            if(fm<l)fm+=pr;\\n            for(int i=max(fm,pr*pr);i<=r;i+=pr){\\n                seg_sieve[i-l]=false;\\n            }\\n        }\\n        for(int i=l;i<=r;i++){\\n            if(!seg_sieve[i-l])continue;\\n            res.push_back(i);\\n        }\\n        return res;\\n\\n    }\\n    VI getPrimes(int n){\\n        VB sieve;\\n        sieve.assign(n,true);\\n        sieve[0]=false;sieve[1]=false;\\n        for(int i=2;i*i<=n;i++){\\n            if(!sieve[i])continue;\\n            for(int j=i*i;j<=n;j+=i){\\n                sieve[j]=false;\\n            }\\n        }\\n        VI primes;\\n        for(int i=2;i<=n;i++){\\n            if(sieve[i])primes.push_back(i);\\n        }\\n        return primes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n#define VI vector<int> \\n#define VB vector<bool>\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if(left==right)return {-1,-1};\\n        VI primes;\\n        if(left==1)primes=getPrimes(right+1);\\n        else primes=generatePrimes(left,right);\\n        int n=primes.size();\\n        if(n<=1)return {-1,-1};\\n        int mini=primes[0],maxi=primes[1],diff=maxi-mini;\\n        for(int i=1,j=2;j<n;j++,i++){\\n            if(diff>primes[j]-primes[i]){\\n                diff=primes[j]-primes[i];\\n                maxi=primes[j];\\n                mini=primes[i];\\n            }\\n        }\\n        return {mini,maxi};\\n    }\\n    VI generatePrimes(int l,int r){\\n        int n=sqrt(r);\\n        VI primes=getPrimes(n);\\n        if(primes.size()==0)return {};\\n        VI res;\\n        VB seg_sieve(r-l+1,true);\\n        for(int pr:primes){\\n            int fm=(l/pr) * pr;\\n            if(fm<l)fm+=pr;\\n            for(int i=max(fm,pr*pr);i<=r;i+=pr){\\n                seg_sieve[i-l]=false;\\n            }\\n        }\\n        for(int i=l;i<=r;i++){\\n            if(!seg_sieve[i-l])continue;\\n            res.push_back(i);\\n        }\\n        return res;\\n\\n    }\\n    VI getPrimes(int n){\\n        VB sieve;\\n        sieve.assign(n,true);\\n        sieve[0]=false;sieve[1]=false;\\n        for(int i=2;i*i<=n;i++){\\n            if(!sieve[i])continue;\\n            for(int j=i*i;j<=n;j+=i){\\n                sieve[j]=false;\\n            }\\n        }\\n        VI primes;\\n        for(int i=2;i<=n;i++){\\n            if(sieve[i])primes.push_back(i);\\n        }\\n        return primes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979098,
                "title": "2523-closest-prime-numbers-in-range",
                "content": "```\\nclass Solution {\\n public:\\n  vector<int> closestPrimes(int left, int right) {\\n    const vector<bool> isPrime = sieveEratosthenes(right + 1);\\n    vector<int> primes;\\n\\n    for (int i = left; i <= right; ++i)\\n      if (isPrime[i])\\n        primes.push_back(i);\\n\\n    if (primes.size() < 2)\\n      return {-1, -1};\\n\\n    int minDiff = INT_MAX;\\n    int num1 = -1;\\n    int num2 = -1;\\n\\n    for (int i = 1; i < primes.size(); ++i) {\\n      const int diff = primes[i] - primes[i - 1];\\n      if (diff < minDiff) {\\n        minDiff = diff;\\n        num1 = primes[i - 1];\\n        num2 = primes[i];\\n      }\\n    }\\n\\n    return {num1, num2};\\n  }\\n\\n private:\\n  vector<bool> sieveEratosthenes(int n) {\\n    vector<bool> isPrime(n, true);\\n    isPrime[0] = false;\\n    isPrime[1] = false;\\n    for (int i = 2; i * i < n; ++i)\\n      if (isPrime[i])\\n        for (int j = i * i; j < n; j += i)\\n          isPrime[j] = false;\\n    return isPrime;\\n  }\\n};\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n public:\\n  vector<int> closestPrimes(int left, int right) {\\n    const vector<bool> isPrime = sieveEratosthenes(right + 1);\\n    vector<int> primes;\\n\\n    for (int i = left; i <= right; ++i)\\n      if (isPrime[i])\\n        primes.push_back(i);\\n\\n    if (primes.size() < 2)\\n      return {-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 3962330,
                "title": "easy-approach-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int l, int r) {\\n        boolean[] bol = new boolean[r+1];\\n        List <Integer> list = new ArrayList<>();\\n        int[] res = new int[2];\\n        res[0] = -1;\\n        res [1] = -1;\\n        Arrays.fill(bol, true);\\n        for(int i = 2;i<=r;i++){\\n            for(int j = i*2;j<=r;j+=i) {\\n                if(bol[j] == true) {\\n                    bol[j] = false;\\n                }\\n            }\\n        }\\n        bol[0] = false;\\n        bol[1] = false;\\n        for(int i = l;i<=r;i++) {\\n            if(bol[i] == true) {\\n                list.add(i);\\n            }\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0;i<list.size()-1;i++) {\\n            if(list.get(i+1)- list.get(i) < min) {\\n                min = list.get(i+1) - list.get(i);\\n                res[0] = list.get(i);\\n                res[1] = list.get(i+1);\\n            }\\n        }\\n    \\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int l, int r) {\\n        boolean[] bol = new boolean[r+1];\\n        List <Integer> list = new ArrayList<>();\\n        int[] res = new int[2];\\n        res[0] = -1;\\n        res [1] = -1;\\n        Arrays.fill(bol, true);\\n        for(int i = 2;i<=r;i++){\\n            for(int j = i*2;j<=r;j+=i) {\\n                if(bol[j] == true) {\\n                    bol[j] = false;\\n                }\\n            }\\n        }\\n        bol[0] = false;\\n        bol[1] = false;\\n        for(int i = l;i<=r;i++) {\\n            if(bol[i] == true) {\\n                list.add(i);\\n            }\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0;i<list.size()-1;i++) {\\n            if(list.get(i+1)- list.get(i) < min) {\\n                min = list.get(i+1) - list.get(i);\\n                res[0] = list.get(i);\\n                res[1] = list.get(i+1);\\n            }\\n        }\\n    \\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935730,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        res = [-1, -1]\\n        marked = [False for _ in range(right+1)]\\n        marked[0] = True\\n        marked[1] = True\\n\\n        for i in range(2, right +1):\\n            if not marked[i]:\\n                for j in range(i*i, right+1, i):\\n                    marked[j] = True\\n        ans =[]\\n        for x in range(left, right+1):\\n            if marked[x] == False: ans.append(x)\\n        d = float(\\'inf\\')\\n        for i in range(len(ans)-1):\\n            if ans[i+1]-ans[i]<d:\\n                d = ans[i+1]-ans[i]\\n                res = [ans[i], ans[i+1]]\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        res = [-1, -1]\\n        marked = [False for _ in range(right+1)]\\n        marked[0] = True\\n        marked[1] = True\\n\\n        for i in range(2, right +1):\\n            if not marked[i]:\\n                for j in range(i*i, right+1, i):\\n                    marked[j] = True\\n        ans =[]\\n        for x in range(left, right+1):\\n            if marked[x] == False: ans.append(x)\\n        d = float(\\'inf\\')\\n        for i in range(len(ans)-1):\\n            if ans[i+1]-ans[i]<d:\\n                d = ans[i+1]-ans[i]\\n                res = [ans[i], ans[i+1]]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910307,
                "title": "100-faster-java-1ms-program",
                "content": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        \\n        if(left == right){\\n            return new int[]{-1,-1};\\n        }\\n        \\n        if(left <= 2) {\\n            return new int[]{2,3};\\n        }\\n        \\n        if(left == 3) {\\n            return new int[]{3,5};\\n        }\\n        \\n        int lastPrime = -1;\\n        int minDiff = Integer.MAX_VALUE;\\n        int[] result = null;\\n        \\n        for(int i=left;i<=right;i++){\\n            \\n            if(isPrime(i)){\\n                if(lastPrime == -1){\\n                    lastPrime = i;\\n                } else {\\n                    minDiff = Math.min(i-lastPrime, minDiff);\\n                    result = new int[]{lastPrime, i};\\n                    lastPrime = i;\\n                }\\n                if(minDiff == 2){\\n                    return result;\\n                }\\n            }\\n            \\n        }\\n        \\n        return result == null ? new int[]{-1,-1} : result;\\n    }\\n    \\n    public boolean isPrime(int n){\\n        \\n        for(int i=2;i<(int)(Math.sqrt(n)+1);i++){\\n            if(n%i == 0){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        \\n        if(left == right){\\n            return new int[]{-1,-1};\\n        }\\n        \\n        if(left <= 2) {\\n            return new int[]{2,3};\\n        }\\n        \\n        if(left == 3) {\\n            return new int[]{3,5};\\n        }\\n        \\n        int lastPrime = -1;\\n        int minDiff = Integer.MAX_VALUE;\\n        int[] result = null;\\n        \\n        for(int i=left;i<=right;i++){\\n            \\n            if(isPrime(i)){\\n                if(lastPrime == -1){\\n                    lastPrime = i;\\n                } else {\\n                    minDiff = Math.min(i-lastPrime, minDiff);\\n                    result = new int[]{lastPrime, i};\\n                    lastPrime = i;\\n                }\\n                if(minDiff == 2){\\n                    return result;\\n                }\\n            }\\n            \\n        }\\n        \\n        return result == null ? new int[]{-1,-1} : result;\\n    }\\n    \\n    public boolean isPrime(int n){\\n        \\n        for(int i=2;i<(int)(Math.sqrt(n)+1);i++){\\n            if(n%i == 0){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907473,
                "title": "good-solution-problems-with-corner-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isPrime(n: int) -> bool:\\n            if n < 2:\\n                return False\\n            for i in range(2, (n//2)+1) :\\n                if n % i == 0:\\n                    return False\\n            return True\\n        \\n        r=[]\\n        d={}\\n        if (right-left) < 10000:            \\n            for i in range(left, right+1):\\n                if isPrime(i) :\\n                    r+=[i]\\n        else:\\n            for i in range(left, left+1000):\\n                if isPrime(i) :\\n                    r+=[i]\\n\\n        if len(r) > 1 and len(r) <= 104:            \\n            for i in range(len(r)) :\\n                for j in range(len(r)) :\\n                    if i != j and (abs(r[i]-r[j]) not in list(d.keys())):\\n                        d.update({abs(r[i]-r[j]) : list([r[i]] + [r[j]])})\\n            \\n        elif len(r) > 104:\\n            for i in range(30) :\\n                for j in range(30) :\\n                    if i != j and (abs(r[i]-r[j]) not in list(d.keys())):\\n                        d.update({abs(r[i]-r[j]) : list([r[i]] + [r[j]])})\\n\\n        if d:\\n            d=dict(sorted(d.items()))\\n            return list(d.values())[0]\\n        return [-1,-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isPrime(n: int) -> bool:\\n            if n < 2:\\n                return False\\n            for i in range(2, (n//2)+1) :\\n                if n % i == 0:\\n                    return False\\n            return True\\n        \\n        r=[]\\n        d={}\\n        if (right-left) < 10000:            \\n            for i in range(left, right+1):\\n                if isPrime(i) :\\n                    r+=[i]\\n        else:\\n            for i in range(left, left+1000):\\n                if isPrime(i) :\\n                    r+=[i]\\n\\n        if len(r) > 1 and len(r) <= 104:            \\n            for i in range(len(r)) :\\n                for j in range(len(r)) :\\n                    if i != j and (abs(r[i]-r[j]) not in list(d.keys())):\\n                        d.update({abs(r[i]-r[j]) : list([r[i]] + [r[j]])})\\n            \\n        elif len(r) > 104:\\n            for i in range(30) :\\n                for j in range(30) :\\n                    if i != j and (abs(r[i]-r[j]) not in list(d.keys())):\\n                        d.update({abs(r[i]-r[j]) : list([r[i]] + [r[j]])})\\n\\n        if d:\\n            d=dict(sorted(d.items()))\\n            return list(d.values())[0]\\n        return [-1,-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884504,
                "title": "sieve-of-eratosthenes-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> v,prime(right+1,1);\\n        int u = sqrt(right);\\n        for(int i=2; i<=right; i++){\\n            if(prime[i]){\\n                if(i>=left){\\n                    v.push_back(i);\\n                }\\n                if(i>u){\\n                    continue;\\n                }\\n                for(int j=i*i; j<=right; j+=i){\\n                    prime[j]=0;\\n                }\\n            }\\n        }\\n        if(v.size()<2){\\n            return {-1,-1};\\n        }\\n        int i=0,j=1;\\n        int a=0,b=INT_MAX;\\n        while(j<v.size()){\\n            if(v[j]-v[i]<b-a){\\n                a=v[i];\\n                b=v[j];\\n            }\\n            i++;\\n            j++;\\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> v,prime(right+1,1);\\n        int u = sqrt(right);\\n        for(int i=2; i<=right; i++){\\n            if(prime[i]){\\n                if(i>=left){\\n                    v.push_back(i);\\n                }\\n                if(i>u){\\n                    continue;\\n                }\\n                for(int j=i*i; j<=right; j+=i){\\n                    prime[j]=0;\\n                }\\n            }\\n        }\\n        if(v.size()<2){\\n            return {-1,-1};\\n        }\\n        int i=0,j=1;\\n        int a=0,b=INT_MAX;\\n        while(j<v.size()){\\n            if(v[j]-v[i]<b-a){\\n                a=v[i];\\n                b=v[j];\\n            }\\n            i++;\\n            j++;\\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842896,
                "title": "brute-force-c-accepted-solution-officially-explained",
                "content": "# Explantion\\nStart checking for prime numbers in between left and right(both inclusive) and push them in vector(here, $$ans$$). \\n\\nNow, check the min diff between all the prime numbers pushed in $$ans$$. Let $$mn$$ stores the min diff.\\n\\nIn the final step,start iterating from first element of ans and go on checking the consecutive difference between any 2 elements. If it is equal to $$mn$$, return it\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        bool chk(int n)\\n        {\\n            if (n == 1) return false;\\n            for (int i = 2; i * i <= n; i++)\\n            {\\n                if ((n % i) == 0) return false;\\n            }\\n            return true;\\n        }\\n    vector<int> closestPrimes(int left, int right)\\n    {\\n        vector<int> ans;\\n        vector<int> r(2, -1);\\n        for (int i = left; i <= right; i++)\\n        {\\n            if (chk(i)) ans.push_back(i);\\n        }\\n        int mn = 1e9;\\n        for (int i = 1; i < ans.size(); i++)\\n        {\\n            mn = min(mn, ans[i] - ans[i - 1]);\\n        }\\n        for (int i = 1; i < ans.size(); i++)\\n        {\\n            if (ans[i] - ans[i - 1] == mn)\\n            {\\n                r[0] = (ans[i - 1]);\\n                r[1] = (ans[i]);\\n                break;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool chk(int n)\\n        {\\n            if (n == 1) return false;\\n            for (int i = 2; i * i <= n; i++)\\n            {\\n                if ((n % i) == 0) return false;\\n            }\\n            return true;\\n        }\\n    vector<int> closestPrimes(int left, int right)\\n    {\\n        vector<int> ans;\\n        vector<int> r(2, -1);\\n        for (int i = left; i <= right; i++)\\n        {\\n            if (chk(i)) ans.push_back(i);\\n        }\\n        int mn = 1e9;\\n        for (int i = 1; i < ans.size(); i++)\\n        {\\n            mn = min(mn, ans[i] - ans[i - 1]);\\n        }\\n        for (int i = 1; i < ans.size(); i++)\\n        {\\n            if (ans[i] - ans[i - 1] == mn)\\n            {\\n                r[0] = (ans[i - 1]);\\n                r[1] = (ans[i]);\\n                break;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828058,
                "title": "sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        boolean[] IsPrime = new boolean[right + 1];\\n        Arrays.fill(IsPrime, true);\\n        IsPrime[0]=IsPrime[1]=false;\\n\\n        int min = Integer.MAX_VALUE;\\n        findPrimes(right,IsPrime);\\n        \\n        ArrayList<Integer> primes = new ArrayList<>();\\n        for(int i = left; i <= right; i++)\\n        {\\n            if(IsPrime[i])\\n                primes.add(i);\\n        }\\n      \\n        int[] res=null;\\n        for(int i = 0; i < primes.size() - 1; i++) {\\n            if(primes.get(i + 1) - primes.get(i) < min) {\\n                min = primes.get(i + 1) - primes.get(i);\\n                res = new int[]{primes.get(i),primes.get(i + 1)};\\n            }\\n        }\\n\\n        return res == null ? new int[]{-1, -1} : res;\\n    }\\n    \\n    private void findPrimes(int n,boolean[] IsPrime) {\\n       for(int i = 2; i * i <= n; i++){\\n           if(IsPrime[i]){\\n               for(int j = i * i; j <= n; j += i)\\n                   IsPrime[j] = false;\\n           }\\n       }  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        boolean[] IsPrime = new boolean[right + 1];\\n        Arrays.fill(IsPrime, true);\\n        IsPrime[0]=IsPrime[1]=false;\\n\\n        int min = Integer.MAX_VALUE;\\n        findPrimes(right,IsPrime);\\n        \\n        ArrayList<Integer> primes = new ArrayList<>();\\n        for(int i = left; i <= right; i++)\\n        {\\n            if(IsPrime[i])\\n                primes.add(i);\\n        }\\n      \\n        int[] res=null;\\n        for(int i = 0; i < primes.size() - 1; i++) {\\n            if(primes.get(i + 1) - primes.get(i) < min) {\\n                min = primes.get(i + 1) - primes.get(i);\\n                res = new int[]{primes.get(i),primes.get(i + 1)};\\n            }\\n        }\\n\\n        return res == null ? new int[]{-1, -1} : res;\\n    }\\n    \\n    private void findPrimes(int n,boolean[] IsPrime) {\\n       for(int i = 2; i * i <= n; i++){\\n           if(IsPrime[i]){\\n               for(int j = i * i; j <= n; j += i)\\n                   IsPrime[j] = false;\\n           }\\n       }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784294,
                "title": "solution-using-sieve-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int n = right;\\n        int l = left;\\n        boolean prime[] = new boolean[n+1];\\n        return sieve(l,n, prime);\\n\\n      \\n    }\\n\\n    static int[] sieve(int l, int x , boolean[] prime) {\\n    for (int i = 2; i*i <= x; i++) {\\n        if (!prime[i]) {\\n            for (int j = i * 2; j <= x; j += i) {\\n                prime[j] = true;\\n            }\\n        }\\n    }\\n\\n    int le = l;\\n    int re = x;\\n    int c1 = 0;\\n    int min = 10000000;\\n    int smin=0;\\n    for (int i = l; i <= x; i++) {\\n        if (!prime[i] && c1 == 0) {\\n            c1 = i;\\n        } else if (!prime[i]) {\\n             smin = i - c1;\\n            if (smin < min) {\\n                min = smin;\\n                le = c1;\\n                re = i;\\n               \\n            }\\n            c1 = i;\\n        }\\n    }\\n    if(le==re){\\n         return new int[]{-1,-1};\\n    }\\n    if (le == l && re == x && !prime[le] && !prime[re]) {\\n        return new int[]{le, re}; // No prime pair found\\n    }\\n    if (le == l && re == x ) {\\n        return new int[]{-1,-1}; // No prime pair found\\n    }\\n    if(1==re){\\n        return new int[]{-1, -1};\\n    }\\n    if(l==1){\\n        return new int[]{2,3};\\n    }\\n\\n    return new int[]{le, re};\\n\\n        \\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int n = right;\\n        int l = left;\\n        boolean prime[] = new boolean[n+1];\\n        return sieve(l,n, prime);\\n\\n      \\n    }\\n\\n    static int[] sieve(int l, int x , boolean[] prime) {\\n    for (int i = 2; i*i <= x; i++) {\\n        if (!prime[i]) {\\n            for (int j = i * 2; j <= x; j += i) {\\n                prime[j] = true;\\n            }\\n        }\\n    }\\n\\n    int le = l;\\n    int re = x;\\n    int c1 = 0;\\n    int min = 10000000;\\n    int smin=0;\\n    for (int i = l; i <= x; i++) {\\n        if (!prime[i] && c1 == 0) {\\n            c1 = i;\\n        } else if (!prime[i]) {\\n             smin = i - c1;\\n            if (smin < min) {\\n                min = smin;\\n                le = c1;\\n                re = i;\\n               \\n            }\\n            c1 = i;\\n        }\\n    }\\n    if(le==re){\\n         return new int[]{-1,-1};\\n    }\\n    if (le == l && re == x && !prime[le] && !prime[re]) {\\n        return new int[]{le, re}; // No prime pair found\\n    }\\n    if (le == l && re == x ) {\\n        return new int[]{-1,-1}; // No prime pair found\\n    }\\n    if(1==re){\\n        return new int[]{-1, -1};\\n    }\\n    if(l==1){\\n        return new int[]{2,3};\\n    }\\n\\n    return new int[]{le, re};\\n\\n        \\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784293,
                "title": "solution-using-sieve-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int n = right;\\n        int l = left;\\n        boolean prime[] = new boolean[n+1];\\n        return sieve(l,n, prime);\\n\\n      \\n    }\\n\\n    static int[] sieve(int l, int x , boolean[] prime) {\\n    for (int i = 2; i*i <= x; i++) {\\n        if (!prime[i]) {\\n            for (int j = i * 2; j <= x; j += i) {\\n                prime[j] = true;\\n            }\\n        }\\n    }\\n\\n    int le = l;\\n    int re = x;\\n    int c1 = 0;\\n    int min = 10000000;\\n    int smin=0;\\n    for (int i = l; i <= x; i++) {\\n        if (!prime[i] && c1 == 0) {\\n            c1 = i;\\n        } else if (!prime[i]) {\\n             smin = i - c1;\\n            if (smin < min) {\\n                min = smin;\\n                le = c1;\\n                re = i;\\n               \\n            }\\n            c1 = i;\\n        }\\n    }\\n    if(le==re){\\n         return new int[]{-1,-1};\\n    }\\n    if (le == l && re == x && !prime[le] && !prime[re]) {\\n        return new int[]{le, re}; // No prime pair found\\n    }\\n    if (le == l && re == x ) {\\n        return new int[]{-1,-1}; // No prime pair found\\n    }\\n    if(1==re){\\n        return new int[]{-1, -1};\\n    }\\n    if(l==1){\\n        return new int[]{2,3};\\n    }\\n\\n    return new int[]{le, re};\\n\\n        \\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int n = right;\\n        int l = left;\\n        boolean prime[] = new boolean[n+1];\\n        return sieve(l,n, prime);\\n\\n      \\n    }\\n\\n    static int[] sieve(int l, int x , boolean[] prime) {\\n    for (int i = 2; i*i <= x; i++) {\\n        if (!prime[i]) {\\n            for (int j = i * 2; j <= x; j += i) {\\n                prime[j] = true;\\n            }\\n        }\\n    }\\n\\n    int le = l;\\n    int re = x;\\n    int c1 = 0;\\n    int min = 10000000;\\n    int smin=0;\\n    for (int i = l; i <= x; i++) {\\n        if (!prime[i] && c1 == 0) {\\n            c1 = i;\\n        } else if (!prime[i]) {\\n             smin = i - c1;\\n            if (smin < min) {\\n                min = smin;\\n                le = c1;\\n                re = i;\\n               \\n            }\\n            c1 = i;\\n        }\\n    }\\n    if(le==re){\\n         return new int[]{-1,-1};\\n    }\\n    if (le == l && re == x && !prime[le] && !prime[re]) {\\n        return new int[]{le, re}; // No prime pair found\\n    }\\n    if (le == l && re == x ) {\\n        return new int[]{-1,-1}; // No prime pair found\\n    }\\n    if(1==re){\\n        return new int[]{-1, -1};\\n    }\\n    if(l==1){\\n        return new int[]{2,3};\\n    }\\n\\n    return new int[]{le, re};\\n\\n        \\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776719,
                "title": "easy-to-understand-java-solution-using-sieve-of-eratosthenes",
                "content": "```\\nclass Solution {\\n    \\n    \\n    public int[] closestPrimes(int left, int right) {\\n        \\n        boolean[] prime=new boolean[right+1];\\n        \\n        for(int i=2;i*i<=right;i++){\\n            if(!prime[i]){\\n                for(int j=i*2;j<=right;j+=i){\\n                    prime[j]=true;\\n                }\\n            }\\n        }\\n        ArrayList<Integer> l=new ArrayList<>();\\n        int gap=Integer.MAX_VALUE;\\n        int j=left;;\\n        if(left==1)\\n            j++;\\n        for( ;j<=right;j++){\\n            if(!prime[j])\\n                l.add(j);\\n        }\\n        \\n        int[] ans={-1,-1};\\n        for(int i=l.size()-1;i>=1;i--){\\n            if(gap>=l.get(i)-l.get(i-1)){\\n                ans[0]=l.get(i-1);\\n                ans[1]=l.get(i);\\n                gap=l.get(i)-l.get(i-1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public int[] closestPrimes(int left, int right) {\\n        \\n        boolean[] prime=new boolean[right+1];\\n        \\n        for(int i=2;i*i<=right;i++){\\n            if(!prime[i]){\\n                for(int j=i*2;j<=right;j+=i){\\n                    prime[j]=true;\\n                }\\n            }\\n        }\\n        ArrayList<Integer> l=new ArrayList<>();\\n        int gap=Integer.MAX_VALUE;\\n        int j=left;;\\n        if(left==1)\\n            j++;\\n        for( ;j<=right;j++){\\n            if(!prime[j])\\n                l.add(j);\\n        }\\n        \\n        int[] ans={-1,-1};\\n        for(int i=l.size()-1;i>=1;i--){\\n            if(gap>=l.get(i)-l.get(i-1)){\\n                ans[0]=l.get(i-1);\\n                ans[1]=l.get(i);\\n                gap=l.get(i)-l.get(i-1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774397,
                "title": "two-pointer-and-sieve-of-eratosthenes-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int n=right-left+1;\\n        vector<bool>isprime(right+2,1);\\n        isprime[0]=0;\\n        isprime[1]=0;\\n        vector<int>primes;\\n        for(int i=2;i<=sqrt(right);i++)\\n        {\\n            if(isprime[i]==1)\\n            {\\n                for(int j=i+i;j<=right;j+=i)\\n               {\\n                isprime[j]=0;\\n               }\\n            }\\n           \\n        }\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(isprime[i])\\n            {\\n               primes.push_back(i);\\n            }\\n        }\\n        int min=INT_MAX;\\n       int i=0;\\n       int j=i+1;\\n       vector<int>ans;\\n       while(i<j&&j<primes.size())\\n       {  int sub=primes[j]-primes[i];\\n           if(sub<min)\\n           {\\n               min=sub;\\n               if(ans.size()!=0)\\n               {\\n                  ans.pop_back();\\n                  ans.pop_back();\\n\\n               }\\n               ans.push_back(primes[i]);\\n               ans.push_back(primes[j]);\\n           }\\n           i++;\\n           j++;\\n       }\\n       if(ans.size()==0)\\n       {\\n           ans.push_back(-1);\\n           ans.push_back(-1);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int n=right-left+1;\\n        vector<bool>isprime(right+2,1);\\n        isprime[0]=0;\\n        isprime[1]=0;\\n        vector<int>primes;\\n        for(int i=2;i<=sqrt(right);i++)\\n        {\\n            if(isprime[i]==1)\\n            {\\n                for(int j=i+i;j<=right;j+=i)\\n               {\\n                isprime[j]=0;\\n               }\\n            }\\n           \\n        }\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(isprime[i])\\n            {\\n               primes.push_back(i);\\n            }\\n        }\\n        int min=INT_MAX;\\n       int i=0;\\n       int j=i+1;\\n       vector<int>ans;\\n       while(i<j&&j<primes.size())\\n       {  int sub=primes[j]-primes[i];\\n           if(sub<min)\\n           {\\n               min=sub;\\n               if(ans.size()!=0)\\n               {\\n                  ans.pop_back();\\n                  ans.pop_back();\\n\\n               }\\n               ans.push_back(primes[i]);\\n               ans.push_back(primes[j]);\\n           }\\n           i++;\\n           j++;\\n       }\\n       if(ans.size()==0)\\n       {\\n           ans.push_back(-1);\\n           ans.push_back(-1);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764377,
                "title": "simple-easy-fast-python-way-of-solving",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstep 1 -> use sieve method to find the prime numbers in least time\\nstep 2 -> then iterate through the list returend from seive method , & claculate the min difference & return the numbers\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        primes = self.sieve(left, right)\\n        \\n        min_difference = float(\\'inf\\')\\n        min_diff_primes = []\\n        \\n        for i in range(len(primes) - 1):\\n            difference = primes[i+1] - primes[i]\\n            if difference < min_difference:\\n                min_difference = difference\\n                min_diff_primes = [primes[i], primes[i+1]]\\n        \\n        if min_diff_primes:\\n            return min_diff_primes\\n        else:\\n            return [-1, -1]\\n\\n    def sieve(self, start, end):\\n        prime = [True] * (end+1)\\n        prime[0] = prime[1] = False\\n        \\n        p = 2\\n        while p*p <= end:\\n            if prime[p]:\\n                for i in range(p*p, end+1, p):\\n                    prime[i] = False\\n            p += 1\\n        \\n        primes = []\\n        for num in range(start, end+1):\\n            if prime[num]:\\n                primes.append(num)\\n        return primes\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        primes = self.sieve(left, right)\\n        \\n        min_difference = float(\\'inf\\')\\n        min_diff_primes = []\\n        \\n        for i in range(len(primes) - 1):\\n            difference = primes[i+1] - primes[i]\\n            if difference < min_difference:\\n                min_difference = difference\\n                min_diff_primes = [primes[i], primes[i+1]]\\n        \\n        if min_diff_primes:\\n            return min_diff_primes\\n        else:\\n            return [-1, -1]\\n\\n    def sieve(self, start, end):\\n        prime = [True] * (end+1)\\n        prime[0] = prime[1] = False\\n        \\n        p = 2\\n        while p*p <= end:\\n            if prime[p]:\\n                for i in range(p*p, end+1, p):\\n                    prime[i] = False\\n            p += 1\\n        \\n        primes = []\\n        for num in range(start, end+1):\\n            if prime[num]:\\n                primes.append(num)\\n        return primes\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736431,
                "title": "sieve-of-eratosthenes-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> sieve(int n){\\n        vector<bool> isPrime(n+1, true);\\n        isPrime[1] = false;\\n        for(int i = 2; i <= n; i++){\\n            if(isPrime[i]){\\n                for(int j = i*2; j <= n; j+=i){\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n        return isPrime;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> primes = sieve(right);\\n        vector<int> v;\\n        int count = 0;\\n        for(int i = left; i <= right; i++){\\n                if(primes[i]){\\n                     v.push_back(i);\\n                     count++;\\n            }\\n        }\\n        if(count < 2) return {-1, -1};\\n        int num1 = v[v.size()-2], num2 = v[v.size()-1];\\n        int diff = num2 - num1;\\n        for(int i = v.size()-2; i >= 1; i--){\\n            if(v[i] - v[i-1] <= diff){\\n                diff = v[i] - v[i-1];\\n                num1 = v[i-1];\\n                num2 = v[i];\\n            }\\n        }\\n        return {num1, num2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> sieve(int n){\\n        vector<bool> isPrime(n+1, true);\\n        isPrime[1] = false;\\n        for(int i = 2; i <= n; i++){\\n            if(isPrime[i]){\\n                for(int j = i*2; j <= n; j+=i){\\n                    isPrime[j] = false;\\n                }\\n            }\\n        }\\n        return isPrime;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> primes = sieve(right);\\n        vector<int> v;\\n        int count = 0;\\n        for(int i = left; i <= right; i++){\\n                if(primes[i]){\\n                     v.push_back(i);\\n                     count++;\\n            }\\n        }\\n        if(count < 2) return {-1, -1};\\n        int num1 = v[v.size()-2], num2 = v[v.size()-1];\\n        int diff = num2 - num1;\\n        for(int i = v.size()-2; i >= 1; i--){\\n            if(v[i] - v[i-1] <= diff){\\n                diff = v[i] - v[i-1];\\n                num1 = v[i-1];\\n                num2 = v[i];\\n            }\\n        }\\n        return {num1, num2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706556,
                "title": "sieve-of-eratosthenes",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<bool> sieveOfEratosthenes(int n) {\\n        vector<bool> prime(n + 1, true);\\n        \\n        for (int i = 2; i * i <= n; i++) {\\n            if (prime[i]) {\\n                for (int j = i * i; j <= n; j += i) {\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n\\n        return prime;\\n\\n    }\\n\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> prime = sieveOfEratosthenes(right);\\n        vector<int> primeNum;\\n        int first = -1, second = -1;\\n        int temp = -1;\\n        \\n        if (left < 2) {\\n            left = 2;\\n        }\\n\\n        for (int i = left; i <= right; i++) {\\n            if (prime[i]) {\\n                primeNum.push_back(i);\\n            }\\n        }\\n\\n        int min = INT_MAX;\\n        int pos = -1;\\n        int n = primeNum.size();\\n        for (int i = 0; i < n-1; i++) {\\n            if (primeNum[i + 1] - primeNum[i] < min) {\\n                min = primeNum[i + 1] - primeNum[i];\\n                pos = i;\\n            }\\n        }\\n\\n        if (pos != -1) {\\n            return { primeNum[pos], primeNum[pos + 1] };\\n        }\\n        else {\\n            return { pos, pos };\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<bool> sieveOfEratosthenes(int n) {\\n        vector<bool> prime(n + 1, true);\\n        \\n        for (int i = 2; i * i <= n; i++) {\\n            if (prime[i]) {\\n                for (int j = i * i; j <= n; j += i) {\\n                    prime[j] = false;\\n                }\\n            }\\n        }\\n\\n        return prime;\\n\\n    }\\n\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> prime = sieveOfEratosthenes(right);\\n        vector<int> primeNum;\\n        int first = -1, second = -1;\\n        int temp = -1;\\n        \\n        if (left < 2) {\\n            left = 2;\\n        }\\n\\n        for (int i = left; i <= right; i++) {\\n            if (prime[i]) {\\n                primeNum.push_back(i);\\n            }\\n        }\\n\\n        int min = INT_MAX;\\n        int pos = -1;\\n        int n = primeNum.size();\\n        for (int i = 0; i < n-1; i++) {\\n            if (primeNum[i + 1] - primeNum[i] < min) {\\n                min = primeNum[i + 1] - primeNum[i];\\n                pos = i;\\n            }\\n        }\\n\\n        if (pos != -1) {\\n            return { primeNum[pos], primeNum[pos + 1] };\\n        }\\n        else {\\n            return { pos, pos };\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676134,
                "title": "beginner-s-friendly-code",
                "content": "# Intuition\\nUse Sieve of Eratosthenes\\n# Approach\\nWe create an array which contains which element is prime or not.Firstly, we initialise the array with true,i.e,all are prime. We mark 0 and 1 as not prime.\\n- Now, we iterate from i=2 to i=sqrt(n) as if one of the factor of i is less than sqrt(i) then, other must be greater than sqrt(i).Example: 12-((1x12),(2x6),(3x4)), so sqrt(12)=3.46 thus you can can all the pairs\\'s first factor is within sqrt(12).\\n- Now the second loop goes from j=i*i to j=n; loop starts from i*i because all the previous ones are already marked. Example, let us find prime till 10, then,  3 will start marking its multiple from 9 onward this is because 6 is already marked by 2 and 6 is multiple of 2.so start the marking from i*i onwards.\\n- lastly extract the required number i.e in range left to right and get the pair of minimum difference using two variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n    bool* arr=new bool[right+1];\\n    for(int i=0;i<=right;i++){\\n        arr[i]=true;\\n    }\\n    arr[0]=false;\\n    arr[1]=false;\\n    for(int i=2;i<=sqrt(right);i++){\\n        if (arr[i]==true){\\n            for(int j=i*i;j<=right;j+=i){\\n            arr[j]=false;\\n            }\\n        }\\n    }\\n    int n1=-1,n2=0,mn=INT_MAX;\\n    int out1=-1,out2=-1;\\n    for(int i=0;i<=right;i++){\\n        if (arr[i]==true && i>=left && i<=right){\\n            n2=i;\\n            if (mn>n2-n1){\\n                mn=n2-n1;\\n                out1=n1;\\n                out2=n2;\\n            }\\n            n1=n2;\\n        }\\n    }\\n    if (out1==-1 || out2==-1) return {-1,-1};\\n    return {out1,out2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n    bool* arr=new bool[right+1];\\n    for(int i=0;i<=right;i++){\\n        arr[i]=true;\\n    }\\n    arr[0]=false;\\n    arr[1]=false;\\n    for(int i=2;i<=sqrt(right);i++){\\n        if (arr[i]==true){\\n            for(int j=i*i;j<=right;j+=i){\\n            arr[j]=false;\\n            }\\n        }\\n    }\\n    int n1=-1,n2=0,mn=INT_MAX;\\n    int out1=-1,out2=-1;\\n    for(int i=0;i<=right;i++){\\n        if (arr[i]==true && i>=left && i<=right){\\n            n2=i;\\n            if (mn>n2-n1){\\n                mn=n2-n1;\\n                out1=n1;\\n                out2=n2;\\n            }\\n            n1=n2;\\n        }\\n    }\\n    if (out1==-1 || out2==-1) return {-1,-1};\\n    return {out1,out2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597698,
                "title": "java-beats-98-3",
                "content": "# Intution\\nminimum difference would be between two consecutive prime numbers in this range.\\n\\n# Approach\\niterate from left to right and check if number is prime , keep track of last prime number encountered. \\ncheck if difference is less than previously calculated difference and update both difference and last.\\n\\n# Complexity\\n- Time complexity:\\nO(n*sqrt(n));\\n\\n\\n- Space complexity:\\nO(1)\\n\\n#Code\\nIf we see the trend on prime numbers , difference between any two consecutive is prime numbers is 2 , 3 , 4 , or maybe 6.\\nso if you encounter a pair with difference 2 , return the ans , because you ll not encounter diffrence less that 2 , and if you do , you anywauys have to return where nums1 is least.\\n\\n```\\nclass Solution {\\n\\n\\n    boolean func(int a){\\n        if(a == 2 || a == 3) return true;\\n        if(a == 1) return false;\\n        for(int i = 2 ; i <= Math.sqrt(a) ; i++) if(a%i==0) return false;\\n        return true;\\n    }\\n    public int[] closestPrimes(int left, int right) {\\n\\n        \\n        List<Integer> L = new ArrayList<>();\\n        int[] ans = new int[]{-1,-1};\\n        int dif = 1000000;\\n        int last = -1;\\n\\n        for(int i = left ; i <= right ; i++){\\n            if(func(i)){\\n               if(last == -1) {\\n                   last = i; \\n                   continue;\\n               }\\n               else{\\n                   if(i - last < dif){\\n                       dif = i - last;\\n                       ans[1] = i;\\n                       ans[0] = last;\\n                       if(dif<=2) return ans;\\n\\n                   }\\n                   last = i;\\n               }\\n            }\\n        }\\n     \\n       \\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    boolean func(int a){\\n        if(a == 2 || a == 3) return true;\\n        if(a == 1) return false;\\n        for(int i = 2 ; i <= Math.sqrt(a) ; i++) if(a%i==0) return false;\\n        return true;\\n    }\\n    public int[] closestPrimes(int left, int right) {\\n\\n        \\n        List<Integer> L = new ArrayList<>();\\n        int[] ans = new int[]{-1,-1};\\n        int dif = 1000000;\\n        int last = -1;\\n\\n        for(int i = left ; i <= right ; i++){\\n            if(func(i)){\\n               if(last == -1) {\\n                   last = i; \\n                   continue;\\n               }\\n               else{\\n                   if(i - last < dif){\\n                       dif = i - last;\\n                       ans[1] = i;\\n                       ans[0] = last;\\n                       if(dif<=2) return ans;\\n\\n                   }\\n                   last = i;\\n               }\\n            }\\n        }\\n     \\n       \\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573956,
                "title": "record-min-gap",
                "content": "# Approach\\nIf current gap is 1 or 2, return two primes.\\nElse record min. gap and two primes.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isPrime(n):\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i==0:\\n                    return False\\n        \\n            return True\\n        \\n        n1, n2 = None, None\\n        Min = 10 ** 6 + 1\\n\\n        for i in range(max(left, 2), right+1):\\n            if isPrime(i):\\n                if not n2:\\n                    n2 = i\\n                else:\\n                    n1 = n2\\n                    n2 = i\\n\\n                    if n2 - n1 < 3:\\n                        return [n1, n2]\\n\\n                    Min = min(Min, n2 - n1)\\n                    ret = [n1, n2]\\n        \\n        if Min > 10 ** 6:\\n            return [-1, -1]\\n        else:\\n            return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isPrime(n):\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i==0:\\n                    return False\\n        \\n            return True\\n        \\n        n1, n2 = None, None\\n        Min = 10 ** 6 + 1\\n\\n        for i in range(max(left, 2), right+1):\\n            if isPrime(i):\\n                if not n2:\\n                    n2 = i\\n                else:\\n                    n1 = n2\\n                    n2 = i\\n\\n                    if n2 - n1 < 3:\\n                        return [n1, n2]\\n\\n                    Min = min(Min, n2 - n1)\\n                    ret = [n1, n2]\\n        \\n        if Min > 10 ** 6:\\n            return [-1, -1]\\n        else:\\n            return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562211,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nimport math\\nclass Solution(object):\\n    \\n    def closestPrimes(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: List[int]\\n        \"\"\"\\n        ls=[]\\n        ps=[]\\n        mini=9988888\\n        for i in range(left,right+1):\\n            if self.isPrime(i):\\n                ls.append(i)\\n                if len(ls)==1:\\n                    continue\\n                else:\\n                    if (ls[-1]-ls[-2])<mini:\\n                        mini=ls[-1]-ls[-2]\\n                        ps=[ls[-2],ls[-1]]\\n                        if mini<=2:\\n                            return ps\\n        if ps:\\n            return ps\\n        else:\\n            return [-1,-1]\\n    def isPrime(self,n):\\n        if n<2:\\n            return False\\n        for i in range(2,int(math.sqrt(n))+1):\\n            if n%i==0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nimport math\\nclass Solution(object):\\n    \\n    def closestPrimes(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: List[int]\\n        \"\"\"\\n        ls=[]\\n        ps=[]\\n        mini=9988888\\n        for i in range(left,right+1):\\n            if self.isPrime(i):\\n                ls.append(i)\\n                if len(ls)==1:\\n                    continue\\n                else:\\n                    if (ls[-1]-ls[-2])<mini:\\n                        mini=ls[-1]-ls[-2]\\n                        ps=[ls[-2],ls[-1]]\\n                        if mini<=2:\\n                            return ps\\n        if ps:\\n            return ps\\n        else:\\n            return [-1,-1]\\n    def isPrime(self,n):\\n        if n<2:\\n            return False\\n        for i in range(2,int(math.sqrt(n))+1):\\n            if n%i==0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553533,
                "title": "simple-solution-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is_prime(int n) {\\n        if (n < 2)return false;\\n        if (n >= 2 && n <= 3)return true;\\n        if (n % 2 == 0 || n % 3 == 0)return false;\\n\\n        for (int i = 5;i * i <= n;i += 6) {\\n            if (n % i == 0 || n % (i + 2) == 0)return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> prime;\\n        for (int i = left; i <= right; i++)\\n            if (is_prime(i))\\n                prime.push_back(i);\\n\\n        if (prime.size() < 2)\\n            return { -1, -1 };\\n        int a = -1, b = -1, c = INT_MAX;\\n        for (int i = 1; i < prime.size(); i++) {\\n            if (prime[i] - prime[i - 1] < c) {\\n                a = prime[i - 1];\\n                b = prime[i];\\n                c = prime[i] - prime[i - 1];\\n            }\\n        }\\n        return { a,b };\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_prime(int n) {\\n        if (n < 2)return false;\\n        if (n >= 2 && n <= 3)return true;\\n        if (n % 2 == 0 || n % 3 == 0)return false;\\n\\n        for (int i = 5;i * i <= n;i += 6) {\\n            if (n % i == 0 || n % (i + 2) == 0)return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> prime;\\n        for (int i = left; i <= right; i++)\\n            if (is_prime(i))\\n                prime.push_back(i);\\n\\n        if (prime.size() < 2)\\n            return { -1, -1 };\\n        int a = -1, b = -1, c = INT_MAX;\\n        for (int i = 1; i < prime.size(); i++) {\\n            if (prime[i] - prime[i - 1] < c) {\\n                a = prime[i - 1];\\n                b = prime[i];\\n                c = prime[i] - prime[i - 1];\\n            }\\n        }\\n        return { a,b };\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521553,
                "title": "array-sieve-of-erothostenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n //int prime[1000005];\\n //int n=1e6+3;\\n //memset(prime,0,sizeof(prime));\\n        vector<int> sieve(int l,int n){\\n            int prime[n+3];\\n            memset(prime,0,sizeof(prime));\\n            prime[1]=1;\\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=n;j+=i){\\n                    prime[j]=1;\\n                }\\n            }\\n         }\\n         vector<int> v,v1;\\n         for(int i=l;i<=n;i++){\\n             if(prime[i]==0){\\n                 v.push_back(i);\\n             }\\n         }\\n         if(v.size()>1){\\n               v1.push_back(v[0]);\\n               v1.push_back(v[1]);\\n               int mn=v[1]-v[0];\\n             for(int i=1;i<v.size();i++){\\n                 int x=v[i]-v[i-1];\\n                 if(x<mn){\\n                     mn=x;\\n                     v1.clear();\\n                     v1.push_back(v[i-1]);\\n                     v1.push_back(v[i]);\\n                 }\\n                \\n             }\\n             return v1;\\n         }\\n         else{\\n             v1.push_back(-1);\\n             v1.push_back(-1);\\n             return v1;\\n             }\\n         }\\n    vector<int> closestPrimes(int left, int right) {\\n        //sieve();\\n        vector<int> res=sieve(left,right);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n //int prime[1000005];\\n //int n=1e6+3;\\n //memset(prime,0,sizeof(prime));\\n        vector<int> sieve(int l,int n){\\n            int prime[n+3];\\n            memset(prime,0,sizeof(prime));\\n            prime[1]=1;\\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]==0){\\n                for(int j=i*i;j<=n;j+=i){\\n                    prime[j]=1;\\n                }\\n            }\\n         }\\n         vector<int> v,v1;\\n         for(int i=l;i<=n;i++){\\n             if(prime[i]==0){\\n                 v.push_back(i);\\n             }\\n         }\\n         if(v.size()>1){\\n               v1.push_back(v[0]);\\n               v1.push_back(v[1]);\\n               int mn=v[1]-v[0];\\n             for(int i=1;i<v.size();i++){\\n                 int x=v[i]-v[i-1];\\n                 if(x<mn){\\n                     mn=x;\\n                     v1.clear();\\n                     v1.push_back(v[i-1]);\\n                     v1.push_back(v[i]);\\n                 }\\n                \\n             }\\n             return v1;\\n         }\\n         else{\\n             v1.push_back(-1);\\n             v1.push_back(-1);\\n             return v1;\\n             }\\n         }\\n    vector<int> closestPrimes(int left, int right) {\\n        //sieve();\\n        vector<int> res=sieve(left,right);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518075,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean prime(int num){\\n        if(num == 1)\\n            return false;\\n        for(int i = 2;i*i<=num;i++){\\n            if(num%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int[] closestPrimes(int left, int right) {\\n        int a[]=new int[2];\\n        a[0]=-1;\\n        a[1]=-1;\\n        int min = Integer.MAX_VALUE;\\n        ArrayList<Integer> set = new ArrayList<Integer>();\\n        for(int i = left ; i<=right ; i++){\\n            if(prime(i))\\n                set.add(i);\\n        }\\n        for (int i = 0; i < set.size() - 1; i++){\\n            if((set.get(i+1) - set.get(i))<min){\\n                a[0]=set.get(i);\\n                a[1]=set.get(i+1);\\n                min = set.get(i+1) - set.get(i);\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean prime(int num){\\n        if(num == 1)\\n            return false;\\n        for(int i = 2;i*i<=num;i++){\\n            if(num%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int[] closestPrimes(int left, int right) {\\n        int a[]=new int[2];\\n        a[0]=-1;\\n        a[1]=-1;\\n        int min = Integer.MAX_VALUE;\\n        ArrayList<Integer> set = new ArrayList<Integer>();\\n        for(int i = left ; i<=right ; i++){\\n            if(prime(i))\\n                set.add(i);\\n        }\\n        for (int i = 0; i < set.size() - 1; i++){\\n            if((set.get(i+1) - set.get(i))<min){\\n                a[0]=set.get(i);\\n                a[1]=set.get(i+1);\\n                min = set.get(i+1) - set.get(i);\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517407,
                "title": "easy-and-efficient-solution",
                "content": "# Approach\\nusing Eratosthenes algorithm to generate primes\\n\\n# Complexity\\n- Time complexity: O(n log log n),\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \"\"\"\\n        Returns a pair of closest prime numbers between left and right (both inclusive).\\n        If multiple pairs exist, returns the one with the minimum num1 value.\\n        If no such pair exists, returns [-1, -1].\\n\\n        Uses the Eratosthenes algorithm to generate primes.\\n        \"\"\"\\n        # Generate list of primes using Eratosthenes algorithm\\n        primes = self.sieve_of_eratosthenes(left, right)\\n\\n        # Find closest pair of primes\\n        min_distance = float(\\'inf\\')\\n        closest_pair = [-1, -1]\\n        for i in range(len(primes) - 1):\\n            distance = primes[i + 1] - primes[i]\\n            if distance < min_distance:\\n                min_distance = distance\\n                closest_pair = [primes[i], primes[i + 1]]\\n\\n        return closest_pair\\n        \\n    \\n    def sieve_of_eratosthenes(self, left: int, right: int) -> List[int]:\\n        \"\"\"\\n        Returns a list of prime numbers between left and right (both inclusive).\\n        \"\"\"\\n        is_prime = [True] * (right + 1)\\n        limit = int(right ** 0.5) + 1\\n        for i in range(2, limit):\\n            if is_prime[i]:\\n                for j in range(i * i, right + 1, i):\\n                    is_prime[j] = False\\n\\n        is_prime[0] = is_prime[1] = False\\n\\n        return [i for i in range(left, right + 1) if is_prime[i]]\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \"\"\"\\n        Returns a pair of closest prime numbers between left and right (both inclusive).\\n        If multiple pairs exist, returns the one with the minimum num1 value.\\n        If no such pair exists, returns [-1, -1].\\n\\n        Uses the Eratosthenes algorithm to generate primes.\\n        \"\"\"\\n        # Generate list of primes using Eratosthenes algorithm\\n        primes = self.sieve_of_eratosthenes(left, right)\\n\\n        # Find closest pair of primes\\n        min_distance = float(\\'inf\\')\\n        closest_pair = [-1, -1]\\n        for i in range(len(primes) - 1):\\n            distance = primes[i + 1] - primes[i]\\n            if distance < min_distance:\\n                min_distance = distance\\n                closest_pair = [primes[i], primes[i + 1]]\\n\\n        return closest_pair\\n        \\n    \\n    def sieve_of_eratosthenes(self, left: int, right: int) -> List[int]:\\n        \"\"\"\\n        Returns a list of prime numbers between left and right (both inclusive).\\n        \"\"\"\\n        is_prime = [True] * (right + 1)\\n        limit = int(right ** 0.5) + 1\\n        for i in range(2, limit):\\n            if is_prime[i]:\\n                for j in range(i * i, right + 1, i):\\n                    is_prime[j] = False\\n\\n        is_prime[0] = is_prime[1] = False\\n\\n        return [i for i in range(left, right + 1) if is_prime[i]]\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478100,
                "title": "simple-python-solution",
                "content": "# Intuition\\nThe given code finds the two closest prime numbers in the range [left, right]. It uses the Sieve of Eratosthenes algorithm to mark all non-prime numbers in the range as False in a boolean list called `prime`. It then iterates over the range from left to right and checks whether each number is prime by looking up the corresponding index in the `prime` list. If a number is prime, it is added to a list called `q`.\\n\\nThe code maintains a sliding window of size 2 over the `q` list and updates the closest pair of primes seen so far. If the absolute difference between the two numbers in the window is less than the current minimum distance `d`, the code updates `d` and the closest pair of primes. If `d` is less than or equal to 2, the code returns the closest pair of primes.\\n\\nThe intuition behind using the Sieve of Eratosthenes is that it efficiently marks all non-prime numbers in the range as False, making it faster to check whether a number is prime later on. The sliding window approach is used to avoid comparing every pair of primes in the range, which would take O(N^2) time. Instead, the code only compares adjacent primes, which takes O(N) time. Overall, the code achieves a time complexity of O(Nlog(logN)) by using the Sieve of Eratosthenes and a sliding window approach.\\n\\n# Approach\\nUsing SieveOfEratosthenes \\n# Complexity\\n- Time complexity:\\nO(Nlog(logN))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        prime=[True for i in range(right+1)]\\n        p=2\\n        while p*p<=right:\\n            if prime[p]==True:\\n                for i in range(p*p,right+1,p):\\n                    prime[i]=False\\n            p+=1\\n        def isprime(n):\\n            if prime[n]==True and i>=2:\\n                return True\\n            else:\\n                return False\\n        q=[]\\n        d=float(\\'inf\\')\\n        p=[-1,-1]\\n        for i in range(left,right+1):\\n            if isprime(i):\\n                print(i)\\n                q.append(i)\\n            while len(q)>=2:\\n                if abs(q[0]-q[1])<d:\\n                    p=[q[0],q[1]]\\n                    d=abs(q[0]-q[1])\\n                    if d<=2:\\n                        return p\\n                q.pop(0)\\n        return p\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        prime=[True for i in range(right+1)]\\n        p=2\\n        while p*p<=right:\\n            if prime[p]==True:\\n                for i in range(p*p,right+1,p):\\n                    prime[i]=False\\n            p+=1\\n        def isprime(n):\\n            if prime[n]==True and i>=2:\\n                return True\\n            else:\\n                return False\\n        q=[]\\n        d=float(\\'inf\\')\\n        p=[-1,-1]\\n        for i in range(left,right+1):\\n            if isprime(i):\\n                print(i)\\n                q.append(i)\\n            while len(q)>=2:\\n                if abs(q[0]-q[1])<d:\\n                    p=[q[0],q[1]]\\n                    d=abs(q[0]-q[1])\\n                    if d<=2:\\n                        return p\\n                q.pop(0)\\n        return p\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457691,
                "title": "begginer-solution-using-c",
                "content": "class Solution {\\npublic:\\n    \\n        bool check(int x)\\n        {\\n            if(x<2)\\n            {\\n                return false;\\n            }\\n            for(int i=2;i*i<=x;i++)\\n            {\\n                if(x%i==0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int>v2;\\n        if(left==1 && right==1)\\n        {\\n            v2.push_back(-1);\\n            v2.push_back(-1);\\n            return v2;\\n        }\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(check(i))\\n            {\\n                v2.push_back(i);\\n            }\\n        }\\n        if(v2.size()==0 || v2.size()==1)\\n        {\\n            v2.clear();\\n            v2.push_back(-1);\\n            v2.push_back(-1);\\n            return v2; \\n        }\\n        sort(v2.begin(),v2.end());\\n        int min1=0;\\n        int min2=0;\\n        int max1=INT_MAX;\\n        for(int i=0;i<v2.size()-1;i++)\\n        {\\n            if(abs(v2[i]-v2[i+1])<max1)\\n            {\\n                min1=v2[i];\\n                min2=v2[i+1];\\n                max1=abs(v2[i]-v2[i+1]);\\n            }\\n        }\\n        v2.clear();\\n        if(min1==0 && min2==0)\\n        {\\n            v2.push_back(-1);\\n            v2.push_back(-1);\\n            return v2;\\n        }\\n        v2.push_back(min1);\\n        v2.push_back(min2);\\n        return v2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n        bool check(int x)\\n        {\\n            if(x<2)\\n            {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3443966,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\t\\tvector<int>v;\\n\\t\\tvector<bool>dp;\\n        vector<int> closestPrimes(int left, int right) \\n\\t\\t{\\n\\t\\t\\t//intitally all are the prime numbers\\n\\t\\t\\t\\t\\tdp.resize(right+1,true);   \\n\\t\\t\\t\\t\\tdp[0] = false;   //as 0 is not prime number\\n\\t\\t\\t\\t\\tdp[1] = false;   //as 1 is not prime number\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//applying the seive algorithm\\n\\t\\t\\t\\t\\tfor(int i=2;i<dp.size();i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(dp[i] == true)    //if the dp[i] is the prime number\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(i>=left and i<=right)\\n\\t\\t\\t\\t\\t\\t\\tv.push_back(i);\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=i+i ; j < dp.size() ; j+=i)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t dp[j] = false;\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }        \\n\\t\\t\\t\\t\\t//now finding the pair as we have all the prime numbers with us\\n\\t\\t\\tif(v.size() <= 1)\\n\\t\\t\\treturn {-1,-1};\\n\\n\\t\\t\\t//prining the prime in range\\n\\n\\t\\t\\tint ele1 = -1;\\n\\t\\t\\tint ele2 = -1;\\n\\t\\t\\t\\n\\t\\t\\tint min_diff = INT_MAX;\\n\\t\\t\\tfor(int i=0;i<v.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\tint diff = abs(v[i] - v[i+1]);\\n\\t\\t\\t\\t\\tif(diff < min_diff)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmin_diff = diff;\\n\\t\\t\\t\\t\\t\\tele1 = v[i];\\n\\t\\t\\t\\t\\t\\tele2 = v[i+1];\\t\\n\\t\\t\\t\\t\\t}\\t\\n\\t\\t\\t}\\n\\t\\t\\treturn {ele1,ele2};\\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\t\\tvector<int>v;\\n\\t\\tvector<bool>dp;\\n        vector<int> closestPrimes(int left, int right) \\n\\t\\t{\\n\\t\\t\\t//intitally all are the prime numbers\\n\\t\\t\\t\\t\\tdp.resize(right+1,true);   \\n\\t\\t\\t\\t\\tdp[0] = false;   //as 0 is not prime number\\n\\t\\t\\t\\t\\tdp[1] = false;   //as 1 is not prime number\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//applying the seive algorithm\\n\\t\\t\\t\\t\\tfor(int i=2;i<dp.size();i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(dp[i] == true)    //if the dp[i] is the prime number\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(i>=left and i<=right)\\n\\t\\t\\t\\t\\t\\t\\tv.push_back(i);\\n\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=i+i ; j < dp.size() ; j+=i)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t dp[j] = false;\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }        \\n\\t\\t\\t\\t\\t//now finding the pair as we have all the prime numbers with us\\n\\t\\t\\tif(v.size() <= 1)\\n\\t\\t\\treturn {-1,-1};\\n\\n\\t\\t\\t//prining the prime in range\\n\\n\\t\\t\\tint ele1 = -1;\\n\\t\\t\\tint ele2 = -1;\\n\\t\\t\\t\\n\\t\\t\\tint min_diff = INT_MAX;\\n\\t\\t\\tfor(int i=0;i<v.size()-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\tint diff = abs(v[i] - v[i+1]);\\n\\t\\t\\t\\t\\tif(diff < min_diff)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmin_diff = diff;\\n\\t\\t\\t\\t\\t\\tele1 = v[i];\\n\\t\\t\\t\\t\\t\\tele2 = v[i+1];\\t\\n\\t\\t\\t\\t\\t}\\t\\n\\t\\t\\t}\\n\\t\\t\\treturn {ele1,ele2};\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441873,
                "title": "c-solution-segmented-sieve",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> v(sqrt(right)+1,true);\\n        vector<int> primes;\\n        v[0] = v[1] = false;\\n        for(int i = 2;i*i<=right;i++){\\n            if(v[i]){ \\n                primes.push_back(i);\\n                // cout<<i<<\" \";\\n                for(int j = i*i;j<=sqrt(right);j+=i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n        // cout<<endl;\\n        // for(auto &it: primes){\\n        //     cout<<it<<\" \";\\n        // }\\n        // cout<<endl;\\n        \\n        if(left<2 and right>=2){\\n            left = 2;\\n        }\\n        vector<int> ans;\\n        vector<bool> block(right-left+1,true);\\n        for(auto &i:primes){\\n            int lower = (left/i);\\n            if(lower<=1){\\n                lower = i+i;\\n            }\\n            else if(left%i){\\n                lower = (lower*i)+i;\\n            }\\n            else {\\n                lower = (lower*i);\\n            }\\n            \\n            for(int j = lower;j<=right;j+=i){\\n                block[j-left] = false;\\n            }\\n            // for(int k = 0;k<block.size();k++){\\n            //     cout<<block[k]<<\" \";\\n            // }\\n            // cout<<endl;\\n            \\n        }\\n        for(int it = left;it<=right;it++){\\n                if(block[it-left]){ ans.push_back(it);}\\n            }\\n        // for(auto &ot:ans){\\n        //     cout<<ot<<\" \";\\n        // }\\n        // cout<<endl;\\n        int a,b;\\n        if(ans.size()<2) return {-1,-1};\\n        int mine = ans[ans.size()-1]-ans[ans.size()-2];\\n        a = ans[ans.size()-2],b = ans[ans.size()-1];\\n        for(int i = ans.size()-1;i>0;i--){\\n            if(ans[i]-ans[i-1]<=mine){\\n                mine=ans[i]-ans[i-1];\\n                a = ans[i-1];\\n                b = ans[i];\\n            }\\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> v(sqrt(right)+1,true);\\n        vector<int> primes;\\n        v[0] = v[1] = false;\\n        for(int i = 2;i*i<=right;i++){\\n            if(v[i]){ \\n                primes.push_back(i);\\n                // cout<<i<<\" \";\\n                for(int j = i*i;j<=sqrt(right);j+=i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n        // cout<<endl;\\n        // for(auto &it: primes){\\n        //     cout<<it<<\" \";\\n        // }\\n        // cout<<endl;\\n        \\n        if(left<2 and right>=2){\\n            left = 2;\\n        }\\n        vector<int> ans;\\n        vector<bool> block(right-left+1,true);\\n        for(auto &i:primes){\\n            int lower = (left/i);\\n            if(lower<=1){\\n                lower = i+i;\\n            }\\n            else if(left%i){\\n                lower = (lower*i)+i;\\n            }\\n            else {\\n                lower = (lower*i);\\n            }\\n            \\n            for(int j = lower;j<=right;j+=i){\\n                block[j-left] = false;\\n            }\\n            // for(int k = 0;k<block.size();k++){\\n            //     cout<<block[k]<<\" \";\\n            // }\\n            // cout<<endl;\\n            \\n        }\\n        for(int it = left;it<=right;it++){\\n                if(block[it-left]){ ans.push_back(it);}\\n            }\\n        // for(auto &ot:ans){\\n        //     cout<<ot<<\" \";\\n        // }\\n        // cout<<endl;\\n        int a,b;\\n        if(ans.size()<2) return {-1,-1};\\n        int mine = ans[ans.size()-1]-ans[ans.size()-2];\\n        a = ans[ans.size()-2],b = ans[ans.size()-1];\\n        for(int i = ans.size()-1;i>0;i--){\\n            if(ans[i]-ans[i-1]<=mine){\\n                mine=ans[i]-ans[i-1];\\n                a = ans[i-1];\\n                b = ans[i];\\n            }\\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3401567,
                "title": "python3-sieve-of-eratosthenes",
                "content": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        primes = np.arange(right+1)\\n        primes[1] = -1\\n\\n        for i in range(2, int(math.sqrt(right))+1):\\n            if primes[i] != -1:\\n                primes[i*i::i] = -1\\n\\n        primes = primes[primes != -1]\\n        primes = primes[primes >= left]\\n        min_diff, A, B = math.inf, -1, -1\\n\\n        for i in range(1, len(primes)):\\n            curr = primes[i]-primes[i-1]\\n            if min_diff > curr:\\n                min_diff = curr\\n                A, B = primes[i-1], primes[i]\\n\\n        return [A, B]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        primes = np.arange(right+1)\\n        primes[1] = -1\\n\\n        for i in range(2, int(math.sqrt(right))+1):\\n            if primes[i] != -1:\\n                primes[i*i::i] = -1\\n\\n        primes = primes[primes != -1]\\n        primes = primes[primes >= left]\\n        min_diff, A, B = math.inf, -1, -1\\n\\n        for i in range(1, len(primes)):\\n            curr = primes[i]-primes[i-1]\\n            if min_diff > curr:\\n                min_diff = curr\\n                A, B = primes[i-1], primes[i]\\n\\n        return [A, B]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400612,
                "title": "c-solution-fast-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N sqrt(right))\\nwhere n = right - left\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    bool isPrime(int n){\\n        for(int i = 2; i * i<= n;i++)\\n            if(n % i == 0) return false;\\n        return n != 1;\\n    }\\n\\n    public int[] ClosestPrimes(int left, int right) {\\n        int diff = Int32.MaxValue,prev = 0;\\n        int[] res = new int[] {-1,-1};\\n        for(int i = left; i <= right;i++){\\n            if(!isPrime(i)) continue;\\n            if(prev == 0){\\n                prev = i;\\n                continue;\\n            }\\n            if(i - prev < diff){\\n                res[0] = prev;\\n                res[1] = i;\\n                diff = i - prev;\\n            }\\n            prev = i; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    bool isPrime(int n){\\n        for(int i = 2; i * i<= n;i++)\\n            if(n % i == 0) return false;\\n        return n != 1;\\n    }\\n\\n    public int[] ClosestPrimes(int left, int right) {\\n        int diff = Int32.MaxValue,prev = 0;\\n        int[] res = new int[] {-1,-1};\\n        for(int i = left; i <= right;i++){\\n            if(!isPrime(i)) continue;\\n            if(prev == 0){\\n                prev = i;\\n                continue;\\n            }\\n            if(i - prev < diff){\\n                res[0] = prev;\\n                res[1] = i;\\n                diff = i - prev;\\n            }\\n            prev = i; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397835,
                "title": "java-solution",
                "content": "# Intuition\\nGet the prims between the range and find the minimum difference and only update the ans array when diff is smaller then the previous diff as we will get the strictly increasing array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public  int[] closestPrimes(int left, int right) {\\n        int[] ans = new int[2];\\n        ans[0] = -1;\\n        ans[1] = -1;\\n        int minimum = Integer.MAX_VALUE;\\n        List<Integer> primesList = getPrimes(left,right);\\n        for(int i=0;i<primesList.size()-1;i++){\\n            int sub = Math.abs(primesList.get(i)-primesList.get(i+1));\\n            if(sub < minimum){\\n                minimum = sub;\\n                ans[0] = primesList.get(i);\\n                ans[1] = primesList.get(i+1);\\n            }\\n        }\\n        for(int i :ans) System.out.print(i+ \" \");\\n        return ans;\\n    }\\n\\n    private   List<Integer> getPrimes(int left,int right){\\n        List<Integer> primesList = new ArrayList<>();\\n        boolean[] primes = new boolean[right+1];\\n        for(int i=0;i<primes.length;i++)primes[i] = true;\\n        for(int i=2;i*i<=primes.length;i++){\\n            if(primes[i]){\\n                for(int j=i;j*i<primes.length;j++){\\n                    primes[i*j]=false;\\n                }\\n            }\\n        }\\n        if(left==0 || left==1)left = 2;\\n\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(primes[i]==true)primesList.add(i);\\n        }\\n        return primesList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public  int[] closestPrimes(int left, int right) {\\n        int[] ans = new int[2];\\n        ans[0] = -1;\\n        ans[1] = -1;\\n        int minimum = Integer.MAX_VALUE;\\n        List<Integer> primesList = getPrimes(left,right);\\n        for(int i=0;i<primesList.size()-1;i++){\\n            int sub = Math.abs(primesList.get(i)-primesList.get(i+1));\\n            if(sub < minimum){\\n                minimum = sub;\\n                ans[0] = primesList.get(i);\\n                ans[1] = primesList.get(i+1);\\n            }\\n        }\\n        for(int i :ans) System.out.print(i+ \" \");\\n        return ans;\\n    }\\n\\n    private   List<Integer> getPrimes(int left,int right){\\n        List<Integer> primesList = new ArrayList<>();\\n        boolean[] primes = new boolean[right+1];\\n        for(int i=0;i<primes.length;i++)primes[i] = true;\\n        for(int i=2;i*i<=primes.length;i++){\\n            if(primes[i]){\\n                for(int j=i;j*i<primes.length;j++){\\n                    primes[i*j]=false;\\n                }\\n            }\\n        }\\n        if(left==0 || left==1)left = 2;\\n\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(primes[i]==true)primesList.add(i);\\n        }\\n        return primesList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386803,
                "title": "python-33ms-beat-100-simple-iteration",
                "content": "This method simply locates a prime, then checks the shortest range of larger numbers that could be prime and improve the answer.\\n    \\n    def isPrime(self, n: int) -> bool:\\n        if n <= 3:\\n            return n > 1\\n        if n % 2 == 0 or n % 3 == 0:\\n            return False\\n        limit = isqrt(n)\\n        for i in range(5, limit+1, 6):\\n            if n % i == 0 or n % (i+2) == 0:\\n                return False\\n        return True\\n    \\n    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        res = [-1, -1];\\n        minDiff = right-left;\\n        low = left;\\n        if minDiff < 2:\\n            return res;\\n        elif left == 1:\\n            return [2,3];\\n        elif minDiff == 2 and self.isPrime(right) and self.isPrime(left):\\n            return [left, right]\\n        \\n        while low < right-1 and minDiff > 2:\\n            while not self.isPrime(low) and low < right-1:\\n                low = low + 1;\\n            minDiff = right - low;\\n            \\n            for high in range(low+2, min(right, low + minDiff)+1):\\n                if self.isPrime(high):\\n                    res = (low, high)\\n                    minDiff = high - low\\n                    low = high\\n                    break;\\n            low = high;\\n        \\n        return list(res);\\n   \\n     \\nChallenge: make it even faster with a Sieve implementation for the range check",
                "solutionTags": [
                    "Python3"
                ],
                "code": "This method simply locates a prime, then checks the shortest range of larger numbers that could be prime and improve the answer.\\n    \\n    def isPrime(self, n: int) -> bool:\\n        if n <= 3:\\n            return n > 1\\n        if n % 2 == 0 or n % 3 == 0:\\n            return False\\n        limit = isqrt(n)\\n        for i in range(5, limit+1, 6):\\n            if n % i == 0 or n % (i+2) == 0:\\n                return False\\n        return True\\n    \\n    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        res = [-1, -1];\\n        minDiff = right-left;\\n        low = left;\\n        if minDiff < 2:\\n            return res;\\n        elif left == 1:\\n            return [2,3];\\n        elif minDiff == 2 and self.isPrime(right) and self.isPrime(left):\\n            return [left, right]\\n        \\n        while low < right-1 and minDiff > 2:\\n            while not self.isPrime(low) and low < right-1:\\n                low = low + 1;\\n            minDiff = right - low;\\n            \\n            for high in range(low+2, min(right, low + minDiff)+1):\\n                if self.isPrime(high):\\n                    res = (low, high)\\n                    minDiff = high - low\\n                    low = high\\n                    break;\\n            low = high;\\n        \\n        return list(res);\\n   \\n     \\nChallenge: make it even faster with a Sieve implementation for the range check",
                "codeTag": "Python3"
            },
            {
                "id": 3325791,
                "title": "simple-straight-forward-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isprime(int x){\\n        if(x==1) return false;\\n        if(x==2) return true;\\n        for(int i=2;i<=sqrt(x);i++){\\n            if(x%i==0) return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        int l,r,diff=INT_MAX;\\n        vector<int> ans;\\n        vector<int> uttar;\\n        while(left<=right){\\n            if(isprime(left)){\\n                ans.push_back(left);\\n            }\\n            left++;\\n        }\\n        if(ans.size()<2){\\n            uttar.push_back(-1);\\n            uttar.push_back(-1);\\n            return uttar;\\n        }\\n        else{\\n            for(int i=1;i<ans.size();i++){\\n                if(ans[i]-ans[i-1] < diff){\\n                    diff=ans[i]-ans[i-1] ;\\n                    l=ans[i-1];\\n                    r=ans[i];\\n                }\\n            }\\n        }\\n        uttar.push_back(l);\\n        uttar.push_back(r);\\n        return uttar;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(int x){\\n        if(x==1) return false;\\n        if(x==2) return true;\\n        for(int i=2;i<=sqrt(x);i++){\\n            if(x%i==0) return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        int l,r,diff=INT_MAX;\\n        vector<int> ans;\\n        vector<int> uttar;\\n        while(left<=right){\\n            if(isprime(left)){\\n                ans.push_back(left);\\n            }\\n            left++;\\n        }\\n        if(ans.size()<2){\\n            uttar.push_back(-1);\\n            uttar.push_back(-1);\\n            return uttar;\\n        }\\n        else{\\n            for(int i=1;i<ans.size();i++){\\n                if(ans[i]-ans[i-1] < diff){\\n                    diff=ans[i]-ans[i-1] ;\\n                    l=ans[i-1];\\n                    r=ans[i];\\n                }\\n            }\\n        }\\n        uttar.push_back(l);\\n        uttar.push_back(r);\\n        return uttar;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304916,
                "title": "closest-prime-number-in-range",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def closestPrimes(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n=10**6+1\\n        isPrime = [1] * n\\n        isPrime[0] = isPrime[1] = 0  \\n        for i in range(2, int(n ** 0.5) + 1):\\n            if isPrime[i]:\\n                isPrime[i * i:n:i] = [0] * ((n - 1 - i * i) // i + 1)\\n        a=-1\\n        b=-1\\n        c=0\\n        ans=[]\\n        x=left\\n        for i in isPrime[left:right+1:]:\\n            if i==1:\\n                ans.append(x)\\n            x+=1\\n        for i in range(len(ans)):\\n            if a==-1:\\n                a=ans[i]\\n            else:\\n                if b==-1:\\n                    b=ans[i]\\n                elif b-a>ans[i]-ans[i-1]:\\n                    a=ans[i-1]\\n                    b=ans[i]\\n        if b==-1:\\n            a=-1\\n        return [a,b]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def closestPrimes(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n=10**6+1\\n        isPrime = [1] * n\\n        isPrime[0] = isPrime[1] = 0  \\n        for i in range(2, int(n ** 0.5) + 1):\\n            if isPrime[i]:\\n                isPrime[i * i:n:i] = [0] * ((n - 1 - i * i) // i + 1)\\n        a=-1\\n        b=-1\\n        c=0\\n        ans=[]\\n        x=left\\n        for i in isPrime[left:right+1:]:\\n            if i==1:\\n                ans.append(x)\\n            x+=1\\n        for i in range(len(ans)):\\n            if a==-1:\\n                a=ans[i]\\n            else:\\n                if b==-1:\\n                    b=ans[i]\\n                elif b-a>ans[i]-ans[i-1]:\\n                    a=ans[i-1]\\n                    b=ans[i]\\n        if b==-1:\\n            a=-1\\n        return [a,b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273440,
                "title": "java-solution-easy-to-understand-sieve-pf-eratosthenes",
                "content": "```\\nclass Solution {\\n    public boolean[] prime(int n){\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = true;\\n \\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        return prime;\\n    }\\n    public int[] closestPrimes(int left, int right) {\\n        int[] ans1=new int[2];\\n        ans1[0]=-1;\\n        ans1[1]=-1;\\n        int min=Integer.MAX_VALUE;\\n        boolean[] prime=prime(right);\\n        prime[1]=false;\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=left;i<=right;i++){\\n            if(prime[i]){\\n               ans.add(i);\\n            }\\n        }\\n        for(int i=0;i<ans.size()-1;i++){\\n            int diff=ans.get(i+1)-ans.get(i);\\n            if(diff<min){\\n                ans1[0]=ans.get(i);\\n                ans1[1]=ans.get(i+1);\\n                min=diff;\\n            }\\n        }\\n        return ans1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] prime(int n){\\n        boolean prime[] = new boolean[n + 1];\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = true;\\n \\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        return prime;\\n    }\\n    public int[] closestPrimes(int left, int right) {\\n        int[] ans1=new int[2];\\n        ans1[0]=-1;\\n        ans1[1]=-1;\\n        int min=Integer.MAX_VALUE;\\n        boolean[] prime=prime(right);\\n        prime[1]=false;\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(int i=left;i<=right;i++){\\n            if(prime[i]){\\n               ans.add(i);\\n            }\\n        }\\n        for(int i=0;i<ans.size()-1;i++){\\n            int diff=ans.get(i+1)-ans.get(i);\\n            if(diff<min){\\n                ans1[0]=ans.get(i);\\n                ans1[1]=ans.get(i+1);\\n                min=diff;\\n            }\\n        }\\n        return ans1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268144,
                "title": "solution-using-sieve-of-eratosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n       int size=right+1;\\n        vector<bool> result(size,true);\\nresult[0]=result[1]=false;\\nint cnt=0;\\n       int a=0;int b=0;int diff=INT_MAX;\\n       int p1=-1;int p2=-1;\\n        for(int i=2;i<=right;i++){\\n            result[0]=result[1]=false;\\n            if(result[i]==true){\\n               \\n                if(i>=left){\\n                      cnt++;\\n                    b=i;\\n                    if(b-a<diff){\\n                        diff=b-a;\\n                        p1=a;\\n                        p2=b;\\n                    }\\n                    a=b;\\n                }\\n                for(int j=2;j*i<=right;j++){\\n                    result[i*j]=false;\\n                }\\n            }\\n        }\\n        vector<int>x;\\n        if(cnt==1){\\n           x.push_back(-1);\\n           x.push_back(-1);\\n        }\\n        else{\\n            x.push_back(p1);\\n            x.push_back(p2);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n       int size=right+1;\\n        vector<bool> result(size,true);\\nresult[0]=result[1]=false;\\nint cnt=0;\\n       int a=0;int b=0;int diff=INT_MAX;\\n       int p1=-1;int p2=-1;\\n        for(int i=2;i<=right;i++){\\n            result[0]=result[1]=false;\\n            if(result[i]==true){\\n               \\n                if(i>=left){\\n                      cnt++;\\n                    b=i;\\n                    if(b-a<diff){\\n                        diff=b-a;\\n                        p1=a;\\n                        p2=b;\\n                    }\\n                    a=b;\\n                }\\n                for(int j=2;j*i<=right;j++){\\n                    result[i*j]=false;\\n                }\\n            }\\n        }\\n        vector<int>x;\\n        if(cnt==1){\\n           x.push_back(-1);\\n           x.push_back(-1);\\n        }\\n        else{\\n            x.push_back(p1);\\n            x.push_back(p2);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261798,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number[]}\\n */\\nvar closestPrimes = function(left, right) {\\n    let res = Infinity;\\n    let result=[-1,-1]\\n    let last = 0;\\n    for(let i=left; i<=right; i++){\\n        if(isPrime(i)){\\n            if(last!=0){\\n                if(i-last<res){\\n                    res=i-last;\\n                    result=[last,i]\\n                }\\n            }\\n            last=i;\\n        }\\n    }\\n    return result;\\n};\\nfunction isPrime(n) {\\n  if (n <= 1) {\\n    return false;\\n  }\\n  if (n <= 3) {\\n    return true;\\n  }\\n  if (n % 2 === 0 || n % 3 === 0) {\\n    return false;\\n  }\\n  for (let i = 5; i * i <= n; i += 6) {\\n    if (n % i === 0 || n % (i + 2) === 0) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number[]}\\n */\\nvar closestPrimes = function(left, right) {\\n    let res = Infinity;\\n    let result=[-1,-1]\\n    let last = 0;\\n    for(let i=left; i<=right; i++){\\n        if(isPrime(i)){\\n            if(last!=0){\\n                if(i-last<res){\\n                    res=i-last;\\n                    result=[last,i]\\n                }\\n            }\\n            last=i;\\n        }\\n    }\\n    return result;\\n};\\nfunction isPrime(n) {\\n  if (n <= 1) {\\n    return false;\\n  }\\n  if (n <= 3) {\\n    return true;\\n  }\\n  if (n % 2 === 0 || n % 3 === 0) {\\n    return false;\\n  }\\n  for (let i = 5; i * i <= n; i += 6) {\\n    if (n % i === 0 || n % (i + 2) === 0) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3226782,
                "title": "prime-numbers-in-range-javascript-runtime-75-ms",
                "content": "# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number[]}\\n */\\nbuff = []           // global buff to store prime numbers\\n\\nvar closestPrimes = function(left, right) {    \\n    prime = []          // store result\\n    last_val = 0        // temp variable\\n\\n    if (buff.length < 1) buff = Prime_Numbers(10 ** 6)   // calculate prime numbers and set it to buff     \\n    \\n    for (let i = 0; i < buff.length ; i++) {            // go trougth buff (from 2 to 10 ^ 6)\\n        if (buff[i] > right) break                      // if buff[i] more then right break loop\\n        \\n        if (buff[i] >= left) {                          // if buff[i] more then left go on\\n            if (prime.length >= 2) {                    // check if prime array has already 2 elements\\n                if (buff[i] - last_val < prime[1] - prime[0]) {     // check prime nums difference\\n                    prime[0] = last_val                             // rewrite prime[0] with new value\\n                    prime[1] = buff[i]                              // rewrite prime[1] with new value\\n                }\\n            } else {            \\n                prime.push(buff[i])                     // fill prime if prime has not at least 2 values\\n            }            \\n            last_val = buff[i]                          // store last value for buff[i]\\n        }      \\n    }  \\n\\n    function Prime_Numbers(n) {                         // search prime numbers and return in array\\n        output = []        \\n        isPrime = new Array(n).fill(true)        \\n        isPrime[1] = false\\n        \\n        for (let i = 2; i * i < n; i++) {\\n            if (!isPrime[i]) continue\\n            for (let j = i * i; j < n; j += i) isPrime[j] = false\\n        }\\n        \\n        for (let i = 1; i < n; i++) \\n            if (isPrime[i]) output.push(i)\\n        \\n        return output\\n    } \\n\\n    if (prime.length < 2) prime = [-1, -1]              // if prime has not at least 2 values -> [-1, -1]\\n\\n    return prime                // return result array\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number[]}\\n */\\nbuff = []           // global buff to store prime numbers\\n\\nvar closestPrimes = function(left, right) {    \\n    prime = []          // store result\\n    last_val = 0        // temp variable\\n\\n    if (buff.length < 1) buff = Prime_Numbers(10 ** 6)   // calculate prime numbers and set it to buff     \\n    \\n    for (let i = 0; i < buff.length ; i++) {            // go trougth buff (from 2 to 10 ^ 6)\\n        if (buff[i] > right) break                      // if buff[i] more then right break loop\\n        \\n        if (buff[i] >= left) {                          // if buff[i] more then left go on\\n            if (prime.length >= 2) {                    // check if prime array has already 2 elements\\n                if (buff[i] - last_val < prime[1] - prime[0]) {     // check prime nums difference\\n                    prime[0] = last_val                             // rewrite prime[0] with new value\\n                    prime[1] = buff[i]                              // rewrite prime[1] with new value\\n                }\\n            } else {            \\n                prime.push(buff[i])                     // fill prime if prime has not at least 2 values\\n            }            \\n            last_val = buff[i]                          // store last value for buff[i]\\n        }      \\n    }  \\n\\n    function Prime_Numbers(n) {                         // search prime numbers and return in array\\n        output = []        \\n        isPrime = new Array(n).fill(true)        \\n        isPrime[1] = false\\n        \\n        for (let i = 2; i * i < n; i++) {\\n            if (!isPrime[i]) continue\\n            for (let j = i * i; j < n; j += i) isPrime[j] = false\\n        }\\n        \\n        for (let i = 1; i < n; i++) \\n            if (isPrime[i]) output.push(i)\\n        \\n        return output\\n    } \\n\\n    if (prime.length < 2) prime = [-1, -1]              // if prime has not at least 2 values -> [-1, -1]\\n\\n    return prime                // return result array\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222025,
                "title": "sieve-of-eratosthenes",
                "content": "It\\'s easy if you know the algorithm.\\nYou can look it up here \\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\\nhttps://www.geeksforgeeks.org/sieve-of-eratosthenes/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        //just find all prime numbers between left and right \\n        // look for the one with the minimum difference.\\n        \\n        vector<int>answer = {-1,-1};\\n        \\n        vector<int>isPrime(right+3,true);\\n        isPrime[0]=isPrime[1] = false;\\n        \\n        for(int i = 2; i <= right; i++){\\n            \\n             if(isPrime[i]){\\n                 \\n                for(long long j = 1ll*i*i; j <=right; j+=i){\\n                    \\n                       isPrime[j] = false;\\n                }\\n                 \\n             }\\n            \\n        }\\n        \\n        vector<int>primes;\\n        \\n        for(int i = left; i <= right; i++){\\n               \\n               if(isPrime[i]){\\n                      \\n                       primes.push_back(i);\\n               }\\n        }\\n        \\n        if(primes.size() <2)return answer;\\n        \\n        int diff = INT_MAX;\\n        \\n        for(int i = 1; i < primes.size(); i++){\\n              diff = min(diff, primes[i]-primes[i-1]);\\n        }\\n        \\n        for(int i = 1; i < primes.size(); i++){\\n               if(primes[i]-primes[i-1]== diff){\\n                     answer = {primes[i-1],primes[i]};\\n                     break;\\n               }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        //just find all prime numbers between left and right \\n        // look for the one with the minimum difference.\\n        \\n        vector<int>answer = {-1,-1};\\n        \\n        vector<int>isPrime(right+3,true);\\n        isPrime[0]=isPrime[1] = false;\\n        \\n        for(int i = 2; i <= right; i++){\\n            \\n             if(isPrime[i]){\\n                 \\n                for(long long j = 1ll*i*i; j <=right; j+=i){\\n                    \\n                       isPrime[j] = false;\\n                }\\n                 \\n             }\\n            \\n        }\\n        \\n        vector<int>primes;\\n        \\n        for(int i = left; i <= right; i++){\\n               \\n               if(isPrime[i]){\\n                      \\n                       primes.push_back(i);\\n               }\\n        }\\n        \\n        if(primes.size() <2)return answer;\\n        \\n        int diff = INT_MAX;\\n        \\n        for(int i = 1; i < primes.size(); i++){\\n              diff = min(diff, primes[i]-primes[i-1]);\\n        }\\n        \\n        for(int i = 1; i < primes.size(); i++){\\n               if(primes[i]-primes[i-1]== diff){\\n                     answer = {primes[i-1],primes[i]};\\n                     break;\\n               }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205429,
                "title": "c-sieve-sparse-table-precalc-o-log-n-for-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nprecalculate O(n log n)\\nquery O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconstexpr uint max_n = 1E6;\\nbool mark_primes[max_n + 1];\\nvector<uint> primes;\\n\\nvoid sieve() {\\n    for (uint i = 2; i <= max_n; i++) {\\n        if (!mark_primes[i]) {\\n            primes.push_back(i);\\n            for (uint j = i * i; j <= max_n; j += i) {\\n                mark_primes[j] = 1;\\n            }\\n        }\\n    }\\n}\\n\\ntemplate <typename T>\\nclass minimum {\\npublic:\\n\\ttypedef T value_type;\\n\\tvalue_type n_value = numeric_limits<T>::max();\\n\\tconst auto& operator()(const T& lhs, const T& rhs) {\\n\\t\\treturn std::min(lhs, rhs);\\n\\t}\\n};\\n\\ntemplate <typename T, typename Function = minimum<T>>\\nclass sparse_table {\\npublic:\\n\\tusing value_type = T;\\nprivate:\\n\\tvector<vector<value_type>> mins {};\\n\\tvector<uint>                lg2  {};\\n\\tFunction                   fn   {};\\npublic:\\n\\tsparse_table() = default;\\n\\tsparse_table(const vector<T>& __d) {\\n\\t\\tbuild(__d);\\n\\t}\\n    void build(const vector<T>& __d) {\\n        mins = {{__d}};\\n        lg2 = vector<uint>(__d.size() + 1, 0);\\n        uint n = __d.size();\\n\\t\\tfor (uint i = 1; (1 << i) <= n; i++) {\\n\\t\\t\\tmins.push_back(vector<value_type>(n - (i << 1) + 1));\\n\\t\\t\\tfor (uint j = 0; j < n - (1 << i) + 1; j++) {\\n\\t\\t\\t\\tmins[i][j] = fn(mins[i - 1][j], mins[i - 1][j + (1 << (i - 1))]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (uint i = 2; i <= n; i++)\\n\\t\\t\\tlg2[i] = lg2[i >> 1] + 1;\\n    }\\n\\t// [l...r)\\n\\tauto query(int l, int r) {\\n\\t\\tint i = lg2[r - l];\\n\\t\\treturn fn(mins[i][l], mins[i][r - (1 << i)]);\\n\\t}\\n};\\n\\nsparse_table<pair<uint, uint>> st;\\n\\nstatic const int precalc = [](){\\n    sieve();\\n    vector<pair<uint, uint>> diffs = {};\\n    for (uint i = 1; i < primes.size(); i++)\\n        diffs.push_back({primes[i] - primes[i - 1], i});\\n    st.build(diffs);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int i = distance(primes.begin(), lower_bound(primes.begin(), primes.end(), left));\\n        int j = distance(primes.begin(), upper_bound(primes.begin(), primes.end(), right));\\n        if (j - i < 2) return {-1, -1};\\n        int k = st.query(i, j - 1).second;\\n        return {int(primes[k - 1]), int(primes[k])};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconstexpr uint max_n = 1E6;\\nbool mark_primes[max_n + 1];\\nvector<uint> primes;\\n\\nvoid sieve() {\\n    for (uint i = 2; i <= max_n; i++) {\\n        if (!mark_primes[i]) {\\n            primes.push_back(i);\\n            for (uint j = i * i; j <= max_n; j += i) {\\n                mark_primes[j] = 1;\\n            }\\n        }\\n    }\\n}\\n\\ntemplate <typename T>\\nclass minimum {\\npublic:\\n\\ttypedef T value_type;\\n\\tvalue_type n_value = numeric_limits<T>::max();\\n\\tconst auto& operator()(const T& lhs, const T& rhs) {\\n\\t\\treturn std::min(lhs, rhs);\\n\\t}\\n};\\n\\ntemplate <typename T, typename Function = minimum<T>>\\nclass sparse_table {\\npublic:\\n\\tusing value_type = T;\\nprivate:\\n\\tvector<vector<value_type>> mins {};\\n\\tvector<uint>                lg2  {};\\n\\tFunction                   fn   {};\\npublic:\\n\\tsparse_table() = default;\\n\\tsparse_table(const vector<T>& __d) {\\n\\t\\tbuild(__d);\\n\\t}\\n    void build(const vector<T>& __d) {\\n        mins = {{__d}};\\n        lg2 = vector<uint>(__d.size() + 1, 0);\\n        uint n = __d.size();\\n\\t\\tfor (uint i = 1; (1 << i) <= n; i++) {\\n\\t\\t\\tmins.push_back(vector<value_type>(n - (i << 1) + 1));\\n\\t\\t\\tfor (uint j = 0; j < n - (1 << i) + 1; j++) {\\n\\t\\t\\t\\tmins[i][j] = fn(mins[i - 1][j], mins[i - 1][j + (1 << (i - 1))]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (uint i = 2; i <= n; i++)\\n\\t\\t\\tlg2[i] = lg2[i >> 1] + 1;\\n    }\\n\\t// [l...r)\\n\\tauto query(int l, int r) {\\n\\t\\tint i = lg2[r - l];\\n\\t\\treturn fn(mins[i][l], mins[i][r - (1 << i)]);\\n\\t}\\n};\\n\\nsparse_table<pair<uint, uint>> st;\\n\\nstatic const int precalc = [](){\\n    sieve();\\n    vector<pair<uint, uint>> diffs = {};\\n    for (uint i = 1; i < primes.size(); i++)\\n        diffs.push_back({primes[i] - primes[i - 1], i});\\n    st.build(diffs);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int i = distance(primes.begin(), lower_bound(primes.begin(), primes.end(), left));\\n        int j = distance(primes.begin(), upper_bound(primes.begin(), primes.end(), right));\\n        if (j - i < 2) return {-1, -1};\\n        int k = st.query(i, j - 1).second;\\n        return {int(primes[k - 1]), int(primes[k])};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193300,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> closestPrimes(int left, int right) {\\n   List<int>  primes = [];\\n   Map<int, List<int>> diffs = {};\\n      for( var i = left ; i <= right; i++) { \\n         if(isPrime(i)){\\n            if(primes.isEmpty){\\n                primes.add(i);\\n            } else {\\n                final diff = i - primes.last;\\n                if(diffs[diff] == null) {\\n                    diffs[diff] = [primes.last, i];\\n                }\\n                primes.add(i);\\n                if(diffs[1] != null){\\n                    return diffs[1]!;\\n                }\\n                if(diffs[2] != null){\\n                    return diffs[2]!;\\n                }\\n            }\\n         } \\n      }\\n      return diffs.keys.isEmpty ? [-1, -1] : diffs[diffs.keys.toList().reduce(min)]!;\\n  }\\n\\n  bool isPrime(int num){\\n   if (num <= 1){\\n      return false;\\n   }\\n   for (int j = 2; j <= num/2; j++){\\n      if (num % j == 0) { \\n          return false;\\n     }\\n   }\\n   return true;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> closestPrimes(int left, int right) {\\n   List<int>  primes = [];\\n   Map<int, List<int>> diffs = {};\\n      for( var i = left ; i <= right; i++) { \\n         if(isPrime(i)){\\n            if(primes.isEmpty){\\n                primes.add(i);\\n            } else {\\n                final diff = i - primes.last;\\n                if(diffs[diff] == null) {\\n                    diffs[diff] = [primes.last, i];\\n                }\\n                primes.add(i);\\n                if(diffs[1] != null){\\n                    return diffs[1]!;\\n                }\\n                if(diffs[2] != null){\\n                    return diffs[2]!;\\n                }\\n            }\\n         } \\n      }\\n      return diffs.keys.isEmpty ? [-1, -1] : diffs[diffs.keys.toList().reduce(min)]!;\\n  }\\n\\n  bool isPrime(int num){\\n   if (num <= 1){\\n      return false;\\n   }\\n   for (int j = 2; j <= num/2; j++){\\n      if (num % j == 0) { \\n          return false;\\n     }\\n   }\\n   return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172124,
                "title": "c-sieve-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n  const int n = 1000005;\\n   vector<int> prime(n+1,1);\\n\\nclass Solution {\\npublic:\\n\\n \\n\\n    vector<int> closestPrimes(int left, int right) {\\n        \\n\\n\\n         //sieve\\n         prime[0]=prime[1]=0;\\n         for(int i=2;i<=n;i++)\\n         {\\n               if(prime[i])\\n               {\\n                   for(int j=2*i;j<=n;j+=i){\\n                       prime[j]=false;\\n                   }\\n               }\\n         }\\n\\n\\n        vector<int> ans;\\n\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(prime[i])ans.push_back(i);\\n        }\\n\\n        if(ans.size()<=1) return {-1,-1};\\n        int mn = INT_MAX;\\n        for(int i=1;i<ans.size();i++)\\n        {\\n               int curr = ans[i]-ans[i-1];\\n               mn=min(mn,curr);\\n        }\\n\\n\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            int curr = ans[i]-ans[i-1];\\n            if(curr==mn) return {ans[i-1],ans[i]};\\n        }\\n\\n\\n        return {};\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n  const int n = 1000005;\\n   vector<int> prime(n+1,1);\\n\\nclass Solution {\\npublic:\\n\\n \\n\\n    vector<int> closestPrimes(int left, int right) {\\n        \\n\\n\\n         //sieve\\n         prime[0]=prime[1]=0;\\n         for(int i=2;i<=n;i++)\\n         {\\n               if(prime[i])\\n               {\\n                   for(int j=2*i;j<=n;j+=i){\\n                       prime[j]=false;\\n                   }\\n               }\\n         }\\n\\n\\n        vector<int> ans;\\n\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(prime[i])ans.push_back(i);\\n        }\\n\\n        if(ans.size()<=1) return {-1,-1};\\n        int mn = INT_MAX;\\n        for(int i=1;i<ans.size();i++)\\n        {\\n               int curr = ans[i]-ans[i-1];\\n               mn=min(mn,curr);\\n        }\\n\\n\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            int curr = ans[i]-ans[i-1];\\n            if(curr==mn) return {ans[i-1],ans[i]};\\n        }\\n\\n\\n        return {};\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168442,
                "title": "c-not-c-0-ms-beats-100",
                "content": "# Code\\n```\\nint min(int a, int b) {\\n    return a < b ? a : b;\\n}\\n\\nint is_prime(int n) {\\n    if (n <= 1) {\\n        return 0;\\n    }\\n    int i;\\n    for (i = 2; i <= sqrt(n); ++i) {\\n        if (n % i == 0) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\n\\nint* closestPrimes(int left, int right, int* returnSize) {\\n    int* closestPrimes = (int*)malloc(2 * sizeof(int));\\n    closestPrimes[0] = -1;\\n    closestPrimes[1] = -1;\\n    if (right <= 1) {\\n        *returnSize = 2;\\n        return closestPrimes;\\n    }\\n    int* primes = (int*)malloc((right - left + 1) * sizeof(int));\\n    int primeCount = 0;\\n    int minDiff = INT_MAX;\\n    int i;\\n    for (i = left; i <= right; ++i) {\\n        if (is_prime(i)) {\\n            primes[primeCount++] = i;\\n            if (primeCount >= 2 && primes[primeCount - 1] - primes[primeCount - 2] < minDiff) {\\n                minDiff = primes[primeCount - 1] - primes[primeCount - 2];\\n                closestPrimes[0] = primes[primeCount - 2];\\n                closestPrimes[1] = primes[primeCount - 1];\\n                if (minDiff <= 2) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    *returnSize = 2;\\n    free(primes);\\n    return closestPrimes;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint min(int a, int b) {\\n    return a < b ? a : b;\\n}\\n\\nint is_prime(int n) {\\n    if (n <= 1) {\\n        return 0;\\n    }\\n    int i;\\n    for (i = 2; i <= sqrt(n); ++i) {\\n        if (n % i == 0) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\n\\nint* closestPrimes(int left, int right, int* returnSize) {\\n    int* closestPrimes = (int*)malloc(2 * sizeof(int));\\n    closestPrimes[0] = -1;\\n    closestPrimes[1] = -1;\\n    if (right <= 1) {\\n        *returnSize = 2;\\n        return closestPrimes;\\n    }\\n    int* primes = (int*)malloc((right - left + 1) * sizeof(int));\\n    int primeCount = 0;\\n    int minDiff = INT_MAX;\\n    int i;\\n    for (i = left; i <= right; ++i) {\\n        if (is_prime(i)) {\\n            primes[primeCount++] = i;\\n            if (primeCount >= 2 && primes[primeCount - 1] - primes[primeCount - 2] < minDiff) {\\n                minDiff = primes[primeCount - 1] - primes[primeCount - 2];\\n                closestPrimes[0] = primes[primeCount - 2];\\n                closestPrimes[1] = primes[primeCount - 1];\\n                if (minDiff <= 2) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    *returnSize = 2;\\n    free(primes);\\n    return closestPrimes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3168361,
                "title": "php-10-25ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public function closestPrimes($left, $right) {\\n        $closestPrimes = array(-1, -1);\\n        if ($right <= 1) {\\n            return $closestPrimes;\\n        }\\n        $primes = array();\\n        $minDiff = PHP_INT_MAX;\\n        for ($i = $left; $i <= $right; ++$i) {\\n            if ($this->isPrime($i)) {\\n                $primes[] = $i;\\n                $primeCount = count($primes);\\n                if ($primeCount >= 2 && $primes[$primeCount - 1] - $primes[$primeCount - 2] < $minDiff) {\\n                    $minDiff = $primes[$primeCount - 1] - $primes[$primeCount - 2];\\n                    $closestPrimes[0] = $primes[$primeCount - 2];\\n                    $closestPrimes[1] = $primes[$primeCount - 1];\\n                    if ($minDiff <= 2) {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return $closestPrimes;\\n    }\\n\\n    private function isPrime($n) {\\n        if ($n <= 1) {\\n            return false;\\n        }\\n        for ($i = 2; $i <= sqrt($n); ++$i) {\\n            if ($n % $i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    public function closestPrimes($left, $right) {\\n        $closestPrimes = array(-1, -1);\\n        if ($right <= 1) {\\n            return $closestPrimes;\\n        }\\n        $primes = array();\\n        $minDiff = PHP_INT_MAX;\\n        for ($i = $left; $i <= $right; ++$i) {\\n            if ($this->isPrime($i)) {\\n                $primes[] = $i;\\n                $primeCount = count($primes);\\n                if ($primeCount >= 2 && $primes[$primeCount - 1] - $primes[$primeCount - 2] < $minDiff) {\\n                    $minDiff = $primes[$primeCount - 1] - $primes[$primeCount - 2];\\n                    $closestPrimes[0] = $primes[$primeCount - 2];\\n                    $closestPrimes[1] = $primes[$primeCount - 1];\\n                    if ($minDiff <= 2) {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return $closestPrimes;\\n    }\\n\\n    private function isPrime($n) {\\n        if ($n <= 1) {\\n            return false;\\n        }\\n        for ($i = 2; $i <= sqrt($n); ++$i) {\\n            if ($n % $i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146453,
                "title": "c-golang-seive",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> isPrime(right + 1, true);\\n        isPrime[0] = isPrime[1] = false;\\n        for(int i = 2; i <= right; i++) {\\n            if(!isPrime[i]) continue;\\n            for(int j = i + i; j <= right; j += i) {\\n                isPrime[j] = false;\\n            }\\n        }\\n        vector<int> ans = {0, INT_MAX};\\n        int prevPrime = -1;\\n        for(int i = left; i <= right; i++) {\\n            if(isPrime[i]) {\\n                if(prevPrime != -1 && i - prevPrime < ans[1] - ans[0])\\n                    ans = {prevPrime, i};\\n                prevPrime = i;\\n            }\\n        }\\n        if(ans[1] == INT_MAX) return {-1, -1};\\n        return ans;\\n    }\\n};\\n\\n// Golang\\nfunc closestPrimes(left int, right int) []int {\\n    notPrime := make([]bool, right + 1)\\n    notPrime[0], notPrime[1] = true, true\\n    for i := 2; i <= right; i++ {\\n        if notPrime[i] {continue}\\n        for j := i + i; j <= right; j += i {\\n            notPrime[j] = true\\n        }\\n    }\\n    ans := []int{0, math.MaxInt}\\n    var prevPrime int = -1\\n    for i := left; i <= right; i++ {\\n        if !notPrime[i] {\\n            if prevPrime != -1 && i - prevPrime < ans[1] - ans[0] {\\n                ans[0], ans[1] = prevPrime, i\\n            }\\n            prevPrime = i\\n        }\\n    }\\n    if ans[1] == math.MaxInt {return []int{-1, -1}}\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> isPrime(right + 1, true);\\n        isPrime[0] = isPrime[1] = false;\\n        for(int i = 2; i <= right; i++) {\\n            if(!isPrime[i]) continue;\\n            for(int j = i + i; j <= right; j += i) {\\n                isPrime[j] = false;\\n            }\\n        }\\n        vector<int> ans = {0, INT_MAX};\\n        int prevPrime = -1;\\n        for(int i = left; i <= right; i++) {\\n            if(isPrime[i]) {\\n                if(prevPrime != -1 && i - prevPrime < ans[1] - ans[0])\\n                    ans = {prevPrime, i};\\n                prevPrime = i;\\n            }\\n        }\\n        if(ans[1] == INT_MAX) return {-1, -1};\\n        return ans;\\n    }\\n};\\n\\n// Golang\\nfunc closestPrimes(left int, right int) []int {\\n    notPrime := make([]bool, right + 1)\\n    notPrime[0], notPrime[1] = true, true\\n    for i := 2; i <= right; i++ {\\n        if notPrime[i] {continue}\\n        for j := i + i; j <= right; j += i {\\n            notPrime[j] = true\\n        }\\n    }\\n    ans := []int{0, math.MaxInt}\\n    var prevPrime int = -1\\n    for i := left; i <= right; i++ {\\n        if !notPrime[i] {\\n            if prevPrime != -1 && i - prevPrime < ans[1] - ans[0] {\\n                ans[0], ans[1] = prevPrime, i\\n            }\\n            prevPrime = i\\n        }\\n    }\\n    if ans[1] == math.MaxInt {return []int{-1, -1}}\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145618,
                "title": "simple-java-solution-using-soe-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int n=right;\\n        ArrayList<Integer> primes=new ArrayList<>();\\n        boolean []prime=new boolean[right+1];\\n        \\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]==false){\\n                for(int j=i*i;j<=n;j+=i){\\n                    prime[j]=true;\\n                }\\n            }\\n        }\\n        for(int i=left;i<=right;i++){\\n            if(prime[i]==false){\\n                primes.add(i);\\n            }\\n        }\\n        if (left<=1) {\\n            primes.remove(0);\\n        }\\n        \\n        int[] ans=new int[2];\\n        ans[0]=-1;\\n        ans[1]=-1;\\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=1;i<primes.size();i++){\\n            if(primes.get(i)-primes.get(i-1)<min){\\n                ans[0]=primes.get(i-1);\\n                ans[1]=primes.get(i);\\n                min=primes.get(i)-primes.get(i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int n=right;\\n        ArrayList<Integer> primes=new ArrayList<>();\\n        boolean []prime=new boolean[right+1];\\n        \\n        for(int i=2;i*i<=n;i++){\\n            if(prime[i]==false){\\n                for(int j=i*i;j<=n;j+=i){\\n                    prime[j]=true;\\n                }\\n            }\\n        }\\n        for(int i=left;i<=right;i++){\\n            if(prime[i]==false){\\n                primes.add(i);\\n            }\\n        }\\n        if (left<=1) {\\n            primes.remove(0);\\n        }\\n        \\n        int[] ans=new int[2];\\n        ans[0]=-1;\\n        ans[1]=-1;\\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=1;i<primes.size();i++){\\n            if(primes.get(i)-primes.get(i-1)<min){\\n                ans[0]=primes.get(i-1);\\n                ans[1]=primes.get(i);\\n                min=primes.get(i)-primes.get(i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142658,
                "title": "c-sieve-of-eratosthenes-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> v(1+right, true);\\n        v[0] = v[1] = false;\\n        for(int i=2;i<=sqrt(right+1);i++){\\n            if(!v[i]) continue;\\n            for(int j=2;j<=right/i; j++){\\n                v[j*i] = false;\\n            }\\n        }   \\n\\n      //  for(int i=0;i<=right;i++) if(v[i]) cout<<i<<\" \";\\n\\n        int minDis = 1e9, pre = -1, l = -1, r = -1;\\n        for(int i = left;i<=right;i++){\\n            if(v[i]){\\n                if(pre != -1 && i - pre < minDis){\\n                    minDis = i - pre;\\n                    l = pre, r = i;\\n                }\\n                pre = i;\\n            }\\n        }\\n        return {l, r};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> v(1+right, true);\\n        v[0] = v[1] = false;\\n        for(int i=2;i<=sqrt(right+1);i++){\\n            if(!v[i]) continue;\\n            for(int j=2;j<=right/i; j++){\\n                v[j*i] = false;\\n            }\\n        }   \\n\\n      //  for(int i=0;i<=right;i++) if(v[i]) cout<<i<<\" \";\\n\\n        int minDis = 1e9, pre = -1, l = -1, r = -1;\\n        for(int i = left;i<=right;i++){\\n            if(v[i]){\\n                if(pre != -1 && i - pre < minDis){\\n                    minDis = i - pre;\\n                    l = pre, r = i;\\n                }\\n                pre = i;\\n            }\\n        }\\n        return {l, r};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3139150,
                "title": "c-easy-approach-explained",
                "content": "# Approach\\nApplying Sieve of Eratosthenes.\\nSieve of Eratosthenes method states that if we want to find the prime number between a given range(left,right) than make a array of size right+1 and initially mark all elements as 0.\\nAfter that start from 2 (bcz it the smallest prime number) and mark all the factors of 2 as visited and after that check for next unmaked element and mark its all factors as visited .\\n\\nAt the end only those numbers left unvisited which are not a factor of any number.\\n\\nNow store those all numbers in an array and find minimum 2 elemnts \\nwith minimum difference.\\n\\n# Complexity\\n- Time complexity: O(right+1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(righ+1)+O(prime)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        vector<int>ans(2,-1);\\n        vector<int>mark(right+1,0);\\n        vector<int>prime;\\n        if(left==1)\\n        left++;\\n        for(long i=2;i<=right;i++)\\n        {\\n            if(mark[i]==0)\\n            {\\n                for(long j=i*i;j<=right;j=j+i)\\n                {\\n                    mark[j]=1;\\n                }\\n            }\\n        } \\n          \\n        for(int i=left;i<=right;i++)\\n        {\\n            if(mark[i]==0)\\n            {\\n                //cout<<i<<\"  \";\\n                prime.push_back(i);\\n            }    \\n        } \\n\\n        if(prime.size()==1)\\n        return ans;\\n\\n        int n=prime.size();\\n        int i=0,j=1;\\n        int mini=INT_MAX;\\n        int n1=-1,n2=-1;\\n        for( ;i<n && j<n ;i++,j++)\\n        {\\n            int t1=prime[i];\\n            int t2=prime[j];\\n            int diff=t2-t1;\\n            if(mini>diff)\\n            {\\n                mini=diff;\\n                n1=t1;\\n                n2=t2;\\n            }\\n        }\\n        ans[0]=n1;\\n        ans[1]=n2;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        vector<int>ans(2,-1);\\n        vector<int>mark(right+1,0);\\n        vector<int>prime;\\n        if(left==1)\\n        left++;\\n        for(long i=2;i<=right;i++)\\n        {\\n            if(mark[i]==0)\\n            {\\n                for(long j=i*i;j<=right;j=j+i)\\n                {\\n                    mark[j]=1;\\n                }\\n            }\\n        } \\n          \\n        for(int i=left;i<=right;i++)\\n        {\\n            if(mark[i]==0)\\n            {\\n                //cout<<i<<\"  \";\\n                prime.push_back(i);\\n            }    \\n        } \\n\\n        if(prime.size()==1)\\n        return ans;\\n\\n        int n=prime.size();\\n        int i=0,j=1;\\n        int mini=INT_MAX;\\n        int n1=-1,n2=-1;\\n        for( ;i<n && j<n ;i++,j++)\\n        {\\n            int t1=prime[i];\\n            int t2=prime[j];\\n            int diff=t2-t1;\\n            if(mini>diff)\\n            {\\n                mini=diff;\\n                n1=t1;\\n                n2=t2;\\n            }\\n        }\\n        ans[0]=n1;\\n        ans[1]=n2;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3138630,
                "title": "c-easy-optimized",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void fillPrimes(vector<int>& prime, int high)\\n    {\\n        bool ck[high + 1];\\n        memset(ck, true, sizeof(ck));\\n        ck[1] = false;\\n        ck[0] = false;\\n        for (int i = 2; (i * i) <= high; i++) {\\n            if (ck[i] == true) {\\n                for (int j = i * i; j <= sqrt(high); j = j + i) {\\n                    ck[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i * i <= high; i++) {\\n            if (ck[i] == true) {\\n                prime.push_back(i);\\n            }\\n        }\\n    }\\n    void segmentedSieve(int low, int high)\\n    {\\n        if (low<2 and high>=2){\\n            low = 2;\\n        }\\n        bool prime[high - low + 1];\\n\\n        memset(prime, true, sizeof(prime));\\n\\n        vector<int> chprime;\\n        fillPrimes(chprime, high);\\n\\n        for (int i : chprime) {\\n            int lower = (low / i);\\n\\n            if (lower <= 1) {\\n                lower = i + i;\\n            }\\n            else if (low % i) {\\n                lower = (lower * i) + i;\\n            }\\n            else {\\n                lower = (lower * i);\\n            }\\n            for (int j = lower; j <= high; j = j + i) {\\n                prime[j - low] = false;\\n            }\\n        }\\n\\n        for (int i = low; i <= high; i++) {\\n            if (prime[i - low] == true) {\\n                ans.push_back(i);\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        segmentedSieve(left,right);\\n        sort(ans.begin(),ans.end());\\n        int mini=INT_MAX;\\n        vector<int>arr(2);\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            if(ans[i]-ans[i-1]<mini)\\n            {\\n                mini=ans[i]-ans[i-1];\\n                arr={ans[i-1],ans[i]};\\n            }\\n        }\\n        if(ans.size()<2) return {-1,-1};\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void fillPrimes(vector<int>& prime, int high)\\n    {\\n        bool ck[high + 1];\\n        memset(ck, true, sizeof(ck));\\n        ck[1] = false;\\n        ck[0] = false;\\n        for (int i = 2; (i * i) <= high; i++) {\\n            if (ck[i] == true) {\\n                for (int j = i * i; j <= sqrt(high); j = j + i) {\\n                    ck[j] = false;\\n                }\\n            }\\n        }\\n        for (int i = 2; i * i <= high; i++) {\\n            if (ck[i] == true) {\\n                prime.push_back(i);\\n            }\\n        }\\n    }\\n    void segmentedSieve(int low, int high)\\n    {\\n        if (low<2 and high>=2){\\n            low = 2;\\n        }\\n        bool prime[high - low + 1];\\n\\n        memset(prime, true, sizeof(prime));\\n\\n        vector<int> chprime;\\n        fillPrimes(chprime, high);\\n\\n        for (int i : chprime) {\\n            int lower = (low / i);\\n\\n            if (lower <= 1) {\\n                lower = i + i;\\n            }\\n            else if (low % i) {\\n                lower = (lower * i) + i;\\n            }\\n            else {\\n                lower = (lower * i);\\n            }\\n            for (int j = lower; j <= high; j = j + i) {\\n                prime[j - low] = false;\\n            }\\n        }\\n\\n        for (int i = low; i <= high; i++) {\\n            if (prime[i - low] == true) {\\n                ans.push_back(i);\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        segmentedSieve(left,right);\\n        sort(ans.begin(),ans.end());\\n        int mini=INT_MAX;\\n        vector<int>arr(2);\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            if(ans[i]-ans[i-1]<mini)\\n            {\\n                mini=ans[i]-ans[i-1];\\n                arr={ans[i-1],ans[i]};\\n            }\\n        }\\n        if(ans.size()<2) return {-1,-1};\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127925,
                "title": "easy-understanding-sc-o-1-python3-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you see prime numbers table, then you can see that minimum difference between two prime numbers can be 2,except 2 and 3.\\nExample: (29, 31), (11, 13), (17, 19) you cannot find two distinct prime numbers with difference equal to 1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou should find such prime numbers with difference 2 and return it, otherwise save another prime numbers and return them, there will be minimum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * sqrt(n))$$\\n- Space complexity:\\n- \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def is_prime(n):\\n            if n == 1:\\n                return False\\n            for i in range(2, int(n**0.5) + 1):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        first = 0\\n        ans1, ans2 = 0, 0\\n        for i in range(left, right + 1):\\n            if is_prime(i):\\n                # print(i)\\n                if first:\\n                    if i - first <= 2:\\n                        return [first, i]\\n                    else:\\n                        ans1 = first\\n                        ans2 = i\\n                first = i\\n        return [ans1, ans2] if ans1 and ans2 else [-1, -1]\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def is_prime(n):\\n            if n == 1:\\n                return False\\n            for i in range(2, int(n**0.5) + 1):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        first = 0\\n        ans1, ans2 = 0, 0\\n        for i in range(left, right + 1):\\n            if is_prime(i):\\n                # print(i)\\n                if first:\\n                    if i - first <= 2:\\n                        return [first, i]\\n                    else:\\n                        ans1 = first\\n                        ans2 = i\\n                first = i\\n        return [ans1, ans2] if ans1 and ans2 else [-1, -1]\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125742,
                "title": "java-beats-100-short-and-fast-easy-to-understand-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int n1 = -1, n2 = -1, min1 = -1, min2 = -1, min = Integer.MAX_VALUE;\\n        for(int i = left;i <= right;i++){\\n            if(isPrime(i)){\\n                if(n1 == -1) n1 = i;\\n                else{\\n                    if(n2 == -1) n2 = i;\\n                    else{\\n                        n1 = n2;\\n                        n2 = i;\\n                    }\\n                    if(n2 - n1 < min){\\n                        min1 = n1;\\n                        min2 = n2;\\n                        min = n2 - n1;\\n                        if(min == 1 || min == 2) break;\\n                    }\\n                }\\n            }\\n        }\\n        return new int[]{min1, min2};\\n    }\\n    private boolean isPrime(int n){\\n        if (n < 2){\\n            return false;\\n        }\\n        for(int i = 2; i * i <= n; i++){\\n            if (n % i == 0) return false;\\n        }return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int n1 = -1, n2 = -1, min1 = -1, min2 = -1, min = Integer.MAX_VALUE;\\n        for(int i = left;i <= right;i++){\\n            if(isPrime(i)){\\n                if(n1 == -1) n1 = i;\\n                else{\\n                    if(n2 == -1) n2 = i;\\n                    else{\\n                        n1 = n2;\\n                        n2 = i;\\n                    }\\n                    if(n2 - n1 < min){\\n                        min1 = n1;\\n                        min2 = n2;\\n                        min = n2 - n1;\\n                        if(min == 1 || min == 2) break;\\n                    }\\n                }\\n            }\\n        }\\n        return new int[]{min1, min2};\\n    }\\n    private boolean isPrime(int n){\\n        if (n < 2){\\n            return false;\\n        }\\n        for(int i = 2; i * i <= n; i++){\\n            if (n % i == 0) return false;\\n        }return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114559,
                "title": "c-math-faster-easy-to-understand",
                "content": "* ***Using Math***\\n\\n* ***Time Complexity :- O(Right - Left)***\\n\\n* ***Space Complexity :- O(Right - Left)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> closestPrimes(int left, int right) {\\n        \\n        int n = 1e6 + 1;\\n        \\n        // find all the prime numbers between left and right\\n        \\n        vector<bool> is_prime(n, true);\\n        \\n        for(int i = 2; i <= right; i++)\\n        {\\n            if(is_prime[i])\\n            {\\n                for(int j = 2 * i; j <= right; j += i)\\n                {\\n                    is_prime[j] = false;\\n                }\\n            }\\n        }\\n       \\n        vector<int> primes;\\n        \\n        for(int i = left; i <= right; i++)\\n        {\\n            if(i >= 2 && is_prime[i])\\n            {\\n                primes.push_back(i);\\n            }\\n        }\\n        \\n        // edge case\\n        \\n        if(primes.size() <= 1)\\n        {\\n            return {-1, -1};\\n        }\\n        \\n        // find the numbers with minimum diff.\\n        \\n        int mini = INT_MAX;\\n        \\n        int first = -1;\\n        \\n        int second = -1;\\n        \\n        for(int i = 0; i < primes.size() - 1; i++)\\n        {\\n            int diff = primes[i + 1] - primes[i];\\n            \\n            if(diff < mini)\\n            {\\n                mini = diff;\\n                \\n                first = primes[i];\\n                \\n                second = primes[i + 1];\\n            }\\n        }\\n        \\n        return {first, second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> closestPrimes(int left, int right) {\\n        \\n        int n = 1e6 + 1;\\n        \\n        // find all the prime numbers between left and right\\n        \\n        vector<bool> is_prime(n, true);\\n        \\n        for(int i = 2; i <= right; i++)\\n        {\\n            if(is_prime[i])\\n            {\\n                for(int j = 2 * i; j <= right; j += i)\\n                {\\n                    is_prime[j] = false;\\n                }\\n            }\\n        }\\n       \\n        vector<int> primes;\\n        \\n        for(int i = left; i <= right; i++)\\n        {\\n            if(i >= 2 && is_prime[i])\\n            {\\n                primes.push_back(i);\\n            }\\n        }\\n        \\n        // edge case\\n        \\n        if(primes.size() <= 1)\\n        {\\n            return {-1, -1};\\n        }\\n        \\n        // find the numbers with minimum diff.\\n        \\n        int mini = INT_MAX;\\n        \\n        int first = -1;\\n        \\n        int second = -1;\\n        \\n        for(int i = 0; i < primes.size() - 1; i++)\\n        {\\n            int diff = primes[i + 1] - primes[i];\\n            \\n            if(diff < mini)\\n            {\\n                mini = diff;\\n                \\n                first = primes[i];\\n                \\n                second = primes[i + 1];\\n            }\\n        }\\n        \\n        return {first, second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113940,
                "title": "optimised-js-solution",
                "content": "-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar closestPrimes = function(left, right) {\\n    if(left ==1 && right >= 3){\\n        return [2,3]\\n    }\\n    let isprime = (n)=>{\\n        if(n%2 == 0){return false}\\n        for(let i = 3 ; i < Math.sqrt(n)+1 ;i +=2 ){\\n            if(n%i==0){return false}\\n        }\\n        return true\\n    }\\n    let a = []\\n    for(let i = left ; i < right+1 ;i++ ){\\n        if(isprime(i)){a.push(i)}\\n    }\\n    if(a.length < 2){return [-1,-1]}\\n    let m = 100000\\n    let ans =[]\\n    for(let i = 1 ; i < a.length ;i++ ){\\n        if(a[i] - a[i-1] < m){\\n            m = a[i] - a[i-1]\\n            ans = [a[i-1],a[i]]\\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar closestPrimes = function(left, right) {\\n    if(left ==1 && right >= 3){\\n        return [2,3]\\n    }\\n    let isprime = (n)=>{\\n        if(n%2 == 0){return false}\\n        for(let i = 3 ; i < Math.sqrt(n)+1 ;i +=2 ){\\n            if(n%i==0){return false}\\n        }\\n        return true\\n    }\\n    let a = []\\n    for(let i = left ; i < right+1 ;i++ ){\\n        if(isprime(i)){a.push(i)}\\n    }\\n    if(a.length < 2){return [-1,-1]}\\n    let m = 100000\\n    let ans =[]\\n    for(let i = 1 ; i < a.length ;i++ ){\\n        if(a[i] - a[i-1] < m){\\n            m = a[i] - a[i-1]\\n            ans = [a[i-1],a[i]]\\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3110192,
                "title": "easy-c-solution-using-optimized-isprime-function",
                "content": "# Intuition\\nThe idea is to iterate over all the numbers in the range `left` to `right` and check wheather they are prime or not. Some optimizations done on finding whether the number of prime or not\\n\\n# Approach\\nChecking each number and choosing the first occuring minimum-difference pair\\n\\n# Complexity\\n- Time complexity: $$O(n.root(n))$$\\n\\n- Space complexity: $$O(n)$$ (Note: Space Complexity can be avoided by using just iterators as well and managing the `{-1,-1}` cases)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private :\\n        bool isprime(int n)\\n        {\\n            if(n==2 || n == 3)return true;\\n            if(n==1 || n%2==0 || n % 3 == 0) return false;\\n\\n            for(int i=5;i*i<=n;i+=6)\\n            {\\n                if(n%i==0 || n % (i+2) == 0) return false;\\n            }\\n\\n            return true;\\n        }\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        queue<int> q;\\n        int cnt=0;\\n        for(int i=left ;i <= right ; i++ )\\n        {\\n            if(isprime(i)){\\n                q.push(i);\\n            }\\n        }\\n\\n        if(q.size() < 2) return {-1,-1};\\n        pair<int,int> ans = {-1,-1};\\n\\n        int diff = INT_MAX, first = q.front(), second;\\n        q.pop();\\n\\n        while(!q.empty()){\\n            second = q.front();\\n            q.pop();\\n\\n            if(diff > second - first){\\n                diff = second - first;\\n                ans = {first, second};\\n            }\\n\\n            first = second;\\n        }\\n\\n        return {ans.first,ans.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    private :\\n        bool isprime(int n)\\n        {\\n            if(n==2 || n == 3)return true;\\n            if(n==1 || n%2==0 || n % 3 == 0) return false;\\n\\n            for(int i=5;i*i<=n;i+=6)\\n            {\\n                if(n%i==0 || n % (i+2) == 0) return false;\\n            }\\n\\n            return true;\\n        }\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        queue<int> q;\\n        int cnt=0;\\n        for(int i=left ;i <= right ; i++ )\\n        {\\n            if(isprime(i)){\\n                q.push(i);\\n            }\\n        }\\n\\n        if(q.size() < 2) return {-1,-1};\\n        pair<int,int> ans = {-1,-1};\\n\\n        int diff = INT_MAX, first = q.front(), second;\\n        q.pop();\\n\\n        while(!q.empty()){\\n            second = q.front();\\n            q.pop();\\n\\n            if(diff > second - first){\\n                diff = second - first;\\n                ans = {first, second};\\n            }\\n\\n            first = second;\\n        }\\n\\n        return {ans.first,ans.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104991,
                "title": "c-easiest-way-to-solve-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private :\\n    bool isprime(int n)\\n    {\\n        if(n==2)return true;\\n        if(n==1 || n%2==0)return false;\\n        for(int i=3;i*i<=n;i+=2)\\n        {\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> v;\\n        int cnt=0;\\n        for(int i=left ;i <= right ; i++ )\\n        {\\n            if(isprime(i)){\\n            v.push_back(i);\\n            cnt++;\\n            }\\n        }\\n        if(cnt<2)return {-1,-1};\\n        int num2=v[v.size()-1],num1=v[v.size()-2];\\n        int diff=num2-num1;\\n        for(int i=v.size()-2;i>=1;i--)\\n        {\\n            if(diff>=v[i]-v[i-1])\\n            {\\n                diff=v[i]-v[i-1];\\n                num2=v[i];\\n                num1=v[i-1];\\n            }\\n        }\\n        return {num1,num2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n\\n    private :\\n    bool isprime(int n)\\n    {\\n        if(n==2)return true;\\n        if(n==1 || n%2==0)return false;\\n        for(int i=3;i*i<=n;i+=2)\\n        {\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> v;\\n        int cnt=0;\\n        for(int i=left ;i <= right ; i++ )\\n        {\\n            if(isprime(i)){\\n            v.push_back(i);\\n            cnt++;\\n            }\\n        }\\n        if(cnt<2)return {-1,-1};\\n        int num2=v[v.size()-1],num1=v[v.size()-2];\\n        int diff=num2-num1;\\n        for(int i=v.size()-2;i>=1;i--)\\n        {\\n            if(diff>=v[i]-v[i-1])\\n            {\\n                diff=v[i]-v[i-1];\\n                num2=v[i];\\n                num1=v[i-1];\\n            }\\n        }\\n        return {num1,num2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100861,
                "title": "closest-prime-numbers-in-range-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool isprime(int n){\\n    int i=2;\\n    while(i<=sqrt(n)){\\n        if(n%i==0) return false;\\n        i++;\\n    }\\n    return true;\\n}\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n    int temp= -1;\\n    int diff=INT_MAX;\\n    int x= -1,y= -1;\\n    if(left==1) left++;\\n    for(int i=left;i<=right;i++){\\n        if(isprime(i)){\\n         if(temp== -1) temp=i;\\n         else{\\n            if(diff > i-temp){\\n                x=temp;\\n                y=i;\\n                diff=i-temp;\\n            }\\n            temp=i;\\n         }\\n        }\\n    }\\n    vector<int>v={x,y};\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isprime(int n){\\n    int i=2;\\n    while(i<=sqrt(n)){\\n        if(n%i==0) return false;\\n        i++;\\n    }\\n    return true;\\n}\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n    int temp= -1;\\n    int diff=INT_MAX;\\n    int x= -1,y= -1;\\n    if(left==1) left++;\\n    for(int i=left;i<=right;i++){\\n        if(isprime(i)){\\n         if(temp== -1) temp=i;\\n         else{\\n            if(diff > i-temp){\\n                x=temp;\\n                y=i;\\n                diff=i-temp;\\n            }\\n            temp=i;\\n         }\\n        }\\n    }\\n    vector<int>v={x,y};\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099608,
                "title": "short-easy-java-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int[] nums = {-1, -1};\\n        int min = Integer.MAX_VALUE;\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = left; i <= right; i++){\\n            if (isPrime(i)){\\n                list.add(i);\\n            }\\n        }\\n        if (list.isEmpty() || list.size() < 2){\\n            return nums;\\n        }\\n        for (int i = 1; i < list.size(); i++){\\n            int temp = list.get(i) - list.get(i-1);\\n            if (min > temp){\\n                min = temp;\\n                nums[0] = list.get(i-1);\\n                nums[1] = list.get(i);\\n            }\\n        }\\n        return nums;\\n    }\\n\\n    boolean isPrime(int n)\\n    {\\n        if (n <= 1)\\n            return false;\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n}\\n```\\nThe function \"isPrime\" first checks if the input (n) is less than or equal to 1, in which case it returns false as 1 and numbers less than 1 are not considered prime numbers.\\n\\nNext, it checks if the input is less than or equal to 3, in which case it returns true because 2 and 3 are prime numbers.\\n\\nThe function then checks if the input is divisible by 2 or 3 using the modulo operator (%), in which case it returns false because prime numbers are not divisible by 2 or 3.\\n\\nThe function then enters a for loop, starting at 5 and ending when the square of the loop variable is greater than the input. The loop variable is incremented by 6 in each iteration. Within the loop, the function checks if the input is divisible by the current loop variable or the current loop variable plus 2 using the modulo operator (%), in which case it returns false because prime numbers are not divisible by any number other than 1 and itself.\\n\\nIf the input passes all of these tests, the function returns true indicating that the input is a prime number.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int[] nums = {-1, -1};\\n        int min = Integer.MAX_VALUE;\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = left; i <= right; i++){\\n            if (isPrime(i)){\\n                list.add(i);\\n            }\\n        }\\n        if (list.isEmpty() || list.size() < 2){\\n            return nums;\\n        }\\n        for (int i = 1; i < list.size(); i++){\\n            int temp = list.get(i) - list.get(i-1);\\n            if (min > temp){\\n                min = temp;\\n                nums[0] = list.get(i-1);\\n                nums[1] = list.get(i);\\n            }\\n        }\\n        return nums;\\n    }\\n\\n    boolean isPrime(int n)\\n    {\\n        if (n <= 1)\\n            return false;\\n        if (n <= 3)\\n            return true;\\n        if (n % 2 == 0 || n % 3 == 0)\\n            return false;\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098472,
                "title": "closest-prime-numbers-in-range-sieve-of-eratosthenes-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        # Sieve Of Eratosthenes method to generate prime no  \\n      \\n        seieve=[0]*(right+1)\\n        seieve[1]=1\\n        seieve[0]=1\\n\\n        for i in range(2,right+1):\\n            if seieve[i]==0:\\n                j=i*i\\n                while(j<=right):\\n                    seieve[j]=1\\n                    j+=i\\n\\n        # list of all prime numbers in a given range (left,right)\\n\\n        prime=[]\\n\\n        for i in range(left,right+1):\\n            if seieve[i]==0:\\n                prime.append(i) \\n\\n\\n        # finding min difference pair \\n\\n        if len(prime)>=2:\\n            \\n            mi=9999999\\n            for i in range(0,len(prime)-1):\\n                s=prime[i+1]-prime[i]\\n\\n                if s<mi:\\n                    mi=s\\n                    result=[prime[i],prime[i+1]]\\n            return result\\n        else:\\n            return [-1,-1]\\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        # Sieve Of Eratosthenes method to generate prime no  \\n      \\n        seieve=[0]*(right+1)\\n        seieve[1]=1\\n        seieve[0]=1\\n\\n        for i in range(2,right+1):\\n            if seieve[i]==0:\\n                j=i*i\\n                while(j<=right):\\n                    seieve[j]=1\\n                    j+=i\\n\\n        # list of all prime numbers in a given range (left,right)\\n\\n        prime=[]\\n\\n        for i in range(left,right+1):\\n            if seieve[i]==0:\\n                prime.append(i) \\n\\n\\n        # finding min difference pair \\n\\n        if len(prime)>=2:\\n            \\n            mi=9999999\\n            for i in range(0,len(prime)-1):\\n                s=prime[i+1]-prime[i]\\n\\n                if s<mi:\\n                    mi=s\\n                    result=[prime[i],prime[i+1]]\\n            return result\\n        else:\\n            return [-1,-1]\\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088560,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int N = 1000001;\\n    vector<bool>sieve = vector<bool>(N + 1,true);\\n    void createSieve() {\\n        sieve[0] = sieve[1] = false;\\n        for(int i = 2; i * i <= N; i++) {\\n            if(sieve[i] == true) {\\n                for(int j = i * i; j <= N; j += i) {\\n                    sieve[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int>nums,ans(2,-1);\\n        if(left == right) {\\n            return ans;\\n        }\\n        createSieve();\\n        int mini = INT_MAX;\\n        for(int i = left; i <= right; i++) {\\n            if(sieve[i]) {\\n                nums.push_back(i);\\n            }\\n        }\\n        if(nums.size() <= 1) {\\n            return ans;\\n        }\\n        for(int i = 0; i < nums.size() - 1; i++) {\\n            int temp = nums[i + 1] - nums[i];\\n            if(temp < mini) {\\n                mini = temp;\\n                ans[0] = nums[i];\\n                ans[1] = nums[i + 1];\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N = 1000001;\\n    vector<bool>sieve = vector<bool>(N + 1,true);\\n    void createSieve() {\\n        sieve[0] = sieve[1] = false;\\n        for(int i = 2; i * i <= N; i++) {\\n            if(sieve[i] == true) {\\n                for(int j = i * i; j <= N; j += i) {\\n                    sieve[j] = false;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int>nums,ans(2,-1);\\n        if(left == right) {\\n            return ans;\\n        }\\n        createSieve();\\n        int mini = INT_MAX;\\n        for(int i = left; i <= right; i++) {\\n            if(sieve[i]) {\\n                nums.push_back(i);\\n            }\\n        }\\n        if(nums.size() <= 1) {\\n            return ans;\\n        }\\n        for(int i = 0; i < nums.size() - 1; i++) {\\n            int temp = nums[i + 1] - nums[i];\\n            if(temp < mini) {\\n                mini = temp;\\n                ans[0] = nums[i];\\n                ans[1] = nums[i + 1];\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087811,
                "title": "enumerate-primes",
                "content": "# Intuition\\nEnumerate prime between left and right, then calculate the difference between adjacent primes.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ClosestPrimes(int left, int right) {\\n        var list = new List<int>();\\n        for(int i=left;i<=right;i++){\\n            if(IsPrime(i)){\\n                list.Add(i);\\n            }\\n        }\\n        if(list.Count < 2){\\n            return new int[2]{-1,-1};\\n        }\\n        var min = int.MaxValue;\\n        list.Remove(1);\\n        var arr = list.ToArray();\\n        var result = new int[2]{arr[0],arr[1]};\\n        for(int i=0;i<list.Count-1;i++){\\n            if(arr[i+1] - arr[i] < min){\\n                min = arr[i+1] - arr[i];\\n                result = new int[2]{arr[i],arr[i+1]};\\n            }\\n        }\\n        return result;\\n    }\\n\\n    bool IsPrime(int n){\\n        var root = Math.Sqrt(n);\\n        for(int i=2;i<=root;i++){\\n            if(n%i ==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ClosestPrimes(int left, int right) {\\n        var list = new List<int>();\\n        for(int i=left;i<=right;i++){\\n            if(IsPrime(i)){\\n                list.Add(i);\\n            }\\n        }\\n        if(list.Count < 2){\\n            return new int[2]{-1,-1};\\n        }\\n        var min = int.MaxValue;\\n        list.Remove(1);\\n        var arr = list.ToArray();\\n        var result = new int[2]{arr[0],arr[1]};\\n        for(int i=0;i<list.Count-1;i++){\\n            if(arr[i+1] - arr[i] < min){\\n                min = arr[i+1] - arr[i];\\n                result = new int[2]{arr[i],arr[i+1]};\\n            }\\n        }\\n        return result;\\n    }\\n\\n    bool IsPrime(int n){\\n        var root = Math.Sqrt(n);\\n        for(int i=2;i<=root;i++){\\n            if(n%i ==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078660,
                "title": "simple-java-stack-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int res [] = new int [2];\\n        Arrays.fill(res, -1);\\n        int min = Integer.MAX_VALUE;\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for(int i=left ; i <= right ;i++){\\n            if(isPrime(i)){\\n                // System.out.print(i);\\n                if(stack.isEmpty()){\\n                    stack.add(i);\\n                }else{\\n                    if( min > i-stack.peek() ){\\n                        res[0] = stack.peek();\\n                        res[1] = i;\\n                        min = i-stack.peek();\\n                        if(min == 1) return res;\\n                    }\\n                    stack.pop();\\n                    stack.add(i);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    boolean isPrime(int n){\\n        if(n == 1 ) return false;\\n        if(n == 2 || n == 3) return true;\\n        if(n % 2 == 0) return false;\\n\\n        for(int i=3;i<=Math.sqrt(n);i+= 2){\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        int res [] = new int [2];\\n        Arrays.fill(res, -1);\\n        int min = Integer.MAX_VALUE;\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for(int i=left ; i <= right ;i++){\\n            if(isPrime(i)){\\n                // System.out.print(i);\\n                if(stack.isEmpty()){\\n                    stack.add(i);\\n                }else{\\n                    if( min > i-stack.peek() ){\\n                        res[0] = stack.peek();\\n                        res[1] = i;\\n                        min = i-stack.peek();\\n                        if(min == 1) return res;\\n                    }\\n                    stack.pop();\\n                    stack.add(i);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    boolean isPrime(int n){\\n        if(n == 1 ) return false;\\n        if(n == 2 || n == 3) return true;\\n        if(n % 2 == 0) return false;\\n\\n        for(int i=3;i<=Math.sqrt(n);i+= 2){\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074739,
                "title": "python-solution-super-fast-and-very-easy-to-understand",
                "content": "# Intuition\\nI **hate** this question :)\\n\\n# Approach\\n### 1. isPrime Function:\\nThere is an optimized isPrime function.\\n\\nAn important property:\\n`Any prime could be expressed as 6x+1 or 6x+5`\\n\\nHence, we have:\\n\\n```\\n def isPrime(self, num: int) -> bool:\\n        if num < 2:\\n            return 0\\n        if num == 3 or num == 2:\\n            return 1\\n        if num % 6 != 1 and num % 6 != 5:\\n            return 0\\n        for i in range(5, int(math.sqrt(num))+1, 6):\\n            if num % i == 0 or num % (i+2) == 0:\\n                return 0\\n        return 1\\n\\n```\\nThen reason that I used `int(math.sqrt(num))+1` instead of `int(math.sqrt(num))` is because the number in `[25, 36]`, if `int(math.sqrt(num))`, the range function will be `range(5, 5, 6)` which can not loop.\\n\\n### 2. Process\\noperating array in python is very slow, so I directly maintain 3 numbers, `t1, t2 and t3`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, l: int, r: int) -> List[int]:\\n        t1 = -1\\n        t2 = -1\\n        t3 = -1\\n        minv = 1e+7\\n        for i in range(l, r+1):\\n            if self.isPrime(i):\\n                    if t1 != -1:\\n                        if i - t1 < 3:\\n                            return [t1, i]\\n                        elif i - t1 < minv:\\n                            minv = i - t1\\n                            t2 = t1\\n                            t3 = i\\n                        t1 = i\\n                    else:\\n                        t1 = i\\n                    i += 1\\n        if t2 != -1:\\n            return [t2, t3]\\n        return [-1, -1]\\n\\n    def isPrime(self, num: int) -> bool:\\n        if num < 2:\\n            return 0\\n        if num == 3 or num == 2:\\n            return 1\\n        if num % 6 != 1 and num % 6 != 5:\\n            return 0\\n        for i in range(5, int(math.sqrt(num))+1, 6):\\n            if num % i == 0 or num % (i+2) == 0:\\n                return 0\\n        return 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n def isPrime(self, num: int) -> bool:\\n        if num < 2:\\n            return 0\\n        if num == 3 or num == 2:\\n            return 1\\n        if num % 6 != 1 and num % 6 != 5:\\n            return 0\\n        for i in range(5, int(math.sqrt(num))+1, 6):\\n            if num % i == 0 or num % (i+2) == 0:\\n                return 0\\n        return 1\\n\\n```\n```\\nclass Solution:\\n    def closestPrimes(self, l: int, r: int) -> List[int]:\\n        t1 = -1\\n        t2 = -1\\n        t3 = -1\\n        minv = 1e+7\\n        for i in range(l, r+1):\\n            if self.isPrime(i):\\n                    if t1 != -1:\\n                        if i - t1 < 3:\\n                            return [t1, i]\\n                        elif i - t1 < minv:\\n                            minv = i - t1\\n                            t2 = t1\\n                            t3 = i\\n                        t1 = i\\n                    else:\\n                        t1 = i\\n                    i += 1\\n        if t2 != -1:\\n            return [t2, t3]\\n        return [-1, -1]\\n\\n    def isPrime(self, num: int) -> bool:\\n        if num < 2:\\n            return 0\\n        if num == 3 or num == 2:\\n            return 1\\n        if num % 6 != 1 and num % 6 != 5:\\n            return 0\\n        for i in range(5, int(math.sqrt(num))+1, 6):\\n            if num % i == 0 or num % (i+2) == 0:\\n                return 0\\n        return 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074174,
                "title": "c-solution-2ms-faster-than-99-very-fast-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPrime(int n){\\n        if(n < 2) return false;\\n        if(n == 2) return true;\\n\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i == 0) return false;\\n        }\\n\\n        return true;\\n    }\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int num1 = -1,num2 = -1,last = -1,diff = INT_MAX;\\n\\n        //prime is always odd except 2 so :\\n        if(left <= 2){\\n            num1 = 2;\\n            left = 3;\\n        } \\n        else if(left % 2 == 0) left++;\\n\\n        for(int i=left;i<=right;i += 2){\\n            if(isPrime(i)){\\n                if(num1 == -1) num1 = i;\\n                else if(num2 == -1){\\n                    num2 = i;\\n                    diff = num2 - num1;\\n                }\\n                else if(i - last < diff){\\n                    num1 = last;\\n                    num2 = i;\\n                    diff = i - last;\\n                }\\n                last = i;\\n            }\\n            \\n            //if diff <= 2 then return because can\\'t be better solution(diff ==1 only for 2 and 3)\\n            if(diff <= 2) return {num1,num2};\\n        }\\n        \\n        if(num1 == -1 || num2 == -1) return {-1,-1};\\n        return {num1,num2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPrime(int n){\\n        if(n < 2) return false;\\n        if(n == 2) return true;\\n\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i == 0) return false;\\n        }\\n\\n        return true;\\n    }\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int num1 = -1,num2 = -1,last = -1,diff = INT_MAX;\\n\\n        //prime is always odd except 2 so :\\n        if(left <= 2){\\n            num1 = 2;\\n            left = 3;\\n        } \\n        else if(left % 2 == 0) left++;\\n\\n        for(int i=left;i<=right;i += 2){\\n            if(isPrime(i)){\\n                if(num1 == -1) num1 = i;\\n                else if(num2 == -1){\\n                    num2 = i;\\n                    diff = num2 - num1;\\n                }\\n                else if(i - last < diff){\\n                    num1 = last;\\n                    num2 = i;\\n                    diff = i - last;\\n                }\\n                last = i;\\n            }\\n            \\n            //if diff <= 2 then return because can\\'t be better solution(diff ==1 only for 2 and 3)\\n            if(diff <= 2) return {num1,num2};\\n        }\\n        \\n        if(num1 == -1 || num2 == -1) return {-1,-1};\\n        return {num1,num2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069215,
                "title": "sieve-of-eratosthenes-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// int isPrime(int a)\\n//     {\\n//         int i=2;\\n//         if(a==1)return 0;\\n//         while(i<=sqrt(a))\\n//         {\\n//             if(a%i==0)return 0;i++;\\n//         }   \\n//         return 1;\\n//     }\\n    vector<int> closestPrimes(int left, int right) {\\n        //   int first=0,second=0,ans1=0,ans2=0,mini=INT_MAX;\\n        // for(int i=left;i<=right;i++)\\n        // {   \\n        //    if(isPrime(i))\\n        //    {\\n        //        //cout<<\"j\";\\n        //        if(first==0)first=i;\\n        //        else if(first!=0 && second==0)second=i;\\n        //        if(first!=0 && second!=0 )\\n        //        {\\n        //            int d=second-first;\\n        //            if(mini>d)\\n        //            {\\n        //                mini=d;\\n        //                ans1=first;\\n        //                ans2=second;\\n        //            }\\n        //            first=second;\\n        //            second=0;\\n        //        }\\n        //    }\\n        // }\\n        // if(ans1==0||ans2==0)\\n        // return {-1,-1};\\n        // else\\n        // return {ans1,ans2};\\n        \\n        vector<int>sieve(right+1,1);\\n        for(int i=2;i*i<=right;i++)\\n        {\\n            if(sieve[i])\\n            {\\n                for(int j=i*i;j<=right;j+=i)\\n                {\\n                    if(j%i==0 && sieve[j]==1)sieve[j]=0;\\n                }\\n            }\\n        }\\n\\n        int mini=INT_MAX;int first=0,second=0,ans1=0,ans2=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(sieve[i] && i!=1)\\n            {\\n                if(first==0)first=i;\\n               else if(first!=0 && second==0)second=i;\\n               if(first!=0 && second!=0 )\\n               {\\n                   int d=second-first;\\n                   if(mini>d)\\n                   {\\n                       mini=d;\\n                       ans1=first;\\n                       ans2=second;\\n                   }\\n                   first=second;\\n                   second=0;\\n               }\\n            }\\n        }\\n        if(ans1==0||ans2==0)\\n        return {-1,-1};\\n        else\\n        return {ans1,ans2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// int isPrime(int a)\\n//     {\\n//         int i=2;\\n//         if(a==1)return 0;\\n//         while(i<=sqrt(a))\\n//         {\\n//             if(a%i==0)return 0;i++;\\n//         }   \\n//         return 1;\\n//     }\\n    vector<int> closestPrimes(int left, int right) {\\n        //   int first=0,second=0,ans1=0,ans2=0,mini=INT_MAX;\\n        // for(int i=left;i<=right;i++)\\n        // {   \\n        //    if(isPrime(i))\\n        //    {\\n        //        //cout<<\"j\";\\n        //        if(first==0)first=i;\\n        //        else if(first!=0 && second==0)second=i;\\n        //        if(first!=0 && second!=0 )\\n        //        {\\n        //            int d=second-first;\\n        //            if(mini>d)\\n        //            {\\n        //                mini=d;\\n        //                ans1=first;\\n        //                ans2=second;\\n        //            }\\n        //            first=second;\\n        //            second=0;\\n        //        }\\n        //    }\\n        // }\\n        // if(ans1==0||ans2==0)\\n        // return {-1,-1};\\n        // else\\n        // return {ans1,ans2};\\n        \\n        vector<int>sieve(right+1,1);\\n        for(int i=2;i*i<=right;i++)\\n        {\\n            if(sieve[i])\\n            {\\n                for(int j=i*i;j<=right;j+=i)\\n                {\\n                    if(j%i==0 && sieve[j]==1)sieve[j]=0;\\n                }\\n            }\\n        }\\n\\n        int mini=INT_MAX;int first=0,second=0,ans1=0,ans2=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(sieve[i] && i!=1)\\n            {\\n                if(first==0)first=i;\\n               else if(first!=0 && second==0)second=i;\\n               if(first!=0 && second!=0 )\\n               {\\n                   int d=second-first;\\n                   if(mini>d)\\n                   {\\n                       mini=d;\\n                       ans1=first;\\n                       ans2=second;\\n                   }\\n                   first=second;\\n                   second=0;\\n               }\\n            }\\n        }\\n        if(ans1==0||ans2==0)\\n        return {-1,-1};\\n        else\\n        return {ans1,ans2};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3068770,
                "title": "solution-in-c-using-min-heap",
                "content": "# Intuition\\nWe want to find the minimum differnce so min heap can be used.\\n\\n# Approach\\nUse a minimum priority queue which stores the minimum difference between two primes. Check for every number in the given range if it is prime. Once found, find the difference between this prime and the previous one and store it in the min heap after updating prev prime to this one.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ppi pair<int,pair<int,int>>\\nclass Solution {\\npublic:\\n    bool checkPrime(int n){\\n        if(n<=1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int>ans;\\n        int prevPrime=0; // Initialising the prevPrime to 0\\n        priority_queue<ppi,vector<ppi>,greater<ppi>>mini;\\n        for(int i=left;i<=right;i++){\\n            if(checkPrime(i)){\\n                mini.push({i-prevPrime,{prevPrime,i}});\\n                prevPrime=i; // Updating prevPrime\\n            }\\n        }\\n        // if size of heap is 1 then only one prime\\n        // if size of heap is 0 then no prime \\n        if(mini.size()<=1){   \\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            auto temp=mini.top();\\n            ans.push_back(temp.second.first);\\n            ans.push_back(temp.second.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ppi pair<int,pair<int,int>>\\nclass Solution {\\npublic:\\n    bool checkPrime(int n){\\n        if(n<=1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int>ans;\\n        int prevPrime=0; // Initialising the prevPrime to 0\\n        priority_queue<ppi,vector<ppi>,greater<ppi>>mini;\\n        for(int i=left;i<=right;i++){\\n            if(checkPrime(i)){\\n                mini.push({i-prevPrime,{prevPrime,i}});\\n                prevPrime=i; // Updating prevPrime\\n            }\\n        }\\n        // if size of heap is 1 then only one prime\\n        // if size of heap is 0 then no prime \\n        if(mini.size()<=1){   \\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            auto temp=mini.top();\\n            ans.push_back(temp.second.first);\\n            ans.push_back(temp.second.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068128,
                "title": "easy-simple-c-intuitive",
                "content": "# Intuition\\n1.We have to generate all the prime numbers till right\\n2.Then we have to check between left and right which pair of prime nos will have the min distance and then return that pair in a vector.\\n\\n# Approach\\n1.First we take a vector \\n2.Then generate all the prime nos till right with SieveOfEratosthenes because of TLE\\n3.In the main part of the program we will resize the prime as it will now only contains the prime numbers.\\n4.We will initialize a vector result of size 2 to -1 value which will store the final pair\\n4.We run a for loop from left to right and find the pair of prime nos that has min distance and store it in our result vector.\\n5.Finally we will return the result vector\\n\\n# Complexity\\n- Time complexity:\\n  O(N*log(logN))-Sieve Of Eratosthenes\\n\\n- Space complexity:\\n  O(N)- prime vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool>prime;\\n    void SieveofEratosthenes(int n){\\n        for(int p=2;p*p<=n;p++){\\n            if(prime[p]==true){\\n                for(int i=p*p;i<=n;i+=p)prime[i]=false;\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        prime.resize(right+1,1);\\n        SieveofEratosthenes(right+1);\\n        prime[0]=0;\\n        prime[1]=0;\\n        int prev=-1;\\n        int ans =INT_MAX;\\n        vector<int>res(2,-1);\\n\\n        for(int p=left;p<=right;p++){\\n            if(prime[p]){\\n                if(prev==-1)prev=p;\\n                else if(p-prev<ans){\\n                    res[0]=prev;\\n                    res[1]=p;\\n                    ans=p-prev;\\n                    \\n                }\\n                prev=p;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool>prime;\\n    void SieveofEratosthenes(int n){\\n        for(int p=2;p*p<=n;p++){\\n            if(prime[p]==true){\\n                for(int i=p*p;i<=n;i+=p)prime[i]=false;\\n            }\\n        }\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        prime.resize(right+1,1);\\n        SieveofEratosthenes(right+1);\\n        prime[0]=0;\\n        prime[1]=0;\\n        int prev=-1;\\n        int ans =INT_MAX;\\n        vector<int>res(2,-1);\\n\\n        for(int p=left;p<=right;p++){\\n            if(prime[p]){\\n                if(prev==-1)prev=p;\\n                else if(p-prev<ans){\\n                    res[0]=prev;\\n                    res[1]=p;\\n                    ans=p-prev;\\n                    \\n                }\\n                prev=p;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068097,
                "title": "shiva-solution-c-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int l, int r) {\\n        const int n = 1000005;\\n        vector<bool> prime(n, true);\\n        auto find_primes = [&] () {\\n            prime[1] = false;\\n            for (int p = 2; p * p <= n; p++) {\\n                if (prime[p] == true) {\\n                    for (int i = p * p; i <= n; i += p)\\n                        prime[i] = false;\\n                }\\n            }\\n        };\\n        find_primes();\\n        int ans_l = -1, ans_r = -1, d = INT_MAX, last_prime = -1;\\n        for (int i = l; i <= r; i++) {\\n            if (prime[i]) {\\n                if (ans_l == -1) {\\n                    ans_l = i;\\n                    \\n                }\\n                else if(ans_r == -1) {\\n                    ans_r = i;\\n                    d = ans_r - ans_l;\\n                }\\n                else {\\n                    int D = i - last_prime;\\n                    if (D < d) {\\n                        ans_l = last_prime;\\n                        ans_r = i;\\n                        d = D;\\n                    }\\n                }\\n                last_prime = i;\\n            }\\n        }\\n        if (ans_l == -1 || ans_r == -1)\\n            return {-1, -1};\\n        return {ans_l, ans_r};\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int l, int r) {\\n        const int n = 1000005;\\n        vector<bool> prime(n, true);\\n        auto find_primes = [&] () {\\n            prime[1] = false;\\n            for (int p = 2; p * p <= n; p++) {\\n                if (prime[p] == true) {\\n                    for (int i = p * p; i <= n; i += p)\\n                        prime[i] = false;\\n                }\\n            }\\n        };\\n        find_primes();\\n        int ans_l = -1, ans_r = -1, d = INT_MAX, last_prime = -1;\\n        for (int i = l; i <= r; i++) {\\n            if (prime[i]) {\\n                if (ans_l == -1) {\\n                    ans_l = i;\\n                    \\n                }\\n                else if(ans_r == -1) {\\n                    ans_r = i;\\n                    d = ans_r - ans_l;\\n                }\\n                else {\\n                    int D = i - last_prime;\\n                    if (D < d) {\\n                        ans_l = last_prime;\\n                        ans_r = i;\\n                        d = D;\\n                    }\\n                }\\n                last_prime = i;\\n            }\\n        }\\n        if (ans_l == -1 || ans_r == -1)\\n            return {-1, -1};\\n        return {ans_l, ans_r};\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067430,
                "title": "c-sieve-of-eratosthenes-number-theory",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> SieveOfEratosthenes(int n)\\n    {\\n        vector<bool> prime(n+1,1);\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        return prime;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool >is_prime = SieveOfEratosthenes(right);\\n        vector<int> a;\\n\\n        for(int i=left;i<=right;++i){\\n            if(i==1)continue;\\n            if(is_prime[i]){\\n                a.push_back(i);\\n            }\\n        }\\n        if(a.size()<=1)return {-1,-1};\\n        int x=-1,y=-1;\\n        for(int i=0;i<a.size()-1;++i){\\n            if(x==-1){\\n                x = a[i];\\n                y = a[i+1];\\n            }\\n            else{\\n                if(y-x>a[i+1]-a[i]){\\n                    x = a[i];\\n                    y = a[i+1];\\n                }\\n            }\\n        }\\n        return {x,y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> SieveOfEratosthenes(int n)\\n    {\\n        vector<bool> prime(n+1,1);\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        return prime;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool >is_prime = SieveOfEratosthenes(right);\\n        vector<int> a;\\n\\n        for(int i=left;i<=right;++i){\\n            if(i==1)continue;\\n            if(is_prime[i]){\\n                a.push_back(i);\\n            }\\n        }\\n        if(a.size()<=1)return {-1,-1};\\n        int x=-1,y=-1;\\n        for(int i=0;i<a.size()-1;++i){\\n            if(x==-1){\\n                x = a[i];\\n                y = a[i+1];\\n            }\\n            else{\\n                if(y-x>a[i+1]-a[i]){\\n                    x = a[i];\\n                    y = a[i+1];\\n                }\\n            }\\n        }\\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050998,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn closest_primes(left: i32, right: i32) -> Vec<i32> {\\n        let start = 2.max(left) as usize;\\n        let end = right as usize;\\n        \\n        // Sieve of Eratosthenes\\n        let mut i = 2;\\n        let mut sieve = [true; 1_000_001];\\n        while i < 1 + (right as f64).sqrt() as usize {\\n            if sieve[i] {\\n                sieve[i * i..=end]\\n                    .iter_mut()\\n                    .step_by(i)\\n                    .for_each(|x| *x = false);\\n            }\\n            i += 1;\\n        }\\n\\n        let mut prev_prime = -1;\\n        let mut first_prime = -1;\\n        let mut delta = i32::MAX;\\n\\n        for i in sieve[start..=end]\\n            .iter()\\n            .zip(start..)\\n            .filter_map(|(x, i)| x.then(|| i as i32))\\n        {\\n            if prev_prime > -1 {\\n                let new_delta = i - prev_prime;\\n                if new_delta < delta {\\n                    first_prime = prev_prime;\\n                    delta = new_delta;\\n                    if delta <= 2 {\\n                        break;\\n                    }\\n                }\\n            }\\n            prev_prime = i;\\n        }\\n\\n        match first_prime == -1 {\\n            true => vec![-1, -1],\\n            false => vec![first_prime, first_prime + delta],\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Iterator",
                    "Number Theory"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn closest_primes(left: i32, right: i32) -> Vec<i32> {\\n        let start = 2.max(left) as usize;\\n        let end = right as usize;\\n        \\n        // Sieve of Eratosthenes\\n        let mut i = 2;\\n        let mut sieve = [true; 1_000_001];\\n        while i < 1 + (right as f64).sqrt() as usize {\\n            if sieve[i] {\\n                sieve[i * i..=end]\\n                    .iter_mut()\\n                    .step_by(i)\\n                    .for_each(|x| *x = false);\\n            }\\n            i += 1;\\n        }\\n\\n        let mut prev_prime = -1;\\n        let mut first_prime = -1;\\n        let mut delta = i32::MAX;\\n\\n        for i in sieve[start..=end]\\n            .iter()\\n            .zip(start..)\\n            .filter_map(|(x, i)| x.then(|| i as i32))\\n        {\\n            if prev_prime > -1 {\\n                let new_delta = i - prev_prime;\\n                if new_delta < delta {\\n                    first_prime = prev_prime;\\n                    delta = new_delta;\\n                    if delta <= 2 {\\n                        break;\\n                    }\\n                }\\n            }\\n            prev_prime = i;\\n        }\\n\\n        match first_prime == -1 {\\n            true => vec![-1, -1],\\n            false => vec![first_prime, first_prime + delta],\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043273,
                "title": "typescript-sieve-of-eratosthenes",
                "content": "```typescript\\n/**\\n * TC: O(nloglog(n)), SC: O(N)\\n * @param left\\n * @param right\\n */\\nfunction closestPrimes(left: number, right: number): number[] {\\n  const primes = getPrimes(left, right + 1);\\n\\n  let res: number[] = [-1, -1];\\n  let min = Infinity;\\n  for (let i = 1; i < primes.length; i++) {\\n    if (primes[i] - primes[i - 1] < min) {\\n      min = primes[i] - primes[i - 1];\\n      res = [primes[i - 1], primes[i]];\\n    }\\n  }\\n  return res;\\n}\\n\\n/**\\n * Generate primes from range [left, right)\\n * TC: O(nloglog(n))\\n * SC: O(n)\\n * @param left\\n * @param right\\n */\\nconst getPrimes = (left: number, right: number): number[] => {\\n  const res: boolean[] = Array(right).fill(true);\\n\\n  for (let i = 2; i <= Math.sqrt(right); i++) {\\n    if (!res[i]) continue;\\n    for (let j = i * i; j < right; j += i) {\\n      res[j] = false;\\n    }\\n  }\\n  // primes from [left, right)\\n  const primes: number[] = [];\\n  for (let i = Math.max(2, left); i < right; i++) {\\n    if (res[i]) {\\n      primes.push(i);\\n    }\\n  }\\n  return primes;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\n/**\\n * TC: O(nloglog(n)), SC: O(N)\\n * @param left\\n * @param right\\n */\\nfunction closestPrimes(left: number, right: number): number[] {\\n  const primes = getPrimes(left, right + 1);\\n\\n  let res: number[] = [-1, -1];\\n  let min = Infinity;\\n  for (let i = 1; i < primes.length; i++) {\\n    if (primes[i] - primes[i - 1] < min) {\\n      min = primes[i] - primes[i - 1];\\n      res = [primes[i - 1], primes[i]];\\n    }\\n  }\\n  return res;\\n}\\n\\n/**\\n * Generate primes from range [left, right)\\n * TC: O(nloglog(n))\\n * SC: O(n)\\n * @param left\\n * @param right\\n */\\nconst getPrimes = (left: number, right: number): number[] => {\\n  const res: boolean[] = Array(right).fill(true);\\n\\n  for (let i = 2; i <= Math.sqrt(right); i++) {\\n    if (!res[i]) continue;\\n    for (let j = i * i; j < right; j += i) {\\n      res[j] = false;\\n    }\\n  }\\n  // primes from [left, right)\\n  const primes: number[] = [];\\n  for (let i = Math.max(2, left); i < right; i++) {\\n    if (res[i]) {\\n      primes.push(i);\\n    }\\n  }\\n  return primes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3041716,
                "title": "sleeves-of-tyrannosaurus",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all prime numbers till n(right)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSieve of Eratosthenes\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nloglogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int n = right;\\n        bool prime[n + 1];\\n        memset(prime, true, sizeof(prime));\\n        prime[1] = false;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        int f = -1;\\n        int p = -1, q=-1, t = INT_MAX;\\n        for(int i = left;i<=right;i++){\\n            if(prime[i]){\\n                if(f == -1){\\n                    \\n                } else if(t>(i-f)){\\n                    t = i-f;\\n                    p = i;\\n                    q=f;\\n                }\\n                f = i;\\n            }\\n        }\\n        if(q==-1 || p == -1){\\n            return {-1, -1};\\n        }\\n        return {q, p};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        int n = right;\\n        bool prime[n + 1];\\n        memset(prime, true, sizeof(prime));\\n        prime[1] = false;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == true) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = false;\\n            }\\n        }\\n        int f = -1;\\n        int p = -1, q=-1, t = INT_MAX;\\n        for(int i = left;i<=right;i++){\\n            if(prime[i]){\\n                if(f == -1){\\n                    \\n                } else if(t>(i-f)){\\n                    t = i-f;\\n                    p = i;\\n                    q=f;\\n                }\\n                f = i;\\n            }\\n        }\\n        if(q==-1 || p == -1){\\n            return {-1, -1};\\n        }\\n        return {q, p};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037370,
                "title": "python-using-a-numpy-sieve-of-eratosthenes",
                "content": "# Intuition\\nAnytime you are looking for a list of primes then a sieve is the way to go.\\n\\n# Approach\\nThe fastest sieve of eratosthenes I\\'ve ever used in Python is one using numpy. It can give a full list of primes up to 10**8 in under a second.\\n\\nThen because the sieve gives all primes from 2 up to right I then did a binary search to find the first prime after left.\\n\\n# Code\\n```\\nimport numpy as np\\nfrom bisect import bisect_left\\nclass Solution:\\n    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def numpy_sieve(n):\\n            flags = np.ones(n, dtype=bool)\\n            flags[0] = flags[1] = False\\n            m = int(np.sqrt(n))+1\\n            for i in range(2, m):\\n                if flags[i]:\\n                    flags[i*i::i] = False\\n            return np.flatnonzero(flags)\\n\\n        primes = numpy_sieve(right+1)\\n        arr = primes[bisect_left(primes,left):]\\n        m = inf\\n        if len(arr) < 2:\\n            return[-1,-1]\\n        for a,b in zip(arr,arr[1:]):\\n            if b-a < m:\\n                l = a\\n                r = b\\n                m = b-a\\n        return [l,r]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nfrom bisect import bisect_left\\nclass Solution:\\n    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def numpy_sieve(n):\\n            flags = np.ones(n, dtype=bool)\\n            flags[0] = flags[1] = False\\n            m = int(np.sqrt(n))+1\\n            for i in range(2, m):\\n                if flags[i]:\\n                    flags[i*i::i] = False\\n            return np.flatnonzero(flags)\\n\\n        primes = numpy_sieve(right+1)\\n        arr = primes[bisect_left(primes,left):]\\n        m = inf\\n        if len(arr) < 2:\\n            return[-1,-1]\\n        for a,b in zip(arr,arr[1:]):\\n            if b-a < m:\\n                l = a\\n                r = b\\n                m = b-a\\n        return [l,r]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033615,
                "title": "sieve-of-erastosthenes",
                "content": "```\\nclass Solution {\\n    public int[] closestPrimes(int l, int r) {\\n        int p[]=new int[r+1];\\n        int root=(int)Math.pow(r,0.5);\\n        for(int i=2;i<=root;i++){\\n            int j=i*2;\\n            while(j<=r){\\n                p[j]=1;\\n                j=j+i;\\n            }\\n        }\\n        p[0]=1;p[1]=1;\\n        List<Integer>li=new ArrayList<>();\\n        for(int i=l;i<=r;i++){\\n            if(p[i]==0)li.add(i);\\n        }\\n        int min=Integer.MAX_VALUE;\\n        int ans[]={-1,-1};\\n        int ll=-1,rr=-1;\\n        if(li.size()<2)return ans;\\n        for(int i=1;i<li.size();i++){\\n            if(li.get(i)-li.get(i-1)<min){\\n                min=li.get(i)-li.get(i-1);\\n                ll=li.get(i-1);rr=li.get(i);\\n            }            \\n        }\\n        ans[0]=ll;\\n        ans[1]=rr;\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int l, int r) {\\n        int p[]=new int[r+1];\\n        int root=(int)Math.pow(r,0.5);\\n        for(int i=2;i<=root;i++){\\n            int j=i*2;\\n            while(j<=r){\\n                p[j]=1;\\n                j=j+i;\\n            }\\n        }\\n        p[0]=1;p[1]=1;\\n        List<Integer>li=new ArrayList<>();\\n        for(int i=l;i<=r;i++){\\n            if(p[i]==0)li.add(i);\\n        }\\n        int min=Integer.MAX_VALUE;\\n        int ans[]={-1,-1};\\n        int ll=-1,rr=-1;\\n        if(li.size()<2)return ans;\\n        for(int i=1;i<li.size();i++){\\n            if(li.get(i)-li.get(i-1)<min){\\n                min=li.get(i)-li.get(i-1);\\n                ll=li.get(i-1);rr=li.get(i);\\n            }            \\n        }\\n        ans[0]=ll;\\n        ans[1]=rr;\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3027755,
                "title": "c-sieve-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFIRST I THOUGHT OF GENERATING ENTIRE PRIME NUMBERS TILL 1e6 AND THEN BINARY SEARCH TO \\'LEFT\\' AND START CHECKING FROM THEIR.\\n\\nWE CHECK TWO ADJACENT PRIME NUMBERS IF THEIR DIFFERENCE IS THE LOWEST AMONG ALL THE GIVEN PAIRS, WE RETURN THE FIRST MINIMUM DIFFERENCE PAIR.\\n\\nGENERATING ALL THE PRIMES FROM 2 TO 1e6 WOULD BE A WASTE OF TIME AND SPACE SO WE JUST GENERATE NUMBERS FROM LEFT TO RIGHT\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUSE SIEVE, GET PRIMES, GET MINIMUM PAIRS \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        // generate sieve\\n        \\n        vector<int>primes;\\n        \\n        vector<bool>p(right+1,true);\\n        \\n        for(int i=2;i*i<=right;i++  ){\\n            if(p[i]){\\n            for(int j=i*i; j<=right;j+=i){\\n                \\n                p[j]=false;\\n            }\\n            }\\n        }\\n        \\n        if(left==1)\\n        left++;\\n        \\n        for(int i=left;i<=right;i++){\\n            if(p[i])\\n                primes.push_back(i);\\n        }\\n      \\n        if(primes.size()<2)\\n            return {-1,-1};\\n        \\n        \\n       int mini=INT_MAX;\\n         vector<int>ans={-1,-1};\\n        \\n        for(int i=0;i<primes.size()-1;i++){\\n            if(primes[i+1]-primes[i]<mini){\\n                mini=primes[i+1]-primes[i];\\n                ans={primes[i],primes[i+1]};\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        // generate sieve\\n        \\n        vector<int>primes;\\n        \\n        vector<bool>p(right+1,true);\\n        \\n        for(int i=2;i*i<=right;i++  ){\\n            if(p[i]){\\n            for(int j=i*i; j<=right;j+=i){\\n                \\n                p[j]=false;\\n            }\\n            }\\n        }\\n        \\n        if(left==1)\\n        left++;\\n        \\n        for(int i=left;i<=right;i++){\\n            if(p[i])\\n                primes.push_back(i);\\n        }\\n      \\n        if(primes.size()<2)\\n            return {-1,-1};\\n        \\n        \\n       int mini=INT_MAX;\\n         vector<int>ans={-1,-1};\\n        \\n        for(int i=0;i<primes.size()-1;i++){\\n            if(primes[i+1]-primes[i]<mini){\\n                mini=primes[i+1]-primes[i];\\n                ans={primes[i],primes[i+1]};\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020184,
                "title": "loop-over-primes-with-o-n-time-o-1-memory-99",
                "content": "# Approach\\n\\n- create a helper function for checking if a number is prime\\n- create variable that will contain the min diff (starts with max int)\\n- create a variable that will contain the no result pair\\n- create a variable that will contain the prev prime number, will start with infinity\\n- run through the range\\n  - if not prime, continue\\n  - get the absulute diff between the current number and the prev prime number\\n  - compare with the min diff, if bigger continue\\n  - update the min diff\\n  - update the pair\\n  - if diff is smaller than 2, return the pair early\\n  - update prev to current\\n- return the pair you found\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfrom typing import List\\nimport math\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        prev = math.inf\\n        diff = math.inf\\n        pair = [-1, -1]\\n\\n        for cur in range(left, right + 1):\\n            if not self.__is_prime(cur):\\n                continue\\n            cur_diff = abs(cur - prev)\\n            if cur_diff < diff:\\n                diff = cur_diff\\n                pair = [prev, cur]\\n                if diff <= 2:\\n                    return pair\\n\\n            prev = cur\\n        \\n        return pair\\n\\n    def __is_prime(self, num: int) -> bool:\\n        if num < 2:\\n            return False\\n        if num <= 3:\\n            return True\\n        if num % 2 == 0:\\n            return False\\n        if num % 3 == 0:\\n            return False\\n        for i in range(5, int(math.sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nimport math\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        prev = math.inf\\n        diff = math.inf\\n        pair = [-1, -1]\\n\\n        for cur in range(left, right + 1):\\n            if not self.__is_prime(cur):\\n                continue\\n            cur_diff = abs(cur - prev)\\n            if cur_diff < diff:\\n                diff = cur_diff\\n                pair = [prev, cur]\\n                if diff <= 2:\\n                    return pair\\n\\n            prev = cur\\n        \\n        return pair\\n\\n    def __is_prime(self, num: int) -> bool:\\n        if num < 2:\\n            return False\\n        if num <= 3:\\n            return True\\n        if num % 2 == 0:\\n            return False\\n        if num % 3 == 0:\\n            return False\\n        for i in range(5, int(math.sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020025,
                "title": "easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNot the tough one\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust check every element is prime or not and add element in list and find the pair with least difference and with some minute edge cases. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*sqrt(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\nMD ARHAM KALAM ANSARI\\n```\\nclass Solution {\\npublic:\\n    bool sol(int r)\\n    {\\n        for(int i=2;i<=sqrt(r);i++)\\n        {\\n            if(r%i==0) return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> v;\\n        if(left==1 and right==1) return {-1,-1};\\n        if(left==1) left++;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(sol(i)==true)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()==0 or v.size()==1) return {-1,-1};\\n        vector<int> ans;\\n        int q1=-1,q2=-1;\\n        int h=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            if(h>v[i+1]-v[i])\\n            {\\n                h=v[i+1]-v[i];\\n                q1=v[i];\\n                q2=v[i+1];\\n            }\\n        }\\n        if(q1!=-1) ans.push_back(q1);\\n        if(q2!=-1) ans.push_back(q2);\\n        if(ans.size()<=1) return {-1,-1};\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool sol(int r)\\n    {\\n        for(int i=2;i<=sqrt(r);i++)\\n        {\\n            if(r%i==0) return false;\\n        }\\n        return true;\\n    }\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<int> v;\\n        if(left==1 and right==1) return {-1,-1};\\n        if(left==1) left++;\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(sol(i)==true)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()==0 or v.size()==1) return {-1,-1};\\n        vector<int> ans;\\n        int q1=-1,q2=-1;\\n        int h=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            if(h>v[i+1]-v[i])\\n            {\\n                h=v[i+1]-v[i];\\n                q1=v[i];\\n                q2=v[i+1];\\n            }\\n        }\\n        if(q1!=-1) ans.push_back(q1);\\n        if(q2!=-1) ans.push_back(q2);\\n        if(ans.size()<=1) return {-1,-1};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016323,
                "title": "python-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate from \\'left\\' to \\'right\\'.\\n2. If \\'num\\' is prime, store it in an array.\\n2.1 Iterate to all the \\'primes\\' till now and check if the difference between any two \\'primes\\' is minimum. Store it in answer array.\\n2.2 If difference is less than or equals to two, return the answer array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nless than $$O(n2)$$ where n = right - left\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrime(self, num):\\n        if num < 2:\\n            return False\\n        if num % 2 == 0:\\n            return num == 2\\n            \\n        for i in range(3, int(num**0.5) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n        \\n        \\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        primes = []\\n        ans = [-1, -1]\\n        diff = float(\\'inf\\')\\n        for num in range(left, right + 1):\\n            if self.isPrime(num):\\n                primes.append(num)\\n          \\n                for i in range(1, len(primes)):\\n                    df = primes[i] - primes[i-1]\\n                    if df < diff:\\n                        diff = df\\n                        ans[0] = primes[i-1]\\n                        ans[1] = primes[i]\\n                        if diff <= 2:\\n                            return ans\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isPrime(self, num):\\n        if num < 2:\\n            return False\\n        if num % 2 == 0:\\n            return num == 2\\n            \\n        for i in range(3, int(num**0.5) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n        \\n        \\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        primes = []\\n        ans = [-1, -1]\\n        diff = float(\\'inf\\')\\n        for num in range(left, right + 1):\\n            if self.isPrime(num):\\n                primes.append(num)\\n          \\n                for i in range(1, len(primes)):\\n                    df = primes[i] - primes[i-1]\\n                    if df < diff:\\n                        diff = df\\n                        ans[0] = primes[i-1]\\n                        ans[1] = primes[i]\\n                        if diff <= 2:\\n                            return ans\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015124,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isPrime(n):\\n            if n<2:\\n                return False\\n\\n            for x in range(2,int(n**0.5)+1):\\n                if n%x==0:\\n                    return False\\n\\n            return True\\n\\n        q=[]\\n        diff=float(\\'inf\\')\\n        pair=[-1,-1]\\n        for i in range(left,right+1):\\n            if isPrime(i):\\n                q.append(i)\\n\\n            while len(q)>=2:\\n                if abs(q[0]-q[1])<diff:\\n                    pair=[q[0],q[-1]]\\n                    diff=abs(q[0]-q[1])\\n                    if diff<=2:\\n                        return pair\\n\\n                q.pop(0)\\n\\n        return pair                                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isPrime(n):\\n            if n<2:\\n                return False\\n\\n            for x in range(2,int(n**0.5)+1):\\n                if n%x==0:\\n                    return False\\n\\n            return True\\n\\n        q=[]\\n        diff=float(\\'inf\\')\\n        pair=[-1,-1]\\n        for i in range(left,right+1):\\n            if isPrime(i):\\n                q.append(i)\\n\\n            while len(q)>=2:\\n                if abs(q[0]-q[1])<diff:\\n                    pair=[q[0],q[-1]]\\n                    diff=abs(q[0]-q[1])\\n                    if diff<=2:\\n                        return pair\\n\\n                q.pop(0)\\n\\n        return pair                                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014302,
                "title": "python-using-default-dict",
                "content": "# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.total_prime= 0\\n        self.contains_prime = defaultdict(list)\\n        self.minimum = float(\"inf\")\\n        self.prev = None\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n\\n        \"\"\" \\n        Use a dict which holds the key,val : (diff,pair)\\n        Use an utility function to find the prime\\n        Get the minimum pair from the dict\\n\\n        \"\"\"\\n\\n        for i in range(left,right+1):\\n            if self.minimum == 1:\\n                return self.contains_prime[self.minimum][0]\\n            elif self.minimum == 2:\\n                return self.contains_prime[self.minimum][0]\\n            elif self.minimum == 3:\\n                return self.contains_prime[self.minimum][0]\\n            \\n            if i!=1:\\n                self.is_prime(i)\\n\\n        if (self.total_prime == 1) or (self.total_prime == 0):\\n            return [-1,-1]\\n        else:\\n            return self.contains_prime[self.minimum][0]\\n\\n    def is_prime(self,num):\\n        factors = 0\\n\\n        for i in range(1,num):\\n            if num%i == 0:\\n                factors+=1\\n            \\n            if factors>1:\\n                return 0\\n        \\n        self.total_prime+=1\\n        if self.prev == None:\\n            self.prev = num\\n        else:\\n\\n            diff = num - self.prev\\n            if diff < self.minimum:\\n                self.minimum = diff\\n\\n            self.contains_prime[diff].append([self.prev,num])\\n            self.prev = num\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.total_prime= 0\\n        self.contains_prime = defaultdict(list)\\n        self.minimum = float(\"inf\")\\n        self.prev = None\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n\\n        \"\"\" \\n        Use a dict which holds the key,val : (diff,pair)\\n        Use an utility function to find the prime\\n        Get the minimum pair from the dict\\n\\n        \"\"\"\\n\\n        for i in range(left,right+1):\\n            if self.minimum == 1:\\n                return self.contains_prime[self.minimum][0]\\n            elif self.minimum == 2:\\n                return self.contains_prime[self.minimum][0]\\n            elif self.minimum == 3:\\n                return self.contains_prime[self.minimum][0]\\n            \\n            if i!=1:\\n                self.is_prime(i)\\n\\n        if (self.total_prime == 1) or (self.total_prime == 0):\\n            return [-1,-1]\\n        else:\\n            return self.contains_prime[self.minimum][0]\\n\\n    def is_prime(self,num):\\n        factors = 0\\n\\n        for i in range(1,num):\\n            if num%i == 0:\\n                factors+=1\\n            \\n            if factors>1:\\n                return 0\\n        \\n        self.total_prime+=1\\n        if self.prev == None:\\n            self.prev = num\\n        else:\\n\\n            diff = num - self.prev\\n            if diff < self.minimum:\\n                self.minimum = diff\\n\\n            self.contains_prime[diff].append([self.prev,num])\\n            self.prev = num\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013634,
                "title": "c-solution-sieve-of-eratosthenes",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        // using Seive of Eratosthenes to find the Prime Numbers in the range\\n        vector<bool> nums;  \\n        vector<int> primes;\\n\\n        for(int i = 0 ;i <= right; i++) nums.push_back(true);   \\n\\n        // all composite numbers in nums will turn false\\n        for(int i = 2; i*i <= right; i++){\\n            if(nums[i]){\\n                for(int j = i*i; j <= right; j += i){\\n                    nums[j] = false;\\n                }\\n            }\\n        }\\n\\n        // 1 is never considered in the above loop, so\\n        // it remains true. But if left = 1, it has to skip\\n        // it. As 1 isn\\'t prime.\\n        if(left == 1) left++;    \\n\\n        for(int i = left; i <= right; i++){\\n            if(nums[i]) primes.push_back(i);\\n        }\\n\\n        // No only 1 or no primes, there return {-1, -1}\\n        if(primes.size() <= 1) return {-1, -1};\\n\\n        int num1 = primes[0];\\n        int num2 = primes[1];\\n        int d;\\n        int diff = num2 - num1;\\n        \\n        // finding the minimum difference and the \\n        // corresponding pair with minimum num1\\n        for(int i = 0; i < primes.size()-1; i++){\\n            d = primes[i+1] - primes[i];\\n            if(diff > d){\\n                diff = d;\\n                num1 = primes[i];\\n                num2 = primes[i+1];\\n            }\\n        }\\n\\n        return {num1, num2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        // using Seive of Eratosthenes to find the Prime Numbers in the range\\n        vector<bool> nums;  \\n        vector<int> primes;\\n\\n        for(int i = 0 ;i <= right; i++) nums.push_back(true);   \\n\\n        // all composite numbers in nums will turn false\\n        for(int i = 2; i*i <= right; i++){\\n            if(nums[i]){\\n                for(int j = i*i; j <= right; j += i){\\n                    nums[j] = false;\\n                }\\n            }\\n        }\\n\\n        // 1 is never considered in the above loop, so\\n        // it remains true. But if left = 1, it has to skip\\n        // it. As 1 isn\\'t prime.\\n        if(left == 1) left++;    \\n\\n        for(int i = left; i <= right; i++){\\n            if(nums[i]) primes.push_back(i);\\n        }\\n\\n        // No only 1 or no primes, there return {-1, -1}\\n        if(primes.size() <= 1) return {-1, -1};\\n\\n        int num1 = primes[0];\\n        int num2 = primes[1];\\n        int d;\\n        int diff = num2 - num1;\\n        \\n        // finding the minimum difference and the \\n        // corresponding pair with minimum num1\\n        for(int i = 0; i < primes.size()-1; i++){\\n            d = primes[i+1] - primes[i];\\n            if(diff > d){\\n                diff = d;\\n                num1 = primes[i];\\n                num2 = primes[i+1];\\n            }\\n        }\\n\\n        return {num1, num2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012614,
                "title": "java-solution-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        \\n        int[] nums = {-1, -1};\\n        int min = Integer.MAX_VALUE;\\n        List<Integer> list = new ArrayList<>();\\n\\n        for (int i = left; i <= right; i++){\\n            if (isPrime(i)){\\n                list.add(i);\\n            }\\n        }\\n\\n        if (list.isEmpty() || list.size() < 2){\\n            return nums;\\n        }\\n\\n        for (int i = 1; i < list.size(); i++){\\n            int temp = list.get(i) - list.get(i-1);\\n            if (min > temp){\\n                min = temp;\\n                nums[0] = list.get(i-1);\\n                nums[1] = list.get(i);\\n            }\\n        }\\n\\n        return nums;\\n    }\\n\\n    public boolean isPrime(int num){\\n\\n        int n = (int) Math.sqrt(num);\\n\\n        for (int i = 2; i <= n; i++){\\n            if (num % i == 0){\\n                return false;\\n            }\\n        }\\n\\n        return num != 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[] closestPrimes(int left, int right) {\\n        \\n        int[] nums = {-1, -1};\\n        int min = Integer.MAX_VALUE;\\n        List<Integer> list = new ArrayList<>();\\n\\n        for (int i = left; i <= right; i++){\\n            if (isPrime(i)){\\n                list.add(i);\\n            }\\n        }\\n\\n        if (list.isEmpty() || list.size() < 2){\\n            return nums;\\n        }\\n\\n        for (int i = 1; i < list.size(); i++){\\n            int temp = list.get(i) - list.get(i-1);\\n            if (min > temp){\\n                min = temp;\\n                nums[0] = list.get(i-1);\\n                nums[1] = list.get(i);\\n            }\\n        }\\n\\n        return nums;\\n    }\\n\\n    public boolean isPrime(int num){\\n\\n        int n = (int) Math.sqrt(num);\\n\\n        for (int i = 2; i <= n; i++){\\n            if (num % i == 0){\\n                return false;\\n            }\\n        }\\n\\n        return num != 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010918,
                "title": "other-aproach",
                "content": "class Solution {\\npublic:\\n    \\n    bool isprime(int n)\\n    {\\n        if(n<2)\\n            return false;\\n        for(int i=2;(i*i)<=n;i++)\\n        {\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        int n=right-left+1;\\n        \\n        vector<bool> have(n,false);\\n        \\n        vector<int> ans;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=left+i;\\n            \\n            if(val<2)\\n                continue;\\n            \\n            if(have[i]==false)\\n            {\\n                bool p=isprime(val);\\n                \\n                if(p==false)\\n                {\\n                    int j=i;\\n                    while(j<n)\\n                    {\\n                        have[j]=true;\\n                        j+=val;\\n                    }\\n                }\\n                else\\n                {\\n                    ans.push_back(val);\\n                    int j=i+val;\\n                    while(j<n)\\n                    {\\n                        have[j]=true;\\n                        j+=val;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        int res=INT_MAX;\\n        int a=-1;\\n        int b=-1;\\n        \\n        int s=ans.size();\\n        \\n        for(int ele:ans)\\n            cout<<ele<<\" \";\\n        for(int k=0;k<(s-1);k++)\\n        {\\n            int val=ans[k];\\n            \\n            if(val<2)\\n                continue;\\n\\n            int aa=ans[k];\\n            int bb=ans[k+1];\\n            \\n            int diff=bb-aa;\\n            if(diff<res)\\n            {\\n                res=diff;\\n                a=aa;\\n                b=bb;\\n            }\\n        }\\n        return {a,b};\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isprime(int n)\\n    {\\n        if(n<2)\\n            return false;\\n        for(int i=2;(i*i)<=n;i++)\\n        {\\n            if(n%i==0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3009577,
                "title": "c-beats-100-0-ms-6-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSieve of Eratosthenes is inefficient for this situation. Testing for primes with division is better.\\nNeed to find first 2 primes, if they exist, and work from there.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake the left and right numbers odd if needed BEFORE getting the first 2 primes in the range. Check for primes in a loop, use a sliding window with 4 integer pointers, and calculate accordingly.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if (left <= 2 && right >= 3) {\\n            return vector<int>({2, 3});\\n        }\\n        if (!(left&1) && left != 2) {\\n            left++;\\n        }\\n        if (!(right&1)) {\\n            right--;\\n        }\\n        int minRange = right - left;\\n        int resultL = 0;\\n        int resultR = 0;\\n        int slideL = 0;\\n        int slideR = 0;\\n        int i = left;\\n        while (i < right + 1 && prime(i) == false) {\\n            i += 2;\\n        }\\n        slideL = i;\\n        resultL = i;\\n        i += 2;\\n        while (i < right + 1 && prime(i) == false) {\\n            i += 2;\\n        }\\n        if (i > right) {\\n            return vector<int>({-1, -1});\\n        } else if (i - slideL == 2) {\\n            return vector<int>({slideL, i});\\n        }\\n        slideR = i;\\n        resultR = i;\\n        for (int n = i + 2; n <= right; n += 2) {\\n            if (prime(n) == true) {\\n                if (n - slideR < minRange) {\\n                    if (n - slideR == 2) {\\n                        return vector<int>({slideR, n});\\n                    }\\n                    resultL = slideR;\\n                    resultR = n;\\n                    minRange = n - slideR;\\n                }\\n                slideL = slideR;\\n                slideR = n;\\n            }\\n        }\\n        return vector<int>({resultL, resultR});\\n    }\\n\\n    bool prime(int n) {\\n        if (n > 1) {\\n            for (int i = 2; i < int(sqrt(n)) + 1; i++) {\\n                if (n % i == 0) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if (left <= 2 && right >= 3) {\\n            return vector<int>({2, 3});\\n        }\\n        if (!(left&1) && left != 2) {\\n            left++;\\n        }\\n        if (!(right&1)) {\\n            right--;\\n        }\\n        int minRange = right - left;\\n        int resultL = 0;\\n        int resultR = 0;\\n        int slideL = 0;\\n        int slideR = 0;\\n        int i = left;\\n        while (i < right + 1 && prime(i) == false) {\\n            i += 2;\\n        }\\n        slideL = i;\\n        resultL = i;\\n        i += 2;\\n        while (i < right + 1 && prime(i) == false) {\\n            i += 2;\\n        }\\n        if (i > right) {\\n            return vector<int>({-1, -1});\\n        } else if (i - slideL == 2) {\\n            return vector<int>({slideL, i});\\n        }\\n        slideR = i;\\n        resultR = i;\\n        for (int n = i + 2; n <= right; n += 2) {\\n            if (prime(n) == true) {\\n                if (n - slideR < minRange) {\\n                    if (n - slideR == 2) {\\n                        return vector<int>({slideR, n});\\n                    }\\n                    resultL = slideR;\\n                    resultR = n;\\n                    minRange = n - slideR;\\n                }\\n                slideL = slideR;\\n                slideR = n;\\n            }\\n        }\\n        return vector<int>({resultL, resultR});\\n    }\\n\\n    bool prime(int n) {\\n        if (n > 1) {\\n            for (int i = 2; i < int(sqrt(n)) + 1; i++) {\\n                if (n % i == 0) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009395,
                "title": "python3-beats-97-7-36-ms-13-9-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet first 2 primes in the range if they exist. If not, return [-1,-1].\\nPrimes are odd numbers, so start and end at odd numbers and step by 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake the left and right numbers odd if needed BEFORE getting the first 2 primes in the range. Check for primes in a loop, use a sliding window approach, and calculate accordingly.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        if left <= 2 and right >= 3:\\n            return [2,3]\\n        if left & 1 == 0 and left != 2:\\n            left += 1\\n        if right & 1 == 0:\\n            right -= 1\\n        minRange = right - left\\n        resultL = 0\\n        resultR = 0\\n        slideL = 0\\n        slideR = 0\\n        i = left\\n        while i < right + 1 and not self.prime(i):\\n            i += 2\\n        slideL = i\\n        resultL = i\\n        i += 2\\n        while i < right + 1 and not self.prime(i):\\n            i += 2\\n        if i >= right + 1:\\n            return [-1,-1]\\n        elif i - slideL == 2:\\n            return [slideL, i]\\n        slideR = i\\n        resultR = i\\n        for n in range(i+2, right+1, 2):\\n            if self.prime(n):\\n                if n - slideR < minRange:\\n                    resultL = slideR\\n                    resultR = n\\n                    minRange = n - slideR\\n                    if minRange == 2:\\n                        return [resultL, resultR]\\n                slideL = slideR\\n                slideR = n\\n        return [resultL, resultR]\\n\\n    def prime(self, n: int) -> bool:\\n        if n > 1:\\n            for i in range(2, int(math.sqrt(n))+1):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        if left <= 2 and right >= 3:\\n            return [2,3]\\n        if left & 1 == 0 and left != 2:\\n            left += 1\\n        if right & 1 == 0:\\n            right -= 1\\n        minRange = right - left\\n        resultL = 0\\n        resultR = 0\\n        slideL = 0\\n        slideR = 0\\n        i = left\\n        while i < right + 1 and not self.prime(i):\\n            i += 2\\n        slideL = i\\n        resultL = i\\n        i += 2\\n        while i < right + 1 and not self.prime(i):\\n            i += 2\\n        if i >= right + 1:\\n            return [-1,-1]\\n        elif i - slideL == 2:\\n            return [slideL, i]\\n        slideR = i\\n        resultR = i\\n        for n in range(i+2, right+1, 2):\\n            if self.prime(n):\\n                if n - slideR < minRange:\\n                    resultL = slideR\\n                    resultR = n\\n                    minRange = n - slideR\\n                    if minRange == 2:\\n                        return [resultL, resultR]\\n                slideL = slideR\\n                slideR = n\\n        return [resultL, resultR]\\n\\n    def prime(self, n: int) -> bool:\\n        if n > 1:\\n            for i in range(2, int(math.sqrt(n))+1):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008632,
                "title": "python-two-solutions-sieve-and-without-sieve",
                "content": "**Sieve**\\n\\n**Time taken** : **$$500 - 1000ms$$**\\n```\\nclass Solution:\\n    primes = [1] * (1000001)\\n    primes[0] = primes[1] = 0\\n    p = 2\\n    while p*p <= 1000000:\\n        for i in range(p*p, 1000001, p):\\n            primes[i] = 0    \\n        p += 1\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        A, diff, res = [], inf, [-1, -1]\\n        \\n        for i in range(left, right + 1):\\n            if self.primes[i]: A.append(i)\\n\\n            while len(A) >= 2:\\n                currdiff = A[1] - A[0]\\n                if currdiff < diff:\\n                    diff = currdiff\\n                    res = [A[0], A[1]]\\n                    if diff < 3: return res\\n                A.pop(0)\\n        return res    \\n```\\n**Without Sieve**\\n\\n**Time taken** : **$$< 100ms$$**\\n\\n```\\nclass Solution:\\n    def is_prime(self, n):\\n        if n < 2: return False\\n        for i in range(2, int(sqrt(n)) + 1):\\n            if not n % i: return False\\n        return True\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        A, diff, res = [], inf, [-1, -1]\\n        \\n        for i in range(left, right + 1):\\n            if self.is_prime(i): A.append(i)\\n\\n            while len(A) >= 2:\\n                currdiff = A[1] - A[0]\\n                if currdiff < diff:\\n                    diff = currdiff\\n                    res = [A[0], A[1]]\\n                    if diff < 3: return res\\n                A.pop(0)\\n        return res      \\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    primes = [1] * (1000001)\\n    primes[0] = primes[1] = 0\\n    p = 2\\n    while p*p <= 1000000:\\n        for i in range(p*p, 1000001, p):\\n            primes[i] = 0    \\n        p += 1\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        A, diff, res = [], inf, [-1, -1]\\n        \\n        for i in range(left, right + 1):\\n            if self.primes[i]: A.append(i)\\n\\n            while len(A) >= 2:\\n                currdiff = A[1] - A[0]\\n                if currdiff < diff:\\n                    diff = currdiff\\n                    res = [A[0], A[1]]\\n                    if diff < 3: return res\\n                A.pop(0)\\n        return res    \\n```\n```\\nclass Solution:\\n    def is_prime(self, n):\\n        if n < 2: return False\\n        for i in range(2, int(sqrt(n)) + 1):\\n            if not n % i: return False\\n        return True\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        \\n        A, diff, res = [], inf, [-1, -1]\\n        \\n        for i in range(left, right + 1):\\n            if self.is_prime(i): A.append(i)\\n\\n            while len(A) >= 2:\\n                currdiff = A[1] - A[0]\\n                if currdiff < diff:\\n                    diff = currdiff\\n                    res = [A[0], A[1]]\\n                    if diff < 3: return res\\n                A.pop(0)\\n        return res      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007105,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> primes(right+1, true);\\n        \\n        for(int i=2;i<=right;i++) {\\n            if(primes[i] == false) {\\n                continue;\\n            }\\n\\n            for(int p=i;(long)p*i<=right;p++) {\\n                primes[p*i] = false;\\n            }\\n        }\\n\\n        int pre = -1;\\n        int min_dif = INT_MAX;\\n        vector<int> res(2, -1);\\n        if(left == 1) {\\n            left++;\\n        }\\n        for(int i = left;i<=right;i++) {\\n            if(!primes[i]) {\\n                continue;\\n            }\\n\\n            if(pre!=-1 && min_dif>i - pre) {\\n                min_dif = i - pre;\\n                res[0] = pre;\\n                res[1] = i;\\n            }\\n\\n            pre = i;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        vector<bool> primes(right+1, true);\\n        \\n        for(int i=2;i<=right;i++) {\\n            if(primes[i] == false) {\\n                continue;\\n            }\\n\\n            for(int p=i;(long)p*i<=right;p++) {\\n                primes[p*i] = false;\\n            }\\n        }\\n\\n        int pre = -1;\\n        int min_dif = INT_MAX;\\n        vector<int> res(2, -1);\\n        if(left == 1) {\\n            left++;\\n        }\\n        for(int i = left;i<=right;i++) {\\n            if(!primes[i]) {\\n                continue;\\n            }\\n\\n            if(pre!=-1 && min_dif>i - pre) {\\n                min_dif = i - pre;\\n                res[0] = pre;\\n                res[1] = i;\\n            }\\n\\n            pre = i;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1736907,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1739605,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1736108,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 2065577,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1737654,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1737136,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1736426,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1736226,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1925614,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1925612,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1736907,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1739605,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1736108,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 2065577,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1737654,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1737136,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1736426,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1736226,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1925614,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            },
            {
                "id": 1925612,
                "content": [
                    {
                        "username": "ajit_2828",
                        "content": "if you are getting TLE ,return the first pair whose difference is less than or equal to 2 (<=2)"
                    },
                    {
                        "username": "tobiaso",
                        "content": "[@annahung](/annahung) thanks - was vital to know to solve it"
                    },
                    {
                        "username": "annahung",
                        "content": "This is called \"twin prime\"! have fun with it :)\nhttps://en.wikipedia.org/wiki/Twin_prime "
                    },
                    {
                        "username": "scorpioneer",
                        "content": "[@ramakant](/ramakant) Two consecutive numbers n and n+1 cannot be prime pair (except 2 and 3 ) because one of them must be even , so the minimum difference between prime pairs can be two only hence if you find out any such pair for which difference is less than or equal to 2 then you should return that pair as answer"
                    },
                    {
                        "username": "smartwork",
                        "content": "I was just one line of code away from AC, if only I knew this one trick!!!"
                    },
                    {
                        "username": "ramakant",
                        "content": "why it worked?"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Whenever you need primes in between any two numbers, use Sieve of Eratosthenes"
                    },
                    {
                        "username": "navid",
                        "content": "Is it possible to make it more efficient than this?\\n\\n```\\nint firstPrime = -1;\\n\\npublic int[] closestPrimes(int left, int right) {\\n    int[] res = {-1, -1};\\n    if (right < 3) {\\n        return res;\\n    }\\n    if (left <= 2) {\\n        res[0] = 2;\\n        res[1] = 3;\\n        return res;\\n    }\\n    if (right - left < 2) {\\n        return res;\\n    }\\n    List<Integer> primes = getSieve(left, right);\\n    if (primes.size() < 2) {\\n        return res;\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = firstPrime + 1; j < primes.size(); j++) {\\n        int leftPrime = primes.get(j - 1);\\n        int rightPrime = primes.get((j));\\n        int dif = rightPrime - leftPrime;\\n        if (dif < min) {\\n            min = dif;\\n            res[0] = leftPrime;\\n            res[1] = rightPrime;\\n        }\\n    }\\n    return res;\\n}\\n\\nList<Integer> getSieve(int left, int right) {\\n    List<Integer> primes = new ArrayList<>();\\n    boolean[] sieve = new boolean[right + 1];\\n    for (int i = 3; i <= right; i += 2)\\n        sieve[i] = true;\\n\\n    for (int p = 3; p * p <= right; p++) {\\n        if (sieve[p]) {\\n            for (int i = p * p; i <= right; i += p)\\n                sieve[i] = false;\\n        }\\n    }\\n    for (int i = 3; i <= right; i += 2) {\\n        if (sieve[i]) {\\n            if (firstPrime == -1 && left <= i) {\\n                firstPrime = primes.size();\\n            }\\n            primes.add(i);\\n        }\\n    }\\n    return primes;\\n}\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@hacker_saran](/hacker_saran) \n```\ndef isprime(self, num: int) -> bool: \n    return  num==2 or (num>1 and num%2!=0 and all(map(num.__mod__, range(2, int(num**.5) + 1))))\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Navid Vafaei](/navid)  Your code looks good but in getSieve function in line no 6 you are doing for(int p = 3; p * p <= right; ++p). Instead of p++ you can do p += 2 since we are starting from 3 so p++ will be 4 in next iteration and we know any even number greater than 2 cannot be a prime. So instead of ++1 you can do p += 2. Hope it helps. Thanks :)"
                    },
                    {
                        "username": "hacker_saran",
                        "content": "What about this ... in Python...\\n\\n\\nclass Solution:\\n\\n    def closestPrimes(self, left: int, right: int) -> List[int]:\\n        def isprime(n):\\n            if n==1:\\n                return 0 \\n            i=2\\n            while(i*i<=n):\\n                if n%i==0:\\n                    return 0\\n                i+=1\\n            return 1\\n        prev=0\\n        minVal=100000000\\n        x=[-1,-1]\\n        for i in range(left,right+1):           \\n            if isprime(i):\\n                if prev==0:\\n                    prev=i \\n                else:\\n                    if i-prev<minVal:\\n                        x=[prev,i]\\n                        minVal=i-prev\\n                    prev=i\\n        print(x)\\n        return x"
                    },
                    {
                        "username": "BaeMax",
                        "content": "can this ques be solved without knowing Sieve of Eratosthenes"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Yes, key observation is that twin primes are pretty common. [My solution](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/2979147/python-twin-primes-no-sieve/)"
                    },
                    {
                        "username": "naveendharavath",
                        "content": "memory limit of the problem 2523"
                    },
                    {
                        "username": "Vengeance_",
                        "content": "i m getting a bug for my code.. it's showing right ans for testcase 17,31 in custom testcase section but while submitting the very same testcase is giving error .. any suggestion how to resolve?\nmy code :\n```\nvector<int> p;\nbool sieve[1000001] = {};\n\nclass Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        \n      \n       for(int i=2;i<1000001;i++){\n           if(!sieve[i]){\n               p.push_back(i);\n               for(long long d =(long long)i*i;d<1000001;d+=i)sieve[d] = true;\n           }\n       }\n        int i = lower_bound(p.begin(),p.end(),left) - p.begin();\n        int mini = 1e9,curr=-1,next=-1;\n\n\n       while(i+1<p.size() && i+1<=right){\n           if(p[i+1]-p[i] < mini){\n               mini = p[i+1]-p[i];\n               curr = p[i];\n               next = p[i+1];\n           }\n           if(mini < 3)break;\n           i++;\n       }\n\n        return {curr,next};\n    }\n};\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is there any other(except sieve of eratosthenes) fast approach to find prime numbers in a given range (Range of 10^9)?\nor \nHow to check whether numbers of range 10^9 are prime or not?\n"
                    },
                    {
                        "username": "nevergiveup_",
                        "content": "Yes.\\nTo find all the prime number between [Left, Right], such that (Right - Left + 1 <= 1e7) and Right can be as large as 1e12. We can use the idea of segmented Sieve.\\nI am attaching a link for reference, do read about it and implement for better understaning.\\nLINK: https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#find-primes-in-range"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "I believe that twin primes are quite common up to 10^9, say every 1'000 numbers there are twin primes. If there are fewer than 1'000 numbers in [left, right] then you can find all primes in O(sqrt(right) * (right - left)). Otherwise, you can stop once you encounter a twin pair, since no gap will be smaller.\n\nAlso, in practice, factoring a range [left, right] is faster than O(sqrt(right) * (right - left)). All even numbers require only one step to determine that they are composite, numbers of the form 6k+3 require only two steps, etc. Surely, some amortized analysis applies here."
                    },
                    {
                        "username": "gralance",
                        "content": "Beat > 90%\\n```python\\nprimes = [True for i in range(10 ** 6 + 1)]\\nprimes[1] = False\\n\\nk = 2\\nwhile k*k <= 10 ** 6:\\n    for i in range(k * k, 10 ** 6 + 1, k):                \\n        primes[i] = False\\n    k += 1\\n            \\nclass Solution:    \\n    def closestPrimes(self, left: int, right: int) -> List[int]:                             \\n       \\n            \\n        dq = deque()\\n        ans = []\\n        mindiff = sys.maxsize\\n        for i in range(left, right + 1):\\n            if primes[i]:\\n                dq.append(i)\\n                if len(dq) == 2:\\n                    if dq[1] - dq[0] < mindiff:\\n                        ans = [dq[0], dq[1]]\\n                        mindiff = dq[1] - dq[0]\\n                    dq.popleft()\\n        \\n        return ans if ans else [-1, -1]\\n    \\n```"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "In normal code"
                    },
                    {
                        "username": "bhuvansaketh",
                        "content": "How it is solved for question "
                    }
                ]
            }
        ]
    }
]